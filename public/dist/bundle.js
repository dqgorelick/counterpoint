/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "public/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(2);
	
	var _jquery = __webpack_require__(3);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _animateNotes = __webpack_require__(4);
	
	var _soundGenerator = __webpack_require__(5);
	
	var _Player = __webpack_require__(7);
	
	var _Player2 = _interopRequireDefault(_Player);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	  feature flags
	 */
	
	// counterpoint
	var QUANTIZE = true;
	var TIMEOUT = false;
	
	// duplicate constants:
	var TEMPOS = {
	  0: 200,
	  1: 400,
	  2: 800
	};
	var CANVAS_TOP = null;
	var DEFAULT_BASE_NOTE = 48;
	var DEFAULT_SONG_RATE = 450;
	var STEPS = 16;
	
	var MAJOR_SCALE = [0, 2, 4, 5, 7, 9, 11];
	var MINOR_SCALE = [0, 2, 3, 5, 7, 8, 10];
	
	var notes = [];
	
	function midi_to_freq(midi) {
	  var freq = Math.pow(2, (midi - 69) / 12) * 440;
	  console.log('freq', freq);
	  return freq;
	}
	
	(0, _jquery2.default)(document).ready(function () {
	  CANVAS_TOP = window.innerHeight / 2;
	
	  var players = {};
	
	  var TEST_SONG = [7, 11, 9, 11, 7, 12, 10, 12];
	
	  var bach = new _Player2.default('bach', {
	    baseNote: DEFAULT_BASE_NOTE,
	    songRate: DEFAULT_SONG_RATE,
	    songTempo: 1,
	    canvasTop: CANVAS_TOP,
	    mode: 0,
	    song: TEST_SONG,
	    scale: MINOR_SCALE,
	    dir: 0,
	    color: '#ff0000'
	  }, _soundGenerator.triggerAttackRelease);
	  bach.start();
	
	  console.log('bach', bach);
	  // view web socket
	  var socket = new WebSocket('ws://localhost:8082/');
	  socket.onmessage = function (evt) {
	    var message = JSON.parse(evt.data);
	    if (message.type === 'notes') {
	      if (!players[message.id]) {
	        // if player doesn't exist, create new player
	        players[message.id] = message;
	        players[message.id].id = message.id;
	        var notes = [];
	        var dir;
	        message.notes.forEach(function (note, iter) {
	          if (iter === 0) {
	            dir = note.dir;
	          }
	          notes.push(note.midi);
	        });
	        players[message.id].notes = notes;
	        players[message.id].player = new _Player2.default(players[message.id].id, {
	          songTempo: message.tempo,
	          songRate: TEMPOS[message.tempo],
	          song: players[message.id].notes,
	          color: message.color,
	          dir: dir
	        }, sendNote);
	        players[message.id].player.stop();
	        players[message.id].player.reset();
	        if (QUANTIZE) {
	          players[message.id].toStart = true;
	        } else {
	          players[message.id].player.start();
	        }
	      } else {
	        // player exists already
	        var notes = [];
	        message.notes.forEach(function (note, iter) {
	          if (iter === 0) {
	            players[message.id].dir = note.dir;
	          }
	          notes.push(note.midi);
	        });
	        players[message.id].player.stop();
	        players[message.id].player.reset();
	        if (QUANTIZE) {
	          players[message.id].toStart = true;
	        } else {
	          players[message.id].player.start();
	        }
	        players[message.id].player.song = notes;
	      }
	    } else if (message.type === 'tempo') {
	      players[message.id].player.tempo(message.tempo);
	    } else if (message.type === 'start') {
	      players[message.id].player.start();
	    } else if (message.type === 'stop') {
	      players[message.id].player.stop();
	    } else if (message.type === 'close') {
	      // remove player if they exist
	      if (players[message.id]) {
	        players[message.id].player.stop();
	        players[message.id].player.remove();
	        players[message.id] = null;
	      }
	    }
	  };
	
	  function sendNote(note, tempo) {
	    // quarternote by default
	    tempo = tempo || 1;
	    console.log('note', note);
	    // socket.send(JSON.stringify({note: note, tempo: tempo}));
	  }
	
	  /*
	    INITIALIZE
	   */
	
	  (0, _animateNotes.createNotes)(notes, DEFAULT_BASE_NOTE, STEPS, MINOR_SCALE, CANVAS_TOP);
	  (0, _animateNotes.initializeSettings)(CANVAS_TOP);
	
	  /*
	    Loop over players
	   */
	  var loopCount = 0;
	
	  function loopPlayers() {
	    for (var id in players) {
	      if (!!players[id]) {
	        // look for players to start
	        if (players[id].toStart) {
	          // reset timeout upon new input
	          players[id].player.timeout = 0;
	          players[id].toStart = false;
	          players[id].player.start();
	        }
	        // look for inactive players every second
	        if (TIMEOUT && loopCount >= 5) {
	          loopCount = 0;
	          // increase timeout every second
	          players[id].player.timeout += 1;
	          // remove player if no actions for more than 30 seconds
	          if (players[id].player.timeout >= 1000) {
	            players[id].player.stop();
	            players[id].player.remove();
	            players[id] = null;
	          }
	        }
	      }
	    }
	    loopCount++;
	  }
	
	  // set interval at the shortest delimination of notes
	  if (QUANTIZE) {
	    setInterval(loopPlayers, TEMPOS[0]);
	  }
	
	  /*
	  USER INPUT
	  */
	  (0, _jquery2.default)('.note').on('click', function (evt) {
	    var note = (0, _jquery2.default)(this).attr("id");
	    console.log('click');
	    sendNote(notes[note].midi);
	  });
	
	  (0, _jquery2.default)('.note').on('mouseenter', function (evt) {
	    var note = (0, _jquery2.default)(this).attr("id");
	    (0, _soundGenerator.triggerAttackRelease)(midi_to_freq(notes[note].midi));
	    console.log('hover');
	  });
	});

/***/ },
/* 2 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.1.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-09-22T22:30Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var document = window.document;
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	
	
		function DOMEval( code, doc ) {
			doc = doc || document;
	
			var script = doc.createElement( "script" );
	
			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.1.1",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
	
			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}
	
			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&
	
				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
	
			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");
	
		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
	
		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {
	
				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {
	
					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}
	
					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||
	
						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}
	
				return elem.disabled === disabled;
	
			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}
	
			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
	
			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );
	
					if ( elem ) {
	
						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
	
						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}
	
					return [];
				}
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}
	
		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}
	
		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}
	
		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}
	
		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}
	
		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		if ( chainable ) {
			return elems;
		}
	
		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}
	
		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}
	
		if ( data === "false" ) {
			return false;
		}
	
		if ( data === "null" ) {
			return null;
		}
	
		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}
	
		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}
	
		return data;
	}
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;
	
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );
	
		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );
	
		} else {
			ret = [];
		}
	
		if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}
	
		return ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;
	
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			if ( delegateCount &&
	
				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&
	
				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}
	
				if ( button & 2 ) {
					return 3;
				}
	
				if ( button & 4 ) {
					return 2;
				}
	
				return 0;
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		/* eslint-disable max-len */
	
		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	
		/* eslint-enable */
	
		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;
	
		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;
	
		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;
	
		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];
	
				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
	
				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}
	
					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}
	
					return -1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}
	
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}
	
					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;
	
					if ( index < 0 ) {
						i = max;
	
					} else {
						i = one ? index : 0;
					}
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				if ( val == null ) {
					return null;
				}
	
				if ( jQuery.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}
	
				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win, rect, doc,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			rect = elem.getBoundingClientRect();
	
			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;
	
				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}
	
			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );
	
	jQuery.parseJSON = JSON.parse;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	
	
	
	return jQuery;
	} );


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createNotes = createNotes;
	exports.renderNotes = renderNotes;
	exports.initializeSettings = initializeSettings;
	exports.animateNote = animateNote;
	
	var _jquery = __webpack_require__(3);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// create the note objects
	function createNotes(notes, baseNote, steps, scale, top) {
	  console.log('top', top);
	  var maxWidth = window.innerWidth;
	  for (var i = 0; i < steps; i++) {
	    var noteWidth = maxWidth / steps;
	    notes[i] = {
	      id: i,
	      midi: baseNote + (i < 7 ? 0 : i > 13 ? 24 : 12) + scale[i % scale.length],
	      left: noteWidth * i,
	      width: noteWidth,
	      height: noteWidth / 2,
	      top: noteWidth / 4,
	      center: noteWidth * i + noteWidth / 2
	    };
	  }
	  renderNotes(notes, steps, top);
	}
	
	function renderNotes(notes, steps, top) {
	  var noteHeight;
	  (0, _jquery2.default)('#canvas').html(function () {
	    var notesHTML = '';
	    notes.forEach(function (note, iter) {
	      var color = parseInt(180 * (iter / steps) + 60).toString(16);
	      noteHeight = note.height;
	      notesHTML += '<div ' + 'class="note" ' + 'id="' + iter + '" ' + 'style="' + 'left:' + note.left + 'px;' + 'top:' + note.top + 'px;' + 'width:' + note.width + 'px;' + 'height:' + note.height + 'px;' + '" ' + '></div>';
	    });
	    return notesHTML;
	  }());
	  (0, _jquery2.default)('.scale').html(function () {
	    console.log('top', top);
	    return '<div class="scale-background"' + 'style="' + 'top:' + top + 'px;' + 'height:' + noteHeight + 'px;' + '" ' + '></div>';
	  }());
	}
	
	function initializeSettings(top) {
	  console.log('top', top);
	  (0, _jquery2.default)('.note').css('top', top);
	}
	
	function animateNote(note, duration) {
	  // note transition
	  var activeNote = (0, _jquery2.default)('#' + note);
	  activeNote.addClass('active');
	  setTimeout(function () {
	    activeNote.removeClass('active');
	  }, duration);
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.triggerAttackRelease = triggerAttackRelease;
	
	var _tone = __webpack_require__(6);
	
	var _tone2 = _interopRequireDefault(_tone);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var vol = new _tone2.default.Volume(12);
	var freeverb = new _tone2.default.Freeverb(0.7, 1200).toMaster();
	var synth = new _tone2.default.PolySynth(6, _tone2.default.FMSynth, {
	    "oscillator": {
	        "partials": [0, 2, 3, 4, 8]
	    },
	    "envelope": {
	        "attack": 0.25,
	        "decay": 0.4
	    },
	    "volume": {}
	}).chain(vol).connect(freeverb).toMaster();
	
	function triggerAttackRelease(note, tempo) {
	    var noteLength = tempo || "8n";
	    synth.triggerAttackRelease(note, noteLength);
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory){
	
		//UMD
		if ( true ) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return factory();
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module === "object") {
			module.exports = factory();
	 	} else {
			root.Tone = factory();
		}
	
	}(this, function(){
	
		"use strict";
		
		var Tone;
		//constructs the main Tone object
		function Main(func){
			Tone = func();
		}
		//invokes each of the modules with the main Tone object as the argument
		function Module(func){
			func(Tone);
		}	/**
		 *  Tone.js
		 *  @author Yotam Mann
		 *  @license http://opensource.org/licenses/MIT MIT License
		 *  @copyright 2014-2017 Yotam Mann
		 */
		Main(function () {
		    
		    //////////////////////////////////////////////////////////////////////////
		    //	WEB AUDIO CONTEXT
		    ///////////////////////////////////////////////////////////////////////////
		    function isUndef(val) {
		        return typeof val === 'undefined';
		    }
		    function isFunction(val) {
		        return typeof val === 'function';
		    }
		    var audioContext;
		    //polyfill for AudioContext and OfflineAudioContext
		    if (isUndef(window.AudioContext)) {
		        window.AudioContext = window.webkitAudioContext;
		    }
		    if (isUndef(window.OfflineAudioContext)) {
		        window.OfflineAudioContext = window.webkitOfflineAudioContext;
		    }
		    if (!isUndef(AudioContext)) {
		        audioContext = new AudioContext();
		    } else {
		        throw new Error('Web Audio is not supported in this browser');
		    }
		    //SHIMS////////////////////////////////////////////////////////////////////
		    if (!isFunction(AudioContext.prototype.createGain)) {
		        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
		    }
		    if (!isFunction(AudioContext.prototype.createDelay)) {
		        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
		    }
		    if (!isFunction(AudioContext.prototype.createPeriodicWave)) {
		        AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
		    }
		    if (!isFunction(AudioBufferSourceNode.prototype.start)) {
		        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;
		    }
		    if (!isFunction(AudioBufferSourceNode.prototype.stop)) {
		        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;
		    }
		    if (!isFunction(OscillatorNode.prototype.start)) {
		        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;
		    }
		    if (!isFunction(OscillatorNode.prototype.stop)) {
		        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;
		    }
		    if (!isFunction(OscillatorNode.prototype.setPeriodicWave)) {
		        OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;
		    }
		    //extend the connect function to include Tones
		    if (isUndef(AudioNode.prototype._nativeConnect)) {
		        AudioNode.prototype._nativeConnect = AudioNode.prototype.connect;
		        AudioNode.prototype.connect = function (B, outNum, inNum) {
		            if (B.input) {
		                if (Array.isArray(B.input)) {
		                    if (isUndef(inNum)) {
		                        inNum = 0;
		                    }
		                    this.connect(B.input[inNum]);
		                } else {
		                    this.connect(B.input, outNum, inNum);
		                }
		            } else {
		                try {
		                    if (B instanceof AudioNode) {
		                        this._nativeConnect(B, outNum, inNum);
		                    } else {
		                        this._nativeConnect(B, outNum);
		                    }
		                } catch (e) {
		                    throw new Error('error connecting to node: ' + B);
		                }
		            }
		        };
		    }
		    ///////////////////////////////////////////////////////////////////////////
		    //	TONE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  @class  Tone is the base class of all other classes. It provides 
			 *          a lot of methods and functionality to all classes that extend
			 *          it. 
			 *  
			 *  @constructor
			 *  @alias Tone
			 *  @param {number} [inputs=1] the number of input nodes
			 *  @param {number} [outputs=1] the number of output nodes
			 */
		    var Tone = function (inputs, outputs) {
		        /**
				 *  the input node(s)
				 *  @type {GainNode|Array}
				 */
		        if (isUndef(inputs) || inputs === 1) {
		            this.input = this.context.createGain();
		        } else if (inputs > 1) {
		            this.input = new Array(inputs);
		        }
		        /**
				 *  the output node(s)
				 *  @type {GainNode|Array}
				 */
		        if (isUndef(outputs) || outputs === 1) {
		            this.output = this.context.createGain();
		        } else if (outputs > 1) {
		            this.output = new Array(inputs);
		        }
		    };
		    /**
			 *  Set the parameters at once. Either pass in an
			 *  object mapping parameters to values, or to set a
			 *  single parameter, by passing in a string and value.
			 *  The last argument is an optional ramp time which 
			 *  will ramp any signal values to their destination value
			 *  over the duration of the rampTime.
			 *  @param {Object|string} params
			 *  @param {number=} value
			 *  @param {Time=} rampTime
			 *  @returns {Tone} this
			 *  @example
			 * //set values using an object
			 * filter.set({
			 * 	"frequency" : 300,
			 * 	"type" : highpass
			 * });
			 *  @example
			 * filter.set("type", "highpass");
			 *  @example
			 * //ramp to the value 220 over 3 seconds. 
			 * oscillator.set({
			 * 	"frequency" : 220
			 * }, 3);
			 */
		    Tone.prototype.set = function (params, value, rampTime) {
		        if (this.isObject(params)) {
		            rampTime = value;
		        } else if (this.isString(params)) {
		            var tmpObj = {};
		            tmpObj[params] = value;
		            params = tmpObj;
		        }
		        paramLoop:
		            for (var attr in params) {
		                value = params[attr];
		                var parent = this;
		                if (attr.indexOf('.') !== -1) {
		                    var attrSplit = attr.split('.');
		                    for (var i = 0; i < attrSplit.length - 1; i++) {
		                        parent = parent[attrSplit[i]];
		                        if (parent instanceof Tone) {
		                            attrSplit.splice(0, i + 1);
		                            var innerParam = attrSplit.join('.');
		                            parent.set(innerParam, value);
		                            continue paramLoop;
		                        }
		                    }
		                    attr = attrSplit[attrSplit.length - 1];
		                }
		                var param = parent[attr];
		                if (isUndef(param)) {
		                    continue;
		                }
		                if (Tone.Signal && param instanceof Tone.Signal || Tone.Param && param instanceof Tone.Param) {
		                    if (param.value !== value) {
		                        if (isUndef(rampTime)) {
		                            param.value = value;
		                        } else {
		                            param.rampTo(value, rampTime);
		                        }
		                    }
		                } else if (param instanceof AudioParam) {
		                    if (param.value !== value) {
		                        param.value = value;
		                    }
		                } else if (param instanceof Tone) {
		                    param.set(value);
		                } else if (param !== value) {
		                    parent[attr] = value;
		                }
		            }
		        return this;
		    };
		    /**
			 *  Get the object's attributes. Given no arguments get
			 *  will return all available object properties and their corresponding
			 *  values. Pass in a single attribute to retrieve or an array
			 *  of attributes. The attribute strings can also include a "."
			 *  to access deeper properties.
			 *  @example
			 * osc.get();
			 * //returns {"type" : "sine", "frequency" : 440, ...etc}
			 *  @example
			 * osc.get("type");
			 * //returns { "type" : "sine"}
			 * @example
			 * //use dot notation to access deep properties
			 * synth.get(["envelope.attack", "envelope.release"]);
			 * //returns {"envelope" : {"attack" : 0.2, "release" : 0.4}}
			 *  @param {Array=|string|undefined} params the parameters to get, otherwise will return 
			 *  					                  all available.
			 *  @returns {Object}
			 */
		    Tone.prototype.get = function (params) {
		        if (isUndef(params)) {
		            params = this._collectDefaults(this.constructor);
		        } else if (this.isString(params)) {
		            params = [params];
		        }
		        var ret = {};
		        for (var i = 0; i < params.length; i++) {
		            var attr = params[i];
		            var parent = this;
		            var subRet = ret;
		            if (attr.indexOf('.') !== -1) {
		                var attrSplit = attr.split('.');
		                for (var j = 0; j < attrSplit.length - 1; j++) {
		                    var subAttr = attrSplit[j];
		                    subRet[subAttr] = subRet[subAttr] || {};
		                    subRet = subRet[subAttr];
		                    parent = parent[subAttr];
		                }
		                attr = attrSplit[attrSplit.length - 1];
		            }
		            var param = parent[attr];
		            if (this.isObject(params[attr])) {
		                subRet[attr] = param.get();
		            } else if (Tone.Signal && param instanceof Tone.Signal) {
		                subRet[attr] = param.value;
		            } else if (Tone.Param && param instanceof Tone.Param) {
		                subRet[attr] = param.value;
		            } else if (param instanceof AudioParam) {
		                subRet[attr] = param.value;
		            } else if (param instanceof Tone) {
		                subRet[attr] = param.get();
		            } else if (!isFunction(param) && !isUndef(param)) {
		                subRet[attr] = param;
		            }
		        }
		        return ret;
		    };
		    /**
			 *  collect all of the default attributes in one
			 *  @private
			 *  @param {function} constr the constructor to find the defaults from
			 *  @return {Array} all of the attributes which belong to the class
			 */
		    Tone.prototype._collectDefaults = function (constr) {
		        var ret = [];
		        if (!isUndef(constr.defaults)) {
		            ret = Object.keys(constr.defaults);
		        }
		        if (!isUndef(constr._super)) {
		            var superDefs = this._collectDefaults(constr._super);
		            //filter out repeats
		            for (var i = 0; i < superDefs.length; i++) {
		                if (ret.indexOf(superDefs[i]) === -1) {
		                    ret.push(superDefs[i]);
		                }
		            }
		        }
		        return ret;
		    };
		    /**
			 *  @returns {string} returns the name of the class as a string
			 */
		    Tone.prototype.toString = function () {
		        for (var className in Tone) {
		            var isLetter = className[0].match(/^[A-Z]$/);
		            var sameConstructor = Tone[className] === this.constructor;
		            if (isFunction(Tone[className]) && isLetter && sameConstructor) {
		                return className;
		            }
		        }
		        return 'Tone';
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	CLASS VARS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  A static pointer to the audio context accessible as Tone.context. 
			 *  @type {AudioContext}
			 */
		    Tone.context = audioContext;
		    /**
			 *  The audio context.
			 *  @type {AudioContext}
			 */
		    Tone.prototype.context = Tone.context;
		    /**
			 *  the default buffer size
			 *  @type {number}
			 *  @static
			 *  @const
			 */
		    Tone.prototype.bufferSize = 2048;
		    /**
			 *  The delay time of a single frame (128 samples according to the spec). 
			 *  @type {number}
			 *  @static
			 *  @const
			 */
		    Tone.prototype.blockTime = 128 / Tone.context.sampleRate;
		    /**
			 *  The time of a single sample
			 *  @type {number}
			 *  @static
			 *  @const
			 */
		    Tone.prototype.sampleTime = 1 / Tone.context.sampleRate;
		    /**
			 *  The number of inputs feeding into the AudioNode. 
			 *  For source nodes, this will be 0.
			 *  @memberOf Tone#
			 *  @name numberOfInputs
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.prototype, 'numberOfInputs', {
		        get: function () {
		            if (this.input) {
		                if (this.isArray(this.input)) {
		                    return this.input.length;
		                } else {
		                    return 1;
		                }
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 *  The number of outputs coming out of the AudioNode. 
			 *  For source nodes, this will be 0.
			 *  @memberOf Tone#
			 *  @name numberOfInputs
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.prototype, 'numberOfOutputs', {
		        get: function () {
		            if (this.output) {
		                if (this.isArray(this.output)) {
		                    return this.output.length;
		                } else {
		                    return 1;
		                }
		            } else {
		                return 0;
		            }
		        }
		    });
		    ///////////////////////////////////////////////////////////////////////////
		    //	CONNECTIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  disconnect and dispose
			 *  @returns {Tone} this
			 */
		    Tone.prototype.dispose = function () {
		        if (!this.isUndef(this.input)) {
		            if (this.input instanceof AudioNode) {
		                this.input.disconnect();
		            }
		            this.input = null;
		        }
		        if (!this.isUndef(this.output)) {
		            if (this.output instanceof AudioNode) {
		                this.output.disconnect();
		            }
		            this.output = null;
		        }
		        return this;
		    };
		    /**
			 *  a silent connection to the DesinationNode
			 *  which will ensure that anything connected to it
			 *  will not be garbage collected
			 *  
			 *  @private
			 */
		    var _silentNode = null;
		    /**
			 *  makes a connection to ensure that the node will not be garbage collected
			 *  until 'dispose' is explicitly called
			 *
			 *  use carefully. circumvents JS and WebAudio's normal Garbage Collection behavior
			 *  @returns {Tone} this
			 */
		    Tone.prototype.noGC = function () {
		        this.output.connect(_silentNode);
		        return this;
		    };
		    AudioNode.prototype.noGC = function () {
		        this.connect(_silentNode);
		        return this;
		    };
		    /**
			 *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode
			 *  @param  {Tone | AudioParam | AudioNode} unit 
			 *  @param {number} [outputNum=0] optionally which output to connect from
			 *  @param {number} [inputNum=0] optionally which input to connect to
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connect = function (unit, outputNum, inputNum) {
		        if (Array.isArray(this.output)) {
		            outputNum = this.defaultArg(outputNum, 0);
		            this.output[outputNum].connect(unit, 0, inputNum);
		        } else {
		            this.output.connect(unit, outputNum, inputNum);
		        }
		        return this;
		    };
		    /**
			 *  disconnect the output
			 *  @param {Number|AudioNode} output Either the output index to disconnect
			 *                                   if the output is an array, or the
			 *                                   node to disconnect from.
			 *  @returns {Tone} this
			 */
		    Tone.prototype.disconnect = function (output) {
		        if (Array.isArray(this.output)) {
		            output = this.defaultArg(output, 0);
		            this.output[output].disconnect();
		        } else if (!this.isUndef(output)) {
		            this.output.disconnect(output);
		        } else {
		            this.output.disconnect();
		        }
		        return this;
		    };
		    /**
			 *  connect together all of the arguments in series
			 *  @param {...AudioParam|Tone|AudioNode} nodes
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connectSeries = function () {
		        if (arguments.length > 1) {
		            var currentUnit = arguments[0];
		            for (var i = 1; i < arguments.length; i++) {
		                var toUnit = arguments[i];
		                currentUnit.connect(toUnit);
		                currentUnit = toUnit;
		            }
		        }
		        return this;
		    };
		    /**
			 *  Connect the output of this node to the rest of the nodes in series.
			 *  @example
			 *  //connect a node to an effect, panVol and then to the master output
			 *  node.chain(effect, panVol, Tone.Master);
			 *  @param {...AudioParam|Tone|AudioNode} nodes
			 *  @returns {Tone} this
			 */
		    Tone.prototype.chain = function () {
		        if (arguments.length > 0) {
		            var currentUnit = this;
		            for (var i = 0; i < arguments.length; i++) {
		                var toUnit = arguments[i];
		                currentUnit.connect(toUnit);
		                currentUnit = toUnit;
		            }
		        }
		        return this;
		    };
		    /**
			 *  connect the output of this node to the rest of the nodes in parallel.
			 *  @param {...AudioParam|Tone|AudioNode} nodes
			 *  @returns {Tone} this
			 */
		    Tone.prototype.fan = function () {
		        if (arguments.length > 0) {
		            for (var i = 0; i < arguments.length; i++) {
		                this.connect(arguments[i]);
		            }
		        }
		        return this;
		    };
		    //give native nodes chain and fan methods
		    AudioNode.prototype.chain = Tone.prototype.chain;
		    AudioNode.prototype.fan = Tone.prototype.fan;
		    ///////////////////////////////////////////////////////////////////////////
		    //	UTILITIES / HELPERS / MATHS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  If the `given` parameter is undefined, use the `fallback`. 
			 *  If both `given` and `fallback` are object literals, it will
			 *  return a deep copy which includes all of the parameters from both 
			 *  objects. If a parameter is undefined in given, it will return
			 *  the fallback property. 
			 *  <br><br>
			 *  WARNING: if object is self referential, it will go into an an 
			 *  infinite recursive loop.
			 *  
			 *  @param  {*} given    
			 *  @param  {*} fallback 
			 *  @return {*}          
			 */
		    Tone.prototype.defaultArg = function (given, fallback) {
		        if (this.isObject(given) && this.isObject(fallback)) {
		            var ret = {};
		            //make a deep copy of the given object
		            for (var givenProp in given) {
		                ret[givenProp] = this.defaultArg(fallback[givenProp], given[givenProp]);
		            }
		            for (var fallbackProp in fallback) {
		                ret[fallbackProp] = this.defaultArg(given[fallbackProp], fallback[fallbackProp]);
		            }
		            return ret;
		        } else {
		            return isUndef(given) ? fallback : given;
		        }
		    };
		    /**
			 *  returns the args as an options object with given arguments
			 *  mapped to the names provided. 
			 *
			 *  if the args given is an array containing only one object, it is assumed
			 *  that that's already the options object and will just return it. 
			 *  
			 *  @param  {Array} values  the 'arguments' object of the function
			 *  @param  {Array} keys the names of the arguments as they
			 *                                 should appear in the options object
			 *  @param {Object=} defaults optional defaults to mixin to the returned 
			 *                            options object                              
			 *  @return {Object}       the options object with the names mapped to the arguments
			 */
		    Tone.prototype.optionsObject = function (values, keys, defaults) {
		        var options = {};
		        if (values.length === 1 && this.isObject(values[0])) {
		            options = values[0];
		        } else {
		            for (var i = 0; i < keys.length; i++) {
		                options[keys[i]] = values[i];
		            }
		        }
		        if (!this.isUndef(defaults)) {
		            return this.defaultArg(options, defaults);
		        } else {
		            return options;
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // TYPE CHECKING
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  test if the arg is undefined
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is undefined
			 *  @function
			 */
		    Tone.prototype.isUndef = isUndef;
		    /**
			 *  test if the arg is a function
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is a function
			 *  @function
			 */
		    Tone.prototype.isFunction = isFunction;
		    /**
			 *  Test if the argument is a number.
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is a number
			 */
		    Tone.prototype.isNumber = function (arg) {
		        return typeof arg === 'number';
		    };
		    /**
			 *  Test if the given argument is an object literal (i.e. `{}`);
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is an object literal.
			 */
		    Tone.prototype.isObject = function (arg) {
		        return Object.prototype.toString.call(arg) === '[object Object]' && arg.constructor === Object;
		    };
		    /**
			 *  Test if the argument is a boolean.
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is a boolean
			 */
		    Tone.prototype.isBoolean = function (arg) {
		        return typeof arg === 'boolean';
		    };
		    /**
			 *  Test if the argument is an Array
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is an array
			 */
		    Tone.prototype.isArray = function (arg) {
		        return Array.isArray(arg);
		    };
		    /**
			 *  Test if the argument is a string.
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is a string
			 */
		    Tone.prototype.isString = function (arg) {
		        return typeof arg === 'string';
		    };
		    /**
			 *  An empty function.
			 *  @static
			 */
		    Tone.noOp = function () {
		    };
		    /**
			 *  Make the property not writable. Internal use only. 
			 *  @private
			 *  @param  {string}  property  the property to make not writable
			 */
		    Tone.prototype._readOnly = function (property) {
		        if (Array.isArray(property)) {
		            for (var i = 0; i < property.length; i++) {
		                this._readOnly(property[i]);
		            }
		        } else {
		            Object.defineProperty(this, property, {
		                writable: false,
		                enumerable: true
		            });
		        }
		    };
		    /**
			 *  Make an attribute writeable. Interal use only. 
			 *  @private
			 *  @param  {string}  property  the property to make writable
			 */
		    Tone.prototype._writable = function (property) {
		        if (Array.isArray(property)) {
		            for (var i = 0; i < property.length; i++) {
		                this._writable(property[i]);
		            }
		        } else {
		            Object.defineProperty(this, property, { writable: true });
		        }
		    };
		    /**
			 * Possible play states. 
			 * @enum {string}
			 */
		    Tone.State = {
		        Started: 'started',
		        Stopped: 'stopped',
		        Paused: 'paused'
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // GAIN CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Equal power gain scale. Good for cross-fading.
			 *  @param  {NormalRange} percent (0-1)
			 *  @return {Number}         output gain (0-1)
			 */
		    Tone.prototype.equalPowerScale = function (percent) {
		        var piFactor = 0.5 * Math.PI;
		        return Math.sin(percent * piFactor);
		    };
		    /**
			 *  Convert decibels into gain.
			 *  @param  {Decibels} db
			 *  @return {Number}   
			 */
		    Tone.prototype.dbToGain = function (db) {
		        return Math.pow(2, db / 6);
		    };
		    /**
			 *  Convert gain to decibels.
			 *  @param  {Number} gain (0-1)
			 *  @return {Decibels}   
			 */
		    Tone.prototype.gainToDb = function (gain) {
		        return 20 * (Math.log(gain) / Math.LN10);
		    };
		    /**
			 *  Convert an interval (in semitones) to a frequency ratio.
			 *  @param  {Interval} interval the number of semitones above the base note
			 *  @return {number}          the frequency ratio
			 *  @example
			 * tone.intervalToFrequencyRatio(0); // 1
			 * tone.intervalToFrequencyRatio(12); // 2
			 * tone.intervalToFrequencyRatio(-12); // 0.5
			 */
		    Tone.prototype.intervalToFrequencyRatio = function (interval) {
		        return Math.pow(2, interval / 12);
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	TIMING
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Return the current time of the AudioContext clock.
			 *  @return {Number} the currentTime from the AudioContext
			 */
		    Tone.prototype.now = function () {
		        return this.context.currentTime;
		    };
		    /**
			 *  Return the current time of the AudioContext clock.
			 *  @return {Number} the currentTime from the AudioContext
			 *  @static
			 */
		    Tone.now = function () {
		        return Tone.context.currentTime;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	INHERITANCE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  have a child inherit all of Tone's (or a parent's) prototype
			 *  to inherit the parent's properties, make sure to call 
			 *  Parent.call(this) in the child's constructor
			 *
			 *  based on closure library's inherit function
			 *
			 *  @static
			 *  @param  {function} 	child  
			 *  @param  {function=} parent (optional) parent to inherit from
			 *                             if no parent is supplied, the child
			 *                             will inherit from Tone
			 */
		    Tone.extend = function (child, parent) {
		        if (isUndef(parent)) {
		            parent = Tone;
		        }
		        function TempConstructor() {
		        }
		        TempConstructor.prototype = parent.prototype;
		        child.prototype = new TempConstructor();
		        /** @override */
		        child.prototype.constructor = child;
		        child._super = parent;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	CONTEXT
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  array of callbacks to be invoked when a new context is added
			 *  @private 
			 *  @private
			 */
		    var newContextCallbacks = [];
		    /**
			 *  invoke this callback when a new context is added
			 *  will be invoked initially with the first context
			 *  @private 
			 *  @static
			 *  @param {function(AudioContext)} callback the callback to be invoked
			 *                                           with the audio context
			 */
		    Tone._initAudioContext = function (callback) {
		        //invoke the callback with the existing AudioContext
		        callback(Tone.context);
		        //add it to the array
		        newContextCallbacks.push(callback);
		    };
		    /**
			 *  Tone automatically creates a context on init, but if you are working
			 *  with other libraries which also create an AudioContext, it can be
			 *  useful to set your own. If you are going to set your own context, 
			 *  be sure to do it at the start of your code, before creating any objects.
			 *  @static
			 *  @param {AudioContext} ctx The new audio context to set
			 */
		    Tone.setContext = function (ctx) {
		        //set the prototypes
		        Tone.prototype.context = ctx;
		        Tone.context = ctx;
		        //invoke all the callbacks
		        for (var i = 0; i < newContextCallbacks.length; i++) {
		            newContextCallbacks[i](ctx);
		        }
		    };
		    //setup the context
		    Tone._initAudioContext(function (audioContext) {
		        //set the blockTime
		        Tone.prototype.blockTime = 128 / audioContext.sampleRate;
		        Tone.prototype.sampleTime = 1 / audioContext.sampleRate;
		        _silentNode = audioContext.createGain();
		        _silentNode.gain.value = 0;
		        _silentNode.connect(audioContext.destination);
		    });
		    Tone.version = 'r9';
		    // allow optional silencing of this log
		    if (!window.TONE_SILENCE_VERSION_LOGGING) {
		        console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');
		    }
		    return Tone;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base class for all Signals. Used Internally. 
			 *
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.SignalBase = function () {
		    };
		    Tone.extend(Tone.SignalBase);
		    /**
			 *  When signals connect to other signals or AudioParams, 
			 *  they take over the output value of that signal or AudioParam. 
			 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
			 *
			 *  @override
			 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
			 *  @param {number} [outputNumber=0] The output number to connect from.
			 *  @param {number} [inputNumber=0] The input number to connect to.
			 *  @returns {Tone.SignalBase} this
			 */
		    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {
		        //zero it out so that the signal can have full control
		        if (Tone.Signal && Tone.Signal === node.constructor || Tone.Param && Tone.Param === node.constructor || Tone.TimelineSignal && Tone.TimelineSignal === node.constructor) {
		            //cancel changes
		            node._param.cancelScheduledValues(0);
		            //reset the value
		            node._param.value = 0;
		            //mark the value as overridden
		            node.overridden = true;
		        } else if (node instanceof AudioParam) {
		            node.cancelScheduledValues(0);
		            node.value = 0;
		        }
		        Tone.prototype.connect.call(this, node, outputNumber, inputNumber);
		        return this;
		    };
		    return Tone.SignalBase;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Wraps the native Web Audio API 
			 *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {function|Array|Number} mapping The function used to define the values. 
			 *                                    The mapping function should take two arguments: 
			 *                                    the first is the value at the current position 
			 *                                    and the second is the array position. 
			 *                                    If the argument is an array, that array will be
			 *                                    set as the wave shaping function. The input
			 *                                    signal is an AudioRange [-1, 1] value and the output
			 *                                    signal can take on any numerical values. 
			 *                                    
			 *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.
			 *  @example
			 * var timesTwo = new Tone.WaveShaper(function(val){
			 * 	return val * 2;
			 * }, 2048);
			 *  @example
			 * //a waveshaper can also be constructed with an array of values
			 * var invert = new Tone.WaveShaper([1, -1]);
			 */
		    Tone.WaveShaper = function (mapping, bufferLen) {
		        /**
				 *  the waveshaper
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._shaper = this.input = this.output = this.context.createWaveShaper();
		        /**
				 *  the waveshapers curve
				 *  @type {Float32Array}
				 *  @private
				 */
		        this._curve = null;
		        if (Array.isArray(mapping)) {
		            this.curve = mapping;
		        } else if (isFinite(mapping) || this.isUndef(mapping)) {
		            this._curve = new Float32Array(this.defaultArg(mapping, 1024));
		        } else if (this.isFunction(mapping)) {
		            this._curve = new Float32Array(this.defaultArg(bufferLen, 1024));
		            this.setMap(mapping);
		        }
		    };
		    Tone.extend(Tone.WaveShaper, Tone.SignalBase);
		    /**
			 *  Uses a mapping function to set the value of the curve. 
			 *  @param {function} mapping The function used to define the values. 
			 *                            The mapping function take two arguments: 
			 *                            the first is the value at the current position 
			 *                            which goes from -1 to 1 over the number of elements
			 *                            in the curve array. The second argument is the array position. 
			 *  @returns {Tone.WaveShaper} this
			 *  @example
			 * //map the input signal from [-1, 1] to [0, 10]
			 * shaper.setMap(function(val, index){
			 * 	return (val + 1) * 5;
			 * })
			 */
		    Tone.WaveShaper.prototype.setMap = function (mapping) {
		        for (var i = 0, len = this._curve.length; i < len; i++) {
		            var normalized = i / (len - 1) * 2 - 1;
		            this._curve[i] = mapping(normalized, i);
		        }
		        this._shaper.curve = this._curve;
		        return this;
		    };
		    /**
			 * The array to set as the waveshaper curve. For linear curves
			 * array length does not make much difference, but for complex curves
			 * longer arrays will provide smoother interpolation. 
			 * @memberOf Tone.WaveShaper#
			 * @type {Array}
			 * @name curve
			 */
		    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {
		        get: function () {
		            return this._shaper.curve;
		        },
		        set: function (mapping) {
		            this._curve = new Float32Array(mapping);
		            this._shaper.curve = this._curve;
		        }
		    });
		    /**
			 * Specifies what type of oversampling (if any) should be used when 
			 * applying the shaping curve. Can either be "none", "2x" or "4x". 
			 * @memberOf Tone.WaveShaper#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            if ([
		                    'none',
		                    '2x',
		                    '4x'
		                ].indexOf(oversampling) !== -1) {
		                this._shaper.oversample = oversampling;
		            } else {
		                throw new RangeError('Tone.WaveShaper: oversampling must be either \'none\', \'2x\', or \'4x\'');
		            }
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.WaveShaper} this
			 */
		    Tone.WaveShaper.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._shaper.disconnect();
		        this._shaper = null;
		        this._curve = null;
		        return this;
		    };
		    return Tone.WaveShaper;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.TimeBase is a flexible encoding of time
			 *         which can be evaluated to and from a string.
			 *         Parsing code modified from https://code.google.com/p/tapdigit/
			 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
			 *  @extends {Tone}
			 *  @param  {Time}  val    The time value as a number or string
			 *  @param  {String=}  units  Unit values
			 *  @example
			 * Tone.TimeBase(4, "n")
			 * Tone.TimeBase(2, "t")
			 * Tone.TimeBase("2t").add("1m")
			 * Tone.TimeBase("2t + 1m");
			 */
		    Tone.TimeBase = function (val, units) {
		        //allows it to be constructed with or without 'new'
		        if (this instanceof Tone.TimeBase) {
		            /**
					 *  Any expressions parsed from the Time
					 *  @type  {Array}
					 *  @private
					 */
		            this._expr = this._noOp;
		            if (val instanceof Tone.TimeBase) {
		                this.copy(val);
		            } else if (!this.isUndef(units) || this.isNumber(val)) {
		                //default units
		                units = this.defaultArg(units, this._defaultUnits);
		                var method = this._primaryExpressions[units].method;
		                this._expr = method.bind(this, val);
		            } else if (this.isString(val)) {
		                this.set(val);
		            } else if (this.isUndef(val)) {
		                //default expression
		                this._expr = this._defaultExpr();
		            }
		        } else {
		            return new Tone.TimeBase(val, units);
		        }
		    };
		    Tone.extend(Tone.TimeBase);
		    /**
			 *  Repalce the current time value with the value
			 *  given by the expression string.
			 *  @param  {String}  exprString
			 *  @return {Tone.TimeBase} this
			 */
		    Tone.TimeBase.prototype.set = function (exprString) {
		        this._expr = this._parseExprString(exprString);
		        return this;
		    };
		    /**
			 *  Return a clone of the TimeBase object.
			 *  @return  {Tone.TimeBase} The new cloned Tone.TimeBase
			 */
		    Tone.TimeBase.prototype.clone = function () {
		        var instance = new this.constructor();
		        instance.copy(this);
		        return instance;
		    };
		    /**
			 *  Copies the value of time to this Time
			 *  @param {Tone.TimeBase} time
			 *  @return  {TimeBase}
			 */
		    Tone.TimeBase.prototype.copy = function (time) {
		        var val = time._expr();
		        return this.set(val);
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	ABSTRACT SYNTAX TREE PARSER
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  All the primary expressions.
			 *  @private
			 *  @type  {Object}
			 */
		    Tone.TimeBase.prototype._primaryExpressions = {
		        'n': {
		            regexp: /^(\d+)n/i,
		            method: function (value) {
		                value = parseInt(value);
		                if (value === 1) {
		                    return this._beatsToUnits(this._timeSignature());
		                } else {
		                    return this._beatsToUnits(4 / value);
		                }
		            }
		        },
		        't': {
		            regexp: /^(\d+)t/i,
		            method: function (value) {
		                value = parseInt(value);
		                return this._beatsToUnits(8 / (parseInt(value) * 3));
		            }
		        },
		        'm': {
		            regexp: /^(\d+)m/i,
		            method: function (value) {
		                return this._beatsToUnits(parseInt(value) * this._timeSignature());
		            }
		        },
		        'i': {
		            regexp: /^(\d+)i/i,
		            method: function (value) {
		                return this._ticksToUnits(parseInt(value));
		            }
		        },
		        'hz': {
		            regexp: /^(\d+(?:\.\d+)?)hz/i,
		            method: function (value) {
		                return this._frequencyToUnits(parseFloat(value));
		            }
		        },
		        'tr': {
		            regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
		            method: function (m, q, s) {
		                var total = 0;
		                if (m && m !== '0') {
		                    total += this._beatsToUnits(this._timeSignature() * parseFloat(m));
		                }
		                if (q && q !== '0') {
		                    total += this._beatsToUnits(parseFloat(q));
		                }
		                if (s && s !== '0') {
		                    total += this._beatsToUnits(parseFloat(s) / 4);
		                }
		                return total;
		            }
		        },
		        's': {
		            regexp: /^(\d+(?:\.\d+)?s)/,
		            method: function (value) {
		                return this._secondsToUnits(parseFloat(value));
		            }
		        },
		        'samples': {
		            regexp: /^(\d+)samples/,
		            method: function (value) {
		                return parseInt(value) / this.context.sampleRate;
		            }
		        },
		        'default': {
		            regexp: /^(\d+(?:\.\d+)?)/,
		            method: function (value) {
		                return this._primaryExpressions[this._defaultUnits].method.call(this, value);
		            }
		        }
		    };
		    /**
			 *  All the binary expressions that TimeBase can accept.
			 *  @private
			 *  @type  {Object}
			 */
		    Tone.TimeBase.prototype._binaryExpressions = {
		        '+': {
		            regexp: /^\+/,
		            precedence: 2,
		            method: function (lh, rh) {
		                return lh() + rh();
		            }
		        },
		        '-': {
		            regexp: /^\-/,
		            precedence: 2,
		            method: function (lh, rh) {
		                return lh() - rh();
		            }
		        },
		        '*': {
		            regexp: /^\*/,
		            precedence: 1,
		            method: function (lh, rh) {
		                return lh() * rh();
		            }
		        },
		        '/': {
		            regexp: /^\//,
		            precedence: 1,
		            method: function (lh, rh) {
		                return lh() / rh();
		            }
		        }
		    };
		    /**
			 *  All the unary expressions.
			 *  @private
			 *  @type  {Object}
			 */
		    Tone.TimeBase.prototype._unaryExpressions = {
		        'neg': {
		            regexp: /^\-/,
		            method: function (lh) {
		                return -lh();
		            }
		        }
		    };
		    /**
			 *  Syntactic glue which holds expressions together
			 *  @private
			 *  @type  {Object}
			 */
		    Tone.TimeBase.prototype._syntaxGlue = {
		        '(': { regexp: /^\(/ },
		        ')': { regexp: /^\)/ }
		    };
		    /**
			 *  tokenize the expression based on the Expressions object
			 *  @param   {string} expr 
			 *  @return  {Object}      returns two methods on the tokenized list, next and peek
			 *  @private
			 */
		    Tone.TimeBase.prototype._tokenize = function (expr) {
		        var position = -1;
		        var tokens = [];
		        while (expr.length > 0) {
		            expr = expr.trim();
		            var token = getNextToken(expr, this);
		            tokens.push(token);
		            expr = expr.substr(token.value.length);
		        }
		        function getNextToken(expr, context) {
		            var expressions = [
		                '_binaryExpressions',
		                '_unaryExpressions',
		                '_primaryExpressions',
		                '_syntaxGlue'
		            ];
		            for (var i = 0; i < expressions.length; i++) {
		                var group = context[expressions[i]];
		                for (var opName in group) {
		                    var op = group[opName];
		                    var reg = op.regexp;
		                    var match = expr.match(reg);
		                    if (match !== null) {
		                        return {
		                            method: op.method,
		                            precedence: op.precedence,
		                            regexp: op.regexp,
		                            value: match[0]
		                        };
		                    }
		                }
		            }
		            throw new SyntaxError('Tone.TimeBase: Unexpected token ' + expr);
		        }
		        return {
		            next: function () {
		                return tokens[++position];
		            },
		            peek: function () {
		                return tokens[position + 1];
		            }
		        };
		    };
		    /**
			 *  Given a token, find the value within the groupName
			 *  @param {Object} token
			 *  @param {String} groupName
			 *  @param {Number} precedence
			 *  @private
			 */
		    Tone.TimeBase.prototype._matchGroup = function (token, group, prec) {
		        var ret = false;
		        if (!this.isUndef(token)) {
		            for (var opName in group) {
		                var op = group[opName];
		                if (op.regexp.test(token.value)) {
		                    if (!this.isUndef(prec)) {
		                        if (op.precedence === prec) {
		                            return op;
		                        }
		                    } else {
		                        return op;
		                    }
		                }
		            }
		        }
		        return ret;
		    };
		    /**
			 *  Match a binary expression given the token and the precedence
			 *  @param {Lexer} lexer
			 *  @param {Number} precedence
			 *  @private
			 */
		    Tone.TimeBase.prototype._parseBinary = function (lexer, precedence) {
		        if (this.isUndef(precedence)) {
		            precedence = 2;
		        }
		        var expr;
		        if (precedence < 0) {
		            expr = this._parseUnary(lexer);
		        } else {
		            expr = this._parseBinary(lexer, precedence - 1);
		        }
		        var token = lexer.peek();
		        while (token && this._matchGroup(token, this._binaryExpressions, precedence)) {
		            token = lexer.next();
		            expr = token.method.bind(this, expr, this._parseBinary(lexer, precedence - 1));
		            token = lexer.peek();
		        }
		        return expr;
		    };
		    /**
			 *  Match a unary expression.
			 *  @param {Lexer} lexer
			 *  @private
			 */
		    Tone.TimeBase.prototype._parseUnary = function (lexer) {
		        var token, expr;
		        token = lexer.peek();
		        var op = this._matchGroup(token, this._unaryExpressions);
		        if (op) {
		            token = lexer.next();
		            expr = this._parseUnary(lexer);
		            return op.method.bind(this, expr);
		        }
		        return this._parsePrimary(lexer);
		    };
		    /**
			 *  Match a primary expression (a value).
			 *  @param {Lexer} lexer
			 *  @private
			 */
		    Tone.TimeBase.prototype._parsePrimary = function (lexer) {
		        var token, expr;
		        token = lexer.peek();
		        if (this.isUndef(token)) {
		            throw new SyntaxError('Tone.TimeBase: Unexpected end of expression');
		        }
		        if (this._matchGroup(token, this._primaryExpressions)) {
		            token = lexer.next();
		            var matching = token.value.match(token.regexp);
		            return token.method.bind(this, matching[1], matching[2], matching[3]);
		        }
		        if (token && token.value === '(') {
		            lexer.next();
		            expr = this._parseBinary(lexer);
		            token = lexer.next();
		            if (!(token && token.value === ')')) {
		                throw new SyntaxError('Expected )');
		            }
		            return expr;
		        }
		        throw new SyntaxError('Tone.TimeBase: Cannot process token ' + token.value);
		    };
		    /**
			 *  Recursively parse the string expression into a syntax tree.
			 *  @param   {string} expr 
			 *  @return  {Function} the bound method to be evaluated later
			 *  @private
			 */
		    Tone.TimeBase.prototype._parseExprString = function (exprString) {
		        if (!this.isString(exprString)) {
		            exprString = exprString.toString();
		        }
		        var lexer = this._tokenize(exprString);
		        var tree = this._parseBinary(lexer);
		        return tree;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	DEFAULTS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  The initial expression value
			 *  @return  {Number}  The initial value 0
			 *  @private
			 */
		    Tone.TimeBase.prototype._noOp = function () {
		        return 0;
		    };
		    /**
			 *  The default expression value if no arguments are given
			 *  @private
			 */
		    Tone.TimeBase.prototype._defaultExpr = function () {
		        return this._noOp;
		    };
		    /**
			 *  The default units if none are given.
			 *  @private
			 */
		    Tone.TimeBase.prototype._defaultUnits = 's';
		    ///////////////////////////////////////////////////////////////////////////
		    //	UNIT CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Returns the value of a frequency in the current units
			 *  @param {Frequency} freq
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.TimeBase.prototype._frequencyToUnits = function (freq) {
		        return 1 / freq;
		    };
		    /**
			 *  Return the value of the beats in the current units
			 *  @param {Number} beats
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.TimeBase.prototype._beatsToUnits = function (beats) {
		        return 60 / Tone.Transport.bpm.value * beats;
		    };
		    /**
			 *  Returns the value of a second in the current units
			 *  @param {Seconds} seconds
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.TimeBase.prototype._secondsToUnits = function (seconds) {
		        return seconds;
		    };
		    /**
			 *  Returns the value of a tick in the current time units
			 *  @param {Ticks} ticks
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.TimeBase.prototype._ticksToUnits = function (ticks) {
		        return ticks * (this._beatsToUnits(1) / Tone.Transport.PPQ);
		    };
		    /**
			 *  Return the time signature.
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.TimeBase.prototype._timeSignature = function () {
		        return Tone.Transport.timeSignature;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	EXPRESSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Push an expression onto the expression list
			 *  @param  {Time}  val
			 *  @param  {String}  type
			 *  @param  {String}  units
			 *  @return  {Tone.TimeBase} 
			 *  @private
			 */
		    Tone.TimeBase.prototype._pushExpr = function (val, name, units) {
		        //create the expression
		        if (!(val instanceof Tone.TimeBase)) {
		            val = new this.constructor(val, units);
		        }
		        this._expr = this._binaryExpressions[name].method.bind(this, this._expr, val._expr);
		        return this;
		    };
		    /**
			 *  Add to the current value.
			 *  @param  {Time}  val    The value to add
			 *  @param  {String=}  units  Optional units to use with the value.
			 *  @return  {Tone.TimeBase}  this
			 *  @example
			 * Tone.TimeBase("2m").add("1m"); //"3m"
			 */
		    Tone.TimeBase.prototype.add = function (val, units) {
		        return this._pushExpr(val, '+', units);
		    };
		    /**
			 *  Subtract the value from the current time.
			 *  @param  {Time}  val    The value to subtract
			 *  @param  {String=}  units  Optional units to use with the value.
			 *  @return  {Tone.TimeBase}  this
			 *  @example
			 * Tone.TimeBase("2m").sub("1m"); //"1m"
			 */
		    Tone.TimeBase.prototype.sub = function (val, units) {
		        return this._pushExpr(val, '-', units);
		    };
		    /**
			 *  Multiply the current value by the given time.
			 *  @param  {Time}  val    The value to multiply
			 *  @param  {String=}  units  Optional units to use with the value.
			 *  @return  {Tone.TimeBase}  this
			 *  @example
			 * Tone.TimeBase("2m").mult("2"); //"4m"
			 */
		    Tone.TimeBase.prototype.mult = function (val, units) {
		        return this._pushExpr(val, '*', units);
		    };
		    /**
			 *  Divide the current value by the given time.
			 *  @param  {Time}  val    The value to divide by
			 *  @param  {String=}  units  Optional units to use with the value.
			 *  @return  {Tone.TimeBase}  this
			 *  @example
			 * Tone.TimeBase("2m").div(2); //"1m"
			 */
		    Tone.TimeBase.prototype.div = function (val, units) {
		        return this._pushExpr(val, '/', units);
		    };
		    /**
			 *  Evaluate the time value. Returns the time
			 *  in seconds.
			 *  @return  {Seconds} 
			 */
		    Tone.TimeBase.prototype.eval = function () {
		        return this._expr();
		    };
		    /**
			 *  Clean up
			 *  @return {Tone.TimeBase} this
			 */
		    Tone.TimeBase.prototype.dispose = function () {
		        this._expr = null;
		    };
		    return Tone.TimeBase;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.Time is a primitive type for encoding Time values. 
			 *         Eventually all time values are evaluated to seconds
			 *         using the `eval` method. Tone.Time can be constructed
			 *         with or without the `new` keyword. Tone.Time can be passed
			 *         into the parameter of any method which takes time as an argument. 
			 *  @constructor
			 *  @extends {Tone.TimeBase}
			 *  @param  {String|Number}  val    The time value.
			 *  @param  {String=}  units  The units of the value.
			 *  @example
			 * var t = Tone.Time("4n");//encodes a quarter note
			 * t.mult(4); // multiply that value by 4
			 * t.toNotation(); //returns "1m"
			 */
		    Tone.Time = function (val, units) {
		        if (this instanceof Tone.Time) {
		            /**
					 *  If the current clock time should
					 *  be added to the output
					 *  @type  {Boolean}
					 *  @private
					 */
		            this._plusNow = false;
		            Tone.TimeBase.call(this, val, units);
		        } else {
		            return new Tone.Time(val, units);
		        }
		    };
		    Tone.extend(Tone.Time, Tone.TimeBase);
		    //clone the expressions so that 
		    //we can add more without modifying the original
		    Tone.Time.prototype._unaryExpressions = Object.create(Tone.TimeBase.prototype._unaryExpressions);
		    /*
			 *  Adds an additional unary expression
			 *  which quantizes values to the next subdivision
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Time.prototype._unaryExpressions.quantize = {
		        regexp: /^@/,
		        method: function (rh) {
		            return Tone.Transport.nextSubdivision(rh());
		        }
		    };
		    /*
			 *  Adds an additional unary expression
			 *  which adds the current clock time.
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Time.prototype._unaryExpressions.now = {
		        regexp: /^\+/,
		        method: function (lh) {
		            this._plusNow = true;
		            return lh();
		        }
		    };
		    /**
			 *  Quantize the time by the given subdivision. Optionally add a
			 *  percentage which will move the time value towards the ideal
			 *  quantized value by that percentage. 
			 *  @param  {Number|Time}  val    The subdivision to quantize to
			 *  @param  {NormalRange}  [percent=1]  Move the time value
			 *                                   towards the quantized value by
			 *                                   a percentage.
			 *  @return  {Tone.Time}  this
			 *  @example
			 * Tone.Time(21).quantize(2).eval() //returns 22
			 * Tone.Time(0.6).quantize("4n", 0.5).eval() //returns 0.55
			 */
		    Tone.Time.prototype.quantize = function (subdiv, percent) {
		        percent = this.defaultArg(percent, 1);
		        this._expr = function (expr, subdivision, percent) {
		            expr = expr();
		            subdivision = subdivision.toSeconds();
		            var multiple = Math.round(expr / subdivision);
		            var ideal = multiple * subdivision;
		            var diff = ideal - expr;
		            return expr + diff * percent;
		        }.bind(this, this._expr, new this.constructor(subdiv), percent);
		        return this;
		    };
		    /**
			 *  Adds the clock time to the time expression at the 
			 *  moment of evaluation. 
			 *  @return  {Tone.Time}  this
			 */
		    Tone.Time.prototype.addNow = function () {
		        this._plusNow = true;
		        return this;
		    };
		    /**
			 *  @override
			 *  Override the default value return when no arguments are passed in.
			 *  The default value is 'now'
			 *  @private
			 */
		    Tone.Time.prototype._defaultExpr = function () {
		        this._plusNow = true;
		        return this._noOp;
		    };
		    /**
			 *  Copies the value of time to this Time
			 *  @param {Tone.Time} time
			 *  @return  {Time}
			 */
		    Tone.Time.prototype.copy = function (time) {
		        Tone.TimeBase.prototype.copy.call(this, time);
		        this._plusNow = time._plusNow;
		        return this;
		    };
		    //CONVERSIONS//////////////////////////////////////////////////////////////
		    /**
			 *  Convert a Time to Notation. Values will be thresholded to the nearest 128th note. 
			 *  @return {Notation} 
			 *  @example
			 * //if the Transport is at 120bpm:
			 * Tone.Time(2).toNotation();//returns "1m"
			 */
		    Tone.Time.prototype.toNotation = function () {
		        var time = this.toSeconds();
		        var testNotations = [
		            '1m',
		            '2n',
		            '4n',
		            '8n',
		            '16n',
		            '32n',
		            '64n',
		            '128n'
		        ];
		        var retNotation = this._toNotationHelper(time, testNotations);
		        //try the same thing but with tripelets
		        var testTripletNotations = [
		            '1m',
		            '2n',
		            '2t',
		            '4n',
		            '4t',
		            '8n',
		            '8t',
		            '16n',
		            '16t',
		            '32n',
		            '32t',
		            '64n',
		            '64t',
		            '128n'
		        ];
		        var retTripletNotation = this._toNotationHelper(time, testTripletNotations);
		        //choose the simpler expression of the two
		        if (retTripletNotation.split('+').length < retNotation.split('+').length) {
		            return retTripletNotation;
		        } else {
		            return retNotation;
		        }
		    };
		    /**
			 *  Helper method for Tone.toNotation
			 *  @param {Number} units 
			 *  @param {Array} testNotations
			 *  @return {String}
			 *  @private
			 */
		    Tone.Time.prototype._toNotationHelper = function (units, testNotations) {
		        //the threshold is the last value in the array
		        var threshold = this._notationToUnits(testNotations[testNotations.length - 1]);
		        var retNotation = '';
		        for (var i = 0; i < testNotations.length; i++) {
		            var notationTime = this._notationToUnits(testNotations[i]);
		            //account for floating point errors (i.e. round up if the value is 0.999999)
		            var multiple = units / notationTime;
		            var floatingPointError = 0.000001;
		            if (1 - multiple % 1 < floatingPointError) {
		                multiple += floatingPointError;
		            }
		            multiple = Math.floor(multiple);
		            if (multiple > 0) {
		                if (multiple === 1) {
		                    retNotation += testNotations[i];
		                } else {
		                    retNotation += multiple.toString() + '*' + testNotations[i];
		                }
		                units -= multiple * notationTime;
		                if (units < threshold) {
		                    break;
		                } else {
		                    retNotation += ' + ';
		                }
		            }
		        }
		        if (retNotation === '') {
		            retNotation = '0';
		        }
		        return retNotation;
		    };
		    /**
			 *  Convert a notation value to the current units
			 *  @param  {Notation}  notation 
			 *  @return  {Number} 
			 *  @private
			 */
		    Tone.Time.prototype._notationToUnits = function (notation) {
		        var primaryExprs = this._primaryExpressions;
		        var notationExprs = [
		            primaryExprs.n,
		            primaryExprs.t,
		            primaryExprs.m
		        ];
		        for (var i = 0; i < notationExprs.length; i++) {
		            var expr = notationExprs[i];
		            var match = notation.match(expr.regexp);
		            if (match) {
		                return expr.method.call(this, match[1]);
		            }
		        }
		    };
		    /**
			 *  Return the time encoded as Bars:Beats:Sixteenths.
			 *  @return  {BarsBeatsSixteenths}
			 */
		    Tone.Time.prototype.toBarsBeatsSixteenths = function () {
		        var quarterTime = this._beatsToUnits(1);
		        var quarters = this.toSeconds() / quarterTime;
		        var measures = Math.floor(quarters / this._timeSignature());
		        var sixteenths = quarters % 1 * 4;
		        quarters = Math.floor(quarters) % this._timeSignature();
		        sixteenths = sixteenths.toString();
		        if (sixteenths.length > 3) {
		            sixteenths = parseFloat(sixteenths).toFixed(3);
		        }
		        var progress = [
		            measures,
		            quarters,
		            sixteenths
		        ];
		        return progress.join(':');
		    };
		    /**
			 *  Return the time in ticks.
			 *  @return  {Ticks}
			 */
		    Tone.Time.prototype.toTicks = function () {
		        var quarterTime = this._beatsToUnits(1);
		        var quarters = this.eval() / quarterTime;
		        return Math.floor(quarters * Tone.Transport.PPQ);
		    };
		    /**
			 *  Return the time in samples
			 *  @return  {Samples}  
			 */
		    Tone.Time.prototype.toSamples = function () {
		        return this.toSeconds() * this.context.sampleRate;
		    };
		    /**
			 *  Return the time as a frequency value
			 *  @return  {Frequency} 
			 *  @example
			 * Tone.Time(2).toFrequency(); //0.5
			 */
		    Tone.Time.prototype.toFrequency = function () {
		        return 1 / this.toSeconds();
		    };
		    /**
			 *  Return the time in seconds.
			 *  @return  {Seconds} 
			 */
		    Tone.Time.prototype.toSeconds = function () {
		        return this.eval();
		    };
		    /**
			 *  Return the time in milliseconds.
			 *  @return  {Milliseconds} 
			 */
		    Tone.Time.prototype.toMilliseconds = function () {
		        return this.toSeconds() * 1000;
		    };
		    /**
			 *  Return the time in seconds.
			 *  @return  {Seconds} 
			 */
		    Tone.Time.prototype.eval = function () {
		        var val = this._expr();
		        return val + (this._plusNow ? this.now() : 0);
		    };
		    return Tone.Time;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.Frequency is a primitive type for encoding Frequency values. 
			 *         Eventually all time values are evaluated to hertz
			 *         using the `eval` method. 
			 *  @constructor
			 *  @extends {Tone.TimeBase}
			 *  @param  {String|Number}  val    The time value.
			 *  @param  {String=}  units  The units of the value.
			 *  @example
			 * Tone.Frequency("C3").eval() // 261
			 * Tone.Frequency(38, "midi").eval() //
			 * Tone.Frequency("C3").transpose(4).eval();
			 */
		    Tone.Frequency = function (val, units) {
		        if (this instanceof Tone.Frequency) {
		            Tone.TimeBase.call(this, val, units);
		        } else {
		            return new Tone.Frequency(val, units);
		        }
		    };
		    Tone.extend(Tone.Frequency, Tone.TimeBase);
		    ///////////////////////////////////////////////////////////////////////////
		    //	AUGMENT BASE EXPRESSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    //clone the expressions so that 
		    //we can add more without modifying the original
		    Tone.Frequency.prototype._primaryExpressions = Object.create(Tone.TimeBase.prototype._primaryExpressions);
		    /*
			 *  midi type primary expression
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Frequency.prototype._primaryExpressions.midi = {
		        regexp: /^(\d+(?:\.\d+)?midi)/,
		        method: function (value) {
		            return this.midiToFrequency(value);
		        }
		    };
		    /*
			 *  note type primary expression
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Frequency.prototype._primaryExpressions.note = {
		        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
		        method: function (pitch, octave) {
		            var index = noteToScaleIndex[pitch.toLowerCase()];
		            var noteNumber = index + (parseInt(octave) + 1) * 12;
		            return this.midiToFrequency(noteNumber);
		        }
		    };
		    /*
			 *  BeatsBarsSixteenths type primary expression
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Frequency.prototype._primaryExpressions.tr = {
		        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
		        method: function (m, q, s) {
		            var total = 1;
		            if (m && m !== '0') {
		                total *= this._beatsToUnits(this._timeSignature() * parseFloat(m));
		            }
		            if (q && q !== '0') {
		                total *= this._beatsToUnits(parseFloat(q));
		            }
		            if (s && s !== '0') {
		                total *= this._beatsToUnits(parseFloat(s) / 4);
		            }
		            return total;
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	EXPRESSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Transposes the frequency by the given number of semitones.
			 *  @param  {Interval}  interval
			 *  @return  {Tone.Frequency} this
			 *  @example
			 * Tone.Frequency("A4").transpose(3); //"C5"
			 */
		    Tone.Frequency.prototype.transpose = function (interval) {
		        this._expr = function (expr, interval) {
		            var val = expr();
		            return val * this.intervalToFrequencyRatio(interval);
		        }.bind(this, this._expr, interval);
		        return this;
		    };
		    /**
			 *  Takes an array of semitone intervals and returns
			 *  an array of frequencies transposed by those intervals.
			 *  @param  {Array}  intervals
			 *  @return  {Tone.Frequency} this
			 *  @example
			 * Tone.Frequency("A4").harmonize([0, 3, 7]); //["A4", "C5", "E5"]
			 */
		    Tone.Frequency.prototype.harmonize = function (intervals) {
		        this._expr = function (expr, intervals) {
		            var val = expr();
		            var ret = [];
		            for (var i = 0; i < intervals.length; i++) {
		                ret[i] = val * this.intervalToFrequencyRatio(intervals[i]);
		            }
		            return ret;
		        }.bind(this, this._expr, intervals);
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	UNIT CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Return the value of the frequency as a MIDI note
			 *  @return  {MIDI}
			 *  @example
			 * Tone.Frequency("C4").toMidi(); //60
			 */
		    Tone.Frequency.prototype.toMidi = function () {
		        return this.frequencyToMidi(this.eval());
		    };
		    /**
			 *  Return the value of the frequency in Scientific Pitch Notation
			 *  @return  {Note}
			 *  @example
			 * Tone.Frequency(69, "midi").toNote(); //"A4"
			 */
		    Tone.Frequency.prototype.toNote = function () {
		        var freq = this.eval();
		        var log = Math.log(freq / Tone.Frequency.A4) / Math.LN2;
		        var noteNumber = Math.round(12 * log) + 57;
		        var octave = Math.floor(noteNumber / 12);
		        if (octave < 0) {
		            noteNumber += -12 * octave;
		        }
		        var noteName = scaleIndexToNote[noteNumber % 12];
		        return noteName + octave.toString();
		    };
		    /**
			 *  Return the duration of one cycle in seconds.
			 *  @return  {Seconds}
			 */
		    Tone.Frequency.prototype.toSeconds = function () {
		        return 1 / this.eval();
		    };
		    /**
			 *  Return the value in Hertz
			 *  @return  {Frequency}
			 */
		    Tone.Frequency.prototype.toFrequency = function () {
		        return this.eval();
		    };
		    /**
			 *  Return the duration of one cycle in ticks
			 *  @return  {Ticks}
			 */
		    Tone.Frequency.prototype.toTicks = function () {
		        var quarterTime = this._beatsToUnits(1);
		        var quarters = this.eval() / quarterTime;
		        return Math.floor(quarters * Tone.Transport.PPQ);
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	UNIT CONVERSIONS HELPERS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Returns the value of a frequency in the current units
			 *  @param {Frequency} freq
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.Frequency.prototype._frequencyToUnits = function (freq) {
		        return freq;
		    };
		    /**
			 *  Returns the value of a tick in the current time units
			 *  @param {Ticks} ticks
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.Frequency.prototype._ticksToUnits = function (ticks) {
		        return 1 / (ticks * 60 / (Tone.Transport.bpm.value * Tone.Transport.PPQ));
		    };
		    /**
			 *  Return the value of the beats in the current units
			 *  @param {Number} beats
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.Frequency.prototype._beatsToUnits = function (beats) {
		        return 1 / Tone.TimeBase.prototype._beatsToUnits.call(this, beats);
		    };
		    /**
			 *  Returns the value of a second in the current units
			 *  @param {Seconds} seconds
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.Frequency.prototype._secondsToUnits = function (seconds) {
		        return 1 / seconds;
		    };
		    /**
			 *  The default units if none are given.
			 *  @private
			 */
		    Tone.Frequency.prototype._defaultUnits = 'hz';
		    ///////////////////////////////////////////////////////////////////////////
		    //	FREQUENCY CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Note to scale index
			 *  @type  {Object}
			 */
		    var noteToScaleIndex = {
		        'cbb': -2,
		        'cb': -1,
		        'c': 0,
		        'c#': 1,
		        'cx': 2,
		        'dbb': 0,
		        'db': 1,
		        'd': 2,
		        'd#': 3,
		        'dx': 4,
		        'ebb': 2,
		        'eb': 3,
		        'e': 4,
		        'e#': 5,
		        'ex': 6,
		        'fbb': 3,
		        'fb': 4,
		        'f': 5,
		        'f#': 6,
		        'fx': 7,
		        'gbb': 5,
		        'gb': 6,
		        'g': 7,
		        'g#': 8,
		        'gx': 9,
		        'abb': 7,
		        'ab': 8,
		        'a': 9,
		        'a#': 10,
		        'ax': 11,
		        'bbb': 9,
		        'bb': 10,
		        'b': 11,
		        'b#': 12,
		        'bx': 13
		    };
		    /**
			 *  scale index to note (sharps)
			 *  @type  {Array}
			 */
		    var scaleIndexToNote = [
		        'C',
		        'C#',
		        'D',
		        'D#',
		        'E',
		        'F',
		        'F#',
		        'G',
		        'G#',
		        'A',
		        'A#',
		        'B'
		    ];
		    /**
			 *  The [concert pitch](https://en.wikipedia.org/wiki/Concert_pitch)
			 *  A4's values in Hertz. 
			 *  @type {Frequency}
			 *  @static
			 */
		    Tone.Frequency.A4 = 440;
		    /**
			 *  Convert a MIDI note to frequency value. 
			 *  @param  {MIDI} midi The midi number to convert.
			 *  @return {Frequency} the corresponding frequency value
			 *  @example
			 * tone.midiToFrequency(69); // returns 440
			 */
		    Tone.Frequency.prototype.midiToFrequency = function (midi) {
		        return Tone.Frequency.A4 * Math.pow(2, (midi - 69) / 12);
		    };
		    /**
			 *  Convert a frequency value to a MIDI note.
			 *  @param {Frequency} frequency The value to frequency value to convert.
			 *  @returns  {MIDI}
			 *  @example
			 * tone.midiToFrequency(440); // returns 69
			 */
		    Tone.Frequency.prototype.frequencyToMidi = function (frequency) {
		        return 69 + 12 * Math.log(frequency / Tone.Frequency.A4) / Math.LN2;
		    };
		    return Tone.Frequency;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.TransportTime is a the time along the Transport's
			 *         timeline. It is similar to Tone.Time, but instead of evaluating
			 *         against the AudioContext's clock, it is evaluated against
			 *         the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
			 *  @constructor
			 *  @param  {Time}  val    The time value as a number or string
			 *  @param  {String=}  units  Unit values
			 *  @extends {Tone.Time}
			 */
		    Tone.TransportTime = function (val, units) {
		        if (this instanceof Tone.TransportTime) {
		            Tone.Time.call(this, val, units);
		        } else {
		            return new Tone.TransportTime(val, units);
		        }
		    };
		    Tone.extend(Tone.TransportTime, Tone.Time);
		    //clone the expressions so that 
		    //we can add more without modifying the original
		    Tone.TransportTime.prototype._unaryExpressions = Object.create(Tone.Time.prototype._unaryExpressions);
		    /**
			 *  Adds an additional unary expression
			 *  which quantizes values to the next subdivision
			 *  @type {Object}
			 *  @private
			 */
		    Tone.TransportTime.prototype._unaryExpressions.quantize = {
		        regexp: /^@/,
		        method: function (rh) {
		            var subdivision = this._secondsToTicks(rh());
		            var multiple = Math.ceil(Tone.Transport.ticks / subdivision);
		            return this._ticksToUnits(multiple * subdivision);
		        }
		    };
		    /**
			 *  Convert seconds into ticks
			 *  @param {Seconds} seconds
			 *  @return  {Ticks}
			 *  @private
			 */
		    Tone.TransportTime.prototype._secondsToTicks = function (seconds) {
		        var quarterTime = this._beatsToUnits(1);
		        var quarters = seconds / quarterTime;
		        return Math.round(quarters * Tone.Transport.PPQ);
		    };
		    /**
			 *  Evaluate the time expression. Returns values in ticks
			 *  @return {Ticks}
			 */
		    Tone.TransportTime.prototype.eval = function () {
		        var val = this._secondsToTicks(this._expr());
		        return val + (this._plusNow ? Tone.Transport.ticks : 0);
		    };
		    /**
			 *  Return the time in ticks.
			 *  @return  {Ticks}
			 */
		    Tone.TransportTime.prototype.toTicks = function () {
		        return this.eval();
		    };
		    /**
			 *  Return the time in seconds.
			 *  @return  {Seconds}
			 */
		    Tone.TransportTime.prototype.toSeconds = function () {
		        var val = this._expr();
		        return val + (this._plusNow ? Tone.Transport.seconds : 0);
		    };
		    /**
			 *  Return the time as a frequency value
			 *  @return  {Frequency} 
			 */
		    Tone.TransportTime.prototype.toFrequency = function () {
		        return 1 / this.toSeconds();
		    };
		    return Tone.TransportTime;
		});
		Module(function (Tone) {
		    ///////////////////////////////////////////////////////////////////////////
		    //	TYPES
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 * Units which a value can take on.
			 * @enum {String}
			 */
		    Tone.Type = {
		        /** 
				 *  Default units
				 *  @typedef {Default}
				 */
		        Default: 'number',
		        /**
				 *  Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).
				 *
				 *  <ul>
				 *  <li>Numbers, which will be taken literally as the time (in seconds).</li>
				 *  <li>Notation, ("4n", "8t") describes time in BPM and time signature relative values.</li>
				 *  <li>TransportTime, ("4:3:2") will also provide tempo and time signature relative times 
				 *  in the form BARS:QUARTERS:SIXTEENTHS.</li>
				 *  <li>Frequency, ("8hz") is converted to the length of the cycle in seconds.</li>
				 *  <li>Now-Relative, ("+1") prefix any of the above with "+" and it will be interpreted as 
				 *  "the current time plus whatever expression follows".</li>
				 *  <li>Expressions, ("3:0 + 2 - (1m / 7)") any of the above can also be combined 
				 *  into a mathematical expression which will be evaluated to compute the desired time.</li>
				 *  <li>No Argument, for methods which accept time, no argument will be interpreted as 
				 *  "now" (i.e. the currentTime).</li>
				 *  </ul>
				 *  
				 *  @typedef {Time}
				 */
		        Time: 'time',
		        /**
				 *  Frequency can be described similar to time, except ultimately the
				 *  values are converted to frequency instead of seconds. A number
				 *  is taken literally as the value in hertz. Additionally any of the 
				 *  Time encodings can be used. Note names in the form
				 *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their
				 *  frequency value. 
				 *  @typedef {Frequency}
				 */
		        Frequency: 'frequency',
		        /**
				 *  TransportTime describes a position along the Transport's timeline. It is
				 *  similar to Time in that it uses all the same encodings, but TransportTime specifically
				 *  pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable. 
				 *  [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)
				 *  @typedef {TransportTime}
				 */
		        TransportTime: 'transportTime',
		        /** 
				 *  Ticks are the basic subunit of the Transport. They are
				 *  the smallest unit of time that the Transport supports.
				 *  @typedef {Ticks}
				 */
		        Ticks: 'ticks',
		        /** 
				 *  Normal values are within the range [0, 1].
				 *  @typedef {NormalRange}
				 */
		        NormalRange: 'normalRange',
		        /** 
				 *  AudioRange values are between [-1, 1].
				 *  @typedef {AudioRange}
				 */
		        AudioRange: 'audioRange',
		        /** 
				 *  Decibels are a logarithmic unit of measurement which is useful for volume
				 *  because of the logarithmic way that we perceive loudness. 0 decibels 
				 *  means no change in volume. -10db is approximately half as loud and 10db 
				 *  is twice is loud. 
				 *  @typedef {Decibels}
				 */
		        Decibels: 'db',
		        /** 
				 *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.
				 *  @typedef {Interval}
				 */
		        Interval: 'interval',
		        /** 
				 *  Beats per minute. 
				 *  @typedef {BPM}
				 */
		        BPM: 'bpm',
		        /** 
				 *  The value must be greater than or equal to 0.
				 *  @typedef {Positive}
				 */
		        Positive: 'positive',
		        /** 
				 *  A cent is a hundredth of a semitone. 
				 *  @typedef {Cents}
				 */
		        Cents: 'cents',
		        /** 
				 *  Angle between 0 and 360. 
				 *  @typedef {Degrees}
				 */
		        Degrees: 'degrees',
		        /** 
				 *  A number representing a midi note.
				 *  @typedef {MIDI}
				 */
		        MIDI: 'midi',
		        /** 
				 *  A colon-separated representation of time in the form of
				 *  Bars:Beats:Sixteenths. 
				 *  @typedef {BarsBeatsSixteenths}
				 */
		        BarsBeatsSixteenths: 'barsBeatsSixteenths',
		        /** 
				 *  Sampling is the reduction of a continuous signal to a discrete signal.
				 *  Audio is typically sampled 44100 times per second. 
				 *  @typedef {Samples}
				 */
		        Samples: 'samples',
		        /** 
				 *  Hertz are a frequency representation defined as one cycle per second.
				 *  @typedef {Hertz}
				 */
		        Hertz: 'hertz',
		        /** 
				 *  A frequency represented by a letter name, 
				 *  accidental and octave. This system is known as
				 *  [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).
				 *  @typedef {Note}
				 */
		        Note: 'note',
		        /** 
				 *  One millisecond is a thousandth of a second. 
				 *  @typedef {Milliseconds}
				 */
		        Milliseconds: 'milliseconds',
		        /** 
				 *  Seconds are the time unit of the AudioContext. In the end, 
				 *  all values need to be evaluated to seconds. 
				 *  @typedef {Seconds}
				 */
		        Seconds: 'seconds',
		        /** 
				 *  A string representing a duration relative to a measure. 
				 *  <ul>
				 *  	<li>"4n" = quarter note</li>
				 *   	<li>"2m" = two measures</li>
				 *    	<li>"8t" = eighth-note triplet</li>
				 *  </ul>
				 *  @typedef {Notation}
				 */
		        Notation: 'notation'
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // AUGMENT TONE's PROTOTYPE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Convert Time into seconds.
			 *  
			 *  Unlike the method which it overrides, this takes into account 
			 *  transporttime and musical notation.
			 *
			 *  Time : 1.40
			 *  Notation: 4n|1m|2t
			 *  Now Relative: +3n
			 *  Math: 3n+16n or even complicated expressions ((3n*2)/6 + 1)
			 *
			 *  @param  {Time} time 
			 *  @return {Seconds} 
			 */
		    Tone.prototype.toSeconds = function (time) {
		        if (this.isNumber(time)) {
		            return time;
		        } else if (this.isUndef(time)) {
		            return this.now();
		        } else if (this.isString(time)) {
		            return new Tone.Time(time).toSeconds();
		        } else if (time instanceof Tone.TimeBase) {
		            return time.toSeconds();
		        }
		    };
		    /**
			 *  Convert a frequency representation into a number.
			 *  @param  {Frequency} freq 
			 *  @return {Hertz}      the frequency in hertz
			 */
		    Tone.prototype.toFrequency = function (freq) {
		        if (this.isNumber(freq)) {
		            return freq;
		        } else if (this.isString(freq) || this.isUndef(freq)) {
		            return new Tone.Frequency(freq).eval();
		        } else if (freq instanceof Tone.TimeBase) {
		            return freq.toFrequency();
		        }
		    };
		    /**
			 *  Convert a time representation into ticks.
			 *  @param  {Time} time
			 *  @return {Ticks}  the time in ticks
			 */
		    Tone.prototype.toTicks = function (time) {
		        if (this.isNumber(time) || this.isString(time)) {
		            return new Tone.TransportTime(time).toTicks();
		        } else if (this.isUndef(time)) {
		            return Tone.Transport.ticks;
		        } else if (time instanceof Tone.TimeBase) {
		            return time.toTicks();
		        }
		    };
		    return Tone;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Param wraps the native Web Audio's AudioParam to provide
			 *         additional unit conversion functionality. It also
			 *         serves as a base-class for classes which have a single,
			 *         automatable parameter. 
			 *  @extends {Tone}
			 *  @param  {AudioParam}  param  The parameter to wrap.
			 *  @param  {Tone.Type} units The units of the audio param.
			 *  @param  {Boolean} convert If the param should be converted.
			 */
		    Tone.Param = function () {
		        var options = this.optionsObject(arguments, [
		            'param',
		            'units',
		            'convert'
		        ], Tone.Param.defaults);
		        /**
				 *  The native parameter to control
				 *  @type  {AudioParam}
				 *  @private
				 */
		        this._param = this.input = options.param;
		        /**
				 *  The units of the parameter
				 *  @type {Tone.Type}
				 */
		        this.units = options.units;
		        /**
				 *  If the value should be converted or not
				 *  @type {Boolean}
				 */
		        this.convert = options.convert;
		        /**
				 *  True if the signal value is being overridden by 
				 *  a connected signal.
				 *  @readOnly
				 *  @type  {boolean}
				 *  @private
				 */
		        this.overridden = false;
		        /**
				 *  If there is an LFO, this is where it is held.
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._lfo = null;
		        if (this.isObject(options.lfo)) {
		            this.value = options.lfo;
		        } else if (!this.isUndef(options.value)) {
		            this.value = options.value;
		        }
		    };
		    Tone.extend(Tone.Param);
		    /**
			 *  Defaults
			 *  @type  {Object}
			 *  @const
			 */
		    Tone.Param.defaults = {
		        'units': Tone.Type.Default,
		        'convert': true,
		        'param': undefined
		    };
		    /**
			 * The current value of the parameter. 
			 * @memberOf Tone.Param#
			 * @type {Number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Param.prototype, 'value', {
		        get: function () {
		            return this._toUnits(this._param.value);
		        },
		        set: function (value) {
		            if (this.isObject(value)) {
		                //throw an error if the LFO needs to be included
		                if (this.isUndef(Tone.LFO)) {
		                    throw new Error('Include \'Tone.LFO\' to use an LFO as a Param value.');
		                }
		                //remove the old one
		                if (this._lfo) {
		                    this._lfo.dispose();
		                }
		                this._lfo = new Tone.LFO(value).start();
		                this._lfo.connect(this.input);
		            } else {
		                var convertedVal = this._fromUnits(value);
		                this._param.cancelScheduledValues(0);
		                this._param.value = convertedVal;
		            }
		        }
		    });
		    /**
			 *  Convert the given value from the type specified by Tone.Param.units
			 *  into the destination value (such as Gain or Frequency).
			 *  @private
			 *  @param  {*} val the value to convert
			 *  @return {number}     the number which the value should be set to
			 */
		    Tone.Param.prototype._fromUnits = function (val) {
		        if (this.convert || this.isUndef(this.convert)) {
		            switch (this.units) {
		            case Tone.Type.Time:
		                return this.toSeconds(val);
		            case Tone.Type.Frequency:
		                return this.toFrequency(val);
		            case Tone.Type.Decibels:
		                return this.dbToGain(val);
		            case Tone.Type.NormalRange:
		                return Math.min(Math.max(val, 0), 1);
		            case Tone.Type.AudioRange:
		                return Math.min(Math.max(val, -1), 1);
		            case Tone.Type.Positive:
		                return Math.max(val, 0);
		            default:
		                return val;
		            }
		        } else {
		            return val;
		        }
		    };
		    /**
			 * Convert the parameters value into the units specified by Tone.Param.units.
			 * @private
			 * @param  {number} val the value to convert
			 * @return {number}
			 */
		    Tone.Param.prototype._toUnits = function (val) {
		        if (this.convert || this.isUndef(this.convert)) {
		            switch (this.units) {
		            case Tone.Type.Decibels:
		                return this.gainToDb(val);
		            default:
		                return val;
		            }
		        } else {
		            return val;
		        }
		    };
		    /**
			 *  the minimum output value
			 *  @type {Number}
			 *  @private
			 */
		    Tone.Param.prototype._minOutput = 0.00001;
		    /**
			 *  Schedules a parameter value change at the given time.
			 *  @param {*}	value The value to set the signal.
			 *  @param {Time}  time The time when the change should occur.
			 *  @returns {Tone.Param} this
			 *  @example
			 * //set the frequency to "G4" in exactly 1 second from now. 
			 * freq.setValueAtTime("G4", "+1");
			 */
		    Tone.Param.prototype.setValueAtTime = function (value, time) {
		        value = this._fromUnits(value);
		        time = this.toSeconds(time);
		        if (time <= this.now() + this.blockTime) {
		            this._param.value = value;
		        } else {
		            this._param.setValueAtTime(value, time);
		        }
		        return this;
		    };
		    /**
			 *  Creates a schedule point with the current value at the current time.
			 *  This is useful for creating an automation anchor point in order to 
			 *  schedule changes from the current value. 
			 *
			 *  @param {number=} now (Optionally) pass the now value in. 
			 *  @returns {Tone.Param} this
			 */
		    Tone.Param.prototype.setRampPoint = function (now) {
		        now = this.defaultArg(now, this.now());
		        var currentVal = this._param.value;
		        // exponentialRampToValueAt cannot ever ramp from or to 0
		        // More info: https://bugzilla.mozilla.org/show_bug.cgi?id=1125600#c2
		        if (currentVal === 0) {
		            currentVal = this._minOutput;
		        }
		        this._param.setValueAtTime(currentVal, now);
		        return this;
		    };
		    /**
			 *  Schedules a linear continuous change in parameter value from the 
			 *  previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.Param} this
			 */
		    Tone.Param.prototype.linearRampToValueAtTime = function (value, endTime) {
		        value = this._fromUnits(value);
		        this._param.linearRampToValueAtTime(value, this.toSeconds(endTime));
		        return this;
		    };
		    /**
			 *  Schedules an exponential continuous change in parameter value from 
			 *  the previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.Param} this
			 */
		    Tone.Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {
		        value = this._fromUnits(value);
		        value = Math.max(this._minOutput, value);
		        this._param.exponentialRampToValueAtTime(value, this.toSeconds(endTime));
		        return this;
		    };
		    /**
			 *  Schedules an exponential continuous change in parameter value from 
			 *  the current time and current value to the given value over the 
			 *  duration of the rampTime.
			 *  
			 *  @param  {number} value   The value to ramp to.
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @param {Time}	[startTime=now] 	When the ramp should start. 
			 *  @returns {Tone.Param} this
			 *  @example
			 * //exponentially ramp to the value 2 over 4 seconds. 
			 * signal.exponentialRampToValue(2, 4);
			 */
		    Tone.Param.prototype.exponentialRampToValue = function (value, rampTime, startTime) {
		        startTime = this.toSeconds(startTime);
		        this.setRampPoint(startTime);
		        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
		        return this;
		    };
		    /**
			 *  Schedules an linear continuous change in parameter value from 
			 *  the current time and current value to the given value over the 
			 *  duration of the rampTime.
			 *  
			 *  @param  {number} value   The value to ramp to.
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @param {Time}	[startTime=now] 	When the ramp should start. 
			 *  @returns {Tone.Param} this
			 *  @example
			 * //linearly ramp to the value 4 over 3 seconds. 
			 * signal.linearRampToValue(4, 3);
			 */
		    Tone.Param.prototype.linearRampToValue = function (value, rampTime, startTime) {
		        startTime = this.toSeconds(startTime);
		        this.setRampPoint(startTime);
		        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
		        return this;
		    };
		    /**
			 *  Start exponentially approaching the target value at the given time with
			 *  a rate having the given time constant.
			 *  @param {number} value        
			 *  @param {Time} startTime    
			 *  @param {number} timeConstant 
			 *  @returns {Tone.Param} this 
			 */
		    Tone.Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
		        value = this._fromUnits(value);
		        // The value will never be able to approach without timeConstant > 0.
		        // http://www.w3.org/TR/webaudio/#dfn-setTargetAtTime, where the equation
		        // is described. 0 results in a division by 0.
		        value = Math.max(this._minOutput, value);
		        timeConstant = Math.max(this._minOutput, timeConstant);
		        this._param.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);
		        return this;
		    };
		    /**
			 *  Sets an array of arbitrary parameter values starting at the given time
			 *  for the given duration.
			 *  	
			 *  @param {Array} values    
			 *  @param {Time} startTime 
			 *  @param {Time} duration  
			 *  @returns {Tone.Param} this
			 */
		    Tone.Param.prototype.setValueCurveAtTime = function (values, startTime, duration) {
		        for (var i = 0; i < values.length; i++) {
		            values[i] = this._fromUnits(values[i]);
		        }
		        this._param.setValueCurveAtTime(values, this.toSeconds(startTime), this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Cancels all scheduled parameter changes with times greater than or 
			 *  equal to startTime.
			 *  
			 *  @param  {Time} startTime
			 *  @returns {Tone.Param} this
			 */
		    Tone.Param.prototype.cancelScheduledValues = function (startTime) {
		        this._param.cancelScheduledValues(this.toSeconds(startTime));
		        return this;
		    };
		    /**
			 *  Ramps to the given value over the duration of the rampTime. 
			 *  Automatically selects the best ramp type (exponential or linear)
			 *  depending on the `units` of the signal
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} rampTime 	The time that it takes the 
			 *                              value to ramp from it's current value
			 *  @param {Time}	[startTime=now] 	When the ramp should start. 
			 *  @returns {Tone.Param} this
			 *  @example
			 * //ramp to the value either linearly or exponentially 
			 * //depending on the "units" value of the signal
			 * signal.rampTo(0, 10);
			 *  @example
			 * //schedule it to ramp starting at a specific time
			 * signal.rampTo(0, 10, 5)
			 */
		    Tone.Param.prototype.rampTo = function (value, rampTime, startTime) {
		        rampTime = this.defaultArg(rampTime, 0);
		        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM) {
		            this.exponentialRampToValue(value, rampTime, startTime);
		        } else {
		            this.linearRampToValue(value, rampTime, startTime);
		        }
		        return this;
		    };
		    /**
			 *  The LFO created by the signal instance. If none
			 *  was created, this is null.
			 *  @type {Tone.LFO}
			 *  @readOnly
			 *  @memberOf Tone.Param#
			 *  @name lfo
			 */
		    Object.defineProperty(Tone.Param.prototype, 'lfo', {
		        get: function () {
		            return this._lfo;
		        }
		    });
		    /**
			 *  Clean up
			 *  @returns {Tone.Param} this
			 */
		    Tone.Param.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._param = null;
		        if (this._lfo) {
		            this._lfo.dispose();
		            this._lfo = null;
		        }
		        return this;
		    };
		    return Tone.Param;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A thin wrapper around the Native Web Audio GainNode.
			 *         The GainNode is a basic building block of the Web Audio
			 *         API and is useful for routing audio and adjusting gains. 
			 *  @extends {Tone}
			 *  @param  {Number=}  gain  The initial gain of the GainNode
			 *  @param {Tone.Type=} units The units of the gain parameter. 
			 */
		    Tone.Gain = function () {
		        var options = this.optionsObject(arguments, [
		            'gain',
		            'units'
		        ], Tone.Gain.defaults);
		        /**
				 *  The GainNode
				 *  @type  {GainNode}
				 *  @private
				 */
		        this.input = this.output = this._gainNode = this.context.createGain();
		        /**
				 *  The gain parameter of the gain node.
				 *  @type {Tone.Param}
				 *  @signal
				 */
		        this.gain = new Tone.Param({
		            'param': this._gainNode.gain,
		            'units': options.units,
		            'value': options.gain,
		            'convert': options.convert
		        });
		        this._readOnly('gain');
		    };
		    Tone.extend(Tone.Gain);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Gain.defaults = {
		        'gain': 1,
		        'convert': true
		    };
		    /**
			 *  Clean up.
			 *  @return  {Tone.Gain}  this
			 */
		    Tone.Gain.prototype.dispose = function () {
		        Tone.Param.prototype.dispose.call(this);
		        this._gainNode.disconnect();
		        this._gainNode = null;
		        this._writable('gain');
		        this.gain.dispose();
		        this.gain = null;
		    };
		    //STATIC///////////////////////////////////////////////////////////////////
		    /**
			 *  Create input and outputs for this object.
			 *  @param  {Number}  input   The number of inputs
			 *  @param  {Number=}  outputs  The number of outputs
			 *  @return  {Tone}  this
			 *  @internal
			 */
		    Tone.prototype.createInsOuts = function (inputs, outputs) {
		        if (inputs === 1) {
		            this.input = new Tone.Gain();
		        } else if (inputs > 1) {
		            this.input = new Array(inputs);
		        }
		        if (outputs === 1) {
		            this.output = new Tone.Gain();
		        } else if (outputs > 1) {
		            this.output = new Array(inputs);
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    return Tone.Gain;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.
			 *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
			 *          has all of the methods available to native Web Audio 
			 *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
			 *          as well as additional conveniences. Read more about working with signals 
			 *          [here](https://github.com/Tonejs/Tone.js/wiki/Signals).
			 *
			 *  @constructor
			 *  @extends {Tone.Param}
			 *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam
			 *                                     is passed in, that parameter will be wrapped
			 *                                     and controlled by the Signal. 
			 *  @param {string} [units=Number] unit The units the signal is in. 
			 *  @example
			 * var signal = new Tone.Signal(10);
			 */
		    Tone.Signal = function () {
		        var options = this.optionsObject(arguments, [
		            'value',
		            'units'
		        ], Tone.Signal.defaults);
		        /**
				 * The node where the constant signal value is scaled.
				 * @type {GainNode}
				 * @private
				 */
		        this.output = this._gain = this.context.createGain();
		        options.param = this._gain.gain;
		        Tone.Param.call(this, options);
		        /**
				 * The node where the value is set.
				 * @type {Tone.Param}
				 * @private
				 */
		        this.input = this._param = this._gain.gain;
		        //connect the const output to the node output
		        Tone.Signal._constant.chain(this._gain);
		    };
		    Tone.extend(Tone.Signal, Tone.Param);
		    /**
			 *  The default values
			 *  @type  {Object}
			 *  @static
			 *  @const
			 */
		    Tone.Signal.defaults = {
		        'value': 0,
		        'units': Tone.Type.Default,
		        'convert': true
		    };
		    /**
			 *  When signals connect to other signals or AudioParams, 
			 *  they take over the output value of that signal or AudioParam. 
			 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
			 *
			 *  @override
			 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
			 *  @param {number} [outputNumber=0] The output number to connect from.
			 *  @param {number} [inputNumber=0] The input number to connect to.
			 *  @returns {Tone.SignalBase} this
			 *  @method
			 */
		    Tone.Signal.prototype.connect = Tone.SignalBase.prototype.connect;
		    /**
			 *  dispose and disconnect
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.dispose = function () {
		        Tone.Param.prototype.dispose.call(this);
		        this._param = null;
		        this._gain.disconnect();
		        this._gain = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	STATIC
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Generates a constant output of 1.
			 *  @static
			 *  @private
			 *  @const
			 *  @type {AudioBufferSourceNode}
			 */
		    Tone.Signal._constant = null;
		    /**
			 *  initializer function
			 */
		    Tone._initAudioContext(function (audioContext) {
		        var buffer = audioContext.createBuffer(1, 128, audioContext.sampleRate);
		        var arr = buffer.getChannelData(0);
		        for (var i = 0; i < arr.length; i++) {
		            arr[i] = 1;
		        }
		        Tone.Signal._constant = audioContext.createBufferSource();
		        Tone.Signal._constant.channelCount = 1;
		        Tone.Signal._constant.channelCountMode = 'explicit';
		        Tone.Signal._constant.buffer = buffer;
		        Tone.Signal._constant.loop = true;
		        Tone.Signal._constant.start(0);
		        Tone.Signal._constant.noGC();
		    });
		    return Tone.Signal;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A Timeline class for scheduling and maintaining state
			 *         along a timeline. All events must have a "time" property. 
			 *         Internally, events are stored in time order for fast 
			 *         retrieval.
			 *  @extends {Tone}
			 *  @param {Positive} [memory=Infinity] The number of previous events that are retained.
			 */
		    Tone.Timeline = function () {
		        var options = this.optionsObject(arguments, ['memory'], Tone.Timeline.defaults);
		        /**
				 *  The array of scheduled timeline events
				 *  @type  {Array}
				 *  @private
				 */
		        this._timeline = [];
		        /**
				 *  An array of items to remove from the list. 
				 *  @type {Array}
				 *  @private
				 */
		        this._toRemove = [];
		        /**
				 *  Flag if the tieline is mid iteration
				 *  @private
				 *  @type {Boolean}
				 */
		        this._iterating = false;
		        /**
				 *  The memory of the timeline, i.e.
				 *  how many events in the past it will retain
				 *  @type {Positive}
				 */
		        this.memory = options.memory;
		    };
		    Tone.extend(Tone.Timeline);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 */
		    Tone.Timeline.defaults = { 'memory': Infinity };
		    /**
			 *  The number of items in the timeline.
			 *  @type {Number}
			 *  @memberOf Tone.Timeline#
			 *  @name length
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Timeline.prototype, 'length', {
		        get: function () {
		            return this._timeline.length;
		        }
		    });
		    /**
			 *  Insert an event object onto the timeline. Events must have a "time" attribute.
			 *  @param  {Object}  event  The event object to insert into the 
			 *                           timeline. 
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.add = function (event) {
		        //the event needs to have a time attribute
		        if (this.isUndef(event.time)) {
		            throw new Error('Tone.Timeline: events must have a time attribute');
		        }
		        if (this._timeline.length) {
		            var index = this._search(event.time);
		            this._timeline.splice(index + 1, 0, event);
		        } else {
		            this._timeline.push(event);
		        }
		        //if the length is more than the memory, remove the previous ones
		        if (this.length > this.memory) {
		            var diff = this.length - this.memory;
		            this._timeline.splice(0, diff);
		        }
		        return this;
		    };
		    /**
			 *  Remove an event from the timeline.
			 *  @param  {Object}  event  The event object to remove from the list.
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.remove = function (event) {
		        if (this._iterating) {
		            this._toRemove.push(event);
		        } else {
		            var index = this._timeline.indexOf(event);
		            if (index !== -1) {
		                this._timeline.splice(index, 1);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Get the nearest event whose time is less than or equal to the given time.
			 *  @param  {Number}  time  The time to query.
			 *  @returns {Object} The event object set after that time.
			 */
		    Tone.Timeline.prototype.get = function (time) {
		        var index = this._search(time);
		        if (index !== -1) {
		            return this._timeline[index];
		        } else {
		            return null;
		        }
		    };
		    /**
			 *  Return the first event in the timeline without removing it
			 *  @returns {Object} The first event object
			 */
		    Tone.Timeline.prototype.peek = function () {
		        return this._timeline[0];
		    };
		    /**
			 *  Return the first event in the timeline and remove it
			 *  @returns {Object} The first event object
			 */
		    Tone.Timeline.prototype.shift = function () {
		        return this._timeline.shift();
		    };
		    /**
			 *  Get the event which is scheduled after the given time.
			 *  @param  {Number}  time  The time to query.
			 *  @returns {Object} The event object after the given time
			 */
		    Tone.Timeline.prototype.getAfter = function (time) {
		        var index = this._search(time);
		        if (index + 1 < this._timeline.length) {
		            return this._timeline[index + 1];
		        } else {
		            return null;
		        }
		    };
		    /**
			 *  Get the event before the event at the given time.
			 *  @param  {Number}  time  The time to query.
			 *  @returns {Object} The event object before the given time
			 */
		    Tone.Timeline.prototype.getBefore = function (time) {
		        var len = this._timeline.length;
		        //if it's after the last item, return the last item
		        if (len > 0 && this._timeline[len - 1].time < time) {
		            return this._timeline[len - 1];
		        }
		        var index = this._search(time);
		        if (index - 1 >= 0) {
		            return this._timeline[index - 1];
		        } else {
		            return null;
		        }
		    };
		    /**
			 *  Cancel events after the given time
			 *  @param  {Number}  time  The time to query.
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.cancel = function (after) {
		        if (this._timeline.length > 1) {
		            var index = this._search(after);
		            if (index >= 0) {
		                if (this._timeline[index].time === after) {
		                    //get the first item with that time
		                    for (var i = index; i >= 0; i--) {
		                        if (this._timeline[i].time === after) {
		                            index = i;
		                        } else {
		                            break;
		                        }
		                    }
		                    this._timeline = this._timeline.slice(0, index);
		                } else {
		                    this._timeline = this._timeline.slice(0, index + 1);
		                }
		            } else {
		                this._timeline = [];
		            }
		        } else if (this._timeline.length === 1) {
		            //the first item's time
		            if (this._timeline[0].time >= after) {
		                this._timeline = [];
		            }
		        }
		        return this;
		    };
		    /**
			 *  Cancel events before or equal to the given time.
			 *  @param  {Number}  time  The time to cancel before.
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.cancelBefore = function (time) {
		        if (this._timeline.length) {
		            var index = this._search(time);
		            if (index >= 0) {
		                this._timeline = this._timeline.slice(index + 1);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Does a binary serach on the timeline array and returns the 
			 *  nearest event index whose time is after or equal to the given time.
			 *  If a time is searched before the first index in the timeline, -1 is returned.
			 *  If the time is after the end, the index of the last item is returned.
			 *  @param  {Number}  time  
			 *  @return  {Number} the index in the timeline array 
			 *  @private
			 */
		    Tone.Timeline.prototype._search = function (time) {
		        var beginning = 0;
		        var len = this._timeline.length;
		        var end = len;
		        if (len > 0 && this._timeline[len - 1].time <= time) {
		            return len - 1;
		        }
		        while (beginning < end) {
		            // calculate the midpoint for roughly equal partition
		            var midPoint = Math.floor(beginning + (end - beginning) / 2);
		            var event = this._timeline[midPoint];
		            var nextEvent = this._timeline[midPoint + 1];
		            if (event.time === time) {
		                //choose the last one that has the same time
		                for (var i = midPoint; i < this._timeline.length; i++) {
		                    var testEvent = this._timeline[i];
		                    if (testEvent.time === time) {
		                        midPoint = i;
		                    }
		                }
		                return midPoint;
		            } else if (event.time < time && nextEvent.time > time) {
		                return midPoint;
		            } else if (event.time > time) {
		                //search lower
		                end = midPoint;
		            } else if (event.time < time) {
		                //search upper
		                beginning = midPoint + 1;
		            }
		        }
		        return -1;
		    };
		    /**
			 *  Internal iterator. Applies extra safety checks for 
			 *  removing items from the array. 
			 *  @param  {Function}  callback 
			 *  @param  {Number=}    lowerBound     
			 *  @param  {Number=}    upperBound    
			 *  @private
			 */
		    Tone.Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {
		        this._iterating = true;
		        lowerBound = this.defaultArg(lowerBound, 0);
		        upperBound = this.defaultArg(upperBound, this._timeline.length - 1);
		        for (var i = lowerBound; i <= upperBound; i++) {
		            callback(this._timeline[i]);
		        }
		        this._iterating = false;
		        if (this._toRemove.length > 0) {
		            for (var j = 0; j < this._toRemove.length; j++) {
		                var index = this._timeline.indexOf(this._toRemove[j]);
		                if (index !== -1) {
		                    this._timeline.splice(index, 1);
		                }
		            }
		            this._toRemove = [];
		        }
		    };
		    /**
			 *  Iterate over everything in the array
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.forEach = function (callback) {
		        this._iterate(callback);
		        return this;
		    };
		    /**
			 *  Iterate over everything in the array at or before the given time.
			 *  @param  {Number}  time The time to check if items are before
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.forEachBefore = function (time, callback) {
		        //iterate over the items in reverse so that removing an item doesn't break things
		        var upperBound = this._search(time);
		        if (upperBound !== -1) {
		            this._iterate(callback, 0, upperBound);
		        }
		        return this;
		    };
		    /**
			 *  Iterate over everything in the array after the given time.
			 *  @param  {Number}  time The time to check if items are before
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.forEachAfter = function (time, callback) {
		        //iterate over the items in reverse so that removing an item doesn't break things
		        var lowerBound = this._search(time);
		        this._iterate(callback, lowerBound + 1);
		        return this;
		    };
		    /**
			 *  Iterate over everything in the array at or after the given time. Similar to 
			 *  forEachAfter, but includes the item(s) at the given time.
			 *  @param  {Number}  time The time to check if items are before
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.forEachFrom = function (time, callback) {
		        //iterate over the items in reverse so that removing an item doesn't break things
		        var lowerBound = this._search(time);
		        //work backwards until the event time is less than time
		        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
		            lowerBound--;
		        }
		        this._iterate(callback, lowerBound + 1);
		        return this;
		    };
		    /**
			 *  Iterate over everything in the array at the given time
			 *  @param  {Number}  time The time to check if items are before
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.Timeline} this
			 */
		    Tone.Timeline.prototype.forEachAtTime = function (time, callback) {
		        //iterate over the items in reverse so that removing an item doesn't break things
		        var upperBound = this._search(time);
		        if (upperBound !== -1) {
		            this._iterate(function (event) {
		                if (event.time === time) {
		                    callback(event);
		                }
		            }, 0, upperBound);
		        }
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @return  {Tone.Timeline}  this
			 */
		    Tone.Timeline.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._timeline = null;
		        this._toRemove = null;
		    };
		    return Tone.Timeline;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A signal which adds the method getValueAtTime. 
			 *         Code and inspiration from https://github.com/jsantell/web-audio-automation-timeline
			 *  @extends {Tone.Param}
			 *  @param {Number=} value The initial value of the signal
			 *  @param {String=} units The conversion units of the signal.
			 */
		    Tone.TimelineSignal = function () {
		        var options = this.optionsObject(arguments, [
		            'value',
		            'units'
		        ], Tone.Signal.defaults);
		        /**
				 *  The scheduled events
				 *  @type {Tone.Timeline}
				 *  @private
				 */
		        this._events = new Tone.Timeline(10);
		        //constructors
		        Tone.Signal.apply(this, options);
		        options.param = this._param;
		        Tone.Param.call(this, options);
		        /**
				 *  The initial scheduled value
				 *  @type {Number}
				 *  @private
				 */
		        this._initial = this._fromUnits(this._param.value);
		    };
		    Tone.extend(Tone.TimelineSignal, Tone.Param);
		    /**
			 *  The event types of a schedulable signal.
			 *  @enum {String}
			 *  @private
			 */
		    Tone.TimelineSignal.Type = {
		        Linear: 'linear',
		        Exponential: 'exponential',
		        Target: 'target',
		        Curve: 'curve',
		        Set: 'set'
		    };
		    /**
			 * The current value of the signal. 
			 * @memberOf Tone.TimelineSignal#
			 * @type {Number}
			 * @name value
			 */
		    Object.defineProperty(Tone.TimelineSignal.prototype, 'value', {
		        get: function () {
		            var now = this.now();
		            var val = this.getValueAtTime(now);
		            return this._toUnits(val);
		        },
		        set: function (value) {
		            var convertedVal = this._fromUnits(value);
		            this._initial = convertedVal;
		            this.cancelScheduledValues();
		            this._param.value = convertedVal;
		        }
		    });
		    ///////////////////////////////////////////////////////////////////////////
		    //	SCHEDULING
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Schedules a parameter value change at the given time.
			 *  @param {*}	value The value to set the signal.
			 *  @param {Time}  time The time when the change should occur.
			 *  @returns {Tone.TimelineSignal} this
			 *  @example
			 * //set the frequency to "G4" in exactly 1 second from now. 
			 * freq.setValueAtTime("G4", "+1");
			 */
		    Tone.TimelineSignal.prototype.setValueAtTime = function (value, startTime) {
		        value = this._fromUnits(value);
		        startTime = this.toSeconds(startTime);
		        this._events.add({
		            'type': Tone.TimelineSignal.Type.Set,
		            'value': value,
		            'time': startTime
		        });
		        //invoke the original event
		        this._param.setValueAtTime(value, startTime);
		        return this;
		    };
		    /**
			 *  Schedules a linear continuous change in parameter value from the 
			 *  previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.TimelineSignal} this
			 */
		    Tone.TimelineSignal.prototype.linearRampToValueAtTime = function (value, endTime) {
		        value = this._fromUnits(value);
		        endTime = this.toSeconds(endTime);
		        this._events.add({
		            'type': Tone.TimelineSignal.Type.Linear,
		            'value': value,
		            'time': endTime
		        });
		        this._param.linearRampToValueAtTime(value, endTime);
		        return this;
		    };
		    /**
			 *  Schedules an exponential continuous change in parameter value from 
			 *  the previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.TimelineSignal} this
			 */
		    Tone.TimelineSignal.prototype.exponentialRampToValueAtTime = function (value, endTime) {
		        //get the previous event and make sure it's not starting from 0
		        endTime = this.toSeconds(endTime);
		        var beforeEvent = this._searchBefore(endTime);
		        if (beforeEvent && beforeEvent.value === 0) {
		            //reschedule that event
		            this.setValueAtTime(this._minOutput, beforeEvent.time);
		        }
		        value = this._fromUnits(value);
		        var setValue = Math.max(value, this._minOutput);
		        this._events.add({
		            'type': Tone.TimelineSignal.Type.Exponential,
		            'value': setValue,
		            'time': endTime
		        });
		        //if the ramped to value is 0, make it go to the min output, and then set to 0.
		        if (value < this._minOutput) {
		            this._param.exponentialRampToValueAtTime(this._minOutput, endTime - this.sampleTime);
		            this.setValueAtTime(0, endTime);
		        } else {
		            this._param.exponentialRampToValueAtTime(value, endTime);
		        }
		        return this;
		    };
		    /**
			 *  Start exponentially approaching the target value at the given time with
			 *  a rate having the given time constant.
			 *  @param {number} value        
			 *  @param {Time} startTime    
			 *  @param {number} timeConstant 
			 *  @returns {Tone.TimelineSignal} this 
			 */
		    Tone.TimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
		        value = this._fromUnits(value);
		        value = Math.max(this._minOutput, value);
		        timeConstant = Math.max(this._minOutput, timeConstant);
		        startTime = this.toSeconds(startTime);
		        this._events.add({
		            'type': Tone.TimelineSignal.Type.Target,
		            'value': value,
		            'time': startTime,
		            'constant': timeConstant
		        });
		        this._param.setTargetAtTime(value, startTime, timeConstant);
		        return this;
		    };
		    /**
			 *  Set an array of arbitrary values starting at the given time for the given duration.
			 *  @param {Float32Array} values        
			 *  @param {Time} startTime    
			 *  @param {Time} duration
			 *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value
			 *  @returns {Tone.TimelineSignal} this 
			 */
		    Tone.TimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {
		        scaling = this.defaultArg(scaling, 1);
		        //copy the array
		        var floats = new Array(values.length);
		        for (var i = 0; i < floats.length; i++) {
		            floats[i] = this._fromUnits(values[i]) * scaling;
		        }
		        startTime = this.toSeconds(startTime);
		        duration = this.toSeconds(duration);
		        this._events.add({
		            'type': Tone.TimelineSignal.Type.Curve,
		            'value': floats,
		            'time': startTime,
		            'duration': duration
		        });
		        //set the first value
		        this._param.setValueAtTime(floats[0], startTime);
		        //schedule a lienar ramp for each of the segments
		        for (var j = 1; j < floats.length; j++) {
		            var segmentTime = startTime + j / (floats.length - 1) * duration;
		            this._param.linearRampToValueAtTime(floats[j], segmentTime);
		        }
		        return this;
		    };
		    /**
			 *  Cancels all scheduled parameter changes with times greater than or 
			 *  equal to startTime.
			 *  
			 *  @param  {Time} startTime
			 *  @returns {Tone.TimelineSignal} this
			 */
		    Tone.TimelineSignal.prototype.cancelScheduledValues = function (after) {
		        after = this.toSeconds(after);
		        this._events.cancel(after);
		        this._param.cancelScheduledValues(after);
		        return this;
		    };
		    /**
			 *  Sets the computed value at the given time. This provides
			 *  a point from which a linear or exponential curve
			 *  can be scheduled after. Will cancel events after 
			 *  the given time and shorten the currently scheduled
			 *  linear or exponential ramp so that it ends at `time` .
			 *  This is to avoid discontinuities and clicks in envelopes. 
			 *  @param {Time} time When to set the ramp point
			 *  @returns {Tone.TimelineSignal} this
			 */
		    Tone.TimelineSignal.prototype.setRampPoint = function (time) {
		        time = this.toSeconds(time);
		        //get the value at the given time
		        var val = this._toUnits(this.getValueAtTime(time));
		        //if there is an event at the given time
		        //and that even is not a "set"
		        var before = this._searchBefore(time);
		        if (before && before.time === time) {
		            //remove everything after
		            this.cancelScheduledValues(time + this.sampleTime);
		        } else if (before && before.type === Tone.TimelineSignal.Type.Curve && before.time + before.duration > time) {
		            //if the curve is still playing
		            //cancel the curve
		            this.cancelScheduledValues(time);
		            this.linearRampToValueAtTime(val, time);
		        } else {
		            //reschedule the next event to end at the given time
		            var after = this._searchAfter(time);
		            if (after) {
		                //cancel the next event(s)
		                this.cancelScheduledValues(time);
		                if (after.type === Tone.TimelineSignal.Type.Linear) {
		                    this.linearRampToValueAtTime(val, time);
		                } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
		                    this.exponentialRampToValueAtTime(val, time);
		                }
		            }
		            this.setValueAtTime(val, time);
		        }
		        return this;
		    };
		    /**
			 *  Do a linear ramp to the given value between the start and finish times.
			 *  @param {Number} value The value to ramp to.
			 *  @param {Time} start The beginning anchor point to do the linear ramp
			 *  @param {Time} finish The ending anchor point by which the value of
			 *                       the signal will equal the given value.
			 *  @returns {Tone.TimelineSignal} this
			 */
		    Tone.TimelineSignal.prototype.linearRampToValueBetween = function (value, start, finish) {
		        this.setRampPoint(start);
		        this.linearRampToValueAtTime(value, finish);
		        return this;
		    };
		    /**
			 *  Do a exponential ramp to the given value between the start and finish times.
			 *  @param {Number} value The value to ramp to.
			 *  @param {Time} start The beginning anchor point to do the exponential ramp
			 *  @param {Time} finish The ending anchor point by which the value of
			 *                       the signal will equal the given value.
			 *  @returns {Tone.TimelineSignal} this
			 */
		    Tone.TimelineSignal.prototype.exponentialRampToValueBetween = function (value, start, finish) {
		        this.setRampPoint(start);
		        this.exponentialRampToValueAtTime(value, finish);
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	GETTING SCHEDULED VALUES
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Returns the value before or equal to the given time
			 *  @param  {Number}  time  The time to query
			 *  @return  {Object}  The event at or before the given time.
			 *  @private
			 */
		    Tone.TimelineSignal.prototype._searchBefore = function (time) {
		        return this._events.get(time);
		    };
		    /**
			 *  The event after the given time
			 *  @param  {Number}  time  The time to query.
			 *  @return  {Object}  The next event after the given time
			 *  @private
			 */
		    Tone.TimelineSignal.prototype._searchAfter = function (time) {
		        return this._events.getAfter(time);
		    };
		    /**
			 *  Get the scheduled value at the given time. This will
			 *  return the unconverted (raw) value.
			 *  @param  {Number}  time  The time in seconds.
			 *  @return  {Number}  The scheduled value at the given time.
			 */
		    Tone.TimelineSignal.prototype.getValueAtTime = function (time) {
		        time = this.toSeconds(time);
		        var after = this._searchAfter(time);
		        var before = this._searchBefore(time);
		        var value = this._initial;
		        //if it was set by
		        if (before === null) {
		            value = this._initial;
		        } else if (before.type === Tone.TimelineSignal.Type.Target) {
		            var previous = this._events.getBefore(before.time);
		            var previouVal;
		            if (previous === null) {
		                previouVal = this._initial;
		            } else {
		                previouVal = previous.value;
		            }
		            value = this._exponentialApproach(before.time, previouVal, before.value, before.constant, time);
		        } else if (before.type === Tone.TimelineSignal.Type.Curve) {
		            value = this._curveInterpolate(before.time, before.value, before.duration, time);
		        } else if (after === null) {
		            value = before.value;
		        } else if (after.type === Tone.TimelineSignal.Type.Linear) {
		            value = this._linearInterpolate(before.time, before.value, after.time, after.value, time);
		        } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
		            value = this._exponentialInterpolate(before.time, before.value, after.time, after.value, time);
		        } else {
		            value = before.value;
		        }
		        return value;
		    };
		    /**
			 *  When signals connect to other signals or AudioParams, 
			 *  they take over the output value of that signal or AudioParam. 
			 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
			 *
			 *  @override
			 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
			 *  @param {number} [outputNumber=0] The output number to connect from.
			 *  @param {number} [inputNumber=0] The input number to connect to.
			 *  @returns {Tone.TimelineSignal} this
			 *  @method
			 */
		    Tone.TimelineSignal.prototype.connect = Tone.SignalBase.prototype.connect;
		    ///////////////////////////////////////////////////////////////////////////
		    //	AUTOMATION CURVE CALCULATIONS
		    //	MIT License, copyright (c) 2014 Jordan Santell
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Calculates the the value along the curve produced by setTargetAtTime
			 *  @private
			 */
		    Tone.TimelineSignal.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {
		        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
		    };
		    /**
			 *  Calculates the the value along the curve produced by linearRampToValueAtTime
			 *  @private
			 */
		    Tone.TimelineSignal.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {
		        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
		    };
		    /**
			 *  Calculates the the value along the curve produced by exponentialRampToValueAtTime
			 *  @private
			 */
		    Tone.TimelineSignal.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {
		        v0 = Math.max(this._minOutput, v0);
		        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
		    };
		    /**
			 *  Calculates the the value along the curve produced by setValueCurveAtTime
			 *  @private
			 */
		    Tone.TimelineSignal.prototype._curveInterpolate = function (start, curve, duration, time) {
		        var len = curve.length;
		        // If time is after duration, return the last curve value
		        if (time >= start + duration) {
		            return curve[len - 1];
		        } else if (time <= start) {
		            return curve[0];
		        } else {
		            var progress = (time - start) / duration;
		            var lowerIndex = Math.floor((len - 1) * progress);
		            var upperIndex = Math.ceil((len - 1) * progress);
		            var lowerVal = curve[lowerIndex];
		            var upperVal = curve[upperIndex];
		            if (upperIndex === lowerIndex) {
		                return lowerVal;
		            } else {
		                return this._linearInterpolate(lowerIndex, lowerVal, upperIndex, upperVal, progress * (len - 1));
		            }
		        }
		    };
		    /**
			 *  Clean up.
			 *  @return {Tone.TimelineSignal} this
			 */
		    Tone.TimelineSignal.prototype.dispose = function () {
		        Tone.Signal.prototype.dispose.call(this);
		        Tone.Param.prototype.dispose.call(this);
		        this._events.dispose();
		        this._events = null;
		    };
		    return Tone.TimelineSignal;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Pow applies an exponent to the incoming signal. The incoming signal
			 *         must be AudioRange.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {Positive} exp The exponent to apply to the incoming signal, must be at least 2. 
			 *  @example
			 * var pow = new Tone.Pow(2);
			 * var sig = new Tone.Signal(0.5).connect(pow);
			 * //output of pow is 0.25. 
			 */
		    Tone.Pow = function (exp) {
		        /**
				 * the exponent
				 * @private
				 * @type {number}
				 */
		        this._exp = this.defaultArg(exp, 1);
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);
		    };
		    Tone.extend(Tone.Pow, Tone.SignalBase);
		    /**
			 * The value of the exponent.
			 * @memberOf Tone.Pow#
			 * @type {number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Pow.prototype, 'value', {
		        get: function () {
		            return this._exp;
		        },
		        set: function (exp) {
		            this._exp = exp;
		            this._expScaler.setMap(this._expFunc(this._exp));
		        }
		    });
		    /**
			 *  the function which maps the waveshaper
			 *  @param   {number} exp
			 *  @return {function}
			 *  @private
			 */
		    Tone.Pow.prototype._expFunc = function (exp) {
		        return function (val) {
		            return Math.pow(Math.abs(val), exp);
		        };
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Pow} this
			 */
		    Tone.Pow.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._expScaler.dispose();
		        this._expScaler = null;
		        return this;
		    };
		    return Tone.Pow;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
			 *          envelope generator. Tone.Envelope outputs a signal which 
			 *          can be connected to an AudioParam or Tone.Signal. 
			 *          <img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg">
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Time} [attack] The amount of time it takes for the envelope to go from 
			 *                         0 to it's maximum value. 
			 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
			 *                       	to fall to the sustain value. 
			 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
			 *                                	the release is triggered. 
			 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0. 
			 *  @example
			 * //an amplitude envelope
			 * var gainNode = Tone.context.createGain();
			 * var env = new Tone.Envelope({
			 * 	"attack" : 0.1,
			 * 	"decay" : 0.2,
			 * 	"sustain" : 1,
			 * 	"release" : 0.8,
			 * });
			 * env.connect(gainNode.gain);
			 */
		    Tone.Envelope = function () {
		        //get all of the defaults
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'decay',
		            'sustain',
		            'release'
		        ], Tone.Envelope.defaults);
		        /** 
				 *  When triggerAttack is called, the attack time is the amount of
				 *  time it takes for the envelope to reach it's maximum value. 
				 *  @type {Time}
				 */
		        this.attack = options.attack;
		        /**
				 *  After the attack portion of the envelope, the value will fall
				 *  over the duration of the decay time to it's sustain value. 
				 *  @type {Time}
				 */
		        this.decay = options.decay;
		        /**
				 * 	The sustain value is the value 
				 * 	which the envelope rests at after triggerAttack is
				 * 	called, but before triggerRelease is invoked. 
				 *  @type {NormalRange}
				 */
		        this.sustain = options.sustain;
		        /**
				 *  After triggerRelease is called, the envelope's
				 *  value will fall to it's miminum value over the
				 *  duration of the release time. 
				 *  @type {Time}
				 */
		        this.release = options.release;
		        /**
				 *  the next time the envelope is at standby
				 *  @type {number}
				 *  @private
				 */
		        this._attackCurve = 'linear';
		        /**
				 *  the next time the envelope is at standby
				 *  @type {number}
				 *  @private
				 */
		        this._releaseCurve = 'exponential';
		        /**
				 *  the signal
				 *  @type {Tone.TimelineSignal}
				 *  @private
				 */
		        this._sig = this.output = new Tone.TimelineSignal();
		        this._sig.setValueAtTime(0, 0);
		        //set the attackCurve initially
		        this.attackCurve = options.attackCurve;
		        this.releaseCurve = options.releaseCurve;
		    };
		    Tone.extend(Tone.Envelope);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 */
		    Tone.Envelope.defaults = {
		        'attack': 0.01,
		        'decay': 0.1,
		        'sustain': 0.5,
		        'release': 1,
		        'attackCurve': 'linear',
		        'releaseCurve': 'exponential'
		    };
		    /**
			 * Read the current value of the envelope. Useful for 
			 * syncronizing visual output to the envelope. 
			 * @memberOf Tone.Envelope#
			 * @type {Number}
			 * @name value
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Envelope.prototype, 'value', {
		        get: function () {
		            return this.getValueAtTime(this.now());
		        }
		    });
		    /**
			 * The shape of the attack. 
			 * Can be any of these strings:
			 * <ul>
			 *   <li>linear</li>
			 *   <li>exponential</li>
			 *   <li>sine</li>
			 *   <li>cosine</li>
			 *   <li>bounce</li>
			 *   <li>ripple</li>
			 *   <li>step</li>
			 * </ul>
			 * Can also be an array which describes the curve. Values
			 * in the array are evenly subdivided and linearly
			 * interpolated over the duration of the attack. 
			 * @memberOf Tone.Envelope#
			 * @type {String|Array}
			 * @name attackCurve
			 * @example
			 * env.attackCurve = "linear";
			 * @example
			 * //can also be an array
			 * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]
			 */
		    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {
		        get: function () {
		            if (this.isString(this._attackCurve)) {
		                return this._attackCurve;
		            } else if (this.isArray(this._attackCurve)) {
		                //look up the name in the curves array
		                for (var type in Tone.Envelope.Type) {
		                    if (Tone.Envelope.Type[type].In === this._attackCurve) {
		                        return type;
		                    }
		                }
		                //otherwise just return the array
		                return this._attackCurve;
		            }
		        },
		        set: function (curve) {
		            //check if it's a valid type
		            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
		                var curveDef = Tone.Envelope.Type[curve];
		                if (this.isObject(curveDef)) {
		                    this._attackCurve = curveDef.In;
		                } else {
		                    this._attackCurve = curveDef;
		                }
		            } else if (this.isArray(curve)) {
		                this._attackCurve = curve;
		            } else {
		                throw new Error('Tone.Envelope: invalid curve: ' + curve);
		            }
		        }
		    });
		    /**
			 * The shape of the release. See the attack curve types. 
			 * @memberOf Tone.Envelope#
			 * @type {String|Array}
			 * @name releaseCurve
			 * @example
			 * env.releaseCurve = "linear";
			 */
		    Object.defineProperty(Tone.Envelope.prototype, 'releaseCurve', {
		        get: function () {
		            if (this.isString(this._releaseCurve)) {
		                return this._releaseCurve;
		            } else if (this.isArray(this._releaseCurve)) {
		                //look up the name in the curves array
		                for (var type in Tone.Envelope.Type) {
		                    if (Tone.Envelope.Type[type].Out === this._releaseCurve) {
		                        return type;
		                    }
		                }
		                //otherwise just return the array
		                return this._releaseCurve;
		            }
		        },
		        set: function (curve) {
		            //check if it's a valid type
		            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
		                var curveDef = Tone.Envelope.Type[curve];
		                if (this.isObject(curveDef)) {
		                    this._releaseCurve = curveDef.Out;
		                } else {
		                    this._releaseCurve = curveDef;
		                }
		            } else if (this.isArray(curve)) {
		                this._releaseCurve = curve;
		            } else {
		                throw new Error('Tone.Envelope: invalid curve: ' + curve);
		            }
		        }
		    });
		    /**
			 *  Trigger the attack/decay portion of the ADSR envelope. 
			 *  @param  {Time} [time=now] When the attack should start.
			 *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.
			 *                               number between 0-1
			 *  @returns {Tone.Envelope} this
			 *  @example
			 *  //trigger the attack 0.5 seconds from now with a velocity of 0.2
			 *  env.triggerAttack("+0.5", 0.2);
			 */
		    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {
		        time = this.toSeconds(time);
		        var originalAttack = this.toSeconds(this.attack);
		        var attack = originalAttack;
		        var decay = this.toSeconds(this.decay);
		        velocity = this.defaultArg(velocity, 1);
		        //check if it's not a complete attack
		        var currentValue = this.getValueAtTime(time);
		        if (currentValue > 0) {
		            //subtract the current value from the attack time
		            var attackRate = 1 / attack;
		            var remainingDistance = 1 - currentValue;
		            //the attack is now the remaining time
		            attack = remainingDistance / attackRate;
		        }
		        //attack
		        if (this._attackCurve === 'linear') {
		            this._sig.linearRampToValue(velocity, attack, time);
		        } else if (this._attackCurve === 'exponential') {
		            this._sig.exponentialRampToValue(velocity, attack, time);
		        } else if (attack > 0) {
		            this._sig.setRampPoint(time);
		            var curve = this._attackCurve;
		            //take only a portion of the curve
		            if (attack < originalAttack) {
		                var percentComplete = 1 - attack / originalAttack;
		                var sliceIndex = Math.floor(percentComplete * this._attackCurve.length);
		                curve = this._attackCurve.slice(sliceIndex);
		                //the first index is the current value
		                curve[0] = currentValue;
		            }
		            this._sig.setValueCurveAtTime(curve, time, attack, velocity);
		        }
		        //decay
		        this._sig.exponentialRampToValue(velocity * this.sustain, decay, attack + time);
		        return this;
		    };
		    /**
			 *  Triggers the release of the envelope.
			 *  @param  {Time} [time=now] When the release portion of the envelope should start. 
			 *  @returns {Tone.Envelope} this
			 *  @example
			 *  //trigger release immediately
			 *  env.triggerRelease();
			 */
		    Tone.Envelope.prototype.triggerRelease = function (time) {
		        time = this.toSeconds(time);
		        var currentValue = this.getValueAtTime(time);
		        if (currentValue > 0) {
		            var release = this.toSeconds(this.release);
		            if (this._releaseCurve === 'linear') {
		                this._sig.linearRampToValue(0, release, time);
		            } else if (this._releaseCurve === 'exponential') {
		                this._sig.exponentialRampToValue(0, release, time);
		            } else {
		                var curve = this._releaseCurve;
		                if (this.isArray(curve)) {
		                    this._sig.setRampPoint(time);
		                    this._sig.setValueCurveAtTime(curve, time, release, currentValue);
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Get the scheduled value at the given time. This will
			 *  return the unconverted (raw) value.
			 *  @param  {Number}  time  The time in seconds.
			 *  @return  {Number}  The scheduled value at the given time.
			 */
		    Tone.Envelope.prototype.getValueAtTime = function (time) {
		        return this._sig.getValueAtTime(time);
		    };
		    /**
			 *  triggerAttackRelease is shorthand for triggerAttack, then waiting
			 *  some duration, then triggerRelease. 
			 *  @param {Time} duration The duration of the sustain.
			 *  @param {Time} [time=now] When the attack should be triggered.
			 *  @param {number} [velocity=1] The velocity of the envelope. 
			 *  @returns {Tone.Envelope} this
			 *  @example
			 * //trigger the attack and then the release after 0.6 seconds.
			 * env.triggerAttackRelease(0.6);
			 */
		    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {
		        time = this.toSeconds(time);
		        this.triggerAttack(time, velocity);
		        this.triggerRelease(time + this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Cancels all scheduled envelope changes after the given time.
			 *  @param  {Time} after
			 *  @returns {Tone.Envelope} this
			 */
		    Tone.Envelope.prototype.cancel = function (after) {
		        this._sig.cancelScheduledValues(after);
		        return this;
		    };
		    /**
			 *  Borrows the connect method from Tone.Signal. 
			 *  @function
			 *  @private
			 */
		    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;
		    /**
		 	 *  Generate some complex envelope curves. 
		 	 */
		    (function _createCurves() {
		        var curveLen = 128;
		        var i, k;
		        //cosine curve
		        var cosineCurve = [];
		        for (i = 0; i < curveLen; i++) {
		            cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
		        }
		        //ripple curve
		        var rippleCurve = [];
		        var rippleCurveFreq = 6.4;
		        for (i = 0; i < curveLen - 1; i++) {
		            k = i / (curveLen - 1);
		            var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
		            rippleCurve[i] = sineWave / 10 + k * 0.83;
		        }
		        rippleCurve[curveLen - 1] = 1;
		        //stairs curve
		        var stairsCurve = [];
		        var steps = 5;
		        for (i = 0; i < curveLen; i++) {
		            stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
		        }
		        //in-out easing curve
		        var sineCurve = [];
		        for (i = 0; i < curveLen; i++) {
		            k = i / (curveLen - 1);
		            sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
		        }
		        //a bounce curve
		        var bounceCurve = [];
		        for (i = 0; i < curveLen; i++) {
		            k = i / (curveLen - 1);
		            var freq = Math.pow(k, 3) * 4 + 0.2;
		            var val = Math.cos(freq * Math.PI * 2 * k);
		            bounceCurve[i] = Math.abs(val * (1 - k));
		        }
		        /**
				 *  Invert a value curve to make it work for the release
				 *  @private
				 */
		        function invertCurve(curve) {
		            var out = new Array(curve.length);
		            for (var j = 0; j < curve.length; j++) {
		                out[j] = 1 - curve[j];
		            }
		            return out;
		        }
		        /**
				 *  reverse the curve
				 *  @private
				 */
		        function reverseCurve(curve) {
		            return curve.slice(0).reverse();
		        }
		        /**
				 *  attack and release curve arrays
				 *  @type  {Object}
				 *  @private
				 */
		        Tone.Envelope.Type = {
		            'linear': 'linear',
		            'exponential': 'exponential',
		            'bounce': {
		                In: invertCurve(bounceCurve),
		                Out: bounceCurve
		            },
		            'cosine': {
		                In: cosineCurve,
		                Out: reverseCurve(cosineCurve)
		            },
		            'step': {
		                In: stairsCurve,
		                Out: invertCurve(stairsCurve)
		            },
		            'ripple': {
		                In: rippleCurve,
		                Out: invertCurve(rippleCurve)
		            },
		            'sine': {
		                In: sineCurve,
		                Out: invertCurve(sineCurve)
		            }
		        };
		    }());
		    /**
			 *  Disconnect and dispose.
			 *  @returns {Tone.Envelope} this
			 */
		    Tone.Envelope.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sig.dispose();
		        this._sig = null;
		        this._attackCurve = null;
		        this._releaseCurve = null;
		        return this;
		    };
		    return Tone.Envelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node. 
			 *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts
			 *          an audio signal as the input and will apply the envelope to the amplitude
			 *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
			 *  
			 *  @constructor
			 *  @extends {Tone.Envelope}
			 *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from 
			 *                               0 to it's maximum value. 
			 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
			 *                       	to fall to the sustain value. 
			 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
			 *                                	the release is triggered. 
			 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0. 
			 *  @example
			 * var ampEnv = new Tone.AmplitudeEnvelope({
			 * 	"attack": 0.1,
			 * 	"decay": 0.2,
			 * 	"sustain": 1.0,
			 * 	"release": 0.8
			 * }).toMaster();
			 * //create an oscillator and connect it
			 * var osc = new Tone.Oscillator().connect(ampEnv).start();
			 * //trigger the envelopes attack and release "8t" apart
			 * ampEnv.triggerAttackRelease("8t");
			 */
		    Tone.AmplitudeEnvelope = function () {
		        Tone.Envelope.apply(this, arguments);
		        /**
				 *  the input node
				 *  @type {GainNode}
				 *  @private
				 */
		        this.input = this.output = new Tone.Gain();
		        this._sig.connect(this.output.gain);
		    };
		    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);
		    /**
			 *  Clean up
			 *  @return  {Tone.AmplitudeEnvelope}  this
			 */
		    Tone.AmplitudeEnvelope.prototype.dispose = function () {
		        this.input.dispose();
		        this.input = null;
		        Tone.Envelope.prototype.dispose.call(this);
		        return this;
		    };
		    return Tone.AmplitudeEnvelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Wrapper around the native Web Audio's 
			 *          [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).
			 *          Extracts FFT or Waveform data from the incoming signal.
			 *  @extends {Tone}
			 *  @param {String=} type The return type of the analysis, either "fft", or "waveform". 
			 *  @param {Number=} size The size of the FFT. Value must be a power of 
			 *                       two in the range 32 to 32768.
			 */
		    Tone.Analyser = function () {
		        var options = this.optionsObject(arguments, [
		            'type',
		            'size'
		        ], Tone.Analyser.defaults);
		        /**
				 *  The analyser node.
				 *  @private
				 *  @type {AnalyserNode}
				 */
		        this._analyser = this.input = this.output = this.context.createAnalyser();
		        /**
				 *  The analysis type
				 *  @type {String}
				 *  @private
				 */
		        this._type = options.type;
		        /**
				 *  The return type of the analysis
				 *  @type {String}
				 *  @private
				 */
		        this._returnType = options.returnType;
		        /**
				 *  The buffer that the FFT data is written to
				 *  @type {TypedArray}
				 *  @private
				 */
		        this._buffer = null;
		        //set the values initially
		        this.size = options.size;
		        this.type = options.type;
		        this.returnType = options.returnType;
		        this.minDecibels = options.minDecibels;
		        this.maxDecibels = options.maxDecibels;
		    };
		    Tone.extend(Tone.Analyser);
		    /**
			 *  The default values.
			 *  @type {Object}
			 *  @const
			 */
		    Tone.Analyser.defaults = {
		        'size': 1024,
		        'returnType': 'byte',
		        'type': 'fft',
		        'smoothing': 0.8,
		        'maxDecibels': -30,
		        'minDecibels': -100
		    };
		    /**
			 *  Possible return types of Tone.Analyser.analyse()
			 *  @enum {String}
			 */
		    Tone.Analyser.Type = {
		        Waveform: 'waveform',
		        FFT: 'fft'
		    };
		    /**
			 *  Possible return types of Tone.Analyser.analyse(). 
			 *  byte values are between [0,255]. float values are between 
			 *  [-1, 1] when the type is set to "waveform" and between 
			 *  [minDecibels,maxDecibels] when the type is "fft".
			 *  @enum {String}
			 */
		    Tone.Analyser.ReturnType = {
		        Byte: 'byte',
		        Float: 'float'
		    };
		    /**
			 *  Run the analysis given the current settings and return the 
			 *  result as a TypedArray. 
			 *  @returns {TypedArray}
			 */
		    Tone.Analyser.prototype.analyse = function () {
		        if (this._type === Tone.Analyser.Type.FFT) {
		            if (this._returnType === Tone.Analyser.ReturnType.Byte) {
		                this._analyser.getByteFrequencyData(this._buffer);
		            } else {
		                this._analyser.getFloatFrequencyData(this._buffer);
		            }
		        } else if (this._type === Tone.Analyser.Type.Waveform) {
		            if (this._returnType === Tone.Analyser.ReturnType.Byte) {
		                this._analyser.getByteTimeDomainData(this._buffer);
		            } else {
		                if (this.isFunction(AnalyserNode.prototype.getFloatTimeDomainData)) {
		                    this._analyser.getFloatTimeDomainData(this._buffer);
		                } else {
		                    var uint8 = new Uint8Array(this._buffer.length);
		                    this._analyser.getByteTimeDomainData(uint8);
		                    //referenced https://github.com/mohayonao/get-float-time-domain-data 
		                    // POLYFILL
		                    for (var i = 0; i < uint8.length; i++) {
		                        this._buffer[i] = (uint8[i] - 128) * 0.0078125;
		                    }
		                }
		            }
		        }
		        return this._buffer;
		    };
		    /**
			 *  The size of analysis. This must be a power of two in the range 32 to 32768.
			 *  @memberOf Tone.Analyser#
			 *  @type {Number}
			 *  @name size
			 */
		    Object.defineProperty(Tone.Analyser.prototype, 'size', {
		        get: function () {
		            return this._analyser.frequencyBinCount;
		        },
		        set: function (size) {
		            this._analyser.fftSize = size * 2;
		            this.type = this._type;
		        }
		    });
		    /**
			 *  The return type of Tone.Analyser.analyse(), either "byte" or "float". 
			 *  When the type is set to "byte" the range of values returned in the array
			 *  are between 0-255. "float" values are between 
			 *  [-1, 1] when the type is set to "waveform" and between 
			 *  [minDecibels,maxDecibels] when the type is "fft".
			 *  @memberOf Tone.Analyser#
			 *  @type {String}
			 *  @name type
			 */
		    Object.defineProperty(Tone.Analyser.prototype, 'returnType', {
		        get: function () {
		            return this._returnType;
		        },
		        set: function (type) {
		            if (type === Tone.Analyser.ReturnType.Byte) {
		                this._buffer = new Uint8Array(this._analyser.frequencyBinCount);
		            } else if (type === Tone.Analyser.ReturnType.Float) {
		                this._buffer = new Float32Array(this._analyser.frequencyBinCount);
		            } else {
		                throw new TypeError('Tone.Analayser: invalid return type: ' + type);
		            }
		            this._returnType = type;
		        }
		    });
		    /**
			 *  The analysis function returned by Tone.Analyser.analyse(), either "fft" or "waveform". 
			 *  @memberOf Tone.Analyser#
			 *  @type {String}
			 *  @name type
			 */
		    Object.defineProperty(Tone.Analyser.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            if (type !== Tone.Analyser.Type.Waveform && type !== Tone.Analyser.Type.FFT) {
		                throw new TypeError('Tone.Analyser: invalid type: ' + type);
		            }
		            this._type = type;
		        }
		    });
		    /**
			 *  0 represents no time averaging with the last analysis frame.
			 *  @memberOf Tone.Analyser#
			 *  @type {NormalRange}
			 *  @name smoothing
			 */
		    Object.defineProperty(Tone.Analyser.prototype, 'smoothing', {
		        get: function () {
		            return this._analyser.smoothingTimeConstant;
		        },
		        set: function (val) {
		            this._analyser.smoothingTimeConstant = val;
		        }
		    });
		    /**
			 *  The smallest decibel value which is analysed by the FFT. 
			 *  @memberOf Tone.Analyser#
			 *  @type {Decibels}
			 *  @name minDecibels
			 */
		    Object.defineProperty(Tone.Analyser.prototype, 'minDecibels', {
		        get: function () {
		            return this._analyser.minDecibels;
		        },
		        set: function (val) {
		            this._analyser.minDecibels = val;
		        }
		    });
		    /**
			 *  The largest decibel value which is analysed by the FFT. 
			 *  @memberOf Tone.Analyser#
			 *  @type {Decibels}
			 *  @name maxDecibels
			 */
		    Object.defineProperty(Tone.Analyser.prototype, 'maxDecibels', {
		        get: function () {
		            return this._analyser.maxDecibels;
		        },
		        set: function (val) {
		            this._analyser.maxDecibels = val;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return  {Tone.Analyser}  this
			 */
		    Tone.Analyser.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._analyser.disconnect();
		        this._analyser = null;
		        this._buffer = null;
		    };
		    return Tone.Analyser;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Compressor is a thin wrapper around the Web Audio 
			 *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
			 *         Compression reduces the volume of loud sounds or amplifies quiet sounds 
			 *         by narrowing or "compressing" an audio signal's dynamic range. 
			 *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.
			 *  @param {Positive} [ratio] The gain reduction ratio.
			 *  @example
			 * var comp = new Tone.Compressor(-30, 3);
			 */
		    Tone.Compressor = function () {
		        var options = this.optionsObject(arguments, [
		            'threshold',
		            'ratio'
		        ], Tone.Compressor.defaults);
		        /**
				 *  the compressor node
				 *  @type {DynamicsCompressorNode}
				 *  @private
				 */
		        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();
		        /**
				 *  the threshold vaue
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.threshold = new Tone.Param({
		            'param': this._compressor.threshold,
		            'units': Tone.Type.Decibels,
		            'convert': false
		        });
		        /**
				 *  The attack parameter
				 *  @type {Time}
				 *  @signal
				 */
		        this.attack = new Tone.Param(this._compressor.attack, Tone.Type.Time);
		        /**
				 *  The release parameter
				 *  @type {Time}
				 *  @signal
				 */
		        this.release = new Tone.Param(this._compressor.release, Tone.Type.Time);
		        /**
				 *  The knee parameter
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.knee = new Tone.Param({
		            'param': this._compressor.knee,
		            'units': Tone.Type.Decibels,
		            'convert': false
		        });
		        /**
				 *  The ratio value
				 *  @type {Number}
				 *  @signal
				 */
		        this.ratio = new Tone.Param({
		            'param': this._compressor.ratio,
		            'convert': false
		        });
		        //set the defaults
		        this._readOnly([
		            'knee',
		            'release',
		            'attack',
		            'ratio',
		            'threshold'
		        ]);
		        this.set(options);
		    };
		    Tone.extend(Tone.Compressor);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Compressor.defaults = {
		        'ratio': 12,
		        'threshold': -24,
		        'release': 0.25,
		        'attack': 0.003,
		        'knee': 30
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Compressor} this
			 */
		    Tone.Compressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'knee',
		            'release',
		            'attack',
		            'ratio',
		            'threshold'
		        ]);
		        this._compressor.disconnect();
		        this._compressor = null;
		        this.attack.dispose();
		        this.attack = null;
		        this.release.dispose();
		        this.release = null;
		        this.threshold.dispose();
		        this.threshold = null;
		        this.ratio.dispose();
		        this.ratio = null;
		        this.knee.dispose();
		        this.knee = null;
		        return this;
		    };
		    return Tone.Compressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Add a signal and a number or two signals. When no value is
			 *         passed into the constructor, Tone.Add will sum <code>input[0]</code>
			 *         and <code>input[1]</code>. If a value is passed into the constructor, 
			 *         the it will be added to the input.
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value If no value is provided, Tone.Add will sum the first
			 *                         and second inputs. 
			 *  @example
			 * var signal = new Tone.Signal(2);
			 * var add = new Tone.Add(2);
			 * signal.connect(add);
			 * //the output of add equals 4
			 *  @example
			 * //if constructed with no arguments
			 * //it will add the first and second inputs
			 * var add = new Tone.Add();
			 * var sig0 = new Tone.Signal(3).connect(add, 0, 0);
			 * var sig1 = new Tone.Signal(4).connect(add, 0, 1);
			 * //the output of add equals 7. 
			 */
		    Tone.Add = function (value) {
		        this.createInsOuts(2, 0);
		        /**
				 *  the summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.input[0] = this.input[1] = this.output = new Tone.Gain();
		        /**
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._param = this.input[1] = new Tone.Signal(value);
		        this._param.connect(this._sum);
		    };
		    Tone.extend(Tone.Add, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Add} this
			 */
		    Tone.Add.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sum.dispose();
		        this._sum = null;
		        this._param.dispose();
		        this._param = null;
		        return this;
		    };
		    return Tone.Add;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, 
			 *          multiplies the incoming signal by that value. 
			 *
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value Constant value to multiple. If no value is provided,
			 *                         it will return the product of the first and second inputs
			 *  @example
			 * var mult = new Tone.Multiply();
			 * var sigA = new Tone.Signal(3);
			 * var sigB = new Tone.Signal(4);
			 * sigA.connect(mult, 0, 0);
			 * sigB.connect(mult, 0, 1);
			 * //output of mult is 12.
			 *  @example
			 * var mult = new Tone.Multiply(10);
			 * var sig = new Tone.Signal(2).connect(mult);
			 * //the output of mult is 20. 
			 */
		    Tone.Multiply = function (value) {
		        this.createInsOuts(2, 0);
		        /**
				 *  the input node is the same as the output node
				 *  it is also the GainNode which handles the scaling of incoming signal
				 *  
				 *  @type {GainNode}
				 *  @private
				 */
		        this._mult = this.input[0] = this.output = new Tone.Gain();
		        /**
				 *  the scaling parameter
				 *  @type {AudioParam}
				 *  @private
				 */
		        this._param = this.input[1] = this.output.gain;
		        this._param.value = this.defaultArg(value, 0);
		    };
		    Tone.extend(Tone.Multiply, Tone.Signal);
		    /**
			 *  clean up
			 *  @returns {Tone.Multiply} this
			 */
		    Tone.Multiply.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._mult.dispose();
		        this._mult = null;
		        this._param = null;
		        return this;
		    };
		    return Tone.Multiply;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var neg = new Tone.Negate();
			 * var sig = new Tone.Signal(-2).connect(neg);
			 * //output of neg is positive 2. 
			 */
		    Tone.Negate = function () {
		        /**
				 *  negation is done by multiplying by -1
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._multiply = this.input = this.output = new Tone.Multiply(-1);
		    };
		    Tone.extend(Tone.Negate, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.Negate} this
			 */
		    Tone.Negate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._multiply.dispose();
		        this._multiply = null;
		        return this;
		    };
		    return Tone.Negate;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected 
			 *         to <code>input[0]</code>. If an argument is provided in the constructor, the 
			 *         signals <code>.value</code> will be subtracted from the incoming signal.
			 *
			 *  @extends {Tone.Signal}
			 *  @constructor
			 *  @param {number=} value The value to subtract from the incoming signal. If the value
			 *                         is omitted, it will subtract the second signal from the first.
			 *  @example
			 * var sub = new Tone.Subtract(1);
			 * var sig = new Tone.Signal(4).connect(sub);
			 * //the output of sub is 3. 
			 *  @example
			 * var sub = new Tone.Subtract();
			 * var sigA = new Tone.Signal(10);
			 * var sigB = new Tone.Signal(2.5);
			 * sigA.connect(sub, 0, 0);
			 * sigB.connect(sub, 0, 1);
			 * //output of sub is 7.5
			 */
		    Tone.Subtract = function (value) {
		        this.createInsOuts(2, 0);
		        /**
				 *  the summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.input[0] = this.output = new Tone.Gain();
		        /**
				 *  negate the input of the second input before connecting it
				 *  to the summing node.
				 *  @type {Tone.Negate}
				 *  @private
				 */
		        this._neg = new Tone.Negate();
		        /**
				 *  the node where the value is set
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._param = this.input[1] = new Tone.Signal(value);
		        this._param.chain(this._neg, this._sum);
		    };
		    Tone.extend(Tone.Subtract, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.SignalBase} this
			 */
		    Tone.Subtract.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._neg.dispose();
		        this._neg = null;
		        this._sum.disconnect();
		        this._sum = null;
		        this._param.dispose();
		        this._param = null;
		        return this;
		    };
		    return Tone.Subtract;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var gt0 = new Tone.GreaterThanZero();
			 * var sig = new Tone.Signal(0.01).connect(gt0);
			 * //the output of gt0 is 1. 
			 * sig.value = 0;
			 * //the output of gt0 is 0. 
			 */
		    Tone.GreaterThanZero = function () {
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = this.output = new Tone.WaveShaper(function (val) {
		            if (val <= 0) {
		                return 0;
		            } else {
		                return 1;
		            }
		        }, 127);
		        /**
				 *  scale the first thresholded signal by a large value.
				 *  this will help with values which are very close to 0
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.input = new Tone.Multiply(10000);
		        //connections
		        this._scale.connect(this._thresh);
		    };
		    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);
		    /**
			 *  dispose method
			 *  @returns {Tone.GreaterThanZero} this
			 */
		    Tone.GreaterThanZero.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        return this;
		    };
		    return Tone.GreaterThanZero;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.
			 *          can compare two signals or a signal and a number. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number} [value=0] the value to compare to the incoming signal
			 *  @example
			 * var gt = new Tone.GreaterThan(2);
			 * var sig = new Tone.Signal(4).connect(gt);
			 * //output of gt is equal 1. 
			 */
		    Tone.GreaterThan = function (value) {
		        this.createInsOuts(2, 0);
		        /**
				 *  subtract the amount from the incoming signal
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._param = this.input[0] = new Tone.Subtract(value);
		        this.input[1] = this._param.input[1];
		        /**
				 *  compare that amount to zero
				 *  @type {Tone.GreaterThanZero}
				 *  @private
				 */
		        this._gtz = this.output = new Tone.GreaterThanZero();
		        //connect
		        this._param.connect(this._gtz);
		    };
		    Tone.extend(Tone.GreaterThan, Tone.Signal);
		    /**
			 *  dispose method
			 *  @returns {Tone.GreaterThan} this
			 */
		    Tone.GreaterThan.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._param.dispose();
		        this._param = null;
		        this._gtz.dispose();
		        this._gtz = null;
		        return this;
		    };
		    return Tone.GreaterThan;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Return the absolute value of an incoming signal. 
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var signal = new Tone.Signal(-1);
			 * var abs = new Tone.Abs();
			 * signal.connect(abs);
			 * //the output of abs is 1. 
			 */
		    Tone.Abs = function () {
		        /**
				 *  @type {Tone.LessThan}
				 *  @private
				 */
		        this._abs = this.input = this.output = new Tone.WaveShaper(function (val) {
		            if (val === 0) {
		                return 0;
		            } else {
		                return Math.abs(val);
		            }
		        }, 127);
		    };
		    Tone.extend(Tone.Abs, Tone.SignalBase);
		    /**
			 *  dispose method
			 *  @returns {Tone.Abs} this
			 */
		    Tone.Abs.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._abs.dispose();
		        this._abs = null;
		        return this;
		    };
		    return Tone.Abs;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus
			 *         values in the NormalRange. 
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {NormalRange} modulus The modulus to apply.
			 *  @example
			 * var mod = new Tone.Modulo(0.2)
			 * var sig = new Tone.Signal(0.5).connect(mod);
			 * //mod outputs 0.1
			 */
		    Tone.Modulo = function (modulus) {
		        this.createInsOuts(1, 0);
		        /**
				 *  A waveshaper gets the integer multiple of 
				 *  the input signal and the modulus.
				 *  @private
				 *  @type {Tone.WaveShaper}
				 */
		        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));
		        /**
				 *  the integer multiple is multiplied by the modulus
				 *  @type  {Tone.Multiply}
				 *  @private
				 */
		        this._multiply = new Tone.Multiply();
		        /**
				 *  and subtracted from the input signal
				 *  @type  {Tone.Subtract}
				 *  @private
				 */
		        this._subtract = this.output = new Tone.Subtract();
		        /**
				 *  the modulus signal
				 *  @type  {Tone.Signal}
				 *  @private
				 */
		        this._modSignal = new Tone.Signal(modulus);
		        //connections
		        this.input.fan(this._shaper, this._subtract);
		        this._modSignal.connect(this._multiply, 0, 0);
		        this._shaper.connect(this._multiply, 0, 1);
		        this._multiply.connect(this._subtract, 0, 1);
		        this._setWaveShaper(modulus);
		    };
		    Tone.extend(Tone.Modulo, Tone.SignalBase);
		    /**
			 *  @param  {number}  mod  the modulus to apply
			 *  @private
			 */
		    Tone.Modulo.prototype._setWaveShaper = function (mod) {
		        this._shaper.setMap(function (val) {
		            var multiple = Math.floor((val + 0.0001) / mod);
		            return multiple;
		        });
		    };
		    /**
			 * The modulus value.
			 * @memberOf Tone.Modulo#
			 * @type {NormalRange}
			 * @name value
			 */
		    Object.defineProperty(Tone.Modulo.prototype, 'value', {
		        get: function () {
		            return this._modSignal.value;
		        },
		        set: function (mod) {
		            this._modSignal.value = mod;
		            this._setWaveShaper(mod);
		        }
		    });
		    /**
			 * clean up
			 *  @returns {Tone.Modulo} this
			 */
		    Tone.Modulo.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        this._multiply.dispose();
		        this._multiply = null;
		        this._subtract.dispose();
		        this._subtract = null;
		        this._modSignal.dispose();
		        this._modSignal = null;
		        return this;
		    };
		    return Tone.Modulo;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. 
			 *         See Tone.GainToAudio.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 *  var a2g = new Tone.AudioToGain();
			 */
		    Tone.AudioToGain = function () {
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
		            return (x + 1) / 2;
		        });
		    };
		    Tone.extend(Tone.AudioToGain, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.AudioToGain} this
			 */
		    Tone.AudioToGain.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._norm.dispose();
		        this._norm = null;
		        return this;
		    };
		    return Tone.AudioToGain;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Evaluate an expression at audio rate. <br><br>
			 *         Parsing code modified from https://code.google.com/p/tapdigit/
			 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {string} expr the expression to generate
			 *  @example
			 * //adds the signals from input[0] and input[1].
			 * var expr = new Tone.Expr("$0 + $1");
			 */
		    Tone.Expr = function () {
		        var expr = this._replacements(Array.prototype.slice.call(arguments));
		        var inputCount = this._parseInputs(expr);
		        /**
				 *  hold onto all of the nodes for disposal
				 *  @type {Array}
				 *  @private
				 */
		        this._nodes = [];
		        /**
				 *  The inputs. The length is determined by the expression. 
				 *  @type {Array}
				 */
		        this.input = new Array(inputCount);
		        //create a gain for each input
		        for (var i = 0; i < inputCount; i++) {
		            this.input[i] = this.context.createGain();
		        }
		        //parse the syntax tree
		        var tree = this._parseTree(expr);
		        //evaluate the results
		        var result;
		        try {
		            result = this._eval(tree);
		        } catch (e) {
		            this._disposeNodes();
		            throw new Error('Tone.Expr: Could evaluate expression: ' + expr);
		        }
		        /**
				 *  The output node is the result of the expression
				 *  @type {Tone}
				 */
		        this.output = result;
		    };
		    Tone.extend(Tone.Expr, Tone.SignalBase);
		    //some helpers to cut down the amount of code
		    function applyBinary(Constructor, args, self) {
		        var op = new Constructor();
		        self._eval(args[0]).connect(op, 0, 0);
		        self._eval(args[1]).connect(op, 0, 1);
		        return op;
		    }
		    function applyUnary(Constructor, args, self) {
		        var op = new Constructor();
		        self._eval(args[0]).connect(op, 0, 0);
		        return op;
		    }
		    function getNumber(arg) {
		        return arg ? parseFloat(arg) : undefined;
		    }
		    function literalNumber(arg) {
		        return arg && arg.args ? parseFloat(arg.args) : undefined;
		    }
		    /*
			 *  the Expressions that Tone.Expr can parse.
			 *
			 *  each expression belongs to a group and contains a regexp 
			 *  for selecting the operator as well as that operators method
			 *  
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Expr._Expressions = {
		        //values
		        'value': {
		            'signal': {
		                regexp: /^\d+\.\d+|^\d+/,
		                method: function (arg) {
		                    var sig = new Tone.Signal(getNumber(arg));
		                    return sig;
		                }
		            },
		            'input': {
		                regexp: /^\$\d/,
		                method: function (arg, self) {
		                    return self.input[getNumber(arg.substr(1))];
		                }
		            }
		        },
		        //syntactic glue
		        'glue': {
		            '(': { regexp: /^\(/ },
		            ')': { regexp: /^\)/ },
		            ',': { regexp: /^,/ }
		        },
		        //functions
		        'func': {
		            'abs': {
		                regexp: /^abs/,
		                method: applyUnary.bind(this, Tone.Abs)
		            },
		            'mod': {
		                regexp: /^mod/,
		                method: function (args, self) {
		                    var modulus = literalNumber(args[1]);
		                    var op = new Tone.Modulo(modulus);
		                    self._eval(args[0]).connect(op);
		                    return op;
		                }
		            },
		            'pow': {
		                regexp: /^pow/,
		                method: function (args, self) {
		                    var exp = literalNumber(args[1]);
		                    var op = new Tone.Pow(exp);
		                    self._eval(args[0]).connect(op);
		                    return op;
		                }
		            },
		            'a2g': {
		                regexp: /^a2g/,
		                method: function (args, self) {
		                    var op = new Tone.AudioToGain();
		                    self._eval(args[0]).connect(op);
		                    return op;
		                }
		            }
		        },
		        //binary expressions
		        'binary': {
		            '+': {
		                regexp: /^\+/,
		                precedence: 1,
		                method: applyBinary.bind(this, Tone.Add)
		            },
		            '-': {
		                regexp: /^\-/,
		                precedence: 1,
		                method: function (args, self) {
		                    //both unary and binary op
		                    if (args.length === 1) {
		                        return applyUnary(Tone.Negate, args, self);
		                    } else {
		                        return applyBinary(Tone.Subtract, args, self);
		                    }
		                }
		            },
		            '*': {
		                regexp: /^\*/,
		                precedence: 0,
		                method: applyBinary.bind(this, Tone.Multiply)
		            }
		        },
		        //unary expressions
		        'unary': {
		            '-': {
		                regexp: /^\-/,
		                method: applyUnary.bind(this, Tone.Negate)
		            },
		            '!': {
		                regexp: /^\!/,
		                method: applyUnary.bind(this, Tone.NOT)
		            }
		        }
		    };
		    /**
			 *  @param   {string} expr the expression string
			 *  @return  {number}      the input count
			 *  @private
			 */
		    Tone.Expr.prototype._parseInputs = function (expr) {
		        var inputArray = expr.match(/\$\d/g);
		        var inputMax = 0;
		        if (inputArray !== null) {
		            for (var i = 0; i < inputArray.length; i++) {
		                var inputNum = parseInt(inputArray[i].substr(1)) + 1;
		                inputMax = Math.max(inputMax, inputNum);
		            }
		        }
		        return inputMax;
		    };
		    /**
			 *  @param   {Array} args 	an array of arguments
			 *  @return  {string} the results of the replacements being replaced
			 *  @private
			 */
		    Tone.Expr.prototype._replacements = function (args) {
		        var expr = args.shift();
		        for (var i = 0; i < args.length; i++) {
		            expr = expr.replace(/\%/i, args[i]);
		        }
		        return expr;
		    };
		    /**
			 *  tokenize the expression based on the Expressions object
			 *  @param   {string} expr 
			 *  @return  {Object}      returns two methods on the tokenized list, next and peek
			 *  @private
			 */
		    Tone.Expr.prototype._tokenize = function (expr) {
		        var position = -1;
		        var tokens = [];
		        while (expr.length > 0) {
		            expr = expr.trim();
		            var token = getNextToken(expr);
		            tokens.push(token);
		            expr = expr.substr(token.value.length);
		        }
		        function getNextToken(expr) {
		            for (var type in Tone.Expr._Expressions) {
		                var group = Tone.Expr._Expressions[type];
		                for (var opName in group) {
		                    var op = group[opName];
		                    var reg = op.regexp;
		                    var match = expr.match(reg);
		                    if (match !== null) {
		                        return {
		                            type: type,
		                            value: match[0],
		                            method: op.method
		                        };
		                    }
		                }
		            }
		            throw new SyntaxError('Tone.Expr: Unexpected token ' + expr);
		        }
		        return {
		            next: function () {
		                return tokens[++position];
		            },
		            peek: function () {
		                return tokens[position + 1];
		            }
		        };
		    };
		    /**
			 *  recursively parse the string expression into a syntax tree
			 *  
			 *  @param   {string} expr 
			 *  @return  {Object}
			 *  @private
			 */
		    Tone.Expr.prototype._parseTree = function (expr) {
		        var lexer = this._tokenize(expr);
		        var isUndef = this.isUndef.bind(this);
		        function matchSyntax(token, syn) {
		            return !isUndef(token) && token.type === 'glue' && token.value === syn;
		        }
		        function matchGroup(token, groupName, prec) {
		            var ret = false;
		            var group = Tone.Expr._Expressions[groupName];
		            if (!isUndef(token)) {
		                for (var opName in group) {
		                    var op = group[opName];
		                    if (op.regexp.test(token.value)) {
		                        if (!isUndef(prec)) {
		                            if (op.precedence === prec) {
		                                return true;
		                            }
		                        } else {
		                            return true;
		                        }
		                    }
		                }
		            }
		            return ret;
		        }
		        function parseExpression(precedence) {
		            if (isUndef(precedence)) {
		                precedence = 5;
		            }
		            var expr;
		            if (precedence < 0) {
		                expr = parseUnary();
		            } else {
		                expr = parseExpression(precedence - 1);
		            }
		            var token = lexer.peek();
		            while (matchGroup(token, 'binary', precedence)) {
		                token = lexer.next();
		                expr = {
		                    operator: token.value,
		                    method: token.method,
		                    args: [
		                        expr,
		                        parseExpression(precedence - 1)
		                    ]
		                };
		                token = lexer.peek();
		            }
		            return expr;
		        }
		        function parseUnary() {
		            var token, expr;
		            token = lexer.peek();
		            if (matchGroup(token, 'unary')) {
		                token = lexer.next();
		                expr = parseUnary();
		                return {
		                    operator: token.value,
		                    method: token.method,
		                    args: [expr]
		                };
		            }
		            return parsePrimary();
		        }
		        function parsePrimary() {
		            var token, expr;
		            token = lexer.peek();
		            if (isUndef(token)) {
		                throw new SyntaxError('Tone.Expr: Unexpected termination of expression');
		            }
		            if (token.type === 'func') {
		                token = lexer.next();
		                return parseFunctionCall(token);
		            }
		            if (token.type === 'value') {
		                token = lexer.next();
		                return {
		                    method: token.method,
		                    args: token.value
		                };
		            }
		            if (matchSyntax(token, '(')) {
		                lexer.next();
		                expr = parseExpression();
		                token = lexer.next();
		                if (!matchSyntax(token, ')')) {
		                    throw new SyntaxError('Expected )');
		                }
		                return expr;
		            }
		            throw new SyntaxError('Tone.Expr: Parse error, cannot process token ' + token.value);
		        }
		        function parseFunctionCall(func) {
		            var token, args = [];
		            token = lexer.next();
		            if (!matchSyntax(token, '(')) {
		                throw new SyntaxError('Tone.Expr: Expected ( in a function call "' + func.value + '"');
		            }
		            token = lexer.peek();
		            if (!matchSyntax(token, ')')) {
		                args = parseArgumentList();
		            }
		            token = lexer.next();
		            if (!matchSyntax(token, ')')) {
		                throw new SyntaxError('Tone.Expr: Expected ) in a function call "' + func.value + '"');
		            }
		            return {
		                method: func.method,
		                args: args,
		                name: name
		            };
		        }
		        function parseArgumentList() {
		            var token, expr, args = [];
		            while (true) {
		                expr = parseExpression();
		                if (isUndef(expr)) {
		                    // TODO maybe throw exception?
		                    break;
		                }
		                args.push(expr);
		                token = lexer.peek();
		                if (!matchSyntax(token, ',')) {
		                    break;
		                }
		                lexer.next();
		            }
		            return args;
		        }
		        return parseExpression();
		    };
		    /**
			 *  recursively evaluate the expression tree
			 *  @param   {Object} tree 
			 *  @return  {AudioNode}      the resulting audio node from the expression
			 *  @private
			 */
		    Tone.Expr.prototype._eval = function (tree) {
		        if (!this.isUndef(tree)) {
		            var node = tree.method(tree.args, this);
		            this._nodes.push(node);
		            return node;
		        }
		    };
		    /**
			 *  dispose all the nodes
			 *  @private
			 */
		    Tone.Expr.prototype._disposeNodes = function () {
		        for (var i = 0; i < this._nodes.length; i++) {
		            var node = this._nodes[i];
		            if (this.isFunction(node.dispose)) {
		                node.dispose();
		            } else if (this.isFunction(node.disconnect)) {
		                node.disconnect();
		            }
		            node = null;
		            this._nodes[i] = null;
		        }
		        this._nodes = null;
		    };
		    /**
			 *  clean up
			 */
		    Tone.Expr.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._disposeNodes();
		    };
		    return Tone.Expr;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var eqPowGain = new Tone.EqualPowerGain();
			 */
		    Tone.EqualPowerGain = function () {
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {
		            if (Math.abs(val) < 0.001) {
		                //should output 0 when input is 0
		                return 0;
		            } else {
		                return this.equalPowerScale(val);
		            }
		        }.bind(this), 4096);
		    };
		    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.EqualPowerGain} this
			 */
		    Tone.EqualPowerGain.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._eqPower.dispose();
		        this._eqPower = null;
		        return this;
		    };
		    return Tone.EqualPowerGain;
		});
		Module(function (Tone) {
		    
		    /**
			 * @class  Tone.Crossfade provides equal power fading between two inputs. 
			 *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
			 *
			 * @constructor
			 * @extends {Tone}
			 * @param {NormalRange} [initialFade=0.5]
			 * @example
			 * var crossFade = new Tone.CrossFade(0.5);
			 * //connect effect A to crossfade from
			 * //effect output 0 to crossfade input 0
			 * effectA.connect(crossFade, 0, 0);
			 * //connect effect B to crossfade from
			 * //effect output 0 to crossfade input 1
			 * effectB.connect(crossFade, 0, 1);
			 * crossFade.fade.value = 0;
			 * // ^ only effectA is output
			 * crossFade.fade.value = 1;
			 * // ^ only effectB is output
			 * crossFade.fade.value = 0.5;
			 * // ^ the two signals are mixed equally. 
			 */
		    Tone.CrossFade = function (initialFade) {
		        this.createInsOuts(2, 1);
		        /**
				 *  Alias for <code>input[0]</code>. 
				 *  @type {Tone.Gain}
				 */
		        this.a = this.input[0] = new Tone.Gain();
		        /**
				 *  Alias for <code>input[1]</code>. 
				 *  @type {Tone.Gain}
				 */
		        this.b = this.input[1] = new Tone.Gain();
		        /**
				 * 	The mix between the two inputs. A fade value of 0
				 * 	will output 100% <code>input[0]</code> and 
				 * 	a value of 1 will output 100% <code>input[1]</code>. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.fade = new Tone.Signal(this.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);
		        /**
				 *  equal power gain cross fade
				 *  @private
				 *  @type {Tone.EqualPowerGain}
				 */
		        this._equalPowerA = new Tone.EqualPowerGain();
		        /**
				 *  equal power gain cross fade
				 *  @private
				 *  @type {Tone.EqualPowerGain}
				 */
		        this._equalPowerB = new Tone.EqualPowerGain();
		        /**
				 *  invert the incoming signal
				 *  @private
				 *  @type {Tone}
				 */
		        this._invert = new Tone.Expr('1 - $0');
		        //connections
		        this.a.connect(this.output);
		        this.b.connect(this.output);
		        this.fade.chain(this._equalPowerB, this.b.gain);
		        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);
		        this._readOnly('fade');
		    };
		    Tone.extend(Tone.CrossFade);
		    /**
			 *  clean up
			 *  @returns {Tone.CrossFade} this
			 */
		    Tone.CrossFade.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('fade');
		        this._equalPowerA.dispose();
		        this._equalPowerA = null;
		        this._equalPowerB.dispose();
		        this._equalPowerB = null;
		        this.fade.dispose();
		        this.fade = null;
		        this._invert.dispose();
		        this._invert = null;
		        this.a.dispose();
		        this.a = null;
		        this.b.dispose();
		        this.b = null;
		        return this;
		    };
		    return Tone.CrossFade;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Filter is a filter which allows for all of the same native methods
			 *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface). 
			 *          Tone.Filter has the added ability to set the filter rolloff at -12 
			 *          (default), -24 and -48. 
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.
			 *  @param {string=} type The type of filter.
			 *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.
			 *                            3 choices: -12, -24, and -48
			 *  @example
			 *  var filter = new Tone.Filter(200, "highpass");
			 */
		    Tone.Filter = function () {
		        this.createInsOuts(1, 1);
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type',
		            'rolloff'
		        ], Tone.Filter.defaults);
		        /**
				 *  the filter(s)
				 *  @type {Array}
				 *  @private
				 */
		        this._filters = [];
		        /**
				 *  The cutoff frequency of the filter. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune parameter
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(0, Tone.Type.Cents);
		        /**
				 *  The gain of the filter, only used in certain filter types
				 *  @type {Number}
				 *  @signal
				 */
		        this.gain = new Tone.Signal({
		            'value': options.gain,
		            'convert': false
		        });
		        /**
				 *  The Q or Quality of the filter
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q);
		        /**
				 *  the type of the filter
				 *  @type {string}
				 *  @private
				 */
		        this._type = options.type;
		        /**
				 *  the rolloff value of the filter
				 *  @type {number}
				 *  @private
				 */
		        this._rolloff = options.rolloff;
		        //set the rolloff;
		        this.rolloff = options.rolloff;
		        this._readOnly([
		            'detune',
		            'frequency',
		            'gain',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.Filter);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Filter.defaults = {
		        'type': 'lowpass',
		        'frequency': 350,
		        'rolloff': -12,
		        'Q': 1,
		        'gain': 0
		    };
		    /**
			 * The type of the filter. Types: "lowpass", "highpass", 
			 * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking". 
			 * @memberOf Tone.Filter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Filter.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            var types = [
		                'lowpass',
		                'highpass',
		                'bandpass',
		                'lowshelf',
		                'highshelf',
		                'notch',
		                'allpass',
		                'peaking'
		            ];
		            if (types.indexOf(type) === -1) {
		                throw new TypeError('Tone.Filter: invalid type ' + type);
		            }
		            this._type = type;
		            for (var i = 0; i < this._filters.length; i++) {
		                this._filters[i].type = type;
		            }
		        }
		    });
		    /**
			 * The rolloff of the filter which is the drop in db
			 * per octave. Implemented internally by cascading filters.
			 * Only accepts the values -12, -24, -48 and -96.
			 * @memberOf Tone.Filter#
			 * @type {number}
			 * @name rolloff
			 */
		    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {
		        get: function () {
		            return this._rolloff;
		        },
		        set: function (rolloff) {
		            rolloff = parseInt(rolloff, 10);
		            var possibilities = [
		                -12,
		                -24,
		                -48,
		                -96
		            ];
		            var cascadingCount = possibilities.indexOf(rolloff);
		            //check the rolloff is valid
		            if (cascadingCount === -1) {
		                throw new RangeError('Tone.Filter: rolloff can only be -12, -24, -48 or -96');
		            }
		            cascadingCount += 1;
		            this._rolloff = rolloff;
		            //first disconnect the filters and throw them away
		            this.input.disconnect();
		            for (var i = 0; i < this._filters.length; i++) {
		                this._filters[i].disconnect();
		                this._filters[i] = null;
		            }
		            this._filters = new Array(cascadingCount);
		            for (var count = 0; count < cascadingCount; count++) {
		                var filter = this.context.createBiquadFilter();
		                filter.type = this._type;
		                this.frequency.connect(filter.frequency);
		                this.detune.connect(filter.detune);
		                this.Q.connect(filter.Q);
		                this.gain.connect(filter.gain);
		                this._filters[count] = filter;
		            }
		            //connect them up
		            var connectionChain = [this.input].concat(this._filters).concat([this.output]);
		            this.connectSeries.apply(this, connectionChain);
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @return {Tone.Filter} this
			 */
		    Tone.Filter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        for (var i = 0; i < this._filters.length; i++) {
		            this._filters[i].disconnect();
		            this._filters[i] = null;
		        }
		        this._filters = null;
		        this._writable([
		            'detune',
		            'frequency',
		            'gain',
		            'Q'
		        ]);
		        this.frequency.dispose();
		        this.Q.dispose();
		        this.frequency = null;
		        this.Q = null;
		        this.detune.dispose();
		        this.detune = null;
		        this.gain.dispose();
		        this.gain = null;
		        return this;
		    };
		    return Tone.Filter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Split the incoming signal into three bands (low, mid, high)
			 *         with two crossover frequency controls. 
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency
			 *  @param {Frequency} [highFrequency] the mid/high crossover frequency
			 */
		    Tone.MultibandSplit = function () {
		        var options = this.optionsObject(arguments, [
		            'lowFrequency',
		            'highFrequency'
		        ], Tone.MultibandSplit.defaults);
		        /**
				 *  the input
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this.input = new Tone.Gain();
		        /**
				 *  the outputs
				 *  @type {Array}
				 *  @private
				 */
		        this.output = new Array(3);
		        /**
				 *  The low band. Alias for <code>output[0]</code>
				 *  @type {Tone.Filter}
				 */
		        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');
		        /**
				 *  the lower filter of the mid band
				 *  @type {Tone.Filter}
				 *  @private
				 */
		        this._lowMidFilter = new Tone.Filter(0, 'highpass');
		        /**
				 *  The mid band output. Alias for <code>output[1]</code>
				 *  @type {Tone.Filter}
				 */
		        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');
		        /**
				 *  The high band output. Alias for <code>output[2]</code>
				 *  @type {Tone.Filter}
				 */
		        this.high = this.output[2] = new Tone.Filter(0, 'highpass');
		        /**
				 *  The low/mid crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);
		        /**
				 *  The mid/high crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);
		        /**
				 *  The quality of all the filters
				 *  @type {Number}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q);
		        this.input.fan(this.low, this.high);
		        this.input.chain(this._lowMidFilter, this.mid);
		        //the frequency control signal
		        this.lowFrequency.connect(this.low.frequency);
		        this.lowFrequency.connect(this._lowMidFilter.frequency);
		        this.highFrequency.connect(this.mid.frequency);
		        this.highFrequency.connect(this.high.frequency);
		        //the Q value
		        this.Q.connect(this.low.Q);
		        this.Q.connect(this._lowMidFilter.Q);
		        this.Q.connect(this.mid.Q);
		        this.Q.connect(this.high.Q);
		        this._readOnly([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		    };
		    Tone.extend(Tone.MultibandSplit);
		    /**
			 *  @private
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MultibandSplit.defaults = {
		        'lowFrequency': 400,
		        'highFrequency': 2500,
		        'Q': 1
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.MultibandSplit} this
			 */
		    Tone.MultibandSplit.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		        this.low.dispose();
		        this.low = null;
		        this._lowMidFilter.dispose();
		        this._lowMidFilter = null;
		        this.mid.dispose();
		        this.mid = null;
		        this.high.dispose();
		        this.high = null;
		        this.lowFrequency.dispose();
		        this.lowFrequency = null;
		        this.highFrequency.dispose();
		        this.highFrequency = null;
		        this.Q.dispose();
		        this.Q = null;
		        return this;
		    };
		    return Tone.MultibandSplit;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as
			 *         well as the low and high crossover frequencies.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  
			 *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.
			 *  @param {Decibels} [midLevel] The gain applied to the mid.
			 *  @param {Decibels} [highLevel] The gain applied to the high.
			 *  @example
			 * var eq = new Tone.EQ3(-10, 3, -20);
			 */
		    Tone.EQ3 = function () {
		        var options = this.optionsObject(arguments, [
		            'low',
		            'mid',
		            'high'
		        ], Tone.EQ3.defaults);
		        /**
				 *  the output node
				 *  @type {GainNode}
				 *  @private
				 */
		        this.output = new Tone.Gain();
		        /**
				 *  the multiband split
				 *  @type {Tone.MultibandSplit}
				 *  @private
				 */
		        this._multibandSplit = this.input = new Tone.MultibandSplit({
		            'lowFrequency': options.lowFrequency,
		            'highFrequency': options.highFrequency
		        });
		        /**
				 *  The gain for the lower signals
				 *  @type  {Tone.Gain}
				 *  @private
				 */
		        this._lowGain = new Tone.Gain(options.low, Tone.Type.Decibels);
		        /**
				 *  The gain for the mid signals
				 *  @type  {Tone.Gain}
				 *  @private
				 */
		        this._midGain = new Tone.Gain(options.mid, Tone.Type.Decibels);
		        /**
				 * The gain in decibels of the high part
				 * @type {Tone.Gain}
				 * @private
				 */
		        this._highGain = new Tone.Gain(options.high, Tone.Type.Decibels);
		        /**
				 * The gain in decibels of the low part
				 * @type {Decibels}
				 * @signal
				 */
		        this.low = this._lowGain.gain;
		        /**
				 * The gain in decibels of the mid part
				 * @type {Decibels}
				 * @signal
				 */
		        this.mid = this._midGain.gain;
		        /**
				 * The gain in decibels of the high part
				 * @type {Decibels}
				 * @signal
				 */
		        this.high = this._highGain.gain;
		        /**
				 *  The Q value for all of the filters. 
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = this._multibandSplit.Q;
		        /**
				 *  The low/mid crossover frequency. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = this._multibandSplit.lowFrequency;
		        /**
				 *  The mid/high crossover frequency. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = this._multibandSplit.highFrequency;
		        //the frequency bands
		        this._multibandSplit.low.chain(this._lowGain, this.output);
		        this._multibandSplit.mid.chain(this._midGain, this.output);
		        this._multibandSplit.high.chain(this._highGain, this.output);
		        this._readOnly([
		            'low',
		            'mid',
		            'high',
		            'lowFrequency',
		            'highFrequency'
		        ]);
		    };
		    Tone.extend(Tone.EQ3);
		    /**
			 *  the default values
			 */
		    Tone.EQ3.defaults = {
		        'low': 0,
		        'mid': 0,
		        'high': 0,
		        'lowFrequency': 400,
		        'highFrequency': 2500
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.EQ3} this
			 */
		    Tone.EQ3.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'low',
		            'mid',
		            'high',
		            'lowFrequency',
		            'highFrequency'
		        ]);
		        this._multibandSplit.dispose();
		        this._multibandSplit = null;
		        this.lowFrequency = null;
		        this.highFrequency = null;
		        this._lowGain.dispose();
		        this._lowGain = null;
		        this._midGain.dispose();
		        this._midGain = null;
		        this._highGain.dispose();
		        this._highGain = null;
		        this.low = null;
		        this.mid = null;
		        this.high = null;
		        this.Q = null;
		        return this;
		    };
		    return Tone.EQ3;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Performs a linear scaling on an input signal.
			 *          Scales a NormalRange input to between
			 *          outputMin and outputMax.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputMin=0] The output value when the input is 0. 
			 *  @param {number} [outputMax=1]	The output value when the input is 1. 
			 *  @example
			 * var scale = new Tone.Scale(50, 100);
			 * var signal = new Tone.Signal(0.5).connect(scale);
			 * //the output of scale equals 75
			 */
		    Tone.Scale = function (outputMin, outputMax) {
		        /** 
				 *  @private
				 *  @type {number}
				 */
		        this._outputMin = this.defaultArg(outputMin, 0);
		        /** 
				 *  @private
				 *  @type {number}
				 */
		        this._outputMax = this.defaultArg(outputMax, 1);
		        /** 
				 *  @private
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.input = new Tone.Multiply(1);
		        /** 
				 *  @private
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._add = this.output = new Tone.Add(0);
		        this._scale.connect(this._add);
		        this._setRange();
		    };
		    Tone.extend(Tone.Scale, Tone.SignalBase);
		    /**
			 * The minimum output value. This number is output when 
			 * the value input value is 0. 
			 * @memberOf Tone.Scale#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.Scale.prototype, 'min', {
		        get: function () {
		            return this._outputMin;
		        },
		        set: function (min) {
		            this._outputMin = min;
		            this._setRange();
		        }
		    });
		    /**
			 * The maximum output value. This number is output when 
			 * the value input value is 1. 
			 * @memberOf Tone.Scale#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.Scale.prototype, 'max', {
		        get: function () {
		            return this._outputMax;
		        },
		        set: function (max) {
		            this._outputMax = max;
		            this._setRange();
		        }
		    });
		    /**
			 *  set the values
			 *  @private
			 */
		    Tone.Scale.prototype._setRange = function () {
		        this._add.value = this._outputMin;
		        this._scale.value = this._outputMax - this._outputMin;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Scale} this
			 */
		    Tone.Scale.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._add.dispose();
		        this._add = null;
		        this._scale.dispose();
		        this._scale = null;
		        return this;
		    };
		    return Tone.Scale;
		});
		Module(function (Tone) {
		    /**
			 *  @class  Performs an exponential scaling on an input signal.
			 *          Scales a NormalRange value [0,1] exponentially
			 *          to the output range of outputMin to outputMax.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputMin=0] The output value when the input is 0. 
			 *  @param {number} [outputMax=1]	The output value when the input is 1. 
			 *  @param {number} [exponent=2] The exponent which scales the incoming signal.
			 *  @example
			 * var scaleExp = new Tone.ScaleExp(0, 100, 2);
			 * var signal = new Tone.Signal(0.5).connect(scaleExp);
			 */
		    Tone.ScaleExp = function (outputMin, outputMax, exponent) {
		        /**
				 *  scale the input to the output range
				 *  @type {Tone.Scale}
				 *  @private
				 */
		        this._scale = this.output = new Tone.Scale(outputMin, outputMax);
		        /**
				 *  @private
				 *  @type {Tone.Pow}
				 *  @private
				 */
		        this._exp = this.input = new Tone.Pow(this.defaultArg(exponent, 2));
		        this._exp.connect(this._scale);
		    };
		    Tone.extend(Tone.ScaleExp, Tone.SignalBase);
		    /**
			 * Instead of interpolating linearly between the <code>min</code> and 
			 * <code>max</code> values, setting the exponent will interpolate between
			 * the two values with an exponential curve. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name exponent
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {
		        get: function () {
		            return this._exp.value;
		        },
		        set: function (exp) {
		            this._exp.value = exp;
		        }
		    });
		    /**
			 * The minimum output value. This number is output when 
			 * the value input value is 0. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {
		        get: function () {
		            return this._scale.min;
		        },
		        set: function (min) {
		            this._scale.min = min;
		        }
		    });
		    /**
			 * The maximum output value. This number is output when 
			 * the value input value is 1. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {
		        get: function () {
		            return this._scale.max;
		        },
		        set: function (max) {
		            this._scale.max = max;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.ScaleExp} this
			 */
		    Tone.ScaleExp.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._exp.dispose();
		        this._exp = null;
		        return this;
		    };
		    return Tone.ScaleExp;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface). 
			 *  @extends {Tone}
			 *  @param {Time=} delayTime The delay applied to the incoming signal.
			 *  @param {Time=} maxDelay The maximum delay time. 
			 */
		    Tone.Delay = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'maxDelay'
		        ], Tone.Delay.defaults);
		        /**
				 *  The native delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delayNode = this.input = this.output = this.context.createDelay(this.toSeconds(options.maxDelay));
		        /**
				 *  The amount of time the incoming signal is
				 *  delayed. 
				 *  @type {Tone.Param}
				 *  @signal
				 */
		        this.delayTime = new Tone.Param({
		            'param': this._delayNode.delayTime,
		            'units': Tone.Type.Time,
		            'value': options.delayTime
		        });
		        this._readOnly('delayTime');
		    };
		    Tone.extend(Tone.Delay);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Delay.defaults = {
		        'maxDelay': 1,
		        'delayTime': 0
		    };
		    /**
			 *  Clean up.
			 *  @return  {Tone.Delay}  this
			 */
		    Tone.Delay.prototype.dispose = function () {
		        Tone.Param.prototype.dispose.call(this);
		        this._delayNode.disconnect();
		        this._delayNode = null;
		        this._writable('delayTime');
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.Delay;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Comb filters are basic building blocks for physical modeling. Read more
			 *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Time|Object} [delayTime] The delay time of the filter. 
			 *  @param {NormalRange=} resonance The amount of feedback the filter has. 
			 */
		    Tone.FeedbackCombFilter = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'resonance'
		        ], Tone.FeedbackCombFilter.defaults);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.input = this.output = new Tone.Delay(options.delayTime);
		        /**
				 *  The amount of delay of the comb filter. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = this._delay.delayTime;
		        /**
				 *  the feedback node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
		        /**
				 *  The amount of feedback of the delayed signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = this._feedback.gain;
		        this._delay.chain(this._feedback, this._delay);
		        this._readOnly([
		            'resonance',
		            'delayTime'
		        ]);
		    };
		    Tone.extend(Tone.FeedbackCombFilter);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.FeedbackCombFilter.defaults = {
		        'delayTime': 0.1,
		        'resonance': 0.5
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.FeedbackCombFilter} this
			 */
		    Tone.FeedbackCombFilter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'resonance',
		            'delayTime'
		        ]);
		        this._delay.dispose();
		        this._delay = null;
		        this.delayTime = null;
		        this._feedback.dispose();
		        this._feedback = null;
		        this.resonance = null;
		        return this;
		    };
		    return Tone.FeedbackCombFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Follower is a  crude envelope follower which will follow 
			 *          the amplitude of an incoming signal. 
			 *          Take care with small (< 0.02) attack or decay values 
			 *          as follower has some ripple which is exaggerated
			 *          at these values. Read more about envelope followers (also known 
			 *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Time|Object} [attack] The rate at which the follower rises.
			 *  @param {Time=} release The rate at which the folower falls. 
			 *  @example
			 * var follower = new Tone.Follower(0.2, 0.4);
			 */
		    Tone.Follower = function () {
		        this.createInsOuts(1, 1);
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'release'
		        ], Tone.Follower.defaults);
		        /**
				 *  @type {Tone.Abs}
				 *  @private
				 */
		        this._abs = new Tone.Abs();
		        /**
				 *  the lowpass filter which smooths the input
				 *  @type {BiquadFilterNode}
				 *  @private
				 */
		        this._filter = this.context.createBiquadFilter();
		        this._filter.type = 'lowpass';
		        this._filter.frequency.value = 0;
		        this._filter.Q.value = -100;
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._frequencyValues = new Tone.WaveShaper();
		        /**
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._sub = new Tone.Subtract();
		        /**
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._delay = new Tone.Delay(this.blockTime);
		        /**
				 *  this keeps it far from 0, even for very small differences
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._mult = new Tone.Multiply(10000);
		        /**
				 *  @private
				 *  @type {number}
				 */
		        this._attack = options.attack;
		        /**
				 *  @private
				 *  @type {number}
				 */
		        this._release = options.release;
		        //the smoothed signal to get the values
		        this.input.chain(this._abs, this._filter, this.output);
		        //the difference path
		        this._abs.connect(this._sub, 0, 1);
		        this._filter.chain(this._delay, this._sub);
		        //threshold the difference and use the thresh to set the frequency
		        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);
		        //set the attack and release values in the table
		        this._setAttackRelease(this._attack, this._release);
		    };
		    Tone.extend(Tone.Follower);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Follower.defaults = {
		        'attack': 0.05,
		        'release': 0.5
		    };
		    /**
			 *  sets the attack and release times in the wave shaper
			 *  @param   {Time} attack  
			 *  @param   {Time} release 
			 *  @private
			 */
		    Tone.Follower.prototype._setAttackRelease = function (attack, release) {
		        var minTime = this.blockTime;
		        attack = Tone.Time(attack).toFrequency();
		        release = Tone.Time(release).toFrequency();
		        attack = Math.max(attack, minTime);
		        release = Math.max(release, minTime);
		        this._frequencyValues.setMap(function (val) {
		            if (val <= 0) {
		                return attack;
		            } else {
		                return release;
		            }
		        });
		    };
		    /**
			 * The attack time.
			 * @memberOf Tone.Follower#
			 * @type {Time}
			 * @name attack
			 */
		    Object.defineProperty(Tone.Follower.prototype, 'attack', {
		        get: function () {
		            return this._attack;
		        },
		        set: function (attack) {
		            this._attack = attack;
		            this._setAttackRelease(this._attack, this._release);
		        }
		    });
		    /**
			 * The release time.
			 * @memberOf Tone.Follower#
			 * @type {Time}
			 * @name release
			 */
		    Object.defineProperty(Tone.Follower.prototype, 'release', {
		        get: function () {
		            return this._release;
		        },
		        set: function (release) {
		            this._release = release;
		            this._setAttackRelease(this._attack, this._release);
		        }
		    });
		    /**
			 *  Borrows the connect method from Signal so that the output can be used
			 *  as a Tone.Signal control signal.
			 *  @function
			 */
		    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;
		    /**
			 *  dispose
			 *  @returns {Tone.Follower} this
			 */
		    Tone.Follower.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._filter.disconnect();
		        this._filter = null;
		        this._frequencyValues.disconnect();
		        this._frequencyValues = null;
		        this._delay.dispose();
		        this._delay = null;
		        this._sub.disconnect();
		        this._sub = null;
		        this._abs.dispose();
		        this._abs = null;
		        this._mult.dispose();
		        this._mult = null;
		        this._curve = null;
		        return this;
		    };
		    return Tone.Follower;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.ScaledEnvelop is an envelope which can be scaled 
			 *         to any range. It's useful for applying an envelope 
			 *         to a frequency or any other non-NormalRange signal 
			 *         parameter. 
			 *
			 *  @extends {Tone.Envelope}
			 *  @constructor
			 *  @param {Time|Object} [attack]	the attack time in seconds
			 *  @param {Time} [decay]	the decay time in seconds
			 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
			 *  @param {Time} [release]	the release time in seconds
			 *  @example
			 *  var scaledEnv = new Tone.ScaledEnvelope({
			 *  	"attack" : 0.2,
			 *  	"min" : 200,
			 *  	"max" : 2000
			 *  });
			 *  scaledEnv.connect(oscillator.frequency);
			 */
		    Tone.ScaledEnvelope = function () {
		        //get all of the defaults
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'decay',
		            'sustain',
		            'release'
		        ], Tone.Envelope.defaults);
		        Tone.Envelope.call(this, options);
		        options = this.defaultArg(options, Tone.ScaledEnvelope.defaults);
		        /** 
				 *  scale the incoming signal by an exponent
				 *  @type {Tone.Pow}
				 *  @private
				 */
		        this._exp = this.output = new Tone.Pow(options.exponent);
		        /**
				 *  scale the signal to the desired range
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.output = new Tone.Scale(options.min, options.max);
		        this._sig.chain(this._exp, this._scale);
		    };
		    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);
		    /**
			 *  the default parameters
			 *  @static
			 */
		    Tone.ScaledEnvelope.defaults = {
		        'min': 0,
		        'max': 1,
		        'exponent': 1
		    };
		    /**
			 * The envelope's min output value. This is the value which it
			 * starts at. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {
		        get: function () {
		            return this._scale.min;
		        },
		        set: function (min) {
		            this._scale.min = min;
		        }
		    });
		    /**
			 * The envelope's max output value. In other words, the value
			 * at the peak of the attack portion of the envelope. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {
		        get: function () {
		            return this._scale.max;
		        },
		        set: function (max) {
		            this._scale.max = max;
		        }
		    });
		    /**
			 * The envelope's exponent value. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name exponent
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {
		        get: function () {
		            return this._exp.value;
		        },
		        set: function (exp) {
		            this._exp.value = exp;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.ScaledEnvelope} this
			 */
		    Tone.ScaledEnvelope.prototype.dispose = function () {
		        Tone.Envelope.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._exp.dispose();
		        this._exp = null;
		        return this;
		    };
		    return Tone.ScaledEnvelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.FrequencyEnvelope is a Tone.ScaledEnvelope, but instead of `min` and `max`
			 *         it's got a `baseFrequency` and `octaves` parameter. 
			 *
			 *  @extends {Tone.Envelope}
			 *  @constructor
			 *  @param {Time|Object} [attack]	the attack time in seconds
			 *  @param {Time} [decay]	the decay time in seconds
			 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
			 *  @param {Time} [release]	the release time in seconds
			 *  @example
			 *  var env = new Tone.FrequencyEnvelope({
			 *  	"attack" : 0.2,
			 *  	"baseFrequency" : "C2",
			 *  	"octaves" : 4
			 *  });
			 *  scaledEnv.connect(oscillator.frequency);
			 */
		    Tone.FrequencyEnvelope = function () {
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'decay',
		            'sustain',
		            'release'
		        ], Tone.Envelope.defaults);
		        Tone.ScaledEnvelope.call(this, options);
		        options = this.defaultArg(options, Tone.FrequencyEnvelope.defaults);
		        /**
				 *  Stores the octave value
				 *  @type {Positive}
				 *  @private
				 */
		        this._octaves = options.octaves;
		        //setup
		        this.baseFrequency = options.baseFrequency;
		        this.octaves = options.octaves;
		    };
		    Tone.extend(Tone.FrequencyEnvelope, Tone.Envelope);
		    /**
			 *  the default parameters
			 *  @static
			 */
		    Tone.FrequencyEnvelope.defaults = {
		        'baseFrequency': 200,
		        'octaves': 4,
		        'exponent': 2
		    };
		    /**
			 * The envelope's mininum output value. This is the value which it
			 * starts at. 
			 * @memberOf Tone.FrequencyEnvelope#
			 * @type {Frequency}
			 * @name baseFrequency
			 */
		    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'baseFrequency', {
		        get: function () {
		            return this._scale.min;
		        },
		        set: function (min) {
		            this._scale.min = this.toFrequency(min);
		            //also update the octaves
		            this.octaves = this._octaves;
		        }
		    });
		    /**
			 * The number of octaves above the baseFrequency that the
			 * envelope will scale to.
			 * @memberOf Tone.FrequencyEnvelope#
			 * @type {Positive}
			 * @name octaves
			 */
		    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'octaves', {
		        get: function () {
		            return this._octaves;
		        },
		        set: function (octaves) {
		            this._octaves = octaves;
		            this._scale.max = this.baseFrequency * Math.pow(2, octaves);
		        }
		    });
		    /**
			 * The envelope's exponent value. 
			 * @memberOf Tone.FrequencyEnvelope#
			 * @type {number}
			 * @name exponent
			 */
		    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'exponent', {
		        get: function () {
		            return this._exp.value;
		        },
		        set: function (exp) {
		            this._exp.value = exp;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.FrequencyEnvelope} this
			 */
		    Tone.FrequencyEnvelope.prototype.dispose = function () {
		        Tone.ScaledEnvelope.prototype.dispose.call(this);
		        return this;
		    };
		    return Tone.FrequencyEnvelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Gate only passes a signal through when the incoming 
			 *          signal exceeds a specified threshold. To do this, Gate uses 
			 *          a Tone.Follower to follow the amplitude of the incoming signal. 
			 *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Decibels|Object} [threshold] The threshold above which the gate will open. 
			 *  @param {Time=} attack The follower's attack time
			 *  @param {Time=} release The follower's release time
			 *  @example
			 * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();
			 * var mic = new Tone.UserMedia().connect(gate);
			 * //the gate will only pass through the incoming 
			 * //signal when it's louder than -30db
			 */
		    Tone.Gate = function () {
		        this.createInsOuts(1, 1);
		        var options = this.optionsObject(arguments, [
		            'threshold',
		            'attack',
		            'release'
		        ], Tone.Gate.defaults);
		        /**
				 *  @type {Tone.Follower}
				 *  @private
				 */
		        this._follower = new Tone.Follower(options.attack, options.release);
		        /**
				 *  @type {Tone.GreaterThan}
				 *  @private
				 */
		        this._gt = new Tone.GreaterThan(this.dbToGain(options.threshold));
		        //the connections
		        this.input.connect(this.output);
		        //the control signal
		        this.input.chain(this._gt, this._follower, this.output.gain);
		    };
		    Tone.extend(Tone.Gate);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Gate.defaults = {
		        'attack': 0.1,
		        'release': 0.1,
		        'threshold': -40
		    };
		    /**
			 * The threshold of the gate in decibels
			 * @memberOf Tone.Gate#
			 * @type {Decibels}
			 * @name threshold
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'threshold', {
		        get: function () {
		            return this.gainToDb(this._gt.value);
		        },
		        set: function (thresh) {
		            this._gt.value = this.dbToGain(thresh);
		        }
		    });
		    /**
			 * The attack speed of the gate
			 * @memberOf Tone.Gate#
			 * @type {Time}
			 * @name attack
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'attack', {
		        get: function () {
		            return this._follower.attack;
		        },
		        set: function (attackTime) {
		            this._follower.attack = attackTime;
		        }
		    });
		    /**
			 * The release speed of the gate
			 * @memberOf Tone.Gate#
			 * @type {Time}
			 * @name release
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'release', {
		        get: function () {
		            return this._follower.release;
		        },
		        set: function (releaseTime) {
		            this._follower.release = releaseTime;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Gate} this
			 */
		    Tone.Gate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._follower.dispose();
		        this._gt.dispose();
		        this._follower = null;
		        this._gt = null;
		        return this;
		    };
		    return Tone.Gate;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A Timeline State. Provides the methods: <code>setStateAtTime("state", time)</code>
			 *          and <code>getValueAtTime(time)</code>.
			 *
			 *  @extends {Tone.Timeline}
			 *  @param {String} initial The initial state of the TimelineState. 
			 *                          Defaults to <code>undefined</code>
			 */
		    Tone.TimelineState = function (initial) {
		        Tone.Timeline.call(this);
		        /**
				 *  The initial state
				 *  @private
				 *  @type {String}
				 */
		        this._initial = initial;
		    };
		    Tone.extend(Tone.TimelineState, Tone.Timeline);
		    /**
			 *  Returns the scheduled state scheduled before or at
			 *  the given time.
			 *  @param  {Number}  time  The time to query.
			 *  @return  {String}  The name of the state input in setStateAtTime.
			 */
		    Tone.TimelineState.prototype.getValueAtTime = function (time) {
		        var event = this.get(time);
		        if (event !== null) {
		            return event.state;
		        } else {
		            return this._initial;
		        }
		    };
		    /**
			 *  Returns the scheduled state scheduled before or at
			 *  the given time.
			 *  @param  {String}  state The name of the state to set.
			 *  @param  {Number}  time  The time to query.
			 */
		    Tone.TimelineState.prototype.setStateAtTime = function (state, time) {
		        this.add({
		            'state': state,
		            'time': time
		        });
		    };
		    return Tone.TimelineState;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Emitter gives classes which extend it
			 *         the ability to listen for and emit events. 
			 *         Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).
			 *         MIT (c) 2011 Jerome Etienne.
			 *         
			 *  @extends {Tone}
			 */
		    Tone.Emitter = function () {
		        /**
				 *  Contains all of the events.
				 *  @private
				 *  @type  {Object}
				 */
		        this._events = {};
		    };
		    Tone.extend(Tone.Emitter);
		    /**
			 *  Bind a callback to a specific event.
			 *  @param  {String}    event     The name of the event to listen for.
			 *  @param  {Function}  callback  The callback to invoke when the
			 *                                event is emitted
			 *  @return  {Tone.Emitter}    this
			 */
		    Tone.Emitter.prototype.on = function (event, callback) {
		        //split the event
		        var events = event.split(/\W+/);
		        for (var i = 0; i < events.length; i++) {
		            var eventName = events[i];
		            if (!this._events.hasOwnProperty(eventName)) {
		                this._events[eventName] = [];
		            }
		            this._events[eventName].push(callback);
		        }
		        return this;
		    };
		    /**
			 *  Remove the event listener.
			 *  @param  {String}    event     The event to stop listening to.
			 *  @param  {Function=}  callback  The callback which was bound to 
			 *                                the event with Tone.Emitter.on.
			 *                                If no callback is given, all callbacks
			 *                                events are removed.
			 *  @return  {Tone.Emitter}    this
			 */
		    Tone.Emitter.prototype.off = function (event, callback) {
		        var events = event.split(/\W+/);
		        for (var ev = 0; ev < events.length; ev++) {
		            event = events[ev];
		            if (this._events.hasOwnProperty(event)) {
		                if (Tone.prototype.isUndef(callback)) {
		                    this._events[event] = [];
		                } else {
		                    var eventList = this._events[event];
		                    for (var i = 0; i < eventList.length; i++) {
		                        if (eventList[i] === callback) {
		                            eventList.splice(i, 1);
		                        }
		                    }
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Invoke all of the callbacks bound to the event
			 *  with any arguments passed in. 
			 *  @param  {String}  event  The name of the event.
			 *  @param {*...} args The arguments to pass to the functions listening.
			 *  @return  {Tone.Emitter}  this
			 */
		    Tone.Emitter.prototype.emit = function (event) {
		        if (this._events) {
		            var args = Array.prototype.slice.call(arguments, 1);
		            if (this._events.hasOwnProperty(event)) {
		                var eventList = this._events[event];
		                for (var i = 0, len = eventList.length; i < len; i++) {
		                    eventList[i].apply(this, args);
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Add Emitter functions (on/off/emit) to the object
			 *  @param  {Object|Function}  object  The object or class to extend.
			 */
		    Tone.Emitter.mixin = function (object) {
		        var functions = [
		            'on',
		            'off',
		            'emit'
		        ];
		        object._events = {};
		        for (var i = 0; i < functions.length; i++) {
		            var func = functions[i];
		            var emitterFunc = Tone.Emitter.prototype[func];
		            object[func] = emitterFunc;
		        }
		    };
		    /**
			 *  Clean up
			 *  @return  {Tone.Emitter}  this
			 */
		    Tone.Emitter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._events = null;
		        return this;
		    };
		    return Tone.Emitter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A sample accurate clock which provides a callback at the given rate. 
			 *          While the callback is not sample-accurate (it is still susceptible to
			 *          loose JS timing), the time passed in as the argument to the callback
			 *          is precise. For most applications, it is better to use Tone.Transport
			 *          instead of the Clock by itself since you can synchronize multiple callbacks.
			 *
			 * 	@constructor
			 *  @extends {Tone.Emitter}
			 * 	@param {function} callback The callback to be invoked with the time of the audio event
			 * 	@param {Frequency} frequency The rate of the callback
			 * 	@example
			 * //the callback will be invoked approximately once a second
			 * //and will print the time exactly once a second apart.
			 * var clock = new Tone.Clock(function(time){
			 * 	console.log(time);
			 * }, 1);
			 */
		    Tone.Clock = function () {
		        Tone.Emitter.call(this);
		        var options = this.optionsObject(arguments, [
		            'callback',
		            'frequency'
		        ], Tone.Clock.defaults);
		        /**
				 *  The callback function to invoke at the scheduled tick.
				 *  @type  {Function}
				 */
		        this.callback = options.callback;
		        /**
				 *  The next time the callback is scheduled.
				 *  @type {Number}
				 *  @private
				 */
		        this._nextTick = 0;
		        /**
				 *  The last state of the clock.
				 *  @type  {State}
				 *  @private
				 */
		        this._lastState = Tone.State.Stopped;
		        /**
				 *  The rate the callback function should be invoked. 
				 *  @type  {BPM}
				 *  @signal
				 */
		        this.frequency = new Tone.TimelineSignal(options.frequency, Tone.Type.Frequency);
		        this._readOnly('frequency');
		        /**
				 *  The number of times the callback was invoked. Starts counting at 0
				 *  and increments after the callback was invoked. 
				 *  @type {Ticks}
				 *  @readOnly
				 */
		        this.ticks = 0;
		        /**
				 *  The state timeline
				 *  @type {Tone.TimelineState}
				 *  @private
				 */
		        this._state = new Tone.TimelineState(Tone.State.Stopped);
		        /**
				 *  The loop function bound to its context. 
				 *  This is necessary to remove the event in the end.
				 *  @type {Function}
				 *  @private
				 */
		        this._boundLoop = this._loop.bind(this);
		        //bind a callback to the worker thread
		        Tone.Clock._worker.addEventListener('message', this._boundLoop);
		    };
		    Tone.extend(Tone.Clock, Tone.Emitter);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Clock.defaults = {
		        'callback': Tone.noOp,
		        'frequency': 1,
		        'lookAhead': 'auto'
		    };
		    /**
			 *  Returns the playback state of the source, either "started", "stopped" or "paused".
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.Clock#
			 *  @name state
			 */
		    Object.defineProperty(Tone.Clock.prototype, 'state', {
		        get: function () {
		            return this._state.getValueAtTime(this.now());
		        }
		    });
		    /**
			 *  Start the clock at the given time. Optionally pass in an offset
			 *  of where to start the tick counter from.
			 *  @param  {Time}  time    The time the clock should start
			 *  @param  {Ticks=}  offset  Where the tick counter starts counting from.
			 *  @return  {Tone.Clock}  this
			 */
		    Tone.Clock.prototype.start = function (time, offset) {
		        time = this.toSeconds(time);
		        if (this._state.getValueAtTime(time) !== Tone.State.Started) {
		            this._state.add({
		                'state': Tone.State.Started,
		                'time': time,
		                'offset': offset
		            });
		        }
		        return this;
		    };
		    /**
			 *  Stop the clock. Stopping the clock resets the tick counter to 0.
			 *  @param {Time} [time=now] The time when the clock should stop.
			 *  @returns {Tone.Clock} this
			 *  @example
			 * clock.stop();
			 */
		    Tone.Clock.prototype.stop = function (time) {
		        time = this.toSeconds(time);
		        this._state.cancel(time);
		        this._state.setStateAtTime(Tone.State.Stopped, time);
		        return this;
		    };
		    /**
			 *  Pause the clock. Pausing does not reset the tick counter.
			 *  @param {Time} [time=now] The time when the clock should stop.
			 *  @returns {Tone.Clock} this
			 */
		    Tone.Clock.prototype.pause = function (time) {
		        time = this.toSeconds(time);
		        if (this._state.getValueAtTime(time) === Tone.State.Started) {
		            this._state.setStateAtTime(Tone.State.Paused, time);
		        }
		        return this;
		    };
		    /**
			 *  The scheduling loop.
			 *  @param  {Number}  time  The current page time starting from 0
			 *                          when the page was loaded.
			 *  @private
			 */
		    Tone.Clock.prototype._loop = function () {
		        //get the frequency value to compute the value of the next loop
		        var now = this.now();
		        //if it's started
		        var lookAhead = Tone.Clock.lookAhead;
		        var updateInterval = Tone.Clock.updateInterval;
		        var lagCompensation = Tone.Clock.lag * 2;
		        var loopInterval = now + lookAhead + updateInterval + lagCompensation;
		        while (loopInterval > this._nextTick && this._state) {
		            var currentState = this._state.getValueAtTime(this._nextTick);
		            if (currentState !== this._lastState) {
		                this._lastState = currentState;
		                var event = this._state.get(this._nextTick);
		                // emit an event
		                if (currentState === Tone.State.Started) {
		                    //correct the time
		                    this._nextTick = event.time;
		                    if (!this.isUndef(event.offset)) {
		                        this.ticks = event.offset;
		                    }
		                    this.emit('start', event.time, this.ticks);
		                } else if (currentState === Tone.State.Stopped) {
		                    this.ticks = 0;
		                    this.emit('stop', event.time);
		                } else if (currentState === Tone.State.Paused) {
		                    this.emit('pause', event.time);
		                }
		            }
		            var tickTime = this._nextTick;
		            if (this.frequency) {
		                this._nextTick += 1 / this.frequency.getValueAtTime(this._nextTick);
		                if (currentState === Tone.State.Started) {
		                    this.callback(tickTime);
		                    this.ticks++;
		                }
		            }
		        }
		    };
		    /**
			 *  Returns the scheduled state at the given time.
			 *  @param  {Time}  time  The time to query.
			 *  @return  {String}  The name of the state input in setStateAtTime.
			 *  @example
			 * clock.start("+0.1");
			 * clock.getStateAtTime("+0.1"); //returns "started"
			 */
		    Tone.Clock.prototype.getStateAtTime = function (time) {
		        time = this.toSeconds(time);
		        return this._state.getValueAtTime(time);
		    };
		    /**
			 *  Clean up
			 *  @returns {Tone.Clock} this
			 */
		    Tone.Clock.prototype.dispose = function () {
		        Tone.Emitter.prototype.dispose.call(this);
		        Tone.Clock._worker.removeEventListener('message', this._boundLoop);
		        this._writable('frequency');
		        this.frequency.dispose();
		        this.frequency = null;
		        this._boundLoop = null;
		        this._nextTick = Infinity;
		        this.callback = null;
		        this._state.dispose();
		        this._state = null;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // WORKER
		    ///////////////////////////////////////////////////////////////////////////
		    //URL Shim
		    window.URL = window.URL || window.webkitURL;
		    /**
			 *  The minimum amount of time events are 
			 *  scheduled in advance.
			 *  @private
			 *  @type  {Number}
			 */
		    Tone.Clock._lookAhead = 0.1;
		    /**
			 *  How often the worker ticks
			 *  @type  {Seconds}
			 *  @private
			 */
		    Tone.Clock._updateInterval = Tone.Clock._lookAhead / 3;
		    /**
			 *  The script which runs in a web worker
			 *  @type {Blob}
			 *  @private
			 */
		    var blob = new Blob([//the initial timeout time
		        'var timeoutTime = ' + Tone.Clock._updateInterval * 1000 + ';' + //onmessage callback
		        'self.onmessage = function(msg){' + '\ttimeoutTime = parseInt(msg.data);' + '};' + //the tick function which posts a message
		        //and schedules a new tick
		        'function tick(){' + '\tsetTimeout(tick, timeoutTime);' + '\tself.postMessage(\'tick\');' + '}' + //call tick initially
		        'tick();']);
		    /**
			 *  Create a blob url from the Blob
			 *  @type  {URL}
			 *  @private
			 */
		    var blobUrl = URL.createObjectURL(blob);
		    /**
			 *  The Worker which generates a regular callback
			 *  @type {Worker}
			 *  @private
			 *  @static
			 */
		    Tone.Clock._worker = new Worker(blobUrl);
		    /**
			 *  @private
			 *  @type  {Number}
			 *  The time of the last update
			 */
		    var lastUpdate = -1;
		    /**
			 *  The current computed update rate of the clock.
			 *  @type  {Number}
			 *  @private
			 */
		    var computedUpdateInterval = 0;
		    //listen for message events and update the global clock lookahead
		    Tone.Clock._worker.addEventListener('message', function () {
		        var now = Tone.now();
		        if (lastUpdate !== -1) {
		            var diff = now - lastUpdate;
		            computedUpdateInterval = Math.max(diff, computedUpdateInterval * 0.97);
		        }
		        lastUpdate = now;
		    });
		    /**
			 *  This is the time that the clock is falling behind
			 *  the scheduled update interval. The Clock automatically
			 *  adjusts for the lag and schedules further in advance.
			 *  @type {Number}
			 *  @memberOf Tone.Clock
			 *  @name lag
			 *  @static
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Clock, 'lag', {
		        get: function () {
		            var diff = computedUpdateInterval - Tone.Clock._updateInterval;
		            diff = Math.max(diff, 0);
		            return diff;
		        }
		    });
		    /**
			 *  The amount of time in advance that events are scheduled.
			 *  The lookAhead will adjust slightly in response to the 
			 *  measured update time to try to avoid clicks.
			 *  @type {Number}
			 *  @memberOf Tone.Clock
			 *  @name lookAhead
			 *  @static
			 */
		    Object.defineProperty(Tone.Clock, 'lookAhead', {
		        get: function () {
		            return Tone.Clock._lookAhead;
		        },
		        set: function (lA) {
		            Tone.Clock._lookAhead = lA;
		        }
		    });
		    /**
			 *  How often the Web Worker callback is invoked.
			 *  This number corresponds to how responsive the scheduling
			 *  can be. Clock.updateInterval + Clock.lookAhead gives you the
			 *  total latency between scheduling an event and hearing it.
			 *  @type {Number}
			 *  @memberOf Tone.Clock
			 *  @name updateInterval
			 *  @static
			 */
		    Object.defineProperty(Tone.Clock, 'updateInterval', {
		        get: function () {
		            return Tone.Clock._updateInterval;
		        },
		        set: function (interval) {
		            Tone.Clock._updateInterval = Math.max(interval, 0.01);
		            Tone.Clock._worker.postMessage(interval * 1000);
		        }
		    });
		    /**
			 *  The latency hint
			 *  @private
			 *  @type {String|Number}
			 */
		    var latencyHint = 'interactive';
		    /**
			 *  The type of playback, which affects tradeoffs between audio 
			 *  output latency and responsiveness. 
			 *  
			 *  In addition to setting the value in seconds, the latencyHint also
			 *  accepts the strings "interactive" (prioritizes low latency), 
			 *  "playback" (prioritizes sustained playback), "balanced" (balances
			 *  latency and performance), and "fastest" (lowest latency, might glitch more often). 
			 *  @type {String|Seconds}
			 *  @memberOf Tone.Clock#
			 *  @name latencyHint
			 *  @static
			 *  @example
			 * //set the lookAhead to 0.3 seconds
			 * Tone.Clock.latencyHint = 0.3;
			 */
		    Object.defineProperty(Tone.Clock, 'latencyHint', {
		        get: function () {
		            return latencyHint;
		        },
		        set: function (hint) {
		            var lookAhead = hint;
		            latencyHint = hint;
		            if (Tone.prototype.isString(hint)) {
		                switch (hint) {
		                case 'interactive':
		                    lookAhead = 0.1;
		                    Tone.context.latencyHint = hint;
		                    break;
		                case 'playback':
		                    lookAhead = 0.8;
		                    Tone.context.latencyHint = hint;
		                    break;
		                case 'balanced':
		                    lookAhead = 0.25;
		                    Tone.context.latencyHint = hint;
		                    break;
		                case 'fastest':
		                    lookAhead = 0.01;
		                    break;
		                }
		            }
		            Tone.Clock.lookAhead = lookAhead;
		            Tone.Clock.updateInterval = lookAhead / 3;
		        }
		    });
		    Tone._initAudioContext(function () {
		        lastUpdate = -1;
		        computedUpdateInterval = 0;
		    });
		    return Tone.Clock;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Similar to Tone.Timeline, but all events represent
			 *         intervals with both "time" and "duration" times. The 
			 *         events are placed in a tree structure optimized
			 *         for querying an intersection point with the timeline
			 *         events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)
			 *         to represent the data.
			 *  @extends {Tone}
			 */
		    Tone.IntervalTimeline = function () {
		        /**
				 *  The root node of the inteval tree
				 *  @type  {IntervalNode}
				 *  @private
				 */
		        this._root = null;
		        /**
				 *  Keep track of the length of the timeline.
				 *  @type  {Number}
				 *  @private
				 */
		        this._length = 0;
		    };
		    Tone.extend(Tone.IntervalTimeline);
		    /**
			 *  The event to add to the timeline. All events must 
			 *  have a time and duration value
			 *  @param  {Object}  event  The event to add to the timeline
			 *  @return  {Tone.IntervalTimeline}  this
			 */
		    Tone.IntervalTimeline.prototype.add = function (event) {
		        if (this.isUndef(event.time) || this.isUndef(event.duration)) {
		            throw new Error('Tone.IntervalTimeline: events must have time and duration parameters');
		        }
		        var node = new IntervalNode(event.time, event.time + event.duration, event);
		        if (this._root === null) {
		            this._root = node;
		        } else {
		            this._root.insert(node);
		        }
		        this._length++;
		        // Restructure tree to be balanced
		        while (node !== null) {
		            node.updateHeight();
		            node.updateMax();
		            this._rebalance(node);
		            node = node.parent;
		        }
		        return this;
		    };
		    /**
			 *  Remove an event from the timeline.
			 *  @param  {Object}  event  The event to remove from the timeline
			 *  @return  {Tone.IntervalTimeline}  this
			 */
		    Tone.IntervalTimeline.prototype.remove = function (event) {
		        if (this._root !== null) {
		            var results = [];
		            this._root.search(event.time, results);
		            for (var i = 0; i < results.length; i++) {
		                var node = results[i];
		                if (node.event === event) {
		                    this._removeNode(node);
		                    this._length--;
		                    break;
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  The number of items in the timeline.
			 *  @type {Number}
			 *  @memberOf Tone.IntervalTimeline#
			 *  @name length
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.IntervalTimeline.prototype, 'length', {
		        get: function () {
		            return this._length;
		        }
		    });
		    /**
			 *  Remove events whose time time is after the given time
			 *  @param  {Number}  time  The time to query.
			 *  @returns {Tone.IntervalTimeline} this
			 */
		    Tone.IntervalTimeline.prototype.cancel = function (after) {
		        this.forEachAfter(after, function (event) {
		            this.remove(event);
		        }.bind(this));
		        return this;
		    };
		    /**
			 *  Set the root node as the given node
			 *  @param {IntervalNode} node
			 *  @private
			 */
		    Tone.IntervalTimeline.prototype._setRoot = function (node) {
		        this._root = node;
		        if (this._root !== null) {
		            this._root.parent = null;
		        }
		    };
		    /**
			 *  Replace the references to the node in the node's parent
			 *  with the replacement node.
			 *  @param  {IntervalNode}  node        
			 *  @param  {IntervalNode}  replacement 
			 *  @private
			 */
		    Tone.IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {
		        if (node.parent !== null) {
		            if (node.isLeftChild()) {
		                node.parent.left = replacement;
		            } else {
		                node.parent.right = replacement;
		            }
		            this._rebalance(node.parent);
		        } else {
		            this._setRoot(replacement);
		        }
		    };
		    /**
			 *  Remove the node from the tree and replace it with 
			 *  a successor which follows the schema.
			 *  @param  {IntervalNode}  node
			 *  @private
			 */
		    Tone.IntervalTimeline.prototype._removeNode = function (node) {
		        if (node.left === null && node.right === null) {
		            this._replaceNodeInParent(node, null);
		        } else if (node.right === null) {
		            this._replaceNodeInParent(node, node.left);
		        } else if (node.left === null) {
		            this._replaceNodeInParent(node, node.right);
		        } else {
		            var balance = node.getBalance();
		            var replacement, temp;
		            if (balance > 0) {
		                if (node.left.right === null) {
		                    replacement = node.left;
		                    replacement.right = node.right;
		                    temp = replacement;
		                } else {
		                    replacement = node.left.right;
		                    while (replacement.right !== null) {
		                        replacement = replacement.right;
		                    }
		                    replacement.parent.right = replacement.left;
		                    temp = replacement.parent;
		                    replacement.left = node.left;
		                    replacement.right = node.right;
		                }
		            } else {
		                if (node.right.left === null) {
		                    replacement = node.right;
		                    replacement.left = node.left;
		                    temp = replacement;
		                } else {
		                    replacement = node.right.left;
		                    while (replacement.left !== null) {
		                        replacement = replacement.left;
		                    }
		                    replacement.parent = replacement.parent;
		                    replacement.parent.left = replacement.right;
		                    temp = replacement.parent;
		                    replacement.left = node.left;
		                    replacement.right = node.right;
		                }
		            }
		            if (node.parent !== null) {
		                if (node.isLeftChild()) {
		                    node.parent.left = replacement;
		                } else {
		                    node.parent.right = replacement;
		                }
		            } else {
		                this._setRoot(replacement);
		            }
		            // this._replaceNodeInParent(node, replacement);
		            this._rebalance(temp);
		        }
		        node.dispose();
		    };
		    /**
			 *  Rotate the tree to the left
			 *  @param  {IntervalNode}  node
			 *  @private
			 */
		    Tone.IntervalTimeline.prototype._rotateLeft = function (node) {
		        var parent = node.parent;
		        var isLeftChild = node.isLeftChild();
		        // Make node.right the new root of this sub tree (instead of node)
		        var pivotNode = node.right;
		        node.right = pivotNode.left;
		        pivotNode.left = node;
		        if (parent !== null) {
		            if (isLeftChild) {
		                parent.left = pivotNode;
		            } else {
		                parent.right = pivotNode;
		            }
		        } else {
		            this._setRoot(pivotNode);
		        }
		    };
		    /**
			 *  Rotate the tree to the right
			 *  @param  {IntervalNode}  node
			 *  @private
			 */
		    Tone.IntervalTimeline.prototype._rotateRight = function (node) {
		        var parent = node.parent;
		        var isLeftChild = node.isLeftChild();
		        // Make node.left the new root of this sub tree (instead of node)
		        var pivotNode = node.left;
		        node.left = pivotNode.right;
		        pivotNode.right = node;
		        if (parent !== null) {
		            if (isLeftChild) {
		                parent.left = pivotNode;
		            } else {
		                parent.right = pivotNode;
		            }
		        } else {
		            this._setRoot(pivotNode);
		        }
		    };
		    /**
			 *  Balance the BST
			 *  @param  {IntervalNode}  node
			 *  @private
			 */
		    Tone.IntervalTimeline.prototype._rebalance = function (node) {
		        var balance = node.getBalance();
		        if (balance > 1) {
		            if (node.left.getBalance() < 0) {
		                this._rotateLeft(node.left);
		            } else {
		                this._rotateRight(node);
		            }
		        } else if (balance < -1) {
		            if (node.right.getBalance() > 0) {
		                this._rotateRight(node.right);
		            } else {
		                this._rotateLeft(node);
		            }
		        }
		    };
		    /**
			 *  Get an event whose time and duration span the give time. Will
			 *  return the match whose "time" value is closest to the given time.
			 *  @param  {Object}  event  The event to add to the timeline
			 *  @return  {Object}  The event which spans the desired time
			 */
		    Tone.IntervalTimeline.prototype.get = function (time) {
		        if (this._root !== null) {
		            var results = [];
		            this._root.search(time, results);
		            if (results.length > 0) {
		                var max = results[0];
		                for (var i = 1; i < results.length; i++) {
		                    if (results[i].low > max.low) {
		                        max = results[i];
		                    }
		                }
		                return max.event;
		            }
		        }
		        return null;
		    };
		    /**
			 *  Iterate over everything in the timeline.
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.IntervalTimeline} this
			 */
		    Tone.IntervalTimeline.prototype.forEach = function (callback) {
		        if (this._root !== null) {
		            var allNodes = [];
		            if (this._root !== null) {
		                this._root.traverse(function (node) {
		                    allNodes.push(node);
		                });
		            }
		            for (var i = 0; i < allNodes.length; i++) {
		                var ev = allNodes[i].event;
		                if (ev) {
		                    callback(ev);
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Iterate over everything in the array in which the given time
			 *  overlaps with the time and duration time of the event.
			 *  @param  {Number}  time The time to check if items are overlapping
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.IntervalTimeline} this
			 */
		    Tone.IntervalTimeline.prototype.forEachAtTime = function (time, callback) {
		        if (this._root !== null) {
		            var results = [];
		            this._root.search(time, results);
		            for (var i = results.length - 1; i >= 0; i--) {
		                var ev = results[i].event;
		                if (ev) {
		                    callback(ev);
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Iterate over everything in the array in which the time is greater
			 *  than the given time.
			 *  @param  {Number}  time The time to check if items are before
			 *  @param  {Function}  callback The callback to invoke with every item
			 *  @returns {Tone.IntervalTimeline} this
			 */
		    Tone.IntervalTimeline.prototype.forEachAfter = function (time, callback) {
		        if (this._root !== null) {
		            var results = [];
		            this._root.searchAfter(time, results);
		            for (var i = results.length - 1; i >= 0; i--) {
		                var ev = results[i].event;
		                if (ev) {
		                    callback(ev);
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Clean up
			 *  @return  {Tone.IntervalTimeline}  this
			 */
		    Tone.IntervalTimeline.prototype.dispose = function () {
		        var allNodes = [];
		        if (this._root !== null) {
		            this._root.traverse(function (node) {
		                allNodes.push(node);
		            });
		        }
		        for (var i = 0; i < allNodes.length; i++) {
		            allNodes[i].dispose();
		        }
		        allNodes = null;
		        this._root = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	INTERVAL NODE HELPER
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Represents a node in the binary search tree, with the addition
			 *  of a "high" value which keeps track of the highest value of
			 *  its children. 
			 *  References: 
			 *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/
			 *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf
			 *  @param {Number} low
			 *  @param {Number} high
			 *  @private
			 */
		    var IntervalNode = function (low, high, event) {
		        //the event container
		        this.event = event;
		        //the low value
		        this.low = low;
		        //the high value
		        this.high = high;
		        //the high value for this and all child nodes
		        this.max = this.high;
		        //the nodes to the left
		        this._left = null;
		        //the nodes to the right
		        this._right = null;
		        //the parent node
		        this.parent = null;
		        //the number of child nodes
		        this.height = 0;
		    };
		    /** 
			 *  Insert a node into the correct spot in the tree
			 *  @param  {IntervalNode}  node
			 */
		    IntervalNode.prototype.insert = function (node) {
		        if (node.low <= this.low) {
		            if (this.left === null) {
		                this.left = node;
		            } else {
		                this.left.insert(node);
		            }
		        } else {
		            if (this.right === null) {
		                this.right = node;
		            } else {
		                this.right.insert(node);
		            }
		        }
		    };
		    /**
			 *  Search the tree for nodes which overlap 
			 *  with the given point
			 *  @param  {Number}  point  The point to query
			 *  @param  {Array}  results  The array to put the results
			 */
		    IntervalNode.prototype.search = function (point, results) {
		        // If p is to the right of the rightmost point of any interval
		        // in this node and all children, there won't be any matches.
		        if (point > this.max) {
		            return;
		        }
		        // Search left children
		        if (this.left !== null) {
		            this.left.search(point, results);
		        }
		        // Check this node
		        if (this.low <= point && this.high > point) {
		            results.push(this);
		        }
		        // If p is to the left of the time of this interval,
		        // then it can't be in any child to the right.
		        if (this.low > point) {
		            return;
		        }
		        // Search right children
		        if (this.right !== null) {
		            this.right.search(point, results);
		        }
		    };
		    /**
			 *  Search the tree for nodes which are less 
			 *  than the given point
			 *  @param  {Number}  point  The point to query
			 *  @param  {Array}  results  The array to put the results
			 */
		    IntervalNode.prototype.searchAfter = function (point, results) {
		        // Check this node
		        if (this.low >= point) {
		            results.push(this);
		            if (this.left !== null) {
		                this.left.searchAfter(point, results);
		            }
		        }
		        // search the right side
		        if (this.right !== null) {
		            this.right.searchAfter(point, results);
		        }
		    };
		    /**
			 *  Invoke the callback on this element and both it's branches
			 *  @param  {Function}  callback
			 */
		    IntervalNode.prototype.traverse = function (callback) {
		        callback(this);
		        if (this.left !== null) {
		            this.left.traverse(callback);
		        }
		        if (this.right !== null) {
		            this.right.traverse(callback);
		        }
		    };
		    /**
			 *  Update the height of the node
			 */
		    IntervalNode.prototype.updateHeight = function () {
		        if (this.left !== null && this.right !== null) {
		            this.height = Math.max(this.left.height, this.right.height) + 1;
		        } else if (this.right !== null) {
		            this.height = this.right.height + 1;
		        } else if (this.left !== null) {
		            this.height = this.left.height + 1;
		        } else {
		            this.height = 0;
		        }
		    };
		    /**
			 *  Update the height of the node
			 */
		    IntervalNode.prototype.updateMax = function () {
		        this.max = this.high;
		        if (this.left !== null) {
		            this.max = Math.max(this.max, this.left.max);
		        }
		        if (this.right !== null) {
		            this.max = Math.max(this.max, this.right.max);
		        }
		    };
		    /**
			 *  The balance is how the leafs are distributed on the node
			 *  @return  {Number}  Negative numbers are balanced to the right
			 */
		    IntervalNode.prototype.getBalance = function () {
		        var balance = 0;
		        if (this.left !== null && this.right !== null) {
		            balance = this.left.height - this.right.height;
		        } else if (this.left !== null) {
		            balance = this.left.height + 1;
		        } else if (this.right !== null) {
		            balance = -(this.right.height + 1);
		        }
		        return balance;
		    };
		    /**
			 *  @returns {Boolean} true if this node is the left child
			 *  of its parent
			 */
		    IntervalNode.prototype.isLeftChild = function () {
		        return this.parent !== null && this.parent.left === this;
		    };
		    /**
			 *  get/set the left node
			 *  @type {IntervalNode}
			 */
		    Object.defineProperty(IntervalNode.prototype, 'left', {
		        get: function () {
		            return this._left;
		        },
		        set: function (node) {
		            this._left = node;
		            if (node !== null) {
		                node.parent = this;
		            }
		            this.updateHeight();
		            this.updateMax();
		        }
		    });
		    /**
			 *  get/set the right node
			 *  @type {IntervalNode}
			 */
		    Object.defineProperty(IntervalNode.prototype, 'right', {
		        get: function () {
		            return this._right;
		        },
		        set: function (node) {
		            this._right = node;
		            if (node !== null) {
		                node.parent = this;
		            }
		            this.updateHeight();
		            this.updateMax();
		        }
		    });
		    /**
			 *  null out references.
			 */
		    IntervalNode.prototype.dispose = function () {
		        this.parent = null;
		        this._left = null;
		        this._right = null;
		        this.event = null;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	END INTERVAL NODE HELPER
		    ///////////////////////////////////////////////////////////////////////////
		    return Tone.IntervalTimeline;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Transport for timing musical events.
			 *          Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)
			 *          Tone.Transport timing events pass in the exact time of the scheduled event
			 *          in the argument of the callback function. Pass that time value to the object
			 *          you're scheduling. <br><br>
			 *          A single transport is created for you when the library is initialized. 
			 *          <br><br>
			 *          The transport emits the events: "start", "stop", "pause", and "loop" which are
			 *          called with the time of that event as the argument. 
			 *
			 *  @extends {Tone.Emitter}
			 *  @singleton
			 *  @example
			 * //repeated event every 8th note
			 * Tone.Transport.scheduleRepeat(function(time){
			 * 	//do something with the time
			 * }, "8n");
			 *  @example
			 * //schedule an event on the 16th measure
			 * Tone.Transport.schedule(function(time){
			 * 	//do something with the time
			 * }, "16:0:0");
			 */
		    Tone.Transport = function () {
		        Tone.Emitter.call(this);
		        ///////////////////////////////////////////////////////////////////////
		        //	LOOPING
		        //////////////////////////////////////////////////////////////////////
		        /** 
				 * 	If the transport loops or not.
				 *  @type {boolean}
				 */
		        this.loop = false;
		        /** 
				 * 	The loop start position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
		        this._loopStart = 0;
		        /** 
				 * 	The loop end position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
		        this._loopEnd = 0;
		        ///////////////////////////////////////////////////////////////////////
		        //	CLOCK/TEMPO
		        //////////////////////////////////////////////////////////////////////
		        /**
				 *  Pulses per quarter is the number of ticks per quarter note.
				 *  @private
				 *  @type  {Number}
				 */
		        this._ppq = TransportConstructor.defaults.PPQ;
		        /**
				 *  watches the main oscillator for timing ticks
				 *  initially starts at 120bpm
				 *  @private
				 *  @type {Tone.Clock}
				 */
		        this._clock = new Tone.Clock({
		            'callback': this._processTick.bind(this),
		            'frequency': 0
		        });
		        this._bindClockEvents();
		        /**
				 *  The Beats Per Minute of the Transport. 
				 *  @type {BPM}
				 *  @signal
				 *  @example
				 * Tone.Transport.bpm.value = 80;
				 * //ramp the bpm to 120 over 10 seconds
				 * Tone.Transport.bpm.rampTo(120, 10);
				 */
		        this.bpm = this._clock.frequency;
		        this.bpm._toUnits = this._toUnits.bind(this);
		        this.bpm._fromUnits = this._fromUnits.bind(this);
		        this.bpm.units = Tone.Type.BPM;
		        this.bpm.value = TransportConstructor.defaults.bpm;
		        this._readOnly('bpm');
		        /**
				 *  The time signature, or more accurately the numerator
				 *  of the time signature over a denominator of 4. 
				 *  @type {Number}
				 *  @private
				 */
		        this._timeSignature = TransportConstructor.defaults.timeSignature;
		        ///////////////////////////////////////////////////////////////////////
		        //	TIMELINE EVENTS
		        //////////////////////////////////////////////////////////////////////
		        /**
				 *  All the events in an object to keep track by ID
				 *  @type {Object}
				 *  @private
				 */
		        this._scheduledEvents = {};
		        /**
				 *  The event ID counter
				 *  @type {Number}
				 *  @private
				 */
		        this._eventID = 0;
		        /**
				 * 	The scheduled events.
				 *  @type {Tone.Timeline}
				 *  @private
				 */
		        this._timeline = new Tone.Timeline();
		        /**
				 *  Repeated events
				 *  @type {Array}
				 *  @private
				 */
		        this._repeatedEvents = new Tone.IntervalTimeline();
		        /**
				 *  Events that occur once
				 *  @type {Array}
				 *  @private
				 */
		        this._onceEvents = new Tone.Timeline();
		        /** 
				 *  All of the synced Signals
				 *  @private 
				 *  @type {Array}
				 */
		        this._syncedSignals = [];
		        ///////////////////////////////////////////////////////////////////////
		        //	SWING
		        //////////////////////////////////////////////////////////////////////
		        /**
				 *  The subdivision of the swing
				 *  @type  {Ticks}
				 *  @private
				 */
		        this._swingTicks = TransportConstructor.defaults.PPQ / 2;
		        //8n
		        /**
				 *  The swing amount
				 *  @type {NormalRange}
				 *  @private
				 */
		        this._swingAmount = 0;
		    };
		    Tone.extend(Tone.Transport, Tone.Emitter);
		    /**
			 *  the defaults
			 *  @type {Object}
			 *  @const
			 *  @static
			 */
		    Tone.Transport.defaults = {
		        'bpm': 120,
		        'swing': 0,
		        'swingSubdivision': '8n',
		        'timeSignature': 4,
		        'loopStart': 0,
		        'loopEnd': '4m',
		        'PPQ': 192
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TICKS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  called on every tick
			 *  @param   {number} tickTime clock relative tick time
			 *  @private
			 */
		    Tone.Transport.prototype._processTick = function (tickTime) {
		        var ticks = this._clock.ticks;
		        //handle swing
		        if (this._swingAmount > 0 && ticks % this._ppq !== 0 && //not on a downbeat
		            ticks % (this._swingTicks * 2) !== 0) {
		            //add some swing
		            var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
		            var amount = Math.sin(progress * Math.PI) * this._swingAmount;
		            tickTime += Tone.Time(this._swingTicks * 2 / 3, 'i').eval() * amount;
		        }
		        //do the loop test
		        if (this.loop) {
		            if (ticks === this._loopEnd) {
		                this.emit('loopEnd', tickTime);
		                this._clock.ticks = this._loopStart;
		                ticks = this._loopStart;
		                this.emit('loopStart', tickTime, this.seconds);
		                this.emit('loop', tickTime);
		            }
		        }
		        //process the single occurrence events
		        this._onceEvents.forEachBefore(ticks, function (event) {
		            event.callback(tickTime);
		            //remove the event
		            delete this._scheduledEvents[event.id.toString()];
		        }.bind(this));
		        //and clear the single occurrence timeline
		        this._onceEvents.cancelBefore(ticks);
		        //fire the next tick events if their time has come
		        this._timeline.forEachAtTime(ticks, function (event) {
		            event.callback(tickTime);
		        });
		        //process the repeated events
		        this._repeatedEvents.forEachAtTime(ticks, function (event) {
		            if ((ticks - event.time) % event.interval === 0) {
		                event.callback(tickTime);
		            }
		        });
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	SCHEDULABLE EVENTS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Schedule an event along the timeline.
			 *  @param {Function} callback The callback to be invoked at the time.
			 *  @param {TransportTime}  time The time to invoke the callback at.
			 *  @return {Number} The id of the event which can be used for canceling the event. 
			 *  @example
			 * //trigger the callback when the Transport reaches the desired time
			 * Tone.Transport.schedule(function(time){
			 * 	envelope.triggerAttack(time);
			 * }, "128i");
			 */
		    Tone.Transport.prototype.schedule = function (callback, time) {
		        var event = {
		            'time': this.toTicks(time),
		            'callback': callback
		        };
		        var id = this._eventID++;
		        this._scheduledEvents[id.toString()] = {
		            'event': event,
		            'timeline': this._timeline
		        };
		        this._timeline.add(event);
		        return id;
		    };
		    /**
			 *  Schedule a repeated event along the timeline. The event will fire
			 *  at the `interval` starting at the `startTime` and for the specified
			 *  `duration`. 
			 *  @param  {Function}  callback   The callback to invoke.
			 *  @param  {Time}    interval   The duration between successive
			 *                               callbacks.
			 *  @param  {TimelinePosition=}    startTime  When along the timeline the events should
			 *                               start being invoked.
			 *  @param {Time} [duration=Infinity] How long the event should repeat. 
			 *  @return  {Number}    The ID of the scheduled event. Use this to cancel
			 *                           the event. 
			 *  @example
			 * //a callback invoked every eighth note after the first measure
			 * Tone.Transport.scheduleRepeat(callback, "8n", "1m");
			 */
		    Tone.Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {
		        if (interval <= 0) {
		            throw new Error('Tone.Transport: repeat events must have an interval larger than 0');
		        }
		        var event = {
		            'time': this.toTicks(startTime),
		            'duration': this.toTicks(this.defaultArg(duration, Infinity)),
		            'interval': this.toTicks(interval),
		            'callback': callback
		        };
		        var id = this._eventID++;
		        this._scheduledEvents[id.toString()] = {
		            'event': event,
		            'timeline': this._repeatedEvents
		        };
		        this._repeatedEvents.add(event);
		        return id;
		    };
		    /**
			 *  Schedule an event that will be removed after it is invoked. 
			 *  Note that if the given time is less than the current transport time, 
			 *  the event will be invoked immediately. 
			 *  @param {Function} callback The callback to invoke once.
			 *  @param {TransportTime} time The time the callback should be invoked.
			 *  @returns {Number} The ID of the scheduled event. 
			 */
		    Tone.Transport.prototype.scheduleOnce = function (callback, time) {
		        var id = this._eventID++;
		        var event = {
		            'time': this.toTicks(time),
		            'callback': callback,
		            'id': id
		        };
		        this._scheduledEvents[id.toString()] = {
		            'event': event,
		            'timeline': this._onceEvents
		        };
		        this._onceEvents.add(event);
		        return id;
		    };
		    /**
			 *  Clear the passed in event id from the timeline
			 *  @param {Number} eventId The id of the event.
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.clear = function (eventId) {
		        if (this._scheduledEvents.hasOwnProperty(eventId)) {
		            var item = this._scheduledEvents[eventId.toString()];
		            item.timeline.remove(item.event);
		            delete this._scheduledEvents[eventId.toString()];
		        }
		        return this;
		    };
		    /**
			 *  Remove scheduled events from the timeline after
			 *  the given time. Repeated events will be removed
			 *  if their startTime is after the given time
			 *  @param {TransportTime} [after=0] Clear all events after
			 *                          this time. 
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.cancel = function (after) {
		        after = this.defaultArg(after, 0);
		        after = this.toTicks(after);
		        this._timeline.cancel(after);
		        this._onceEvents.cancel(after);
		        this._repeatedEvents.cancel(after);
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	START/STOP/PAUSE
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Bind start/stop/pause events from the clock and emit them.
			 */
		    Tone.Transport.prototype._bindClockEvents = function () {
		        this._clock.on('start', function (time, offset) {
		            offset = Tone.Time(this._clock.ticks, 'i').toSeconds();
		            this.emit('start', time, offset);
		        }.bind(this));
		        this._clock.on('stop', function (time) {
		            this.emit('stop', time);
		        }.bind(this));
		        this._clock.on('pause', function (time) {
		            this.emit('pause', time);
		        }.bind(this));
		    };
		    /**
			 *  Returns the playback state of the source, either "started", "stopped", or "paused"
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.Transport#
			 *  @name state
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'state', {
		        get: function () {
		            return this._clock.getStateAtTime(this.now());
		        }
		    });
		    /**
			 *  Start the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now] The time when the transport should start.
			 *  @param  {TransportTime=} offset The timeline offset to start the transport.
			 *  @returns {Tone.Transport} this
			 *  @example
			 * //start the transport in one second starting at beginning of the 5th measure. 
			 * Tone.Transport.start("+1", "4:0:0");
			 */
		    Tone.Transport.prototype.start = function (time, offset) {
		        //start the clock
		        if (!this.isUndef(offset)) {
		            offset = this.toTicks(offset);
		        }
		        this._clock.start(time, offset);
		        return this;
		    };
		    /**
			 *  Stop the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now] The time when the transport should stop. 
			 *  @returns {Tone.Transport} this
			 *  @example
			 * Tone.Transport.stop();
			 */
		    Tone.Transport.prototype.stop = function (time) {
		        this._clock.stop(time);
		        return this;
		    };
		    /**
			 *  Pause the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now]
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.pause = function (time) {
		        this._clock.pause(time);
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	SETTERS/GETTERS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  The time signature as just the numerator over 4. 
			 *  For example 4/4 would be just 4 and 6/8 would be 3.
			 *  @memberOf Tone.Transport#
			 *  @type {Number|Array}
			 *  @name timeSignature
			 *  @example
			 * //common time
			 * Tone.Transport.timeSignature = 4;
			 * // 7/8
			 * Tone.Transport.timeSignature = [7, 8];
			 * //this will be reduced to a single number
			 * Tone.Transport.timeSignature; //returns 3.5
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {
		        get: function () {
		            return this._timeSignature;
		        },
		        set: function (timeSig) {
		            if (this.isArray(timeSig)) {
		                timeSig = timeSig[0] / timeSig[1] * 4;
		            }
		            this._timeSignature = timeSig;
		        }
		    });
		    /**
			 * When the Tone.Transport.loop = true, this is the starting position of the loop.
			 * @memberOf Tone.Transport#
			 * @type {TransportTime}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {
		        get: function () {
		            return Tone.TransportTime(this._loopStart, 'i').toSeconds();
		        },
		        set: function (startPosition) {
		            this._loopStart = this.toTicks(startPosition);
		        }
		    });
		    /**
			 * When the Tone.Transport.loop = true, this is the ending position of the loop.
			 * @memberOf Tone.Transport#
			 * @type {TransportTime}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {
		        get: function () {
		            return Tone.TransportTime(this._loopEnd, 'i').toSeconds();
		        },
		        set: function (endPosition) {
		            this._loopEnd = this.toTicks(endPosition);
		        }
		    });
		    /**
			 *  Set the loop start and stop at the same time. 
			 *  @param {TransportTime} startPosition 
			 *  @param {TransportTime} endPosition   
			 *  @returns {Tone.Transport} this
			 *  @example
			 * //loop over the first measure
			 * Tone.Transport.setLoopPoints(0, "1m");
			 * Tone.Transport.loop = true;
			 */
		    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {
		        this.loopStart = startPosition;
		        this.loopEnd = endPosition;
		        return this;
		    };
		    /**
			 *  The swing value. Between 0-1 where 1 equal to 
			 *  the note + half the subdivision.
			 *  @memberOf Tone.Transport#
			 *  @type {NormalRange}
			 *  @name swing
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'swing', {
		        get: function () {
		            return this._swingAmount;
		        },
		        set: function (amount) {
		            //scale the values to a normal range
		            this._swingAmount = amount;
		        }
		    });
		    /**
			 *  Set the subdivision which the swing will be applied to. 
			 *  The default value is an 8th note. Value must be less 
			 *  than a quarter note.
			 *  
			 *  @memberOf Tone.Transport#
			 *  @type {Time}
			 *  @name swingSubdivision
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {
		        get: function () {
		            return Tone.Time(this._swingTicks, 'i').toNotation();
		        },
		        set: function (subdivision) {
		            this._swingTicks = this.toTicks(subdivision);
		        }
		    });
		    /**
			 *  The Transport's position in Bars:Beats:Sixteenths.
			 *  Setting the value will jump to that position right away. 
			 *  @memberOf Tone.Transport#
			 *  @type {BarsBeatsSixteenths}
			 *  @name position
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'position', {
		        get: function () {
		            return Tone.TransportTime(this.ticks, 'i').toBarsBeatsSixteenths();
		        },
		        set: function (progress) {
		            var ticks = this.toTicks(progress);
		            this.ticks = ticks;
		        }
		    });
		    /**
			 *  The Transport's position in seconds
			 *  Setting the value will jump to that position right away. 
			 *  @memberOf Tone.Transport#
			 *  @type {Seconds}
			 *  @name seconds
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'seconds', {
		        get: function () {
		            return Tone.TransportTime(this.ticks, 'i').toSeconds();
		        },
		        set: function (progress) {
		            var ticks = this.toTicks(progress);
		            this.ticks = ticks;
		        }
		    });
		    /**
			 *  The Transport's loop position as a normalized value. Always
			 *  returns 0 if the transport if loop is not true. 
			 *  @memberOf Tone.Transport#
			 *  @name progress
			 *  @type {NormalRange}
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'progress', {
		        get: function () {
		            if (this.loop) {
		                return (this.ticks - this._loopStart) / (this._loopEnd - this._loopStart);
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 *  The transports current tick position.
			 *  
			 *  @memberOf Tone.Transport#
			 *  @type {Ticks}
			 *  @name ticks
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'ticks', {
		        get: function () {
		            return this._clock.ticks;
		        },
		        set: function (t) {
		            var now = this.now();
		            //stop everything synced to the transport
		            if (this.state === Tone.State.Started) {
		                this.emit('stop', now);
		                this._clock.ticks = t;
		                //restart it with the new time
		                this.emit('start', now, this.seconds);
		            } else {
		                this._clock.ticks = t;
		            }
		        }
		    });
		    /**
			 *  Pulses Per Quarter note. This is the smallest resolution
			 *  the Transport timing supports. This should be set once
			 *  on initialization and not set again. Changing this value 
			 *  after other objects have been created can cause problems. 
			 *  
			 *  @memberOf Tone.Transport#
			 *  @type {Number}
			 *  @name PPQ
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'PPQ', {
		        get: function () {
		            return this._ppq;
		        },
		        set: function (ppq) {
		            var bpm = this.bpm.value;
		            this._ppq = ppq;
		            this.bpm.value = bpm;
		        }
		    });
		    /**
			 *  The hint to the type of playback. Affects tradeoffs between audio 
			 *  output latency and responsiveness. 
			 *  
			 *  In addition to setting the value in seconds, the latencyHint also
			 *  accepts the strings "interactive" (prioritizes low latency), 
			 *  "playback" (prioritizes sustained playback), "balanced" (balances
			 *  latency and performance), and "fastest" (lowest latency, might glitch more often). 
			 *  @memberOf Tone.Transport#
			 *  @type {Seconds|String}
			 *  @name latencyHint
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'latencyHint', {
		        get: function () {
		            return Tone.Clock.latencyHint;
		        },
		        set: function (hint) {
		            Tone.Clock.latencyHint = hint;
		        }
		    });
		    /**
			 *  Convert from BPM to frequency (factoring in PPQ)
			 *  @param  {BPM}  bpm The BPM value to convert to frequency
			 *  @return  {Frequency}  The BPM as a frequency with PPQ factored in.
			 *  @private
			 */
		    Tone.Transport.prototype._fromUnits = function (bpm) {
		        return 1 / (60 / bpm / this.PPQ);
		    };
		    /**
			 *  Convert from frequency (with PPQ) into BPM
			 *  @param  {Frequency}  freq The clocks frequency to convert to BPM
			 *  @return  {BPM}  The frequency value as BPM.
			 *  @private
			 */
		    Tone.Transport.prototype._toUnits = function (freq) {
		        return freq / this.PPQ * 60;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	SYNCING
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Returns the time aligned to the next subdivision
			 *  of the Transport. If the Transport is not started,
			 *  it will return 0.
			 *  Note: this will not work precisely during tempo ramps.
			 *  @param  {Time}  subdivision  The subdivision to quantize to
			 *  @return  {Number}  The context time of the next subdivision.
			 *  @example
			 * Tone.Transport.start(); //the transport must be started
			 * Tone.Transport.nextSubdivision("4n");
			 */
		    Tone.Transport.prototype.nextSubdivision = function (subdivision) {
		        subdivision = this.toSeconds(subdivision);
		        //if the transport's not started, return 0
		        var now;
		        if (this.state === Tone.State.Started) {
		            now = this._clock._nextTick;
		        } else {
		            return 0;
		        }
		        var transportPos = Tone.Time(this.ticks, 'i').eval();
		        var remainingTime = subdivision - transportPos % subdivision;
		        if (remainingTime === 0) {
		            remainingTime = subdivision;
		        }
		        return now + remainingTime;
		    };
		    /**
			 *  Attaches the signal to the tempo control signal so that 
			 *  any changes in the tempo will change the signal in the same
			 *  ratio. 
			 *  
			 *  @param  {Tone.Signal} signal 
			 *  @param {number=} ratio Optionally pass in the ratio between
			 *                         the two signals. Otherwise it will be computed
			 *                         based on their current values. 
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.syncSignal = function (signal, ratio) {
		        if (!ratio) {
		            //get the sync ratio
		            if (signal._param.value !== 0) {
		                ratio = signal._param.value / this.bpm._param.value;
		            } else {
		                ratio = 0;
		            }
		        }
		        var ratioSignal = new Tone.Gain(ratio);
		        this.bpm.chain(ratioSignal, signal._param);
		        this._syncedSignals.push({
		            'ratio': ratioSignal,
		            'signal': signal,
		            'initial': signal._param.value
		        });
		        signal._param.value = 0;
		        return this;
		    };
		    /**
			 *  Unsyncs a previously synced signal from the transport's control. 
			 *  See Tone.Transport.syncSignal.
			 *  @param  {Tone.Signal} signal 
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.unsyncSignal = function (signal) {
		        for (var i = this._syncedSignals.length - 1; i >= 0; i--) {
		            var syncedSignal = this._syncedSignals[i];
		            if (syncedSignal.signal === signal) {
		                syncedSignal.ratio.dispose();
		                syncedSignal.signal._param.value = syncedSignal.initial;
		                this._syncedSignals.splice(i, 1);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Transport} this
			 *  @private
			 */
		    Tone.Transport.prototype.dispose = function () {
		        Tone.Emitter.prototype.dispose.call(this);
		        this._clock.dispose();
		        this._clock = null;
		        this._writable('bpm');
		        this.bpm = null;
		        this._timeline.dispose();
		        this._timeline = null;
		        this._onceEvents.dispose();
		        this._onceEvents = null;
		        this._repeatedEvents.dispose();
		        this._repeatedEvents = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	INITIALIZATION
		    ///////////////////////////////////////////////////////////////////////////////
		    var TransportConstructor = Tone.Transport;
		    Tone._initAudioContext(function () {
		        if (typeof Tone.Transport === 'function') {
		            //a single transport object
		            Tone.Transport = new Tone.Transport();
		        } else {
		            //stop the clock
		            Tone.Transport.stop();
		            //get the previous values
		            var prevSettings = Tone.Transport.get();
		            //destory the old transport
		            Tone.Transport.dispose();
		            //make new Transport insides
		            TransportConstructor.call(Tone.Transport);
		            //set the previous config
		            Tone.Transport.set(prevSettings);
		        }
		    });
		    return Tone.Transport;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Volume is a simple volume node, useful for creating a volume fader. 
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Decibels} [volume=0] the initial volume
			 *  @example
			 * var vol = new Tone.Volume(-12);
			 * instrument.chain(vol, Tone.Master);
			 */
		    Tone.Volume = function () {
		        var options = this.optionsObject(arguments, ['volume'], Tone.Volume.defaults);
		        /**
				 * the output node
				 * @type {GainNode}
				 * @private
				 */
		        this.output = this.input = new Tone.Gain(options.volume, Tone.Type.Decibels);
		        /**
				 * The unmuted volume
				 * @type {Decibels}
				 * @private
				 */
		        this._unmutedVolume = 0;
		        /**
				 *  if the volume is muted
				 *  @type {Boolean}
				 *  @private
				 */
		        this._muted = false;
		        /**
				 *  The volume control in decibels. 
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.volume = this.output.gain;
		        this._readOnly('volume');
		        //set the mute initially
		        this.mute = options.mute;
		    };
		    Tone.extend(Tone.Volume);
		    /**
			 *  Defaults
			 *  @type  {Object}
			 *  @const
			 *  @static
			 */
		    Tone.Volume.defaults = {
		        'volume': 0,
		        'mute': false
		    };
		    /**
			 * Mute the output. 
			 * @memberOf Tone.Volume#
			 * @type {boolean}
			 * @name mute
			 * @example
			 * //mute the output
			 * volume.mute = true;
			 */
		    Object.defineProperty(Tone.Volume.prototype, 'mute', {
		        get: function () {
		            return this._muted;
		        },
		        set: function (mute) {
		            if (!this._muted && mute) {
		                this._unmutedVolume = this.volume.value;
		                //maybe it should ramp here?
		                this.volume.value = -Infinity;
		            } else if (this._muted && !mute) {
		                this.volume.value = this._unmutedVolume;
		            }
		            this._muted = mute;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.Volume} this
			 */
		    Tone.Volume.prototype.dispose = function () {
		        this.input.dispose();
		        Tone.prototype.dispose.call(this);
		        this._writable('volume');
		        this.volume.dispose();
		        this.volume = null;
		        return this;
		    };
		    return Tone.Volume;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A single master output which is connected to the
			 *          AudioDestinationNode (aka your speakers). 
			 *          It provides useful conveniences such as the ability 
			 *          to set the volume and mute the entire application. 
			 *          It also gives you the ability to apply master effects to your application. 
			 *          <br><br>
			 *          Like Tone.Transport, A single Tone.Master is created
			 *          on initialization and you do not need to explicitly construct one.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @singleton
			 *  @example
			 * //the audio will go from the oscillator to the speakers
			 * oscillator.connect(Tone.Master);
			 * //a convenience for connecting to the master output is also provided:
			 * oscillator.toMaster();
			 * //the above two examples are equivalent.
			 */
		    Tone.Master = function () {
		        this.createInsOuts(1, 1);
		        /**
				 *  The private volume node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
		        this._volume = this.output = new Tone.Volume();
		        /**
				 * The volume of the master output.
				 * @type {Decibels}
				 * @signal
				 */
		        this.volume = this._volume.volume;
		        this._readOnly('volume');
		        //connections
		        this.input.chain(this.output, this.context.destination);
		    };
		    Tone.extend(Tone.Master);
		    /**
			 *  @type {Object}
			 *  @const
			 */
		    Tone.Master.defaults = {
		        'volume': 0,
		        'mute': false
		    };
		    /**
			 * Mute the output. 
			 * @memberOf Tone.Master#
			 * @type {boolean}
			 * @name mute
			 * @example
			 * //mute the output
			 * Tone.Master.mute = true;
			 */
		    Object.defineProperty(Tone.Master.prototype, 'mute', {
		        get: function () {
		            return this._volume.mute;
		        },
		        set: function (mute) {
		            this._volume.mute = mute;
		        }
		    });
		    /**
			 *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously 
			 *  chained in the master effects chain. 
			 *  @param {AudioNode|Tone...} args All arguments will be connected in a row
			 *                                  and the Master will be routed through it.
			 *  @return  {Tone.Master}  this
			 *  @example
			 * //some overall compression to keep the levels in check
			 * var masterCompressor = new Tone.Compressor({
			 * 	"threshold" : -6,
			 * 	"ratio" : 3,
			 * 	"attack" : 0.5,
			 * 	"release" : 0.1
			 * });
			 * //give a little boost to the lows
			 * var lowBump = new Tone.Filter(200, "lowshelf");
			 * //route everything through the filter 
			 * //and compressor before going to the speakers
			 * Tone.Master.chain(lowBump, masterCompressor);
			 */
		    Tone.Master.prototype.chain = function () {
		        this.input.disconnect();
		        this.input.chain.apply(this.input, arguments);
		        arguments[arguments.length - 1].connect(this.output);
		    };
		    /**
			 *  Clean up
			 *  @return  {Tone.Master}  this
			 */
		    Tone.Master.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('volume');
		        this._volume.dispose();
		        this._volume = null;
		        this.volume = null;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	AUGMENT TONE's PROTOTYPE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)
			 *  @returns {Tone} this
			 *  @example
			 * //connect an oscillator to the master output
			 * var osc = new Tone.Oscillator().toMaster();
			 */
		    Tone.prototype.toMaster = function () {
		        this.connect(Tone.Master);
		        return this;
		    };
		    /**
			 *  Also augment AudioNode's prototype to include toMaster
			 *  as a convenience
			 *  @returns {AudioNode} this
			 */
		    AudioNode.prototype.toMaster = function () {
		        this.connect(Tone.Master);
		        return this;
		    };
		    var MasterConstructor = Tone.Master;
		    /**
			 *  initialize the module and listen for new audio contexts
			 */
		    Tone._initAudioContext(function () {
		        //a single master output
		        if (!Tone.prototype.isUndef(Tone.Master)) {
		            Tone.Master = new MasterConstructor();
		        } else {
		            MasterConstructor.prototype.dispose.call(Tone.Master);
		            MasterConstructor.call(Tone.Master);
		        }
		    });
		    return Tone.Master;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base class for sources. Sources have start/stop methods
			 *          and the ability to be synced to the 
			 *          start/stop of Tone.Transport. 
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @example
			 * //Multiple state change events can be chained together,
			 * //but must be set in the correct order and with ascending times
			 * 
			 * // OK
			 * state.start().stop("+0.2");
			 * // AND
			 * state.start().stop("+0.2").start("+0.4").stop("+0.7")
			 *
			 * // BAD
			 * state.stop("+0.2").start();
			 * // OR
			 * state.start("+0.3").stop("+0.2");
			 * 
			 */
		    Tone.Source = function (options) {
		        // this.createInsOuts(0, 1);
		        options = this.defaultArg(options, Tone.Source.defaults);
		        /**
				 *  The output volume node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
		        this._volume = this.output = new Tone.Volume(options.volume);
		        /**
				 * The volume of the output in decibels.
				 * @type {Decibels}
				 * @signal
				 * @example
				 * source.volume.value = -6;
				 */
		        this.volume = this._volume.volume;
		        this._readOnly('volume');
		        /**
				 * 	Keep track of the scheduled state.
				 *  @type {Tone.TimelineState}
				 *  @private
				 */
		        this._state = new Tone.TimelineState(Tone.State.Stopped);
		        this._state.memory = 10;
		        /**
				 *  The synced `start` callback function from the transport
				 *  @type {Function}
				 *  @private
				 */
		        this._synced = false;
		        /**
				 *  Keep track of all of the scheduled event ids
				 *  @type  {Array}
				 *  @private
				 */
		        this._scheduled = [];
		        //make the output explicitly stereo
		        this._volume.output.output.channelCount = 2;
		        this._volume.output.output.channelCountMode = 'explicit';
		        //mute initially
		        this.mute = options.mute;
		    };
		    Tone.extend(Tone.Source);
		    /**
			 *  The default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Source.defaults = {
		        'volume': 0,
		        'mute': false
		    };
		    /**
			 *  Returns the playback state of the source, either "started" or "stopped".
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.Source#
			 *  @name state
			 */
		    Object.defineProperty(Tone.Source.prototype, 'state', {
		        get: function () {
		            if (this._synced) {
		                if (Tone.Transport.state === Tone.State.Started) {
		                    return this._state.getValueAtTime(Tone.Transport.seconds);
		                } else {
		                    return Tone.State.Stopped;
		                }
		            } else {
		                return this._state.getValueAtTime(this.now());
		            }
		        }
		    });
		    /**
			 * Mute the output. 
			 * @memberOf Tone.Source#
			 * @type {boolean}
			 * @name mute
			 * @example
			 * //mute the output
			 * source.mute = true;
			 */
		    Object.defineProperty(Tone.Source.prototype, 'mute', {
		        get: function () {
		            return this._volume.mute;
		        },
		        set: function (mute) {
		            this._volume.mute = mute;
		        }
		    });
		    //overwrite these functions
		    Tone.Source.prototype._start = Tone.noOp;
		    Tone.Source.prototype._stop = Tone.noOp;
		    /**
			 *  Start the source at the specified time. If no time is given, 
			 *  start the source now.
			 *  @param  {Time} [time=now] When the source should be started.
			 *  @returns {Tone.Source} this
			 *  @example
			 * source.start("+0.5"); //starts the source 0.5 seconds from now
			 */
		    Tone.Source.prototype.start = function (time, offset, duration) {
		        if (this.isUndef(time) && this._synced) {
		            time = Tone.Transport.seconds;
		        } else {
		            time = this.toSeconds(time);
		        }
		        //if it's started, stop it and restart it
		        if (!this.retrigger && this._state.getValueAtTime(time) === Tone.State.Started) {
		            this.stop(time);
		        }
		        this._state.setStateAtTime(Tone.State.Started, time);
		        if (this._synced) {
		            // add the offset time to the event
		            var event = this._state.get(time);
		            event.offset = this.defaultArg(offset, 0);
		            event.duration = duration;
		            var sched = Tone.Transport.schedule(function (t) {
		                this._start(t, offset, duration);
		            }.bind(this), time);
		            this._scheduled.push(sched);
		        } else {
		            this._start.apply(this, arguments);
		        }
		        return this;
		    };
		    /**
			 *  Stop the source at the specified time. If no time is given, 
			 *  stop the source now.
			 *  @param  {Time} [time=now] When the source should be stopped. 
			 *  @returns {Tone.Source} this
			 *  @example
			 * source.stop(); // stops the source immediately
			 */
		    Tone.Source.prototype.stop = function (time) {
		        if (this.isUndef(time) && this._synced) {
		            time = Tone.Transport.seconds;
		        } else {
		            time = this.toSeconds(time);
		        }
		        this._state.cancel(time);
		        this._state.setStateAtTime(Tone.State.Stopped, time);
		        if (!this._synced) {
		            this._stop.apply(this, arguments);
		        } else {
		            var sched = Tone.Transport.schedule(this._stop.bind(this), time);
		            this._scheduled.push(sched);
		        }
		        return this;
		    };
		    /**
			 *  Sync the source to the Transport so that all subsequent
			 *  calls to `start` and `stop` are synced to the TransportTime
			 *  instead of the AudioContext time. 
			 *
			 *  @returns {Tone.Source} this
			 *  @example
			 * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline
			 * source.sync().start(0).stop(0.3);
			 * //start the transport.
			 * Tone.Transport.start();
			 *
			 *  @example
			 * //start the transport with an offset and the sync'ed sources
			 * //will start in the correct position
			 * source.sync().start(0.1);
			 * //the source will be invoked with an offset of 0.4
			 * Tone.Transport.start("+0.5", 0.5);
			 */
		    Tone.Source.prototype.sync = function () {
		        this._synced = true;
		        Tone.Transport.on('start loopStart', function (time, offset) {
		            if (offset > 0) {
		                // get the playback state at that time
		                var stateEvent = this._state.get(offset);
		                // listen for start events which may occur in the middle of the sync'ed time
		                if (stateEvent && stateEvent.state === Tone.State.Started && stateEvent.time !== offset) {
		                    // get the offset
		                    var startOffset = offset - this.toSeconds(stateEvent.time);
		                    var duration;
		                    if (stateEvent.duration) {
		                        duration = this.toSeconds(stateEvent.duration) - startOffset;
		                    }
		                    this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);
		                }
		            }
		        }.bind(this));
		        Tone.Transport.on('stop pause loopEnd', function (time) {
		            if (this._state.getValueAtTime(Tone.Transport.seconds) === Tone.State.Started) {
		                this._stop(time);
		            }
		        }.bind(this));
		        return this;
		    };
		    /**
			 *  Unsync the source to the Transport. See Tone.Source.sync
			 *  @returns {Tone.Source} this
			 */
		    Tone.Source.prototype.unsync = function () {
		        this._synced = false;
		        Tone.Transport.off('start stop pause loopEnd loopStart');
		        // clear all of the scheduled ids
		        for (var i = 0; i < this._scheduled.length; i++) {
		            var id = this._scheduled[i];
		            Tone.Transport.clear(id);
		        }
		        this._scheduled = [];
		        this._state.cancel(0);
		        return this;
		    };
		    /**
			 *	Clean up.
			 *  @return {Tone.Source} this
			 */
		    Tone.Source.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.unsync();
		        this._scheduled = null;
		        this._writable('volume');
		        this._volume.dispose();
		        this._volume = null;
		        this.volume = null;
		        this._state.dispose();
		        this._state = null;
		    };
		    return Tone.Source;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Oscillator supports a number of features including
			 *         phase rotation, multiple oscillator types (see Tone.Oscillator.type), 
			 *         and Transport syncing (see Tone.Oscillator.syncFrequency).
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {Frequency} [frequency] Starting frequency
			 *  @param {string} [type] The oscillator type. Read more about type below.
			 *  @example
			 * //make and start a 440hz sine tone
			 * var osc = new Tone.Oscillator(440, "sine").toMaster().start();
			 */
		    Tone.Oscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type'
		        ], Tone.Oscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  the main oscillator
				 *  @type {OscillatorNode}
				 *  @private
				 */
		        this._oscillator = null;
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control signal.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  the periodic wave
				 *  @type {PeriodicWave}
				 *  @private
				 */
		        this._wave = null;
		        /**
				 *  The partials of the oscillator
				 *  @type {Array}
				 *  @private
				 */
		        this._partials = this.defaultArg(options.partials, [1]);
		        /**
				 *  the phase of the oscillator
				 *  between 0 - 360
				 *  @type {number}
				 *  @private
				 */
		        this._phase = options.phase;
		        /**
				 *  the type of the oscillator
				 *  @type {string}
				 *  @private
				 */
		        this._type = null;
		        //setup
		        this.type = options.type;
		        this.phase = this._phase;
		        this._readOnly([
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.Oscillator, Tone.Source);
		    /**
			 *  the default parameters
			 *  @type {Object}
			 */
		    Tone.Oscillator.defaults = {
		        'type': 'sine',
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'partials': []
		    };
		    /**
			 *  The Oscillator types
			 *  @enum {String}
			 */
		    Tone.Oscillator.Type = {
		        Sine: 'sine',
		        Triangle: 'triangle',
		        Sawtooth: 'sawtooth',
		        Square: 'square',
		        Custom: 'custom'
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now] 
			 *  @private
			 */
		    Tone.Oscillator.prototype._start = function (time) {
		        //new oscillator with previous values
		        this._oscillator = this.context.createOscillator();
		        this._oscillator.setPeriodicWave(this._wave);
		        //connect the control signal to the oscillator frequency & detune
		        this._oscillator.connect(this.output);
		        this.frequency.connect(this._oscillator.frequency);
		        this.detune.connect(this._oscillator.detune);
		        //start the oscillator
		        this._oscillator.start(this.toSeconds(time));
		    };
		    /**
			 *  stop the oscillator
			 *  @private
			 *  @param  {Time} [time=now] (optional) timing parameter
			 *  @returns {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype._stop = function (time) {
		        if (this._oscillator) {
		            this._oscillator.stop(this.toSeconds(time));
		            this._oscillator = null;
		        }
		        return this;
		    };
		    /**
			 *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,
			 *  will also affect the oscillators frequency. 
			 *  @returns {Tone.Oscillator} this
			 *  @example
			 * Tone.Transport.bpm.value = 120;
			 * osc.frequency.value = 440;
			 * //the ration between the bpm and the frequency will be maintained
			 * osc.syncFrequency();
			 * Tone.Transport.bpm.value = 240; 
			 * // the frequency of the oscillator is doubled to 880
			 */
		    Tone.Oscillator.prototype.syncFrequency = function () {
		        Tone.Transport.syncSignal(this.frequency);
		        return this;
		    };
		    /**
			 *  Unsync the oscillator's frequency from the Transport. 
			 *  See Tone.Oscillator.syncFrequency
			 *  @returns {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype.unsyncFrequency = function () {
		        Tone.Transport.unsyncSignal(this.frequency);
		        return this;
		    };
		    /**
			 * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
			 * setting the first x number of partials of the oscillator. For example: "sine4" would
			 * set be the first 4 partials of the sine wave and "triangle8" would set the first
			 * 8 partials of the triangle wave.
			 * <br><br> 
			 * Uses PeriodicWave internally even for native types so that it can set the phase. 
			 * PeriodicWave equations are from the 
			 * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
			 *  
			 * @memberOf Tone.Oscillator#
			 * @type {string}
			 * @name type
			 * @example
			 * //set it to a square wave
			 * osc.type = "square";
			 * @example
			 * //set the first 6 partials of a sawtooth wave
			 * osc.type = "sawtooth6";
			 */
		    Object.defineProperty(Tone.Oscillator.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            var coefs = this._getRealImaginary(type, this._phase);
		            var periodicWave = this.context.createPeriodicWave(coefs[0], coefs[1]);
		            this._wave = periodicWave;
		            if (this._oscillator !== null) {
		                this._oscillator.setPeriodicWave(this._wave);
		            }
		            this._type = type;
		        }
		    });
		    /**
			 *  Returns the real and imaginary components based 
			 *  on the oscillator type.
			 *  @returns {Array} [real, imaginary]
			 *  @private
			 */
		    Tone.Oscillator.prototype._getRealImaginary = function (type, phase) {
		        var fftSize = 4096;
		        var periodicWaveSize = fftSize / 2;
		        var real = new Float32Array(periodicWaveSize);
		        var imag = new Float32Array(periodicWaveSize);
		        var partialCount = 1;
		        if (type === Tone.Oscillator.Type.Custom) {
		            partialCount = this._partials.length + 1;
		            periodicWaveSize = partialCount;
		        } else {
		            var partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
		            if (partial) {
		                partialCount = parseInt(partial[2]) + 1;
		                type = partial[1];
		                partialCount = Math.max(partialCount, 2);
		                periodicWaveSize = partialCount;
		            }
		        }
		        for (var n = 1; n < periodicWaveSize; ++n) {
		            var piFactor = 2 / (n * Math.PI);
		            var b;
		            switch (type) {
		            case Tone.Oscillator.Type.Sine:
		                b = n <= partialCount ? 1 : 0;
		                break;
		            case Tone.Oscillator.Type.Square:
		                b = n & 1 ? 2 * piFactor : 0;
		                break;
		            case Tone.Oscillator.Type.Sawtooth:
		                b = piFactor * (n & 1 ? 1 : -1);
		                break;
		            case Tone.Oscillator.Type.Triangle:
		                if (n & 1) {
		                    b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
		                } else {
		                    b = 0;
		                }
		                break;
		            case Tone.Oscillator.Type.Custom:
		                b = this._partials[n - 1];
		                break;
		            default:
		                throw new TypeError('Tone.Oscillator: invalid type: ' + type);
		            }
		            if (b !== 0) {
		                real[n] = -b * Math.sin(phase * n);
		                imag[n] = b * Math.cos(phase * n);
		            } else {
		                real[n] = 0;
		                imag[n] = 0;
		            }
		        }
		        return [
		            real,
		            imag
		        ];
		    };
		    /**
			 *  Compute the inverse FFT for a given phase.	
			 *  @param  {Float32Array}  real
			 *  @param  {Float32Array}  imag 
			 *  @param  {NormalRange}  phase 
			 *  @return  {AudioRange}
			 *  @private
			 */
		    Tone.Oscillator.prototype._inverseFFT = function (real, imag, phase) {
		        var sum = 0;
		        var len = real.length;
		        for (var i = 0; i < len; i++) {
		            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
		        }
		        return sum;
		    };
		    /**
			 *  Returns the initial value of the oscillator.
			 *  @return  {AudioRange}
			 *  @private
			 */
		    Tone.Oscillator.prototype._getInitialValue = function () {
		        var coefs = this._getRealImaginary(this._type, 0);
		        var real = coefs[0];
		        var imag = coefs[1];
		        var maxValue = 0;
		        var twoPi = Math.PI * 2;
		        //check for peaks in 8 places
		        for (var i = 0; i < 8; i++) {
		            maxValue = Math.max(this._inverseFFT(real, imag, i / 8 * twoPi), maxValue);
		        }
		        return -this._inverseFFT(real, imag, this._phase) / maxValue;
		    };
		    /**
			 * The partials of the waveform. A partial represents 
			 * the amplitude at a harmonic. The first harmonic is the 
			 * fundamental frequency, the second is the octave and so on
			 * following the harmonic series. 
			 * Setting this value will automatically set the type to "custom". 
			 * The value is an empty array when the type is not "custom". 
			 * @memberOf Tone.Oscillator#
			 * @type {Array}
			 * @name partials
			 * @example
			 * osc.partials = [1, 0.2, 0.01];
			 */
		    Object.defineProperty(Tone.Oscillator.prototype, 'partials', {
		        get: function () {
		            if (this._type !== Tone.Oscillator.Type.Custom) {
		                return [];
		            } else {
		                return this._partials;
		            }
		        },
		        set: function (partials) {
		            this._partials = partials;
		            this.type = Tone.Oscillator.Type.Custom;
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees. 
			 * @memberOf Tone.Oscillator#
			 * @type {Degrees}
			 * @name phase
			 * @example
			 * osc.phase = 180; //flips the phase of the oscillator
			 */
		    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {
		        get: function () {
		            return this._phase * (180 / Math.PI);
		        },
		        set: function (phase) {
		            this._phase = phase * Math.PI / 180;
		            //reset the type
		            this.type = this._type;
		        }
		    });
		    /**
			 *  Dispose and disconnect.
			 *  @return {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._oscillator !== null) {
		            this._oscillator.disconnect();
		            this._oscillator = null;
		        }
		        this._wave = null;
		        this._writable([
		            'frequency',
		            'detune'
		        ]);
		        this.frequency.dispose();
		        this.frequency = null;
		        this.detune.dispose();
		        this.detune = null;
		        this._partials = null;
		        return this;
		    };
		    return Tone.Oscillator;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.Zero outputs 0's at audio-rate. The reason this has to be
			 *         it's own class is that many browsers optimize out Tone.Signal
			 *         with a value of 0 and will not process nodes further down the graph. 
			 *  @extends {Tone}
			 */
		    Tone.Zero = function () {
		        /**
				 *  The gain node
				 *  @type  {Tone.Gain}
				 *  @private
				 */
		        this._gain = this.input = this.output = new Tone.Gain();
		        Tone.Zero._zeros.connect(this._gain);
		    };
		    Tone.extend(Tone.Zero);
		    /**
			 *  clean up
			 *  @return  {Tone.Zero}  this
			 */
		    Tone.Zero.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._gain.dispose();
		        this._gain = null;
		        return this;
		    };
		    /**
			 *  Generates a constant output of 0. This is so 
			 *  the processing graph doesn't optimize out this
			 *  segment of the graph. 
			 *  @static
			 *  @private
			 *  @const
			 *  @type {AudioBufferSourceNode}
			 */
		    Tone.Zero._zeros = null;
		    /**
			 *  initializer function
			 */
		    Tone._initAudioContext(function (audioContext) {
		        var buffer = audioContext.createBuffer(1, 128, audioContext.sampleRate);
		        var arr = buffer.getChannelData(0);
		        for (var i = 0; i < arr.length; i++) {
		            arr[i] = 0;
		        }
		        Tone.Zero._zeros = audioContext.createBufferSource();
		        Tone.Zero._zeros.channelCount = 1;
		        Tone.Zero._zeros.channelCountMode = 'explicit';
		        Tone.Zero._zeros.buffer = buffer;
		        Tone.Zero._zeros.loop = true;
		        Tone.Zero._zeros.start(0);
		        Tone.Zero._zeros.noGC();
		    });
		    return Tone.Zero;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal 
			 *          which can be attached to an AudioParam or Tone.Signal 
			 *          in order to modulate that parameter with an oscillator. The LFO can 
			 *          also be synced to the transport to start/stop and change when the tempo changes.
			 *
			 *  @constructor
			 *  @extends {Tone.Oscillator}
			 *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be
			 *                               in the frequency range of 0.1 to 10 hertz. 
			 *  @param {number=} min The minimum output value of the LFO. 
			 *  @param {number=} max The maximum value of the LFO. 
			 *  @example
			 * var lfo = new Tone.LFO("4n", 400, 4000);
			 * lfo.connect(filter.frequency);
			 */
		    Tone.LFO = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'min',
		            'max'
		        ], Tone.LFO.defaults);
		        /** 
				 *  The oscillator. 
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._oscillator = new Tone.Oscillator({
		            'frequency': options.frequency,
		            'type': options.type
		        });
		        /**
				 *  the lfo's frequency
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._oscillator.frequency;
		        /**
				 * The amplitude of the LFO, which controls the output range between
				 * the min and max output. For example if the min is -10 and the max 
				 * is 10, setting the amplitude to 0.5 would make the LFO modulate
				 * between -5 and 5. 
				 * @type {Number}
				 * @signal
				 */
		        this.amplitude = this._oscillator.volume;
		        this.amplitude.units = Tone.Type.NormalRange;
		        this.amplitude.value = options.amplitude;
		        /**
				 *  The signal which is output when the LFO is stopped
				 *  @type  {Tone.Signal}
				 *  @private
				 */
		        this._stoppedSignal = new Tone.Signal(0, Tone.Type.AudioRange);
		        /**
				 *  Just outputs zeros.
				 *  @type {Tone.Zero}
				 *  @private
				 */
		        this._zeros = new Tone.Zero();
		        /**
				 *  The value that the LFO outputs when it's stopped
				 *  @type {AudioRange}
				 *  @private
				 */
		        this._stoppedValue = 0;
		        /**
				 *  @type {Tone.AudioToGain} 
				 *  @private
				 */
		        this._a2g = new Tone.AudioToGain();
		        /**
				 *  @type {Tone.Scale} 
				 *  @private
				 */
		        this._scaler = this.output = new Tone.Scale(options.min, options.max);
		        /**
				 *  the units of the LFO (used for converting)
				 *  @type {Tone.Type} 
				 *  @private
				 */
		        this._units = Tone.Type.Default;
		        this.units = options.units;
		        //connect it up
		        this._oscillator.chain(this._a2g, this._scaler);
		        this._zeros.connect(this._a2g);
		        this._stoppedSignal.connect(this._a2g);
		        this._readOnly([
		            'amplitude',
		            'frequency'
		        ]);
		        this.phase = options.phase;
		    };
		    Tone.extend(Tone.LFO, Tone.Oscillator);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.LFO.defaults = {
		        'type': 'sine',
		        'min': 0,
		        'max': 1,
		        'phase': 0,
		        'frequency': '4n',
		        'amplitude': 1,
		        'units': Tone.Type.Default
		    };
		    /**
			 *  Start the LFO. 
			 *  @param  {Time} [time=now] the time the LFO will start
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.start = function (time) {
		        time = this.toSeconds(time);
		        this._stoppedSignal.setValueAtTime(0, time);
		        this._oscillator.start(time);
		        return this;
		    };
		    /**
			 *  Stop the LFO. 
			 *  @param  {Time} [time=now] the time the LFO will stop
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.stop = function (time) {
		        time = this.toSeconds(time);
		        this._stoppedSignal.setValueAtTime(this._stoppedValue, time);
		        this._oscillator.stop(time);
		        return this;
		    };
		    /**
			 *  Sync the start/stop/pause to the transport 
			 *  and the frequency to the bpm of the transport
			 *  @returns {Tone.LFO} this
			 *  @example
			 *  lfo.frequency.value = "8n";
			 *  lfo.sync().start(0)
			 *  //the rate of the LFO will always be an eighth note, 
			 *  //even as the tempo changes
			 */
		    Tone.LFO.prototype.sync = function () {
		        this._oscillator.sync();
		        this._oscillator.syncFrequency();
		        return this;
		    };
		    /**
			 *  unsync the LFO from transport control
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.unsync = function () {
		        this._oscillator.unsync();
		        this._oscillator.unsyncFrequency();
		        return this;
		    };
		    /**
			 * The miniumum output of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'min', {
		        get: function () {
		            return this._toUnits(this._scaler.min);
		        },
		        set: function (min) {
		            min = this._fromUnits(min);
		            this._scaler.min = min;
		        }
		    });
		    /**
			 * The maximum output of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'max', {
		        get: function () {
		            return this._toUnits(this._scaler.max);
		        },
		        set: function (max) {
		            max = this._fromUnits(max);
		            this._scaler.max = max;
		        }
		    });
		    /**
			 * The type of the oscillator: sine, square, sawtooth, triangle. 
			 * @memberOf Tone.LFO#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'type', {
		        get: function () {
		            return this._oscillator.type;
		        },
		        set: function (type) {
		            this._oscillator.type = type;
		            this._stoppedValue = this._oscillator._getInitialValue();
		            this._stoppedSignal.value = this._stoppedValue;
		        }
		    });
		    /**
			 * The phase of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'phase', {
		        get: function () {
		            return this._oscillator.phase;
		        },
		        set: function (phase) {
		            this._oscillator.phase = phase;
		            this._stoppedValue = this._oscillator._getInitialValue();
		            this._stoppedSignal.value = this._stoppedValue;
		        }
		    });
		    /**
			 * The output units of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {Tone.Type}
			 * @name units
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'units', {
		        get: function () {
		            return this._units;
		        },
		        set: function (val) {
		            var currentMin = this.min;
		            var currentMax = this.max;
		            //convert the min and the max
		            this._units = val;
		            this.min = currentMin;
		            this.max = currentMax;
		        }
		    });
		    /**
			 * Mute the output. 
			 * @memberOf Tone.LFO#
			 * @type {Boolean}
			 * @name mute
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'mute', {
		        get: function () {
		            return this._oscillator.mute;
		        },
		        set: function (mute) {
		            this._oscillator.mute = mute;
		        }
		    });
		    /**
			 *  Returns the playback state of the source, either "started" or "stopped".
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.LFO#
			 *  @name state
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'state', {
		        get: function () {
		            return this._oscillator.state;
		        }
		    });
		    /**
			 *  Connect the output of the LFO to an AudioParam, AudioNode, or Tone Node. 
			 *  Tone.LFO will automatically convert to the destination units of the 
			 *  will get the units from the connected node.
			 *  @param  {Tone | AudioParam | AudioNode} node 
			 *  @param {number} [outputNum=0] optionally which output to connect from
			 *  @param {number} [inputNum=0] optionally which input to connect to
			 *  @returns {Tone.LFO} this
			 *  @private
			 */
		    Tone.LFO.prototype.connect = function (node) {
		        if (node.constructor === Tone.Signal || node.constructor === Tone.Param || node.constructor === Tone.TimelineSignal) {
		            this.convert = node.convert;
		            this.units = node.units;
		        }
		        Tone.Signal.prototype.connect.apply(this, arguments);
		        return this;
		    };
		    /**
			 *  private method borrowed from Param converts 
			 *  units from their destination value
			 *  @function
			 *  @private
			 */
		    Tone.LFO.prototype._fromUnits = Tone.Param.prototype._fromUnits;
		    /**
			 *  private method borrowed from Param converts 
			 *  units to their destination value
			 *  @function
			 *  @private
			 */
		    Tone.LFO.prototype._toUnits = Tone.Param.prototype._toUnits;
		    /**
			 *  disconnect and dispose
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'amplitude',
		            'frequency'
		        ]);
		        this._oscillator.dispose();
		        this._oscillator = null;
		        this._stoppedSignal.dispose();
		        this._stoppedSignal = null;
		        this._zeros.dispose();
		        this._zeros = null;
		        this._scaler.dispose();
		        this._scaler = null;
		        this._a2g.dispose();
		        this._a2g = null;
		        this.frequency = null;
		        this.amplitude = null;
		        return this;
		    };
		    return Tone.LFO;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Limiter will limit the loudness of an incoming signal. 
			 *         It is composed of a Tone.Compressor with a fast attack 
			 *         and release. Limiters are commonly used to safeguard against 
			 *         signal clipping. Unlike a compressor, limiters do not provide 
			 *         smooth gain reduction and almost completely prevent 
			 *         additional gain above the threshold.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {number} threshold The theshold above which the limiting is applied. 
			 *  @example
			 *  var limiter = new Tone.Limiter(-6);
			 */
		    Tone.Limiter = function () {
		        var options = this.optionsObject(arguments, ['threshold'], Tone.Limiter.defaults);
		        /**
				 *  the compressor
				 *  @private
				 *  @type {Tone.Compressor}
				 */
		        this._compressor = this.input = this.output = new Tone.Compressor({
		            'attack': 0.001,
		            'decay': 0.001,
		            'threshold': options.threshold
		        });
		        /**
				 * The threshold of of the limiter
				 * @type {Decibel}
				 * @signal
				 */
		        this.threshold = this._compressor.threshold;
		        this._readOnly('threshold');
		    };
		    Tone.extend(Tone.Limiter);
		    /**
			 *  The default value
			 *  @type {Object}
			 *  @const
			 *  @static
			 */
		    Tone.Limiter.defaults = { 'threshold': -12 };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Limiter} this
			 */
		    Tone.Limiter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._compressor.dispose();
		        this._compressor = null;
		        this._writable('threshold');
		        this.threshold = null;
		        return this;
		    };
		    return Tone.Limiter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to 
			 *         Tone.FeedbackCombFilter, but includes a lowpass filter.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Time|Object} [delayTime] The delay time of the comb filter
			 *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter
			 *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the
			 *                                signal as it is fedback. 
			 */
		    Tone.LowpassCombFilter = function () {
		        this.createInsOuts(1, 1);
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'resonance',
		            'dampening'
		        ], Tone.LowpassCombFilter.defaults);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.input = new Tone.Delay(options.delayTime);
		        /**
				 *  The delayTime of the comb filter. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = this._delay.delayTime;
		        /**
				 *  the lowpass filter
				 *  @type  {BiquadFilterNode}
				 *  @private
				 */
		        this._lowpass = this.output = this.context.createBiquadFilter();
		        this._lowpass.Q.value = -3.0102999566398125;
		        this._lowpass.type = 'lowpass';
		        /**
				 *  The dampening control of the feedback
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = new Tone.Param({
		            'param': this._lowpass.frequency,
		            'units': Tone.Type.Frequency,
		            'value': options.dampening
		        });
		        /**
				 *  the feedback gain
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
		        /**
				 *  The amount of feedback of the delayed signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = this._feedback.gain;
		        //connections
		        this._delay.chain(this._lowpass, this._feedback, this._delay);
		        this._readOnly([
		            'dampening',
		            'resonance',
		            'delayTime'
		        ]);
		    };
		    Tone.extend(Tone.LowpassCombFilter);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.LowpassCombFilter.defaults = {
		        'delayTime': 0.1,
		        'resonance': 0.5,
		        'dampening': 3000
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.LowpassCombFilter} this
			 */
		    Tone.LowpassCombFilter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'dampening',
		            'resonance',
		            'delayTime'
		        ]);
		        this.dampening.dispose();
		        this.dampening = null;
		        this.resonance.dispose();
		        this.resonance = null;
		        this._delay.dispose();
		        this._delay = null;
		        this.delayTime = null;
		        this._lowpass.disconnect();
		        this._lowpass = null;
		        this._feedback.disconnect();
		        this._feedback = null;
		        return this;
		    };
		    return Tone.LowpassCombFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Merge brings two signals into the left and right 
			 *          channels of a single stereo channel.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @example
			 * var merge = new Tone.Merge().toMaster();
			 * //routing a sine tone in the left channel
			 * //and noise in the right channel
			 * var osc = new Tone.Oscillator().connect(merge.left);
			 * var noise = new Tone.Noise().connect(merge.right);
			 * //starting our oscillators
			 * noise.start();
			 * osc.start();
			 */
		    Tone.Merge = function () {
		        this.createInsOuts(2, 0);
		        /**
				 *  The left input channel.
				 *  Alias for <code>input[0]</code>
				 *  @type {GainNode}
				 */
		        this.left = this.input[0] = new Tone.Gain();
		        /**
				 *  The right input channel.
				 *  Alias for <code>input[1]</code>.
				 *  @type {GainNode}
				 */
		        this.right = this.input[1] = new Tone.Gain();
		        /**
				 *  the merger node for the two channels
				 *  @type {ChannelMergerNode}
				 *  @private
				 */
		        this._merger = this.output = this.context.createChannelMerger(2);
		        //connections
		        this.left.connect(this._merger, 0, 0);
		        this.right.connect(this._merger, 0, 1);
		        this.left.channelCount = 1;
		        this.right.channelCount = 1;
		        this.left.channelCountMode = 'explicit';
		        this.right.channelCountMode = 'explicit';
		    };
		    Tone.extend(Tone.Merge);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Merge} this
			 */
		    Tone.Merge.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.left.dispose();
		        this.left = null;
		        this.right.dispose();
		        this.right = null;
		        this._merger.disconnect();
		        this._merger = null;
		        return this;
		    };
		    return Tone.Merge;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
			 *          of an input signal with some averaging applied. It can also get the raw 
			 *          value of the input signal.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {String} type Either "level" or "signal". 
			 *  @param {Number} smoothing The amount of smoothing applied between frames.
			 *  @example
			 * var meter = new Tone.Meter();
			 * var mic = new Tone.UserMedia().start();
			 * //connect mic to the meter
			 * mic.connect(meter);
			 * //the current level of the mic input
			 * var level = meter.value;
			 */
		    Tone.Meter = function () {
		        var options = this.optionsObject(arguments, [
		            'type',
		            'smoothing'
		        ], Tone.Meter.defaults);
		        /**
				 *  The type of the meter, either "level" or "signal". 
				 *  A "level" meter will return the volume level (rms) of the 
				 *  input signal and a "signal" meter will return
				 *  the signal value of the input. 
				 *  @type  {String}
				 */
		        this.type = options.type;
		        /**
				 *  The analyser node which computes the levels.
				 *  @private
				 *  @type  {Tone.Analyser}
				 */
		        this.input = this.output = this._analyser = new Tone.Analyser('waveform', 512);
		        this._analyser.returnType = 'float';
		        /**
				 *  The amount of carryover between the current and last frame. 
				 *  Only applied meter for "level" type.
				 *  @type  {Number}
				 */
		        this.smoothing = options.smoothing;
		        /**
				 *  The last computed value
				 *  @type {Number}
				 *  @private
				 */
		        this._lastValue = 0;
		    };
		    Tone.extend(Tone.Meter);
		    /**
			 *  @private
			 *  @enum {String}
			 */
		    Tone.Meter.Type = {
		        Level: 'level',
		        Signal: 'signal'
		    };
		    /**
			 *  The defaults
			 *  @type {Object}
			 *  @static
			 *  @const
			 */
		    Tone.Meter.defaults = {
		        'smoothing': 0.8,
		        'type': Tone.Meter.Type.Level
		    };
		    /**
			 * The current value of the meter. A value of 1 is
			 * "unity".
			 * @memberOf Tone.Meter#
			 * @type {Number}
			 * @name value
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Meter.prototype, 'value', {
		        get: function () {
		            var signal = this._analyser.analyse();
		            if (this.type === Tone.Meter.Type.Level) {
		                //rms
		                var sum = 0;
		                for (var i = 0; i < signal.length; i++) {
		                    sum += Math.pow(signal[i], 2);
		                }
		                var rms = Math.sqrt(sum / signal.length);
		                //smooth it
		                rms = Math.max(rms, this._lastValue * this.smoothing);
		                this._lastValue = rms;
		                //scale it
		                var unity = 0.35;
		                var val = rms / unity;
		                //scale the output curve
		                return Math.sqrt(val);
		            } else {
		                return signal[0];
		            }
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Meter} this
			 */
		    Tone.Meter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._analyser.dispose();
		        this._analyser = null;
		        return this;
		    };
		    return Tone.Meter;
		});
		Module(function (Tone) {
		    
		    /**
			 *	@class  Tone.Split splits an incoming signal into left and right channels.
			 *	
			 *  @constructor
			 *  @extends {Tone}
			 *  @example
			 * var split = new Tone.Split();
			 * stereoSignal.connect(split);
			 */
		    Tone.Split = function () {
		        this.createInsOuts(0, 2);
		        /** 
				 *  @type {ChannelSplitterNode}
				 *  @private
				 */
		        this._splitter = this.input = this.context.createChannelSplitter(2);
		        /** 
				 *  Left channel output. 
				 *  Alias for <code>output[0]</code>
				 *  @type {Tone.Gain}
				 */
		        this.left = this.output[0] = new Tone.Gain();
		        /**
				 *  Right channel output.
				 *  Alias for <code>output[1]</code>
				 *  @type {Tone.Gain}
				 */
		        this.right = this.output[1] = new Tone.Gain();
		        //connections
		        this._splitter.connect(this.left, 0, 0);
		        this._splitter.connect(this.right, 1, 0);
		    };
		    Tone.extend(Tone.Split);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Split} this
			 */
		    Tone.Split.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._splitter.disconnect();
		        this.left.dispose();
		        this.left = null;
		        this.right.dispose();
		        this.right = null;
		        this._splitter = null;
		        return this;
		    };
		    return Tone.Split;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels). <br><br>
			 *         <code>
			 *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>
			 *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>
			 *         </code>
			 *
			 *  @extends {Tone}
			 *  @constructor
			 */
		    Tone.MidSideSplit = function () {
		        this.createInsOuts(0, 2);
		        /**
				 *  split the incoming signal into left and right channels
				 *  @type  {Tone.Split}
				 *  @private
				 */
		        this._split = this.input = new Tone.Split();
		        /**
				 *  The mid send. Connect to mid processing. Alias for
				 *  <code>output[0]</code>
				 *  @type {Tone.Expr}
				 */
		        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');
		        /**
				 *  The side output. Connect to side processing. Alias for
				 *  <code>output[1]</code>
				 *  @type {Tone.Expr}
				 */
		        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');
		        this._split.connect(this.mid, 0, 0);
		        this._split.connect(this.mid, 1, 1);
		        this._split.connect(this.side, 0, 0);
		        this._split.connect(this.side, 1, 1);
		        sqrtTwo.connect(this.mid, 0, 2);
		        sqrtTwo.connect(this.side, 0, 2);
		    };
		    Tone.extend(Tone.MidSideSplit);
		    /**
			 *  a constant signal equal to 1 / sqrt(2)
			 *  @type {Number}
			 *  @signal
			 *  @private
			 *  @static
			 */
		    var sqrtTwo = null;
		    Tone._initAudioContext(function () {
		        sqrtTwo = new Tone.Signal(1 / Math.sqrt(2));
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.MidSideSplit} this
			 */
		    Tone.MidSideSplit.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.mid.dispose();
		        this.mid = null;
		        this.side.dispose();
		        this.side = null;
		        this._split.dispose();
		        this._split = null;
		        return this;
		    };
		    return Tone.MidSideSplit;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels). 
			 *         MidSideMerge merges the mid and side signal after they've been seperated
			 *         by Tone.MidSideSplit.<br><br>
			 *         <code>
			 *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>
			 *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>
			 *         </code>
			 *
			 *  @extends {Tone.StereoEffect}
			 *  @constructor
			 */
		    Tone.MidSideMerge = function () {
		        this.createInsOuts(2, 0);
		        /**
				 *  The mid signal input. Alias for
				 *  <code>input[0]</code>
				 *  @type  {Tone.Gain}
				 */
		        this.mid = this.input[0] = new Tone.Gain();
		        /**
				 *  recombine the mid/side into Left
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._left = new Tone.Expr('($0 + $1) * $2');
		        /**
				 *  The side signal input. Alias for
				 *  <code>input[1]</code>
				 *  @type  {Tone.Gain}
				 */
		        this.side = this.input[1] = new Tone.Gain();
		        /**
				 *  recombine the mid/side into Right
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._right = new Tone.Expr('($0 - $1) * $2');
		        /**
				 *  Merge the left/right signal back into a stereo signal.
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = this.output = new Tone.Merge();
		        this.mid.connect(this._left, 0, 0);
		        this.side.connect(this._left, 0, 1);
		        this.mid.connect(this._right, 0, 0);
		        this.side.connect(this._right, 0, 1);
		        this._left.connect(this._merge, 0, 0);
		        this._right.connect(this._merge, 0, 1);
		        sqrtTwo.connect(this._left, 0, 2);
		        sqrtTwo.connect(this._right, 0, 2);
		    };
		    Tone.extend(Tone.MidSideMerge);
		    /**
			 *  A constant signal equal to 1 / sqrt(2).
			 *  @type {Number}
			 *  @signal
			 *  @private
			 *  @static
			 */
		    var sqrtTwo = null;
		    Tone._initAudioContext(function () {
		        sqrtTwo = new Tone.Signal(1 / Math.sqrt(2));
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.MidSideMerge} this
			 */
		    Tone.MidSideMerge.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.mid.dispose();
		        this.mid = null;
		        this.side.dispose();
		        this.side = null;
		        this._left.dispose();
		        this._left = null;
		        this._right.dispose();
		        this._right = null;
		        this._merge.dispose();
		        this._merge = null;
		        return this;
		    };
		    return Tone.MidSideMerge;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.MidSideCompressor applies two different compressors to the mid
			 *         and side signal components. See Tone.MidSideSplit. 
			 *
			 *  @extends {Tone}
			 *  @param {Object} options The options that are passed to the mid and side
			 *                          compressors. 
			 *  @constructor
			 */
		    Tone.MidSideCompressor = function (options) {
		        options = this.defaultArg(options, Tone.MidSideCompressor.defaults);
		        /**
				 *  the mid/side split
				 *  @type  {Tone.MidSideSplit}
				 *  @private
				 */
		        this._midSideSplit = this.input = new Tone.MidSideSplit();
		        /**
				 *  the mid/side recombination
				 *  @type  {Tone.MidSideMerge}
				 *  @private
				 */
		        this._midSideMerge = this.output = new Tone.MidSideMerge();
		        /**
				 *  The compressor applied to the mid signal
				 *  @type  {Tone.Compressor}
				 */
		        this.mid = new Tone.Compressor(options.mid);
		        /**
				 *  The compressor applied to the side signal
				 *  @type  {Tone.Compressor}
				 */
		        this.side = new Tone.Compressor(options.side);
		        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);
		        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);
		        this._readOnly([
		            'mid',
		            'side'
		        ]);
		    };
		    Tone.extend(Tone.MidSideCompressor);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MidSideCompressor.defaults = {
		        'mid': {
		            'ratio': 3,
		            'threshold': -24,
		            'release': 0.03,
		            'attack': 0.02,
		            'knee': 16
		        },
		        'side': {
		            'ratio': 6,
		            'threshold': -30,
		            'release': 0.25,
		            'attack': 0.03,
		            'knee': 10
		        }
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.MidSideCompressor} this
			 */
		    Tone.MidSideCompressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'mid',
		            'side'
		        ]);
		        this.mid.dispose();
		        this.mid = null;
		        this.side.dispose();
		        this.side = null;
		        this._midSideSplit.dispose();
		        this._midSideSplit = null;
		        this._midSideMerge.dispose();
		        this._midSideMerge = null;
		        return this;
		    };
		    return Tone.MidSideCompressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal
			 *         where both left and right channels have the same value. This can be useful 
			 *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 */
		    Tone.Mono = function () {
		        this.createInsOuts(1, 0);
		        /**
				 *  merge the signal
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = this.output = new Tone.Merge();
		        this.input.connect(this._merge, 0, 0);
		        this.input.connect(this._merge, 0, 1);
		        this.input.gain.value = this.dbToGain(-10);
		    };
		    Tone.extend(Tone.Mono);
		    /**
			 *  clean up
			 *  @returns {Tone.Mono} this
			 */
		    Tone.Mono.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._merge.dispose();
		        this._merge = null;
		        return this;
		    };
		    return Tone.Mono;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A compressor with seperate controls over low/mid/high dynamics
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Object} options The low/mid/high compressor settings.
			 *  @example
			 *  var multiband = new Tone.MultibandCompressor({
			 *  	"lowFrequency" : 200,
			 *  	"highFrequency" : 1300
			 *  	"low" : {
			 *  		"threshold" : -12
			 *  	}
			 *  })
			 */
		    Tone.MultibandCompressor = function (options) {
		        options = this.defaultArg(arguments, Tone.MultibandCompressor.defaults);
		        /**
				 *  split the incoming signal into high/mid/low
				 *  @type {Tone.MultibandSplit}
				 *  @private
				 */
		        this._splitter = this.input = new Tone.MultibandSplit({
		            'lowFrequency': options.lowFrequency,
		            'highFrequency': options.highFrequency
		        });
		        /**
				 *  low/mid crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = this._splitter.lowFrequency;
		        /**
				 *  mid/high crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = this._splitter.highFrequency;
		        /**
				 *  the output
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this.output = new Tone.Gain();
		        /**
				 *  The compressor applied to the low frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.low = new Tone.Compressor(options.low);
		        /**
				 *  The compressor applied to the mid frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.mid = new Tone.Compressor(options.mid);
		        /**
				 *  The compressor applied to the high frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.high = new Tone.Compressor(options.high);
		        //connect the compressor
		        this._splitter.low.chain(this.low, this.output);
		        this._splitter.mid.chain(this.mid, this.output);
		        this._splitter.high.chain(this.high, this.output);
		        this._readOnly([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		    };
		    Tone.extend(Tone.MultibandCompressor);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MultibandCompressor.defaults = {
		        'low': Tone.Compressor.defaults,
		        'mid': Tone.Compressor.defaults,
		        'high': Tone.Compressor.defaults,
		        'lowFrequency': 250,
		        'highFrequency': 2000
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.MultibandCompressor} this
			 */
		    Tone.MultibandCompressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._splitter.dispose();
		        this._writable([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		        this.low.dispose();
		        this.mid.dispose();
		        this.high.dispose();
		        this._splitter = null;
		        this.low = null;
		        this.mid = null;
		        this.high = null;
		        this.lowFrequency = null;
		        this.highFrequency = null;
		        return this;
		    };
		    return Tone.MultibandCompressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Panner is an equal power Left/Right Panner and does not
			 *          support 3D. Panner uses the StereoPannerNode when available. 
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {NormalRange} [initialPan=0] The initail panner value (defaults to 0 = center)
			 *  @example
			 *  //pan the input signal hard right. 
			 *  var panner = new Tone.Panner(1);
			 */
		    Tone.Panner = function (initialPan) {
		        if (this._hasStereoPanner) {
		            /**
					 *  the panner node
					 *  @type {StereoPannerNode}
					 *  @private
					 */
		            this._panner = this.input = this.output = this.context.createStereoPanner();
		            /**
					 *  The pan control. -1 = hard left, 1 = hard right. 
					 *  @type {NormalRange}
					 *  @signal
					 */
		            this.pan = this._panner.pan;
		        } else {
		            /**
					 *  the dry/wet knob
					 *  @type {Tone.CrossFade}
					 *  @private
					 */
		            this._crossFade = new Tone.CrossFade();
		            /**
					 *  @type {Tone.Merge}
					 *  @private
					 */
		            this._merger = this.output = new Tone.Merge();
		            /**
					 *  @type {Tone.Split}
					 *  @private
					 */
		            this._splitter = this.input = new Tone.Split();
		            /**
					 *  The pan control. -1 = hard left, 1 = hard right. 
					 *  @type {AudioRange}
					 *  @signal
					 */
		            this.pan = new Tone.Signal(0, Tone.Type.AudioRange);
		            /**
					 *  always sends 0
					 *  @type {Tone.Zero}
					 *  @private
					 */
		            this._zero = new Tone.Zero();
		            /**
					 *  The analog to gain conversion
					 *  @type  {Tone.AudioToGain}
					 *  @private
					 */
		            this._a2g = new Tone.AudioToGain();
		            //CONNECTIONS:
		            this._zero.connect(this._a2g);
		            this.pan.chain(this._a2g, this._crossFade.fade);
		            //left channel is a, right channel is b
		            this._splitter.connect(this._crossFade, 0, 0);
		            this._splitter.connect(this._crossFade, 1, 1);
		            //merge it back together
		            this._crossFade.a.connect(this._merger, 0, 0);
		            this._crossFade.b.connect(this._merger, 0, 1);
		        }
		        //initial value
		        this.pan.value = this.defaultArg(initialPan, 0);
		        this._readOnly('pan');
		    };
		    Tone.extend(Tone.Panner);
		    /**
			 *  indicates if the panner is using the new StereoPannerNode internally
			 *  @type  {boolean}
			 *  @private
			 */
		    Tone.Panner.prototype._hasStereoPanner = Tone.prototype.isFunction(Tone.context.createStereoPanner);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Panner} this
			 */
		    Tone.Panner.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('pan');
		        if (this._hasStereoPanner) {
		            this._panner.disconnect();
		            this._panner = null;
		            this.pan = null;
		        } else {
		            this._zero.dispose();
		            this._zero = null;
		            this._crossFade.dispose();
		            this._crossFade = null;
		            this._splitter.dispose();
		            this._splitter = null;
		            this._merger.dispose();
		            this._merger = null;
		            this.pan.dispose();
		            this.pan = null;
		            this._a2g.dispose();
		            this._a2g = null;
		        }
		        return this;
		    };
		    return Tone.Panner;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A spatialized panner node which supports equalpower or HRTF panning.
			 *          Tries to normalize the API across various browsers. See Tone.Listener
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Number} positionX The initial x position.
			 *  @param {Number} positionY The initial y position.
			 *  @param {Number} positionZ The initial z position.
			 */
		    Tone.Panner3D = function () {
		        var options = this.optionsObject(arguments, [
		            'positionX',
		            'positionY',
		            'positionZ'
		        ], Tone.Panner3D.defaults);
		        /**
				 *  The panner node
				 *  @type {PannerNode}
				 *  @private
				 */
		        this._panner = this.input = this.output = this.context.createPanner();
		        //set some values
		        this._panner.panningModel = options.panningModel;
		        this._panner.maxDistance = options.maxDistance;
		        this._panner.distanceModel = options.distanceModel;
		        this._panner.coneOuterGain = options.coneOuterGain;
		        this._panner.coneOuterAngle = options.coneOuterAngle;
		        this._panner.coneInnerAngle = options.coneInnerAngle;
		        this._panner.refDistance = options.refDistance;
		        this._panner.rolloffFactor = options.rolloffFactor;
		        /**
				 *  Holds the current orientation
				 *  @type  {Array}
				 *  @private
				 */
		        this._orientation = [
		            options.orientationX,
		            options.orientationY,
		            options.orientationZ
		        ];
		        /**
				 *  Holds the current position
				 *  @type  {Array}
				 *  @private
				 */
		        this._position = [
		            options.positionX,
		            options.positionY,
		            options.positionZ
		        ];
		        // set the default position/orientation
		        this.orientationX = options.orientationX;
		        this.orientationY = options.orientationY;
		        this.orientationZ = options.orientationZ;
		        this.positionX = options.positionX;
		        this.positionY = options.positionY;
		        this.positionZ = options.positionZ;
		    };
		    Tone.extend(Tone.Panner3D);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 *  Defaults according to the specification
			 */
		    Tone.Panner3D.defaults = {
		        'positionX': 0,
		        'positionY': 0,
		        'positionZ': 0,
		        'orientationX': 0,
		        'orientationY': 0,
		        'orientationZ': 0,
		        'panningModel': 'equalpower',
		        'maxDistance': 10000,
		        'distanceModel': 'inverse',
		        'coneOuterGain': 0,
		        'coneOuterAngle': 360,
		        'coneInnerAngle': 360,
		        'refDistance': 1,
		        'rolloffFactor': 1
		    };
		    /**
			 * The ramp time which is applied to the setTargetAtTime
			 * @type {Number}
			 * @private
			 */
		    Tone.Panner3D.prototype._rampTimeConstant = 0.01;
		    /**
			 *  Sets the position of the source in 3d space.	
			 *  @param  {Number}  x
			 *  @param  {Number}  y
			 *  @param  {Number}  z
			 *  @return {Tone.Panner3D} this
			 */
		    Tone.Panner3D.prototype.setPosition = function (x, y, z) {
		        if (this._panner.positionX) {
		            var now = this.now();
		            this._panner.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
		            this._panner.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
		            this._panner.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
		        } else {
		            this._panner.setPosition(x, y, z);
		        }
		        this._position = Array.prototype.slice.call(arguments);
		        return this;
		    };
		    /**
			 *  Sets the orientation of the source in 3d space.	
			 *  @param  {Number}  x
			 *  @param  {Number}  y
			 *  @param  {Number}  z
			 *  @return {Tone.Panner3D} this
			 */
		    Tone.Panner3D.prototype.setOrientation = function (x, y, z) {
		        if (this._panner.orientationX) {
		            var now = this.now();
		            this._panner.orientationX.setTargetAtTime(x, now, this._rampTimeConstant);
		            this._panner.orientationY.setTargetAtTime(y, now, this._rampTimeConstant);
		            this._panner.orientationZ.setTargetAtTime(z, now, this._rampTimeConstant);
		        } else {
		            this._panner.setOrientation(x, y, z);
		        }
		        this._orientation = Array.prototype.slice.call(arguments);
		        return this;
		    };
		    /**
			 *  The x position of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name positionX
			 */
		    Object.defineProperty(Tone.Panner3D.prototype, 'positionX', {
		        set: function (pos) {
		            this._position[0] = pos;
		            this.setPosition.apply(this, this._position);
		        },
		        get: function () {
		            return this._position[0];
		        }
		    });
		    /**
			 *  The y position of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name positionY
			 */
		    Object.defineProperty(Tone.Panner3D.prototype, 'positionY', {
		        set: function (pos) {
		            this._position[1] = pos;
		            this.setPosition.apply(this, this._position);
		        },
		        get: function () {
		            return this._position[1];
		        }
		    });
		    /**
			 *  The z position of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name positionZ
			 */
		    Object.defineProperty(Tone.Panner3D.prototype, 'positionZ', {
		        set: function (pos) {
		            this._position[2] = pos;
		            this.setPosition.apply(this, this._position);
		        },
		        get: function () {
		            return this._position[2];
		        }
		    });
		    /**
			 *  The x orientation of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name orientationX
			 */
		    Object.defineProperty(Tone.Panner3D.prototype, 'orientationX', {
		        set: function (pos) {
		            this._orientation[0] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[0];
		        }
		    });
		    /**
			 *  The y orientation of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name orientationY
			 */
		    Object.defineProperty(Tone.Panner3D.prototype, 'orientationY', {
		        set: function (pos) {
		            this._orientation[1] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[1];
		        }
		    });
		    /**
			 *  The z orientation of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name orientationZ
			 */
		    Object.defineProperty(Tone.Panner3D.prototype, 'orientationZ', {
		        set: function (pos) {
		            this._orientation[2] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[2];
		        }
		    });
		    /**
			 *  Proxy a property on the panner to an exposed public propery
			 *  @param  {String}  prop
			 *  @private
			 */
		    Tone.Panner3D._aliasProperty = function (prop) {
		        Object.defineProperty(Tone.Panner3D.prototype, prop, {
		            set: function (val) {
		                this._panner[prop] = val;
		            },
		            get: function () {
		                return this._panner[prop];
		            }
		        });
		    };
		    /**
			 *  The panning model. Either "equalpower" or "HRTF".
			 *  @type {String}
			 *  @memberOf Tone.Panner3D#
			 *  @name panningModel
			 */
		    Tone.Panner3D._aliasProperty('panningModel');
		    /**
			 *  A reference distance for reducing volume as source move further from the listener
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name refDistance
			 */
		    Tone.Panner3D._aliasProperty('refDistance');
		    /**
			 *  Describes how quickly the volume is reduced as source moves away from listener.
			 *  @type {Number}
			 *  @memberOf Tone.Panner3D#
			 *  @name rolloffFactor
			 */
		    Tone.Panner3D._aliasProperty('rolloffFactor');
		    /**
			 *  The distance model used by,  "linear", "inverse", or "exponential".
			 *  @type {String}
			 *  @memberOf Tone.Panner3D#
			 *  @name distanceModel
			 */
		    Tone.Panner3D._aliasProperty('distanceModel');
		    /**
			 *  The angle, in degrees, inside of which there will be no volume reduction
			 *  @type {Degrees}
			 *  @memberOf Tone.Panner3D#
			 *  @name coneInnerAngle
			 */
		    Tone.Panner3D._aliasProperty('coneInnerAngle');
		    /**
			 *  The angle, in degrees, outside of which the volume will be reduced 
			 *  to a constant value of coneOuterGain
			 *  @type {Degrees}
			 *  @memberOf Tone.Panner3D#
			 *  @name coneOuterAngle
			 */
		    Tone.Panner3D._aliasProperty('coneOuterAngle');
		    /**
			 *  The gain outside of the coneOuterAngle
			 *  @type {Gain}
			 *  @memberOf Tone.Panner3D#
			 *  @name coneOuterGain
			 */
		    Tone.Panner3D._aliasProperty('coneOuterGain');
		    /**
			 *  The maximum distance between source and listener, 
			 *  after which the volume will not be reduced any further.
			 *  @type {Positive}
			 *  @memberOf Tone.Panner3D#
			 *  @name maxDistance
			 */
		    Tone.Panner3D._aliasProperty('maxDistance');
		    /**
			 *  Clean up.
			 *  @returns {Tone.Panner3D} this
			 */
		    Tone.Panner3D.prototype.dispose = function () {
		        this._panner.disconnect();
		        this._panner = null;
		        this._orientation = null;
		        this._position = null;
		        return this;
		    };
		    return Tone.Panner3D;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {AudioRange} pan the initial pan
			 *  @param {number} volume The output volume. 
			 *  @example
			 * //pan the incoming signal left and drop the volume
			 * var panVol = new Tone.PanVol(0.25, -12);
			 */
		    Tone.PanVol = function () {
		        var options = this.optionsObject(arguments, [
		            'pan',
		            'volume'
		        ], Tone.PanVol.defaults);
		        /**
				 *  The panning node
				 *  @type {Tone.Panner}
				 *  @private
				 */
		        this._panner = this.input = new Tone.Panner(options.pan);
		        /**
				 *  The L/R panning control.
				 *  @type {AudioRange}
				 *  @signal
				 */
		        this.pan = this._panner.pan;
		        /**
				 *  The volume node
				 *  @type {Tone.Volume}
				 */
		        this._volume = this.output = new Tone.Volume(options.volume);
		        /**
				 *  The volume control in decibels. 
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.volume = this._volume.volume;
		        //connections
		        this._panner.connect(this._volume);
		        this._readOnly([
		            'pan',
		            'volume'
		        ]);
		    };
		    Tone.extend(Tone.PanVol);
		    /**
			 *  The defaults
			 *  @type  {Object}
			 *  @const
			 *  @static
			 */
		    Tone.PanVol.defaults = {
		        'pan': 0.5,
		        'volume': 0
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.PanVol} this
			 */
		    Tone.PanVol.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'pan',
		            'volume'
		        ]);
		        this._panner.dispose();
		        this._panner = null;
		        this.pan = null;
		        this._volume.dispose();
		        this._volume = null;
		        this.volume = null;
		        return this;
		    };
		    return Tone.PanVol;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.CtrlInterpolate will interpolate between given values based
			 *         on the "index" property. Passing in an array or object literal
			 *         will interpolate each of the parameters. Note (i.e. "C3")
			 *         and Time (i.e. "4n + 2") can be interpolated. All other values are
			 *         assumed to be numbers. 
			 *  @example
			 * var interp = new Tone.CtrlInterpolate([0, 2, 9, 4]);
			 * interp.index = 0.75;
			 * interp.value; //returns 1.5
			 *
			 *  @example
			 * var interp = new Tone.CtrlInterpolate([
			 * 	[2, 4, 5],
			 * 	[9, 3, 2],
			 * ]);
			 * @param {Array} values The array of values to interpolate over
			 * @param {Positive} index The initial interpolation index.
			 * @extends {Tone}
			 */
		    Tone.CtrlInterpolate = function () {
		        var options = this.optionsObject(arguments, [
		            'values',
		            'index'
		        ], Tone.CtrlInterpolate.defaults);
		        /**
				 *  The values to interpolate between
				 *  @type  {Array}
				 */
		        this.values = options.values;
		        /**
				 *  The interpolated index between values. For example: a value of 1.5
				 *  would interpolate equally between the value at index 1
				 *  and the value at index 2. 
				 *  @example
				 * interp.index = 0; 
				 * interp.value; //returns the value at 0
				 * interp.index = 0.5;
				 * interp.value; //returns the value between indices 0 and 1. 
				 *  @type  {Positive}
				 */
		        this.index = options.index;
		    };
		    Tone.extend(Tone.CtrlInterpolate);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.CtrlInterpolate.defaults = {
		        'index': 0,
		        'values': []
		    };
		    /**
			 *  The current interpolated value based on the index
			 *  @readOnly
			 *  @memberOf Tone.CtrlInterpolate#
			 *  @type {*}
			 *  @name value
			 */
		    Object.defineProperty(Tone.CtrlInterpolate.prototype, 'value', {
		        get: function () {
		            var index = this.index;
		            index = Math.min(index, this.values.length - 1);
		            var lowerPosition = Math.floor(index);
		            var lower = this.values[lowerPosition];
		            var upper = this.values[Math.ceil(index)];
		            return this._interpolate(index - lowerPosition, lower, upper);
		        }
		    });
		    /**
			 *  Internal interpolation routine
			 *  @param  {NormalRange}  index  The index between the lower and upper
			 *  @param  {*}  lower 
			 *  @param  {*}  upper 
			 *  @return  {*}  The interpolated value
			 *  @private
			 */
		    Tone.CtrlInterpolate.prototype._interpolate = function (index, lower, upper) {
		        if (this.isArray(lower)) {
		            var retArray = [];
		            for (var i = 0; i < lower.length; i++) {
		                retArray[i] = this._interpolate(index, lower[i], upper[i]);
		            }
		            return retArray;
		        } else if (this.isObject(lower)) {
		            var retObj = {};
		            for (var attr in lower) {
		                retObj[attr] = this._interpolate(index, lower[attr], upper[attr]);
		            }
		            return retObj;
		        } else {
		            lower = this._toNumber(lower);
		            upper = this._toNumber(upper);
		            return (1 - index) * lower + index * upper;
		        }
		    };
		    /**
			 *  Convert from the given type into a number
			 *  @param  {Number|String}  value
			 *  @return  {Number}
			 *  @private
			 */
		    Tone.CtrlInterpolate.prototype._toNumber = function (val) {
		        if (this.isNumber(val)) {
		            return val;
		        } else {
		            //otherwise assume that it's Time...
		            return this.toSeconds(val);
		        }
		    };
		    /**
			 *  Clean up
			 *  @return  {Tone.CtrlInterpolate}  this
			 */
		    Tone.CtrlInterpolate.prototype.dispose = function () {
		        this.values = null;
		    };
		    return Tone.CtrlInterpolate;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.CtrlMarkov represents a Markov Chain where each call
			 *         to Tone.CtrlMarkov.next will move to the next state. If the next
			 *         state choice is an array, the next state is chosen randomly with
			 *         even probability for all of the choices. For a weighted probability
			 *         of the next choices, pass in an object with "state" and "probability" attributes. 
			 *         The probabilities will be normalized and then chosen. If no next options
			 *         are given for the current state, the state will stay there. 
			 *  @extends {Tone}
			 *  @example
			 * var chain = new Tone.CtrlMarkov({
			 * 	"beginning" : ["end", "middle"],
			 * 	"middle" : "end"
			 * });
			 * chain.value = "beginning";
			 * chain.next(); //returns "end" or "middle" with 50% probability
			 *
			 *  @example
			 * var chain = new Tone.CtrlMarkov({
			 * 	"beginning" : [{"value" : "end", "probability" : 0.8}, 
			 * 					{"value" : "middle", "probability" : 0.2}],
			 * 	"middle" : "end"
			 * });
			 * chain.value = "beginning";
			 * chain.next(); //returns "end" with 80% probability or "middle" with 20%.
			 *  @param {Object} values An object with the state names as the keys
			 *                         and the next state(s) as the values. 
			 */
		    Tone.CtrlMarkov = function (values, initial) {
		        /**
				 *  The Markov values with states as the keys
				 *  and next state(s) as the values. 
				 *  @type {Object}
				 */
		        this.values = this.defaultArg(values, {});
		        /**
				 *  The current state of the Markov values. The next
				 *  state will be evaluated and returned when Tone.CtrlMarkov.next
				 *  is invoked.
				 *  @type {String}
				 */
		        this.value = this.defaultArg(initial, Object.keys(this.values)[0]);
		    };
		    Tone.extend(Tone.CtrlMarkov);
		    /**
			 *  Returns the next state of the Markov values. 
			 *  @return  {String}
			 */
		    Tone.CtrlMarkov.prototype.next = function () {
		        if (this.values.hasOwnProperty(this.value)) {
		            var next = this.values[this.value];
		            if (this.isArray(next)) {
		                var distribution = this._getProbDistribution(next);
		                var rand = Math.random();
		                var total = 0;
		                for (var i = 0; i < distribution.length; i++) {
		                    var dist = distribution[i];
		                    if (rand > total && rand < total + dist) {
		                        var chosen = next[i];
		                        if (this.isObject(chosen)) {
		                            this.value = chosen.value;
		                        } else {
		                            this.value = chosen;
		                        }
		                    }
		                    total += dist;
		                }
		            } else {
		                this.value = next;
		            }
		        }
		        return this.value;
		    };
		    /**
			 *  Choose randomly from an array weighted options in the form 
			 *  {"state" : string, "probability" : number} or an array of values
			 *  @param  {Array}  options 
			 *  @return  {Array}  The randomly selected choice
			 *  @private
			 */
		    Tone.CtrlMarkov.prototype._getProbDistribution = function (options) {
		        var distribution = [];
		        var total = 0;
		        var needsNormalizing = false;
		        for (var i = 0; i < options.length; i++) {
		            var option = options[i];
		            if (this.isObject(option)) {
		                needsNormalizing = true;
		                distribution[i] = option.probability;
		            } else {
		                distribution[i] = 1 / options.length;
		            }
		            total += distribution[i];
		        }
		        if (needsNormalizing) {
		            //normalize the values
		            for (var j = 0; j < distribution.length; j++) {
		                distribution[j] = distribution[j] / total;
		            }
		        }
		        return distribution;
		    };
		    /**
			 *  Clean up
			 *  @return  {Tone.CtrlMarkov}  this
			 */
		    Tone.CtrlMarkov.prototype.dispose = function () {
		        this.values = null;
		    };
		    return Tone.CtrlMarkov;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Generate patterns from an array of values.
			 *         Has a number of arpeggiation and randomized
			 *         selection patterns. 
			 *           <ul>
			 *  	        <li>"up" - cycles upward</li>
			 *  			<li>"down" - cycles downward</li>
			 *  			<li>"upDown" - up then and down</li>
			 *  			<li>"downUp" - cycles down then and up</li>
			 *  			<li>"alternateUp" - jump up two and down one</li>
			 *  			<li>"alternateDown" - jump down two and up one</li>
			 *  			<li>"random" - randomly select an index</li>
			 *  			<li>"randomWalk" - randomly moves one index away from the current position</li>
			 *  			<li>"randomOnce" - randomly select an index without repeating until all values have been chosen.</li>
			 *     		</ul>
			 *  @param  {Array}  values   An array of options to choose from.
			 *  @param  {Tone.CtrlPattern.Type=}  type  The name of the pattern.
			 *  @extends {Tone}
			 */
		    Tone.CtrlPattern = function () {
		        var options = this.optionsObject(arguments, [
		            'values',
		            'type'
		        ], Tone.CtrlPattern.defaults);
		        /**
				 *  The array of values to arpeggiate over
				 *  @type {Array}
				 */
		        this.values = options.values;
		        /**
				 *  The current position in the values array
				 *  @type  {Number}
				 */
		        this.index = 0;
		        /**
				 *  The type placeholder
				 *  @type {Tone.CtrlPattern.Type}
				 *  @private
				 */
		        this._type = null;
		        /**
				 *  Shuffled values for the RandomOnce type
				 *  @type {Array}
				 *  @private
				 */
		        this._shuffled = null;
		        /**
				 *  The direction of the movement
				 *  @type {String}
				 *  @private
				 */
		        this._direction = null;
		        this.type = options.type;
		    };
		    Tone.extend(Tone.CtrlPattern);
		    /**
			 *  The Control Patterns
			 *  @type  {Object}
			 *  @static
			 */
		    Tone.CtrlPattern.Type = {
		        Up: 'up',
		        Down: 'down',
		        UpDown: 'upDown',
		        DownUp: 'downUp',
		        AlternateUp: 'alternateUp',
		        AlternateDown: 'alternateDown',
		        Random: 'random',
		        RandomWalk: 'randomWalk',
		        RandomOnce: 'randomOnce'
		    };
		    /**
			 *  The default values. 
			 *  @type  {Object}
			 */
		    Tone.CtrlPattern.defaults = {
		        'type': Tone.CtrlPattern.Type.Up,
		        'values': []
		    };
		    /**
			 *  The value at the current index of the pattern.
			 *  @readOnly
			 *  @memberOf Tone.CtrlPattern#
			 *  @type {*}
			 *  @name value
			 */
		    Object.defineProperty(Tone.CtrlPattern.prototype, 'value', {
		        get: function () {
		            //some safeguards
		            if (this.values.length === 0) {
		                return;
		            } else if (this.values.length === 1) {
		                return this.values[0];
		            }
		            this.index = Math.min(this.index, this.values.length - 1);
		            var val = this.values[this.index];
		            if (this.type === Tone.CtrlPattern.Type.RandomOnce) {
		                if (this.values.length !== this._shuffled.length) {
		                    this._shuffleValues();
		                }
		                val = this.values[this._shuffled[this.index]];
		            }
		            return val;
		        }
		    });
		    /**
			 *  The pattern used to select the next
			 *  item from the values array
			 *  @memberOf Tone.CtrlPattern#
			 *  @type {Tone.CtrlPattern.Type}
			 *  @name type
			 */
		    Object.defineProperty(Tone.CtrlPattern.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            this._type = type;
		            this._shuffled = null;
		            //the first index
		            if (this._type === Tone.CtrlPattern.Type.Up || this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.RandomOnce || this._type === Tone.CtrlPattern.Type.AlternateUp) {
		                this.index = 0;
		            } else if (this._type === Tone.CtrlPattern.Type.Down || this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
		                this.index = this.values.length - 1;
		            }
		            //the direction
		            if (this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.AlternateUp) {
		                this._direction = Tone.CtrlPattern.Type.Up;
		            } else if (this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
		                this._direction = Tone.CtrlPattern.Type.Down;
		            }
		            //randoms
		            if (this._type === Tone.CtrlPattern.Type.RandomOnce) {
		                this._shuffleValues();
		            } else if (this._type === Tone.CtrlPattern.Random) {
		                this.index = Math.floor(Math.random() * this.values.length);
		            }
		        }
		    });
		    /**
			 *  Return the next value given the current position
			 *  and pattern.
			 *  @return {*} The next value
			 */
		    Tone.CtrlPattern.prototype.next = function () {
		        var type = this.type;
		        //choose the next index
		        if (type === Tone.CtrlPattern.Type.Up) {
		            this.index++;
		            if (this.index >= this.values.length) {
		                this.index = 0;
		            }
		        } else if (type === Tone.CtrlPattern.Type.Down) {
		            this.index--;
		            if (this.index < 0) {
		                this.index = this.values.length - 1;
		            }
		        } else if (type === Tone.CtrlPattern.Type.UpDown || type === Tone.CtrlPattern.Type.DownUp) {
		            if (this._direction === Tone.CtrlPattern.Type.Up) {
		                this.index++;
		            } else {
		                this.index--;
		            }
		            if (this.index < 0) {
		                this.index = 1;
		                this._direction = Tone.CtrlPattern.Type.Up;
		            } else if (this.index >= this.values.length) {
		                this.index = this.values.length - 2;
		                this._direction = Tone.CtrlPattern.Type.Down;
		            }
		        } else if (type === Tone.CtrlPattern.Type.Random) {
		            this.index = Math.floor(Math.random() * this.values.length);
		        } else if (type === Tone.CtrlPattern.Type.RandomWalk) {
		            if (Math.random() < 0.5) {
		                this.index--;
		                this.index = Math.max(this.index, 0);
		            } else {
		                this.index++;
		                this.index = Math.min(this.index, this.values.length - 1);
		            }
		        } else if (type === Tone.CtrlPattern.Type.RandomOnce) {
		            this.index++;
		            if (this.index >= this.values.length) {
		                this.index = 0;
		                //reshuffle the values for next time
		                this._shuffleValues();
		            }
		        } else if (type === Tone.CtrlPattern.Type.AlternateUp) {
		            if (this._direction === Tone.CtrlPattern.Type.Up) {
		                this.index += 2;
		                this._direction = Tone.CtrlPattern.Type.Down;
		            } else {
		                this.index -= 1;
		                this._direction = Tone.CtrlPattern.Type.Up;
		            }
		            if (this.index >= this.values.length) {
		                this.index = 0;
		                this._direction = Tone.CtrlPattern.Type.Up;
		            }
		        } else if (type === Tone.CtrlPattern.Type.AlternateDown) {
		            if (this._direction === Tone.CtrlPattern.Type.Up) {
		                this.index += 1;
		                this._direction = Tone.CtrlPattern.Type.Down;
		            } else {
		                this.index -= 2;
		                this._direction = Tone.CtrlPattern.Type.Up;
		            }
		            if (this.index < 0) {
		                this.index = this.values.length - 1;
		                this._direction = Tone.CtrlPattern.Type.Down;
		            }
		        }
		        return this.value;
		    };
		    /**
			 *  Shuffles the values and places the results into the _shuffled
			 *  @private
			 */
		    Tone.CtrlPattern.prototype._shuffleValues = function () {
		        var copy = [];
		        this._shuffled = [];
		        for (var i = 0; i < this.values.length; i++) {
		            copy[i] = i;
		        }
		        while (copy.length > 0) {
		            var randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);
		            this._shuffled.push(randVal[0]);
		        }
		    };
		    /**
			 *  Clean up
			 *  @returns {Tone.CtrlPattern} this
			 */
		    Tone.CtrlPattern.prototype.dispose = function () {
		        this._shuffled = null;
		        this.values = null;
		    };
		    return Tone.CtrlPattern;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Choose a random value.
			 *  @extends {Tone}
			 *  @example
			 * var randomWalk = new Tone.CtrlRandom({
			 * 	"min" : 0,
			 * 	"max" : 10,
			 * 	"integer" : true
			 * });
			 * randomWalk.eval();
			 *
			 *  @param {Number|Time=} min The minimum return value.
			 *  @param {Number|Time=} max The maximum return value.
			 */
		    Tone.CtrlRandom = function () {
		        var options = this.optionsObject(arguments, [
		            'min',
		            'max'
		        ], Tone.CtrlRandom.defaults);
		        /**
				 *  The minimum return value
				 *  @type  {Number|Time}
				 */
		        this.min = options.min;
		        /**
				 *  The maximum return value
				 *  @type  {Number|Time}
				 */
		        this.max = options.max;
		        /**
				 *  If the return value should be an integer
				 *  @type  {Boolean}
				 */
		        this.integer = options.integer;
		    };
		    Tone.extend(Tone.CtrlRandom);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.CtrlRandom.defaults = {
		        'min': 0,
		        'max': 1,
		        'integer': false
		    };
		    /**
			 *  Return a random value between min and max. 
			 *  @readOnly
			 *  @memberOf Tone.CtrlRandom#
			 *  @type {*}
			 *  @name value
			 */
		    Object.defineProperty(Tone.CtrlRandom.prototype, 'value', {
		        get: function () {
		            var min = this.toSeconds(this.min);
		            var max = this.toSeconds(this.max);
		            var rand = Math.random();
		            var val = rand * min + (1 - rand) * max;
		            if (this.integer) {
		                val = Math.floor(val);
		            }
		            return val;
		        }
		    });
		    return Tone.CtrlRandom;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Buffer loading and storage. Tone.Buffer is used internally by all 
			 *          classes that make requests for audio files such as Tone.Player,
			 *          Tone.Sampler and Tone.Convolver.
			 *          <br><br>
			 *          Aside from load callbacks from individual buffers, Tone.Buffer 
			 *  		provides static methods which keep track of the loading progress 
			 *  		of all of the buffers. These methods are Tone.Buffer.on("load" / "progress" / "error")
			 *
			 *  @constructor 
			 *  @extends {Tone}
			 *  @param {AudioBuffer|string} url The url to load, or the audio buffer to set. 
			 *  @param {Function=} onload A callback which is invoked after the buffer is loaded. 
			 *                            It's recommended to use Tone.Buffer.onload instead 
			 *                            since it will give you a callback when ALL buffers are loaded.
			 *  @param {Function=} onerror The callback to invoke if there is an error
			 *  @example
			 * var buffer = new Tone.Buffer("path/to/sound.mp3", function(){
			 * 	//the buffer is now available.
			 * 	var buff = buffer.get();
			 * });
			 */
		    Tone.Buffer = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload',
		            'onerror'
		        ], Tone.Buffer.defaults);
		        /**
				 *  stores the loaded AudioBuffer
				 *  @type {AudioBuffer}
				 *  @private
				 */
		        this._buffer = null;
		        /**
				 *  indicates if the buffer should be reversed or not
				 *  @type {Boolean}
				 *  @private
				 */
		        this._reversed = options.reverse;
		        /**
				 *  The XHR
				 *  @type  {XMLHttpRequest}
				 *  @private
				 */
		        this._xhr = null;
		        if (options.url instanceof AudioBuffer || options.url instanceof Tone.Buffer) {
		            this.set(options.url);
		            // invoke the onload callback
		            if (options.onload) {
		                options.onload(this);
		            }
		        } else if (this.isString(options.url)) {
		            this.load(options.url, options.onload, options.onerror);
		        }
		    };
		    Tone.extend(Tone.Buffer);
		    /**
			 *  the default parameters
			 *  @type {Object}
			 */
		    Tone.Buffer.defaults = {
		        'url': undefined,
		        'reverse': false
		    };
		    /**
			 *  Pass in an AudioBuffer or Tone.Buffer to set the value
			 *  of this buffer.
			 *  @param {AudioBuffer|Tone.Buffer} buffer the buffer
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.set = function (buffer) {
		        if (buffer instanceof Tone.Buffer) {
		            this._buffer = buffer.get();
		        } else {
		            this._buffer = buffer;
		        }
		        return this;
		    };
		    /**
			 *  @return {AudioBuffer} The audio buffer stored in the object.
			 */
		    Tone.Buffer.prototype.get = function () {
		        return this._buffer;
		    };
		    /**
			 *  Makes an xhr reqest for the selected url then decodes
			 *  the file as an audio buffer. Invokes
			 *  the callback once the audio buffer loads.
			 *  @param {String} url The url of the buffer to load.
			 *                      filetype support depends on the
			 *                      browser.
			 *  @returns {Promise} returns a Promise which resolves with the Tone.Buffer
			 */
		    Tone.Buffer.prototype.load = function (url, onload, onerror) {
		        var promise = new Promise(function (load, error) {
		            this._xhr = Tone.Buffer.load(url, //success
		            function (buff) {
		                this._xhr = null;
		                this.set(buff);
		                load(this);
		                if (onload) {
		                    onload(this);
		                }
		            }.bind(this), //error
		            function (err) {
		                this._xhr = null;
		                error(err);
		                if (onerror) {
		                    onerror(err);
		                }
		            }.bind(this));
		        }.bind(this));
		        return promise;
		    };
		    /**
			 *  dispose and disconnect
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.dispose = function () {
		        Tone.Emitter.prototype.dispose.call(this);
		        this._buffer = null;
		        if (this._xhr) {
		            Tone.Buffer._currentDownloads--;
		            this._xhr.abort();
		            this._xhr = null;
		        }
		        return this;
		    };
		    /**
			 * If the buffer is loaded or not
			 * @memberOf Tone.Buffer#
			 * @type {Boolean}
			 * @name loaded
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'loaded', {
		        get: function () {
		            return this.length > 0;
		        }
		    });
		    /**
			 * The duration of the buffer. 
			 * @memberOf Tone.Buffer#
			 * @type {Number}
			 * @name duration
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'duration', {
		        get: function () {
		            if (this._buffer) {
		                return this._buffer.duration;
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 * The length of the buffer in samples
			 * @memberOf Tone.Buffer#
			 * @type {Number}
			 * @name length
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'length', {
		        get: function () {
		            if (this._buffer) {
		                return this._buffer.length;
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 * The number of discrete audio channels. Returns 0 if no buffer
			 * is loaded.
			 * @memberOf Tone.Buffer#
			 * @type {Number}
			 * @name numberOfChannels
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'numberOfChannels', {
		        get: function () {
		            if (this._buffer) {
		                return this._buffer.numberOfChannels;
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 *  Set the audio buffer from the array
			 *  @param {Float32Array} array The array to fill the audio buffer
			 *  @param {Number} [channels=1] The number of channels contained in the array. 
			 *                               If the channel is more than 1, the input array
			 *                               is expected to be a multidimensional array
			 *                               with dimensions equal to the number of channels.
			 *  @return {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.fromArray = function (array) {
		        var isMultidimensional = array[0].length > 0;
		        var channels = isMultidimensional ? array.length : 1;
		        var len = isMultidimensional ? array[0].length : array.length;
		        var buffer = this.context.createBuffer(channels, len, this.context.sampleRate);
		        if (!isMultidimensional && channels === 1) {
		            array = [array];
		        }
		        for (var c = 0; c < channels; c++) {
		            if (this.isFunction(buffer.copyToChannel)) {
		                buffer.copyToChannel(array[c], c);
		            } else {
		                var channel = buffer.getChannelData(c);
		                var channelArray = array[c];
		                for (var i = 0; i < channelArray.length; i++) {
		                    channel[i] = channelArray[i];
		                }
		            }
		        }
		        this._buffer = buffer;
		        return this;
		    };
		    /**
			 * 	Get the buffer as an array. Single channel buffers will return a 1-dimensional 
			 * 	Float32Array, and multichannel buffers will return multidimensional arrays.
			 *  @param {Number=} channel Optionally only copy a single channel from the array.
			 *  @return {Array}
			 */
		    Tone.Buffer.prototype.toArray = function (channel) {
		        if (this.isNumber(channel)) {
		            return this._buffer.getChannelData(channel);
		        } else {
		            var ret = [];
		            for (var c = 0; c < this.numberOfChannels; c++) {
		                ret[c] = new Float32Array(this.length);
		                if (this.isFunction(this._buffer.copyFromChannel)) {
		                    this._buffer.copyFromChannel(ret[c], c);
		                } else {
		                    var channelData = this._buffer.getChannelData(c);
		                    var retArray = ret[c];
		                    for (var i = 0; i < channelData.length; i++) {
		                        retArray[i] = channelData[i];
		                    }
		                }
		            }
		            if (ret.length === 1) {
		                return ret[0];
		            } else {
		                return ret;
		            }
		        }
		    };
		    /**
			 *  Cut a subsection of the array and return a buffer of the
			 *  subsection. Does not modify the original buffer
			 *  @param {Time} start The time to start the slice
			 *  @param {Time=} end The end time to slice. If none is given
			 *                     will default to the end of the buffer
			 *  @return {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.slice = function (start, end) {
		        end = this.defaultArg(end, this.duration);
		        var startSamples = Math.floor(this.context.sampleRate * this.toSeconds(start));
		        var endSamples = Math.floor(this.context.sampleRate * this.toSeconds(end));
		        var replacement = [];
		        for (var i = 0; i < this.numberOfChannels; i++) {
		            replacement[i] = this.toArray(i).slice(startSamples, endSamples);
		        }
		        var retBuffer = new Tone.Buffer().fromArray(replacement);
		        return retBuffer;
		    };
		    /**
			 *  Reverse the buffer.
			 *  @private
			 *  @return {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype._reverse = function () {
		        if (this.loaded) {
		            for (var i = 0; i < this._buffer.numberOfChannels; i++) {
		                Array.prototype.reverse.call(this._buffer.getChannelData(i));
		            }
		        }
		        return this;
		    };
		    /**
			 * Reverse the buffer.
			 * @memberOf Tone.Buffer#
			 * @type {Boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {
		        get: function () {
		            return this._reversed;
		        },
		        set: function (rev) {
		            if (this._reversed !== rev) {
		                this._reversed = rev;
		                this._reverse();
		            }
		        }
		    });
		    ///////////////////////////////////////////////////////////////////////////
		    // STATIC METHODS
		    ///////////////////////////////////////////////////////////////////////////
		    //statically inherits Emitter methods
		    Tone.Emitter.mixin(Tone.Buffer);
		    /**
			 *  the static queue for all of the xhr requests
			 *  @type {Array}
			 *  @private
			 */
		    Tone.Buffer._downloadQueue = [];
		    /**
			 *  the total number of downloads
			 *  @type {Number}
			 *  @private
			 */
		    Tone.Buffer._currentDownloads = 0;
		    /**
			 *  A path which is prefixed before every url.
			 *  @type  {String}
			 *  @static
			 */
		    Tone.Buffer.baseUrl = '';
		    /**
			 *  Loads a url using XMLHttpRequest.
			 *  @param {String} url
			 *  @param {Function} onload
			 *  @param {Function} onerror
			 *  @param {Function} onprogress
			 *  @return {XMLHttpRequest}
			 */
		    Tone.Buffer.load = function (url, onload, onerror) {
		        //default
		        onload = onload || Tone.noOp;
		        function onError(e) {
		            if (onerror) {
		                onerror(e);
		            } else {
		                throw new Error(e);
		            }
		        }
		        function onProgress() {
		            //calculate the progress
		            var totalProgress = 0;
		            for (var i = 0; i < Tone.Buffer._downloadQueue.length; i++) {
		                totalProgress += Tone.Buffer._downloadQueue[i].progress;
		            }
		            Tone.Buffer.emit('progress', totalProgress / Tone.Buffer._downloadQueue.length);
		        }
		        var request = new XMLHttpRequest();
		        request.open('GET', Tone.Buffer.baseUrl + url, true);
		        request.responseType = 'arraybuffer';
		        //start out as 0
		        request.progress = 0;
		        Tone.Buffer._currentDownloads++;
		        Tone.Buffer._downloadQueue.push(request);
		        request.addEventListener('load', function () {
		            if (request.status === 200) {
		                Tone.context.decodeAudioData(request.response, function (buff) {
		                    request.progress = 1;
		                    onProgress();
		                    onload(buff);
		                    Tone.Buffer._currentDownloads--;
		                    if (Tone.Buffer._currentDownloads === 0) {
		                        // clear the downloads
		                        Tone.Buffer._downloadQueue = [];
		                        //emit the event at the end
		                        Tone.Buffer.emit('load');
		                    }
		                }, function () {
		                    onError('Tone.Buffer: could not decode audio data: ' + url);
		                });
		            } else {
		                onError('Tone.Buffer: could not locate file: ' + url);
		            }
		        });
		        request.addEventListener('error', onError);
		        request.addEventListener('progress', function (event) {
		            if (event.lengthComputable) {
		                //only go to 95%, the last 5% is when the audio is decoded
		                request.progress = event.loaded / event.total * 0.95;
		                onProgress();
		            }
		        });
		        request.send();
		        return request;
		    };
		    /**
			 *  Stop all of the downloads in progress
			 *  @return {Tone.Buffer}
			 */
		    Tone.Buffer.stopDownloads = function () {
		        Tone.Buffer._downloadQueue.forEach(function (request) {
		            request.abort();
		        });
		        Tone.Buffer._currentDownloads = 0;
		        return Tone.Buffer;
		    };
		    /**
			 *  Checks a url's extension to see if the current browser can play that file type.
			 *  @param {String} url The url/extension to test
			 *  @return {Boolean} If the file extension can be played
			 *  @static
			 *  @example
			 * Tone.Buffer.supportsType("wav"); //returns true
			 * Tone.Buffer.supportsType("path/to/file.wav"); //returns true
			 */
		    Tone.Buffer.supportsType = function (url) {
		        var extension = url.split('.');
		        extension = extension[extension.length - 1];
		        var response = document.createElement('audio').canPlayType('audio/' + extension);
		        return response !== '';
		    };
		    return Tone.Buffer;
		});
		Module(function (Tone) {
		    /**
			 *  @class A data structure for holding multiple buffers.
			 *  
			 *  @param  {Object|Array}    urls      An object literal or array
			 *                                      of urls to load.
			 *  @param  {Function=}  callback  The callback to invoke when
			 *                                 the buffers are loaded. 
			 *  @extends {Tone}
			 *  @example
			 * //load a whole bank of piano samples
			 * var pianoSamples = new Tone.Buffers({
			 * 	"C4" : "path/to/C4.mp3"
			 * 	"C#4" : "path/to/C#4.mp3"
			 * 	"D4" : "path/to/D4.mp3"
			 * 	"D#4" : "path/to/D#4.mp3"
			 * 	...
			 * }, function(){
			 * 	//play one of the samples when they all load
			 * 	player.buffer = pianoSamples.get("C4");
			 * 	player.start();
			 * });
			 * 
			 */
		    Tone.Buffers = function (urls, onload, baseUrl) {
		        /**
				 *  All of the buffers
				 *  @type  {Object}
				 *  @private
				 */
		        this._buffers = {};
		        /**
				 *  A path which is prefixed before every url.
				 *  @type  {String}
				 */
		        this.baseUrl = this.defaultArg(baseUrl, '');
		        urls = this._flattenUrls(urls);
		        this._loadingCount = 0;
		        //add each one
		        for (var key in urls) {
		            this._loadingCount++;
		            this.add(key, urls[key], this._bufferLoaded.bind(this, onload));
		        }
		    };
		    Tone.extend(Tone.Buffers);
		    /**
			 *  True if the buffers object has a buffer by that name.
			 *  @param  {String|Number}  name  The key or index of the 
			 *                                 buffer.
			 *  @return  {Boolean}
			 */
		    Tone.Buffers.prototype.has = function (name) {
		        return this._buffers.hasOwnProperty(name);
		    };
		    /**
			 *  Get a buffer by name. If an array was loaded, 
			 *  then use the array index.
			 *  @param  {String|Number}  name  The key or index of the 
			 *                                 buffer.
			 *  @return  {Tone.Buffer}
			 */
		    Tone.Buffers.prototype.get = function (name) {
		        if (this.has(name)) {
		            return this._buffers[name];
		        } else {
		            throw new Error('Tone.Buffers: no buffer named ' + name);
		        }
		    };
		    /**
			 *  A buffer was loaded. decrement the counter.
			 *  @param  {Function}  callback 
			 *  @private
			 */
		    Tone.Buffers.prototype._bufferLoaded = function (callback) {
		        this._loadingCount--;
		        if (this._loadingCount === 0 && callback) {
		            callback(this);
		        }
		    };
		    /**
			 * If the buffers are loaded or not
			 * @memberOf Tone.Buffers#
			 * @type {Boolean}
			 * @name loaded
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Buffers.prototype, 'loaded', {
		        get: function () {
		            var isLoaded = true;
		            for (var buffName in this._buffers) {
		                var buff = this.get(buffName);
		                isLoaded = isLoaded && buff.loaded;
		            }
		            return isLoaded;
		        }
		    });
		    /**
			 *  Add a buffer by name and url to the Buffers
			 *  @param  {String}    name      A unique name to give
			 *                                the buffer
			 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer, 
			 *                                                 or a buffer which will be added
			 *                                                 with the given name.
			 *  @param  {Function=}  callback  The callback to invoke 
			 *                                 when the url is loaded.
			 */
		    Tone.Buffers.prototype.add = function (name, url, callback) {
		        callback = this.defaultArg(callback, Tone.noOp);
		        if (url instanceof Tone.Buffer) {
		            this._buffers[name] = url;
		            callback(this);
		        } else if (url instanceof AudioBuffer) {
		            this._buffers[name] = new Tone.Buffer(url);
		            callback(this);
		        } else if (this.isString(url)) {
		            this._buffers[name] = new Tone.Buffer(this.baseUrl + url, callback);
		        }
		        return this;
		    };
		    /**
			 *  Flatten an object into a single depth object. 
			 *  thanks to https://gist.github.com/penguinboy/762197
			 *  @param   {Object} ob 	
			 *  @return  {Object}    
			 *  @private
			 */
		    Tone.Buffers.prototype._flattenUrls = function (ob) {
		        var toReturn = {};
		        for (var i in ob) {
		            if (!ob.hasOwnProperty(i))
		                continue;
		            if (this.isObject(ob[i])) {
		                var flatObject = this._flattenUrls(ob[i]);
		                for (var x in flatObject) {
		                    if (!flatObject.hasOwnProperty(x))
		                        continue;
		                    toReturn[i + '.' + x] = flatObject[x];
		                }
		            } else {
		                toReturn[i] = ob[i];
		            }
		        }
		        return toReturn;
		    };
		    /**
			 *  Clean up.
			 *  @return  {Tone.Buffers} this
			 */
		    Tone.Buffers.prototype.dispose = function () {
		        for (var name in this._buffers) {
		            this._buffers[name].dispose();
		        }
		        this._buffers = null;
		        return this;
		    };
		    return Tone.Buffers;
		});
		Module(function (Tone) {
		    
		    /**
			 *  buses are another way of routing audio
			 *
			 *  augments Tone.prototype to include send and recieve
			 */
		    /**
			  *  All of the routes
			  *  
			  *  @type {Object}
			  *  @static
			  *  @private
			  */
		    var Buses = {};
		    /**
			 *  Send this signal to the channel name. 
			 *  @param  {string} channelName A named channel to send the signal to.
			 *  @param  {Decibels} amount The amount of the source to send to the bus. 
			 *  @return {GainNode} The gain node which connects this node to the desired channel. 
			 *                     Can be used to adjust the levels of the send.
			 *  @example
			 * source.send("reverb", -12);
			 */
		    Tone.prototype.send = function (channelName, amount) {
		        if (!Buses.hasOwnProperty(channelName)) {
		            Buses[channelName] = this.context.createGain();
		        }
		        amount = this.defaultArg(amount, 0);
		        var sendKnob = new Tone.Gain(amount, Tone.Type.Decibels);
		        this.output.chain(sendKnob, Buses[channelName]);
		        return sendKnob;
		    };
		    /**
			 *  Recieve the input from the desired channelName to the input
			 *
			 *  @param  {string} channelName A named channel to send the signal to.
			 *  @param {AudioNode} [input] If no input is selected, the
			 *                                         input of the current node is
			 *                                         chosen. 
			 *  @returns {Tone} this
			 *  @example
			 * reverbEffect.receive("reverb");
			 */
		    Tone.prototype.receive = function (channelName, input) {
		        if (!Buses.hasOwnProperty(channelName)) {
		            Buses[channelName] = this.context.createGain();
		        }
		        if (this.isUndef(input)) {
		            input = this.input;
		        }
		        Buses[channelName].connect(input);
		        return this;
		    };
		    //remove all the send/receives when a new audio context is passed in
		    Tone._initAudioContext(function () {
		        Buses = {};
		    });
		    return Tone;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Draw is useful for synchronizing visuals and audio events.
			 *         Callbacks from Tone.Transport or any of the Tone.Event classes
			 *         always happen _before_ the scheduled time and are not synchronized
			 *         to the animation frame so they are not good for triggering tightly
			 *         synchronized visuals and sound. Tone.Draw makes it easy to schedule
			 *         callbacks using the AudioContext time and uses requestAnimationFrame.
			 *         
			 *  @singleton
			 *  @extends {Tone}
			 *  @example
			 * Tone.Transport.schedule(function(time){
			 * 	//use the time argument to schedule a callback with Tone.Draw
			 * 	Tone.Draw.schedule(function(){
			 * 		//do drawing or DOM manipulation here
			 * 	}, time)
			 * }, "+0.5")
			 */
		    Tone.Draw = function () {
		        /**
				 *  All of the events.
				 *  @type  {Tone.Timeline}
				 *  @private
				 */
		        this._events = new Tone.Timeline();
		        /**
				 *  The duration after which events are not invoked.
				 *  @type  {Number}
				 *  @default 0.25
				 */
		        this.expiration = 0.25;
		        /**
				 *  The amount of time before the scheduled time 
				 *  that the callback can be invoked. Default is
				 *  half the time of an animation frame (0.008 seconds).
				 *  @type  {Number}
				 *  @default 0.008
				 */
		        this.anticipation = 0.008;
		        /**
				 *  The draw loop
				 *  @type  {Function}
				 *  @private
				 */
		        this._boundDrawLoop = this._drawLoop.bind(this);
		        //start the loop
		        this._drawLoop();
		    };
		    Tone.extend(Tone.Draw);
		    /**
			 *  Schedule a function at the given time to be invoked
			 *  on the nearest animation frame.
			 *  @param  {Function}  callback  Callback is invoked at the given time.
			 *  @param  {Time}    time      The time relative to the AudioContext time
			 *                              to invoke the callback.
			 *  @return  {Tone.Draw}    this
			 */
		    Tone.Draw.prototype.schedule = function (callback, time) {
		        this._events.add({
		            callback: callback,
		            time: this.toSeconds(time)
		        });
		        return this;
		    };
		    /**
			 *  Cancel events scheduled after the given time
			 *  @param  {Time=}  after  Time after which scheduled events will 
			 *                          be removed from the scheduling timeline.
			 *  @return  {Tone.Draw}  this
			 */
		    Tone.Draw.prototype.cancel = function (after) {
		        this._events.cancel(this.toSeconds(after));
		        return this;
		    };
		    /**
			 *  The draw loop
			 *  @private
			 */
		    Tone.Draw.prototype._drawLoop = function () {
		        requestAnimationFrame(this._boundDrawLoop);
		        var now = Tone.now();
		        while (this._events.length && this._events.peek().time - this.anticipation <= now) {
		            var event = this._events.shift();
		            if (now - event.time <= this.expiration) {
		                event.callback();
		            }
		        }
		    };
		    //make a singleton
		    Tone.Draw = new Tone.Draw();
		    return Tone.Draw;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Both Tone.Panner3D and Tone.Listener have a position in 3D space 
			 *          using a right-handed cartesian coordinate system. 
			 *          The units used in the coordinate system are not defined; 
			 *          these coordinates are independent/invariant of any particular 
			 *          units such as meters or feet. Tone.Panner3D objects have an forward 
			 *          vector representing the direction the sound is projecting. Additionally, 
			 *          they have a sound cone representing how directional the sound is. 
			 *          For example, the sound could be omnidirectional, in which case it would 
			 *          be heard anywhere regardless of its forward, or it can be more directional 
			 *          and heard only if it is facing the listener. Tone.Listener objects 
			 *          (representing a person's ears) have an forward and up vector 
			 *          representing in which direction the person is facing. Because both the 
			 *          source stream and the listener can be moving, they both have a velocity 
			 *          vector representing both the speed and direction of movement. Taken together, 
			 *          these two velocities can be used to generate a doppler shift effect which changes the pitch.
			 *          <br><br>
			 *          Note: the position of the Listener will have no effect on nodes not connected to a Tone.Panner3D
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @singleton
			 *  @param {Number} positionX The initial x position.
			 *  @param {Number} positionY The initial y position.
			 *  @param {Number} positionZ The initial z position.
			 */
		    Tone.Listener = function () {
		        var options = this.optionsObject(arguments, [
		            'positionX',
		            'positionY',
		            'positionZ'
		        ], ListenerConstructor.defaults);
		        /**
				 *  The listener node
				 *  @type {AudioListener}
				 *  @private
				 */
		        this._listener = this.context.listener;
		        /**
				 *  Holds the current forward orientation
				 *  @type  {Array}
				 *  @private
				 */
		        this._orientation = [
		            options.forwardX,
		            options.forwardY,
		            options.forwardZ,
		            options.upX,
		            options.upY,
		            options.upZ
		        ];
		        /**
				 *  Holds the current position
				 *  @type  {Array}
				 *  @private
				 */
		        this._position = [
		            options.positionX,
		            options.positionY,
		            options.positionZ
		        ];
		        // set the default position/forward
		        this.forwardX = options.forwardX;
		        this.forwardY = options.forwardY;
		        this.forwardZ = options.forwardZ;
		        this.upX = options.upX;
		        this.upY = options.upY;
		        this.upZ = options.upZ;
		        this.positionX = options.positionX;
		        this.positionY = options.positionY;
		        this.positionZ = options.positionZ;
		    };
		    Tone.extend(Tone.Listener);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 *  Defaults according to the specification
			 */
		    Tone.Listener.defaults = {
		        'positionX': 0,
		        'positionY': 0,
		        'positionZ': 0,
		        'forwardX': 0,
		        'forwardY': 0,
		        'forwardZ': 1,
		        'upX': 0,
		        'upY': 1,
		        'upZ': 0
		    };
		    /**
			 * The ramp time which is applied to the setTargetAtTime
			 * @type {Number}
			 * @private
			 */
		    Tone.Listener.prototype._rampTimeConstant = 0.01;
		    /**
			 *  Sets the position of the listener in 3d space.	
			 *  @param  {Number}  x
			 *  @param  {Number}  y
			 *  @param  {Number}  z
			 *  @return {Tone.Listener} this
			 */
		    Tone.Listener.prototype.setPosition = function (x, y, z) {
		        if (this._listener.positionX) {
		            var now = this.now();
		            this._listener.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
		            this._listener.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
		            this._listener.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
		        } else {
		            this._listener.setPosition(x, y, z);
		        }
		        this._position = Array.prototype.slice.call(arguments);
		        return this;
		    };
		    /**
			 *  Sets the orientation of the listener using two vectors, the forward
			 *  vector (which direction the listener is facing) and the up vector 
			 *  (which the up direction of the listener). An up vector
			 *  of 0, 0, 1 is equivalent to the listener standing up in the Z direction. 
			 *  @param  {Number}  x
			 *  @param  {Number}  y
			 *  @param  {Number}  z
			 *  @param  {Number}  upX
			 *  @param  {Number}  upY
			 *  @param  {Number}  upZ
			 *  @return {Tone.Listener} this
			 */
		    Tone.Listener.prototype.setOrientation = function (x, y, z, upX, upY, upZ) {
		        if (this._listener.forwardX) {
		            var now = this.now();
		            this._listener.forwardX.setTargetAtTime(x, now, this._rampTimeConstant);
		            this._listener.forwardY.setTargetAtTime(y, now, this._rampTimeConstant);
		            this._listener.forwardZ.setTargetAtTime(z, now, this._rampTimeConstant);
		            this._listener.upX.setTargetAtTime(upX, now, this._rampTimeConstant);
		            this._listener.upY.setTargetAtTime(upY, now, this._rampTimeConstant);
		            this._listener.upZ.setTargetAtTime(upZ, now, this._rampTimeConstant);
		        } else {
		            this._listener.setOrientation(x, y, z, upX, upY, upZ);
		        }
		        this._orientation = Array.prototype.slice.call(arguments);
		        return this;
		    };
		    /**
			 *  The x position of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name positionX
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'positionX', {
		        set: function (pos) {
		            this._position[0] = pos;
		            this.setPosition.apply(this, this._position);
		        },
		        get: function () {
		            return this._position[0];
		        }
		    });
		    /**
			 *  The y position of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name positionY
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'positionY', {
		        set: function (pos) {
		            this._position[1] = pos;
		            this.setPosition.apply(this, this._position);
		        },
		        get: function () {
		            return this._position[1];
		        }
		    });
		    /**
			 *  The z position of the panner object.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name positionZ
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'positionZ', {
		        set: function (pos) {
		            this._position[2] = pos;
		            this.setPosition.apply(this, this._position);
		        },
		        get: function () {
		            return this._position[2];
		        }
		    });
		    /**
			 *  The x coordinate of the listeners front direction. i.e. 
			 *  which way they are facing.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name forwardX
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'forwardX', {
		        set: function (pos) {
		            this._orientation[0] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[0];
		        }
		    });
		    /**
			 *  The y coordinate of the listeners front direction. i.e. 
			 *  which way they are facing.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name forwardY
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'forwardY', {
		        set: function (pos) {
		            this._orientation[1] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[1];
		        }
		    });
		    /**
			 *  The z coordinate of the listeners front direction. i.e. 
			 *  which way they are facing.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name forwardZ
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'forwardZ', {
		        set: function (pos) {
		            this._orientation[2] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[2];
		        }
		    });
		    /**
			 *  The x coordinate of the listener's up direction. i.e.
			 *  the direction the listener is standing in.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name upX
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'upX', {
		        set: function (pos) {
		            this._orientation[3] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[3];
		        }
		    });
		    /**
			 *  The y coordinate of the listener's up direction. i.e.
			 *  the direction the listener is standing in.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name upY
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'upY', {
		        set: function (pos) {
		            this._orientation[4] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[4];
		        }
		    });
		    /**
			 *  The z coordinate of the listener's up direction. i.e.
			 *  the direction the listener is standing in.
			 *  @type {Number}
			 *  @memberOf Tone.Listener#
			 *  @name upZ
			 */
		    Object.defineProperty(Tone.Listener.prototype, 'upZ', {
		        set: function (pos) {
		            this._orientation[5] = pos;
		            this.setOrientation.apply(this, this._orientation);
		        },
		        get: function () {
		            return this._orientation[5];
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Listener} this
			 */
		    Tone.Listener.prototype.dispose = function () {
		        this._listener.disconnect();
		        this._listener = null;
		        this._orientation = null;
		        this._position = null;
		        return this;
		    };
		    //SINGLETON SETUP
		    var ListenerConstructor = Tone.Listener;
		    Tone._initAudioContext(function () {
		        if (typeof Tone.Listener === 'function') {
		            //a single listener object
		            Tone.Listener = new Tone.Listener();
		        } else {
		            //make new Listener insides
		            ListenerConstructor.call(Tone.Listener);
		        }
		    });
		    //END SINGLETON SETUP
		    return Tone.Listener;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Tone.Effect is the base class for effects. Connect the effect between
			 * 	        the effectSend and effectReturn GainNodes, then control the amount of
			 * 	        effect which goes to the output using the wet control.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {NormalRange|Object} [wet] The starting wet value. 
			 */
		    Tone.Effect = function () {
		        this.createInsOuts(1, 1);
		        //get all of the defaults
		        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);
		        /**
				 *  the drywet knob to control the amount of effect
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
		        this._dryWet = new Tone.CrossFade(options.wet);
		        /**
				 *  The wet control is how much of the effected
				 *  will pass through to the output. 1 = 100% effected
				 *  signal, 0 = 100% dry signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.wet = this._dryWet.fade;
		        /**
				 *  connect the effectSend to the input of hte effect
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this.effectSend = new Tone.Gain();
		        /**
				 *  connect the output of the effect to the effectReturn
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this.effectReturn = new Tone.Gain();
		        //connections
		        this.input.connect(this._dryWet.a);
		        this.input.connect(this.effectSend);
		        this.effectReturn.connect(this._dryWet.b);
		        this._dryWet.connect(this.output);
		        this._readOnly(['wet']);
		    };
		    Tone.extend(Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Effect.defaults = { 'wet': 1 };
		    /**
			 *  chains the effect in between the effectSend and effectReturn
			 *  @param  {Tone} effect
			 *  @private
			 *  @returns {Tone.Effect} this
			 */
		    Tone.Effect.prototype.connectEffect = function (effect) {
		        this.effectSend.chain(effect, this.effectReturn);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Effect} this
			 */
		    Tone.Effect.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._dryWet.dispose();
		        this._dryWet = null;
		        this.effectSend.dispose();
		        this.effectSend = null;
		        this.effectReturn.dispose();
		        this.effectReturn = null;
		        this._writable(['wet']);
		        this.wet = null;
		        return this;
		    };
		    return Tone.Effect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.
			 *         Setting the LFO rate and depth allows for control over the filter modulation rate 
			 *         and depth.
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Time|Object} [frequency] The rate of the LFO.
			 *  @param {Frequency=} baseFrequency The lower value of the LFOs oscillation
		 	 *  @param {Frequency=} octaves The number of octaves above the baseFrequency
			 *  @example
			 * //create an autofilter and start it's LFO
			 * var autoFilter = new Tone.AutoFilter("4n").toMaster().start();
			 * //route an oscillator through the filter and start it
			 * var oscillator = new Tone.Oscillator().connect(autoFilter).start();
			 */
		    Tone.AutoFilter = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'baseFrequency',
		            'octaves'
		        ], Tone.AutoFilter.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  the lfo which drives the filter cutoff
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth
		        });
		        /**
				 * The range of the filter modulating between the min and max frequency. 
				 * 0 = no modulation. 1 = full modulation.
				 * @type {NormalRange}
				 * @signal
				 */
		        this.depth = this._lfo.amplitude;
		        /**
				 * How fast the filter modulates between min and max. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfo.frequency;
		        /**
				 *  The filter node
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        /**
				 *  The octaves placeholder
				 *  @type {Positive}
				 *  @private
				 */
		        this._octaves = 0;
		        //connections
		        this.connectEffect(this.filter);
		        this._lfo.connect(this.filter.frequency);
		        this.type = options.type;
		        this._readOnly([
		            'frequency',
		            'depth'
		        ]);
		        this.octaves = options.octaves;
		        this.baseFrequency = options.baseFrequency;
		    };
		    //extend Effect
		    Tone.extend(Tone.AutoFilter, Tone.Effect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoFilter.defaults = {
		        'frequency': 1,
		        'type': 'sine',
		        'depth': 1,
		        'baseFrequency': 200,
		        'octaves': 2.6,
		        'filter': {
		            'type': 'lowpass',
		            'rolloff': -12,
		            'Q': 1
		        }
		    };
		    /**
			 * Start the effect.
			 * @param {Time} [time=now] When the LFO will start. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the effect.
			 * @param {Time} [time=now] When the LFO will stop. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the filter to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                               Transport has started. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the filter from the transport.
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the AutoFilter. 
			 * Possible values: "sine", "square", "triangle", "sawtooth".
			 * @memberOf Tone.AutoFilter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 * The minimum value of the filter's cutoff frequency.
			 * @memberOf Tone.AutoFilter#
			 * @type {Frequency}
			 * @name min
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'baseFrequency', {
		        get: function () {
		            return this._lfo.min;
		        },
		        set: function (freq) {
		            this._lfo.min = this.toFrequency(freq);
		            //and set the max
		            this.octaves = this._octaves;
		        }
		    });
		    /**
			 * The maximum value of the filter's cutoff frequency. 
			 * @memberOf Tone.AutoFilter#
			 * @type {Positive}
			 * @name octaves
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'octaves', {
		        get: function () {
		            return this._octaves;
		        },
		        set: function (oct) {
		            this._octaves = oct;
		            this._lfo.max = this.baseFrequency * Math.pow(2, oct);
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._lfo.dispose();
		        this._lfo = null;
		        this.filter.dispose();
		        this.filter = null;
		        this._writable([
		            'frequency',
		            'depth'
		        ]);
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.AutoFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. 
			 *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. 
			 *  @example
			 * //create an autopanner and start it's LFO
			 * var autoPanner = new Tone.AutoPanner("4n").toMaster().start();
			 * //route an oscillator through the panner and start it
			 * var oscillator = new Tone.Oscillator().connect(autoPanner).start();
			 */
		    Tone.AutoPanner = function () {
		        var options = this.optionsObject(arguments, ['frequency'], Tone.AutoPanner.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  the lfo which drives the panning
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth,
		            'min': -1,
		            'max': 1
		        });
		        /**
				 * The amount of panning between left and right. 
				 * 0 = always center. 1 = full range between left and right. 
				 * @type {NormalRange}
				 * @signal
				 */
		        this.depth = this._lfo.amplitude;
		        /**
				 *  the panner node which does the panning
				 *  @type {Tone.Panner}
				 *  @private
				 */
		        this._panner = new Tone.Panner();
		        /**
				 * How fast the panner modulates between left and right. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfo.frequency;
		        //connections
		        this.connectEffect(this._panner);
		        this._lfo.connect(this._panner.pan);
		        this.type = options.type;
		        this._readOnly([
		            'depth',
		            'frequency'
		        ]);
		    };
		    //extend Effect
		    Tone.extend(Tone.AutoPanner, Tone.Effect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoPanner.defaults = {
		        'frequency': 1,
		        'type': 'sine',
		        'depth': 1
		    };
		    /**
			 * Start the effect.
			 * @param {Time} [time=now] When the LFO will start. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the effect.
			 * @param {Time} [time=now] When the LFO will stop. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the panner to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                               Transport has started. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the panner from the transport
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the AutoFilter. 
			 * Possible values: "sine", "square", "triangle", "sawtooth".
			 * @memberOf Tone.AutoFilter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._lfo.dispose();
		        this._lfo = null;
		        this._panner.dispose();
		        this._panner = null;
		        this._writable([
		            'depth',
		            'frequency'
		        ]);
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.AutoPanner;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).
			 *          The frequency of the filter is adjusted proportionally to the 
			 *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set 
			 *                                            to at the low point of the wah
			 *  @param {Positive} [octaves] The number of octaves above the baseFrequency
			 *                                the filter will sweep to when fully open
			 *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for 
			 *                                   the incoming signal. Normal range of -40 to 0. 
			 *  @example
			 * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();
			 * //initialize the synth and connect to autowah
			 * var synth = new Synth.connect(autoWah);
			 * //Q value influences the effect of the wah - default is 2
			 * autoWah.Q.value = 6;
			 * //more audible on higher notes
			 * synth.triggerAttackRelease("C4", "8n")
			 */
		    Tone.AutoWah = function () {
		        var options = this.optionsObject(arguments, [
		            'baseFrequency',
		            'octaves',
		            'sensitivity'
		        ], Tone.AutoWah.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The envelope follower. Set the attack/release
				 *  timing to adjust how the envelope is followed. 
				 *  @type {Tone.Follower}
				 *  @private
				 */
		        this.follower = new Tone.Follower(options.follower);
		        /**
				 *  scales the follower value to the frequency domain
				 *  @type {Tone}
				 *  @private
				 */
		        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);
		        /**
				 *  @type {number}
				 *  @private
				 */
		        this._baseFrequency = options.baseFrequency;
		        /**
				 *  @type {number}
				 *  @private
				 */
		        this._octaves = options.octaves;
		        /**
				 *  the input gain to adjust the sensitivity
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._inputBoost = new Tone.Gain();
		        /**
				 *  @type {BiquadFilterNode}
				 *  @private
				 */
		        this._bandpass = new Tone.Filter({
		            'rolloff': -48,
		            'frequency': 0,
		            'Q': options.Q
		        });
		        /**
				 *  @type {Tone.Filter}
				 *  @private
				 */
		        this._peaking = new Tone.Filter(0, 'peaking');
		        this._peaking.gain.value = options.gain;
		        /**
				 * The gain of the filter.
				 * @type {Number}
				 * @signal
				 */
		        this.gain = this._peaking.gain;
		        /**
				 * The quality of the filter.
				 * @type {Positive}
				 * @signal
				 */
		        this.Q = this._bandpass.Q;
		        //the control signal path
		        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);
		        this._sweepRange.connect(this._bandpass.frequency);
		        this._sweepRange.connect(this._peaking.frequency);
		        //the filtered path
		        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);
		        //set the initial value
		        this._setSweepRange();
		        this.sensitivity = options.sensitivity;
		        this._readOnly([
		            'gain',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.AutoWah, Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoWah.defaults = {
		        'baseFrequency': 100,
		        'octaves': 6,
		        'sensitivity': 0,
		        'Q': 2,
		        'gain': 2,
		        'follower': {
		            'attack': 0.3,
		            'release': 0.5
		        }
		    };
		    /**
			 * The number of octaves that the filter will sweep above the 
			 * baseFrequency. 
			 * @memberOf Tone.AutoWah#
			 * @type {Number}
			 * @name octaves
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {
		        get: function () {
		            return this._octaves;
		        },
		        set: function (octaves) {
		            this._octaves = octaves;
		            this._setSweepRange();
		        }
		    });
		    /**
			 * The base frequency from which the sweep will start from.
			 * @memberOf Tone.AutoWah#
			 * @type {Frequency}
			 * @name baseFrequency
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {
		        get: function () {
		            return this._baseFrequency;
		        },
		        set: function (baseFreq) {
		            this._baseFrequency = baseFreq;
		            this._setSweepRange();
		        }
		    });
		    /**
			 * The sensitivity to control how responsive to the input signal the filter is. 
			 * @memberOf Tone.AutoWah#
			 * @type {Decibels}
			 * @name sensitivity
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {
		        get: function () {
		            return this.gainToDb(1 / this._inputBoost.gain.value);
		        },
		        set: function (sensitivy) {
		            this._inputBoost.gain.value = 1 / this.dbToGain(sensitivy);
		        }
		    });
		    /**
			 *  sets the sweep range of the scaler
			 *  @private
			 */
		    Tone.AutoWah.prototype._setSweepRange = function () {
		        this._sweepRange.min = this._baseFrequency;
		        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.AutoWah} this
			 */
		    Tone.AutoWah.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this.follower.dispose();
		        this.follower = null;
		        this._sweepRange.dispose();
		        this._sweepRange = null;
		        this._bandpass.dispose();
		        this._bandpass = null;
		        this._peaking.dispose();
		        this._peaking = null;
		        this._inputBoost.dispose();
		        this._inputBoost = null;
		        this._writable([
		            'gain',
		            'Q'
		        ]);
		        this.gain = null;
		        this.Q = null;
		        return this;
		    };
		    return Tone.AutoWah;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. 
			 *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing
			 *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Number} bits The number of bits to downsample the signal. Nominal range
			 *                       of 1 to 8. 
			 *  @example
			 * //initialize crusher and route a synth through it
			 * var crusher = new Tone.BitCrusher(4).toMaster();
			 * var synth = new Tone.MonoSynth().connect(crusher);
			 */
		    Tone.BitCrusher = function () {
		        var options = this.optionsObject(arguments, ['bits'], Tone.BitCrusher.defaults);
		        Tone.Effect.call(this, options);
		        var invStepSize = 1 / Math.pow(2, options.bits - 1);
		        /**
				 *  Subtract the input signal and the modulus of the input signal
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._subtract = new Tone.Subtract();
		        /**
				 *  The mod function
				 *  @type  {Tone.Modulo}
				 *  @private
				 */
		        this._modulo = new Tone.Modulo(invStepSize);
		        /**
				 *  keeps track of the bits
				 *  @type {number}
				 *  @private
				 */
		        this._bits = options.bits;
		        //connect it up
		        this.effectSend.fan(this._subtract, this._modulo);
		        this._modulo.connect(this._subtract, 0, 1);
		        this._subtract.connect(this.effectReturn);
		    };
		    Tone.extend(Tone.BitCrusher, Tone.Effect);
		    /**
			 *  the default values
			 *  @static
			 *  @type {Object}
			 */
		    Tone.BitCrusher.defaults = { 'bits': 4 };
		    /**
			 * The bit depth of the effect. Nominal range of 1-8. 
			 * @memberOf Tone.BitCrusher#
			 * @type {number}
			 * @name bits
			 */
		    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {
		        get: function () {
		            return this._bits;
		        },
		        set: function (bits) {
		            this._bits = bits;
		            var invStepSize = 1 / Math.pow(2, bits - 1);
		            this._modulo.value = invStepSize;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.BitCrusher} this
			 */
		    Tone.BitCrusher.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._subtract.dispose();
		        this._subtract = null;
		        this._modulo.dispose();
		        this._modulo = null;
		        return this;
		    };
		    return Tone.BitCrusher;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good 
			 *         for making different types of distortion sounds.
			 *         Note that odd orders sound very different from even ones, 
			 *         and order = 1 is no change. 
			 *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. 
			 *  @example
			 * //create a new cheby
			 * var cheby = new Tone.Chebyshev(50);
			 * //create a monosynth connected to our cheby
			 * synth = new Tone.MonoSynth().connect(cheby);
			 */
		    Tone.Chebyshev = function () {
		        var options = this.optionsObject(arguments, ['order'], Tone.Chebyshev.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._shaper = new Tone.WaveShaper(4096);
		        /**
				 * holds onto the order of the filter
				 * @type {number}
				 * @private
				 */
		        this._order = options.order;
		        this.connectEffect(this._shaper);
		        this.order = options.order;
		        this.oversample = options.oversample;
		    };
		    Tone.extend(Tone.Chebyshev, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Chebyshev.defaults = {
		        'order': 1,
		        'oversample': 'none'
		    };
		    /**
			 *  get the coefficient for that degree
			 *  @param {number} x the x value
			 *  @param   {number} degree 
			 *  @param {Object} memo memoize the computed value. 
			 *                       this speeds up computation greatly. 
			 *  @return  {number}       the coefficient 
			 *  @private
			 */
		    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {
		        if (memo.hasOwnProperty(degree)) {
		            return memo[degree];
		        } else if (degree === 0) {
		            memo[degree] = 0;
		        } else if (degree === 1) {
		            memo[degree] = x;
		        } else {
		            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);
		        }
		        return memo[degree];
		    };
		    /**
			 * The order of the Chebyshev polynomial which creates
			 * the equation which is applied to the incoming 
			 * signal through a Tone.WaveShaper. The equations
			 * are in the form:<br>
			 * order 2: 2x^2 + 1<br>
			 * order 3: 4x^3 + 3x <br>
			 * @memberOf Tone.Chebyshev#
			 * @type {Positive}
			 * @name order
			 */
		    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {
		        get: function () {
		            return this._order;
		        },
		        set: function (order) {
		            this._order = order;
		            var curve = new Array(4096);
		            var len = curve.length;
		            for (var i = 0; i < len; ++i) {
		                var x = i * 2 / len - 1;
		                if (x === 0) {
		                    //should output 0 when input is 0
		                    curve[i] = 0;
		                } else {
		                    curve[i] = this._getCoefficient(x, order, {});
		                }
		            }
		            this._shaper.curve = curve;
		        }
		    });
		    /**
			 * The oversampling of the effect. Can either be "none", "2x" or "4x".
			 * @memberOf Tone.Chebyshev#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Chebyshev} this
			 */
		    Tone.Chebyshev.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        return this;
		    };
		    return Tone.Chebyshev;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R. 
			 *
			 *	@constructor
			 *	@extends {Tone.Effect}
			 */
		    Tone.StereoEffect = function () {
		        this.createInsOuts(1, 1);
		        //get the defaults
		        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);
		        /**
				 *  the drywet knob to control the amount of effect
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
		        this._dryWet = new Tone.CrossFade(options.wet);
		        /**
				 *  The wet control, i.e. how much of the effected
				 *  will pass through to the output. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.wet = this._dryWet.fade;
		        /**
				 *  then split it
				 *  @type {Tone.Split}
				 *  @private
				 */
		        this._split = new Tone.Split();
		        /**
				 *  the effects send LEFT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSendL = this._split.left;
		        /**
				 *  the effects send RIGHT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSendR = this._split.right;
		        /**
				 *  the stereo effect merger
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = new Tone.Merge();
		        /**
				 *  the effect return LEFT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturnL = this._merge.left;
		        /**
				 *  the effect return RIGHT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturnR = this._merge.right;
		        //connections
		        this.input.connect(this._split);
		        //dry wet connections
		        this.input.connect(this._dryWet, 0, 0);
		        this._merge.connect(this._dryWet, 0, 1);
		        this._dryWet.connect(this.output);
		        this._readOnly(['wet']);
		    };
		    Tone.extend(Tone.StereoEffect, Tone.Effect);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.StereoEffect} this
			 */
		    Tone.StereoEffect.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._dryWet.dispose();
		        this._dryWet = null;
		        this._split.dispose();
		        this._split = null;
		        this._merge.dispose();
		        this._merge = null;
		        this.effectSendL = null;
		        this.effectSendR = null;
		        this.effectReturnL = null;
		        this.effectReturnR = null;
		        this._writable(['wet']);
		        this.wet = null;
		        return this;
		    };
		    return Tone.StereoEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Tone.FeedbackEffect provides a loop between an 
			 * 	        audio source and its own output. This is a base-class
			 * 	        for feedback effects. 
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {NormalRange|Object} [feedback] The initial feedback value.
			 */
		    Tone.FeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback']);
		        options = this.defaultArg(options, Tone.FeedbackEffect.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  the gain which controls the feedback
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._feedbackGain = new Tone.Gain(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  The amount of signal which is fed back into the effect input. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = this._feedbackGain.gain;
		        //the feedback loop
		        this.effectReturn.chain(this._feedbackGain, this.effectSend);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.FeedbackEffect, Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.FeedbackEffect} this
			 */
		    Tone.FeedbackEffect.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this._feedbackGain.dispose();
		        this._feedbackGain = null;
		        this.feedback = null;
		        return this;
		    };
		    return Tone.FeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Just like a stereo feedback effect, but the feedback is routed from left to right
			 *         and right to left instead of on the same channel.
			 *
			 *	@constructor
			 *	@extends {Tone.FeedbackEffect}
			 */
		    Tone.StereoXFeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  The amount of feedback from the output
				 *  back into the input of the effect (routed
				 *  across left and right channels).
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the left side feeback
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._feedbackLR = new Tone.Gain();
		        /**
				 *  the right side feeback
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._feedbackRL = new Tone.Gain();
		        //connect it up
		        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);
		        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);
		        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.StereoXFeedbackEffect, Tone.FeedbackEffect);
		    /**
			 *  clean up
			 *  @returns {Tone.StereoXFeedbackEffect} this
			 */
		    Tone.StereoXFeedbackEffect.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackLR.dispose();
		        this._feedbackLR = null;
		        this._feedbackRL.dispose();
		        this._feedbackRL = null;
		        return this;
		    };
		    return Tone.StereoXFeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Chorus is a stereo chorus effect with feedback composed of 
			 *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. 
			 *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).
			 *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).
			 *
			 *	@constructor
			 *	@extends {Tone.StereoXFeedbackEffect}
			 *	@param {Frequency|Object} [frequency] The frequency of the LFO.
			 *	@param {Milliseconds} [delayTime] The delay of the chorus effect in ms. 
			 *	@param {NormalRange} [depth] The depth of the chorus.
			 *	@example
			 * var chorus = new Tone.Chorus(4, 2.5, 0.5);
			 * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);
			 * synth.triggerAttackRelease(["C3","E3","G3"], "8n");
			 */
		    Tone.Chorus = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'delayTime',
		            'depth'
		        ], Tone.Chorus.defaults);
		        Tone.StereoXFeedbackEffect.call(this, options);
		        /**
				 *  the depth of the chorus
				 *  @type {number}
				 *  @private
				 */
		        this._depth = options.depth;
		        /**
				 *  the delayTime
				 *  @type {number}
				 *  @private
				 */
		        this._delayTime = options.delayTime / 1000;
		        /**
				 *  the lfo which controls the delayTime
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoL = new Tone.LFO({
		            'frequency': options.frequency,
		            'min': 0,
		            'max': 1
		        });
		        /**
				 *  another LFO for the right side with a 180 degree phase diff
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoR = new Tone.LFO({
		            'frequency': options.frequency,
		            'min': 0,
		            'max': 1,
		            'phase': 180
		        });
		        /**
				 *  delay for left
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._delayNodeL = new Tone.Delay();
		        /**
				 *  delay for right
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._delayNodeR = new Tone.Delay();
		        /**
				 * The frequency of the LFO which modulates the delayTime. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfoL.frequency;
		        //connections
		        this.effectSendL.chain(this._delayNodeL, this.effectReturnL);
		        this.effectSendR.chain(this._delayNodeR, this.effectReturnR);
		        //and pass through to make the detune apparent
		        this.effectSendL.connect(this.effectReturnL);
		        this.effectSendR.connect(this.effectReturnR);
		        //lfo setup
		        this._lfoL.connect(this._delayNodeL.delayTime);
		        this._lfoR.connect(this._delayNodeR.delayTime);
		        //start the lfo
		        this._lfoL.start();
		        this._lfoR.start();
		        //have one LFO frequency control the other
		        this._lfoL.frequency.connect(this._lfoR.frequency);
		        //set the initial values
		        this.depth = this._depth;
		        this.frequency.value = options.frequency;
		        this.type = options.type;
		        this._readOnly(['frequency']);
		        this.spread = options.spread;
		    };
		    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Chorus.defaults = {
		        'frequency': 1.5,
		        'delayTime': 3.5,
		        'depth': 0.7,
		        'feedback': 0.1,
		        'type': 'sine',
		        'spread': 180
		    };
		    /**
			 * The depth of the effect. A depth of 1 makes the delayTime
			 * modulate between 0 and 2*delayTime (centered around the delayTime). 
			 * @memberOf Tone.Chorus#
			 * @type {NormalRange}
			 * @name depth
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'depth', {
		        get: function () {
		            return this._depth;
		        },
		        set: function (depth) {
		            this._depth = depth;
		            var deviation = this._delayTime * depth;
		            this._lfoL.min = Math.max(this._delayTime - deviation, 0);
		            this._lfoL.max = this._delayTime + deviation;
		            this._lfoR.min = Math.max(this._delayTime - deviation, 0);
		            this._lfoR.max = this._delayTime + deviation;
		        }
		    });
		    /**
			 * The delayTime in milliseconds of the chorus. A larger delayTime
			 * will give a more pronounced effect. Nominal range a delayTime
			 * is between 2 and 20ms. 
			 * @memberOf Tone.Chorus#
			 * @type {Milliseconds}
			 * @name delayTime
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {
		        get: function () {
		            return this._delayTime * 1000;
		        },
		        set: function (delayTime) {
		            this._delayTime = delayTime / 1000;
		            this.depth = this._depth;
		        }
		    });
		    /**
			 * The oscillator type of the LFO. 
			 * @memberOf Tone.Chorus#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'type', {
		        get: function () {
		            return this._lfoL.type;
		        },
		        set: function (type) {
		            this._lfoL.type = type;
		            this._lfoR.type = type;
		        }
		    });
		    /** 
			 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
			 * When set to 180, LFO's will be panned hard left and right respectively.
			 * @memberOf Tone.Chorus#
			 * @type {Degrees}
			 * @name spread
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'spread', {
		        get: function () {
		            return this._lfoR.phase - this._lfoL.phase;    //180
		        },
		        set: function (spread) {
		            this._lfoL.phase = 90 - spread / 2;
		            this._lfoR.phase = spread / 2 + 90;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Chorus} this
			 */
		    Tone.Chorus.prototype.dispose = function () {
		        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
		        this._lfoL.dispose();
		        this._lfoL = null;
		        this._lfoR.dispose();
		        this._lfoR = null;
		        this._delayNodeL.dispose();
		        this._delayNodeL = null;
		        this._delayNodeR.dispose();
		        this._delayNodeR = null;
		        this._writable('frequency');
		        this.frequency = null;
		        return this;
		    };
		    return Tone.Chorus;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Convolver is a wrapper around the Native Web Audio 
			 *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
			 *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
			 *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
			 *  
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer
			 *                                           contianing the impulse response. 
			 *  @param {Function} onload The callback to invoke when the url is loaded.
			 *  @example
			 * //initializing the convolver with an impulse response
			 * var convolver = new Tone.Convolver("./path/to/ir.wav").toMaster();
			 */
		    Tone.Convolver = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload'
		        ], Tone.Convolver.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  convolver node
				 *  @type {ConvolverNode}
				 *  @private
				 */
		        this._convolver = this.context.createConvolver();
		        /**
				 *  the convolution buffer
				 *  @type {Tone.Buffer}
				 *  @private
				 */
		        this._buffer = new Tone.Buffer();
		        if (this.isString(options.url)) {
		            this._buffer.load(options.url, function (buffer) {
		                this.buffer = buffer;
		                options.onload();
		            }.bind(this));
		        } else if (options.url) {
		            this.buffer = options.url;
		            options.onload();
		        }
		        this.connectEffect(this._convolver);
		    };
		    Tone.extend(Tone.Convolver, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Convolver.defaults = { 'onload': Tone.noOp };
		    /**
			 *  The convolver's buffer
			 *  @memberOf Tone.Convolver#
			 *  @type {AudioBuffer}
			 *  @name buffer
			 */
		    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {
		        get: function () {
		            return this._buffer.get();
		        },
		        set: function (buffer) {
		            this._buffer.set(buffer);
		            this._convolver.buffer = this._buffer.get();
		        }
		    });
		    /**
			 *  Load an impulse response url as an audio buffer.
			 *  Decodes the audio asynchronously and invokes
			 *  the callback once the audio buffer loads.
			 *  @param {string} url The url of the buffer to load.
			 *                      filetype support depends on the
			 *                      browser.
			 *  @param  {function=} callback
			 *  @returns {Promise}
			 */
		    Tone.Convolver.prototype.load = function (url, callback) {
		        return this._buffer.load(url, function (buff) {
		            this.buffer = buff;
		            if (callback) {
		                callback();
		            }
		        }.bind(this));
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Convolver} this
			 */
		    Tone.Convolver.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._convolver.disconnect();
		        this._convolver = null;
		        this._buffer.dispose();
		        this._buffer = null;
		        return this;
		    };
		    return Tone.Convolver;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.
			 *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)
			 *  @example
			 * var dist = new Tone.Distortion(0.8).toMaster();
			 * var fm = new Tone.SimpleFM().connect(dist);
			 * //this sounds good on bass notes
			 * fm.triggerAttackRelease("A1", "8n");
			 */
		    Tone.Distortion = function () {
		        var options = this.optionsObject(arguments, ['distortion'], Tone.Distortion.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._shaper = new Tone.WaveShaper(4096);
		        /**
				 * holds the distortion amount
				 * @type {number}
				 * @private
				 */
		        this._distortion = options.distortion;
		        this.connectEffect(this._shaper);
		        this.distortion = options.distortion;
		        this.oversample = options.oversample;
		    };
		    Tone.extend(Tone.Distortion, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Distortion.defaults = {
		        'distortion': 0.4,
		        'oversample': 'none'
		    };
		    /**
			 * The amount of distortion.
			 * @memberOf Tone.Distortion#
			 * @type {NormalRange}
			 * @name distortion
			 */
		    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {
		        get: function () {
		            return this._distortion;
		        },
		        set: function (amount) {
		            this._distortion = amount;
		            var k = amount * 100;
		            var deg = Math.PI / 180;
		            this._shaper.setMap(function (x) {
		                if (Math.abs(x) < 0.001) {
		                    //should output 0 when input is 0
		                    return 0;
		                } else {
		                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
		                }
		            });
		        }
		    });
		    /**
			 * The oversampling of the effect. Can either be "none", "2x" or "4x".
			 * @memberOf Tone.Distortion#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Distortion} this
			 */
		    Tone.Distortion.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        return this;
		    };
		    return Tone.Distortion;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.FeedbackDelay is a DelayNode in which part of output
			 *          signal is fed back into the delay. 
			 *
			 *  @constructor
			 *  @extends {Tone.FeedbackEffect}
			 *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. 
			 *  @param {NormalRange=} feedback The amount of the effected signal which 
			 *                            is fed back through the delay.
			 *  @example
			 * var feedbackDelay = new Tone.FeedbackDelay("8n", 0.5).toMaster();
			 * var tom = new Tone.DrumSynth({
			 * 	"octaves" : 4,
			 * 	"pitchDecay" : 0.1
			 * }).connect(feedbackDelay);
			 * tom.triggerAttackRelease("A2","32n");
			 */
		    Tone.FeedbackDelay = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'feedback'
		        ], Tone.FeedbackDelay.defaults);
		        Tone.FeedbackEffect.call(this, options);
		        /**
				 *  the delay node
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._delayNode = new Tone.Delay(options.delayTime);
		        /**
				 *  The delayTime of the DelayNode. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = this._delayNode.delayTime;
		        // connect it up
		        this.connectEffect(this._delayNode);
		        this._readOnly(['delayTime']);
		    };
		    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);
		    /**
			 *  The default values. 
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };
		    /**
			 *  clean up
			 *  @returns {Tone.FeedbackDelay} this
			 */
		    Tone.FeedbackDelay.prototype.dispose = function () {
		        Tone.FeedbackEffect.prototype.dispose.call(this);
		        this._delayNode.dispose();
		        this._delayNode = null;
		        this._writable(['delayTime']);
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.FeedbackDelay;
		});
		Module(function (Tone) {
		    
		    /**
			 *  an array of comb filter delay values from Freeverb implementation
			 *  @static
			 *  @private
			 *  @type {Array}
			 */
		    var combFilterTunings = [
		        1557 / 44100,
		        1617 / 44100,
		        1491 / 44100,
		        1422 / 44100,
		        1277 / 44100,
		        1356 / 44100,
		        1188 / 44100,
		        1116 / 44100
		    ];
		    /**
			 *  an array of allpass filter frequency values from Freeverb implementation
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var allpassFilterFrequencies = [
		        225,
		        556,
		        441,
		        341
		    ];
		    /**
			 *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).
			 *         Read more on reverb on [SoundOnSound](http://www.soundonsound.com/sos/may00/articles/reverb.htm).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {NormalRange|Object} [roomSize] Correlated to the decay time. 
			 *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part 
			 *                                 of the reverb. 
			 *  @example
			 * var freeverb = new Tone.Freeverb().toMaster();
			 * freeverb.dampening.value = 1000;
			 * //routing synth through the reverb
			 * var synth = new Tone.AMSynth().connect(freeverb);
			 */
		    Tone.Freeverb = function () {
		        var options = this.optionsObject(arguments, [
		            'roomSize',
		            'dampening'
		        ], Tone.Freeverb.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  The roomSize value between. A larger roomSize
				 *  will result in a longer decay. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
		        /**
				 *  The amount of dampening of the reverberant signal. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);
		        /**
				 *  the comb filters
				 *  @type {Array}
				 *  @private
				 */
		        this._combFilters = [];
		        /**
				 *  the allpass filters on the left
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFiltersL = [];
		        /**
				 *  the allpass filters on the right
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFiltersR = [];
		        //make the allpass filters on teh right
		        for (var l = 0; l < allpassFilterFrequencies.length; l++) {
		            var allpassL = this.context.createBiquadFilter();
		            allpassL.type = 'allpass';
		            allpassL.frequency.value = allpassFilterFrequencies[l];
		            this._allpassFiltersL.push(allpassL);
		        }
		        //make the allpass filters on the left
		        for (var r = 0; r < allpassFilterFrequencies.length; r++) {
		            var allpassR = this.context.createBiquadFilter();
		            allpassR.type = 'allpass';
		            allpassR.frequency.value = allpassFilterFrequencies[r];
		            this._allpassFiltersR.push(allpassR);
		        }
		        //make the comb filters
		        for (var c = 0; c < combFilterTunings.length; c++) {
		            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);
		            if (c < combFilterTunings.length / 2) {
		                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);
		            } else {
		                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);
		            }
		            this.roomSize.connect(lfpf.resonance);
		            this.dampening.connect(lfpf.dampening);
		            this._combFilters.push(lfpf);
		        }
		        //chain the allpass filters togetehr
		        this.connectSeries.apply(this, this._allpassFiltersL);
		        this.connectSeries.apply(this, this._allpassFiltersR);
		        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);
		        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);
		        this._readOnly([
		            'roomSize',
		            'dampening'
		        ]);
		    };
		    Tone.extend(Tone.Freeverb, Tone.StereoEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Freeverb.defaults = {
		        'roomSize': 0.7,
		        'dampening': 3000
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Freeverb} this
			 */
		    Tone.Freeverb.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        for (var al = 0; al < this._allpassFiltersL.length; al++) {
		            this._allpassFiltersL[al].disconnect();
		            this._allpassFiltersL[al] = null;
		        }
		        this._allpassFiltersL = null;
		        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {
		            this._allpassFiltersR[ar].disconnect();
		            this._allpassFiltersR[ar] = null;
		        }
		        this._allpassFiltersR = null;
		        for (var cf = 0; cf < this._combFilters.length; cf++) {
		            this._combFilters[cf].dispose();
		            this._combFilters[cf] = null;
		        }
		        this._combFilters = null;
		        this._writable([
		            'roomSize',
		            'dampening'
		        ]);
		        this.roomSize.dispose();
		        this.roomSize = null;
		        this.dampening.dispose();
		        this.dampening = null;
		        return this;
		    };
		    return Tone.Freeverb;
		});
		Module(function (Tone) {
		    
		    /**
			 *  an array of the comb filter delay time values
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var combFilterDelayTimes = [
		        1687 / 25000,
		        1601 / 25000,
		        2053 / 25000,
		        2251 / 25000
		    ];
		    /**
			 *  the resonances of each of the comb filters
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var combFilterResonances = [
		        0.773,
		        0.802,
		        0.753,
		        0.733
		    ];
		    /**
			 *  the allpass filter frequencies
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var allpassFilterFreqs = [
		        347,
		        113,
		        37
		    ];
		    /**
			 *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)
			 *         tuned by John Chowning in 1970.
			 *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. 
			 *         
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.
			 *  @example
			 * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);
			 * var delay = new Tone.FeedbackDelay(0.5); 
			 * //connecting the synth to reverb through delay
			 * var synth = new Tone.DuoSynth().chain(delay, reverb);
			 * synth.triggerAttackRelease("A4","8n");
			 */
		    Tone.JCReverb = function () {
		        var options = this.optionsObject(arguments, ['roomSize'], Tone.JCReverb.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  room size control values between [0,1]
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
		        /**
				 *  scale the room size
				 *  @type {Tone.Scale}
				 *  @private
				 */
		        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);
		        /**
				 *  a series of allpass filters
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFilters = [];
		        /**
				 *  parallel feedback comb filters
				 *  @type {Array}
				 *  @private
				 */
		        this._feedbackCombFilters = [];
		        //make the allpass filters
		        for (var af = 0; af < allpassFilterFreqs.length; af++) {
		            var allpass = this.context.createBiquadFilter();
		            allpass.type = 'allpass';
		            allpass.frequency.value = allpassFilterFreqs[af];
		            this._allpassFilters.push(allpass);
		        }
		        //and the comb filters
		        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {
		            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);
		            this._scaleRoomSize.connect(fbcf.resonance);
		            fbcf.resonance.value = combFilterResonances[cf];
		            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);
		            if (cf < combFilterDelayTimes.length / 2) {
		                fbcf.connect(this.effectReturnL);
		            } else {
		                fbcf.connect(this.effectReturnR);
		            }
		            this._feedbackCombFilters.push(fbcf);
		        }
		        //chain the allpass filters together
		        this.roomSize.connect(this._scaleRoomSize);
		        this.connectSeries.apply(this, this._allpassFilters);
		        this.effectSendL.connect(this._allpassFilters[0]);
		        this.effectSendR.connect(this._allpassFilters[0]);
		        this._readOnly(['roomSize']);
		    };
		    Tone.extend(Tone.JCReverb, Tone.StereoEffect);
		    /**
			 *  the default values
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.JCReverb.defaults = { 'roomSize': 0.5 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.JCReverb} this
			 */
		    Tone.JCReverb.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        for (var apf = 0; apf < this._allpassFilters.length; apf++) {
		            this._allpassFilters[apf].disconnect();
		            this._allpassFilters[apf] = null;
		        }
		        this._allpassFilters = null;
		        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {
		            this._feedbackCombFilters[fbcf].dispose();
		            this._feedbackCombFilters[fbcf] = null;
		        }
		        this._feedbackCombFilters = null;
		        this._writable(['roomSize']);
		        this.roomSize.dispose();
		        this.roomSize = null;
		        this._scaleRoomSize.dispose();
		        this._scaleRoomSize = null;
		        return this;
		    };
		    return Tone.JCReverb;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels) 
			 *         and effects them separately before being recombined.
			 *         Applies a Mid/Side seperation and recombination.
			 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
			 *         <br><br>
			 *         This is a base-class for Mid/Side Effects. 
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 */
		    Tone.MidSideEffect = function () {
		        Tone.Effect.apply(this, arguments);
		        /**
				 *  The mid/side split
				 *  @type  {Tone.MidSideSplit}
				 *  @private
				 */
		        this._midSideSplit = new Tone.MidSideSplit();
		        /**
				 *  The mid/side merge
				 *  @type  {Tone.MidSideMerge}
				 *  @private
				 */
		        this._midSideMerge = new Tone.MidSideMerge();
		        /**
				 *  The mid send. Connect to mid processing
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this.midSend = this._midSideSplit.mid;
		        /**
				 *  The side send. Connect to side processing
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this.sideSend = this._midSideSplit.side;
		        /**
				 *  The mid return connection
				 *  @type {GainNode}
				 *  @private
				 */
		        this.midReturn = this._midSideMerge.mid;
		        /**
				 *  The side return connection
				 *  @type {GainNode}
				 *  @private
				 */
		        this.sideReturn = this._midSideMerge.side;
		        //the connections
		        this.effectSend.connect(this._midSideSplit);
		        this._midSideMerge.connect(this.effectReturn);
		    };
		    Tone.extend(Tone.MidSideEffect, Tone.Effect);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.MidSideEffect} this
			 */
		    Tone.MidSideEffect.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._midSideSplit.dispose();
		        this._midSideSplit = null;
		        this._midSideMerge.dispose();
		        this._midSideMerge = null;
		        this.midSend = null;
		        this.sideSend = null;
		        this.midReturn = null;
		        this.sideReturn = null;
		        return this;
		    };
		    return Tone.MidSideEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase
			 *         of different frequency components of an incoming signal. Read more on 
			 *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). 
			 *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).
			 *
			 *	@extends {Tone.StereoEffect}
			 *	@constructor
			 *	@param {Frequency|Object} [frequency] The speed of the phasing. 
			 *	@param {number} [octaves] The octaves of the effect. 
			 *	@param {Frequency} [baseFrequency] The base frequency of the filters. 
			 *	@example
			 * var phaser = new Tone.Phaser({
			 * 	"frequency" : 15, 
			 * 	"octaves" : 5, 
			 * 	"baseFrequency" : 1000
			 * }).toMaster();
			 * var synth = new Tone.FMSynth().connect(phaser);
			 * synth.triggerAttackRelease("E3", "2n");
			 */
		    Tone.Phaser = function () {
		        //set the defaults
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'octaves',
		            'baseFrequency'
		        ], Tone.Phaser.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  the lfo which controls the frequency on the left side
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoL = new Tone.LFO(options.frequency, 0, 1);
		        /**
				 *  the lfo which controls the frequency on the right side
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoR = new Tone.LFO(options.frequency, 0, 1);
		        this._lfoR.phase = 180;
		        /**
				 *  the base modulation frequency
				 *  @type {number}
				 *  @private
				 */
		        this._baseFrequency = options.baseFrequency;
		        /**
				 *  the octaves of the phasing
				 *  @type {number}
				 *  @private
				 */
		        this._octaves = options.octaves;
		        /**
				 *  The quality factor of the filters
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);
		        /**
				 *  the array of filters for the left side
				 *  @type {Array}
				 *  @private
				 */
		        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);
		        /**
				 *  the array of filters for the left side
				 *  @type {Array}
				 *  @private
				 */
		        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);
		        /**
				 * the frequency of the effect
				 * @type {Tone.Signal}
				 */
		        this.frequency = this._lfoL.frequency;
		        this.frequency.value = options.frequency;
		        //connect them up
		        this.effectSendL.connect(this._filtersL[0]);
		        this.effectSendR.connect(this._filtersR[0]);
		        this._filtersL[options.stages - 1].connect(this.effectReturnL);
		        this._filtersR[options.stages - 1].connect(this.effectReturnR);
		        //control the frequency with one LFO
		        this._lfoL.frequency.connect(this._lfoR.frequency);
		        //set the options
		        this.baseFrequency = options.baseFrequency;
		        this.octaves = options.octaves;
		        //start the lfo
		        this._lfoL.start();
		        this._lfoR.start();
		        this._readOnly([
		            'frequency',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.Phaser, Tone.StereoEffect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {object}
			 */
		    Tone.Phaser.defaults = {
		        'frequency': 0.5,
		        'octaves': 3,
		        'stages': 10,
		        'Q': 10,
		        'baseFrequency': 350
		    };
		    /**
			 *  @param {number} stages
			 *  @returns {Array} the number of filters all connected together
			 *  @private
			 */
		    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {
		        var filters = new Array(stages);
		        //make all the filters
		        for (var i = 0; i < stages; i++) {
		            var filter = this.context.createBiquadFilter();
		            filter.type = 'allpass';
		            Q.connect(filter.Q);
		            connectToFreq.connect(filter.frequency);
		            filters[i] = filter;
		        }
		        this.connectSeries.apply(this, filters);
		        return filters;
		    };
		    /**
			 * The number of octaves the phase goes above
			 * the baseFrequency
			 * @memberOf Tone.Phaser#
			 * @type {Positive}
			 * @name octaves
			 */
		    Object.defineProperty(Tone.Phaser.prototype, 'octaves', {
		        get: function () {
		            return this._octaves;
		        },
		        set: function (octaves) {
		            this._octaves = octaves;
		            var max = this._baseFrequency * Math.pow(2, octaves);
		            this._lfoL.max = max;
		            this._lfoR.max = max;
		        }
		    });
		    /**
			 * The the base frequency of the filters. 
			 * @memberOf Tone.Phaser#
			 * @type {number}
			 * @name baseFrequency
			 */
		    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {
		        get: function () {
		            return this._baseFrequency;
		        },
		        set: function (freq) {
		            this._baseFrequency = freq;
		            this._lfoL.min = freq;
		            this._lfoR.min = freq;
		            this.octaves = this._octaves;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.Phaser} this
			 */
		    Tone.Phaser.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'Q'
		        ]);
		        this.Q.dispose();
		        this.Q = null;
		        this._lfoL.dispose();
		        this._lfoL = null;
		        this._lfoR.dispose();
		        this._lfoR = null;
		        for (var i = 0; i < this._filtersL.length; i++) {
		            this._filtersL[i].disconnect();
		            this._filtersL[i] = null;
		        }
		        this._filtersL = null;
		        for (var j = 0; j < this._filtersR.length; j++) {
		            this._filtersR[j].disconnect();
		            this._filtersR[j] = null;
		        }
		        this._filtersR = null;
		        this.frequency = null;
		        return this;
		    };
		    return Tone.Phaser;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard
			 *          first in one channel and next in the opposite channel. In a stereo
			 *          system these are the right and left channels.
			 *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays 
			 *          with independent delay values. Each delay is routed to one channel
			 *          (left or right), and the channel triggered second will always 
			 *          trigger at the same interval after the first.
			 *
			 * 	@constructor
			 * 	@extends {Tone.StereoXFeedbackEffect}
			 *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.
			 *  @param {NormalRange=} feedback The amount of the effected signal which 
			 *                                 is fed back through the delay.
			 *  @example
			 * var pingPong = new Tone.PingPongDelay("4n", 0.2).toMaster();
			 * var drum = new Tone.DrumSynth().connect(pingPong);
			 * drum.triggerAttackRelease("C4", "32n");
			 */
		    Tone.PingPongDelay = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'feedback'
		        ], Tone.PingPongDelay.defaults);
		        Tone.StereoXFeedbackEffect.call(this, options);
		        /**
				 *  the delay node on the left side
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._leftDelay = new Tone.Delay(0, options.maxDelayTime);
		        /**
				 *  the delay node on the right side
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._rightDelay = new Tone.Delay(0, options.maxDelayTime);
		        /**
				 *  the predelay on the right side
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._rightPreDelay = new Tone.Delay(0, options.maxDelayTime);
		        /**
				 *  the delay time signal
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        //connect it up
		        this.effectSendL.chain(this._leftDelay, this.effectReturnL);
		        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);
		        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
		        //rearranged the feedback to be after the rightPreDelay
		        this._feedbackLR.disconnect();
		        this._feedbackLR.connect(this._rightDelay);
		        this._readOnly(['delayTime']);
		    };
		    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.PingPongDelay.defaults = {
		        'delayTime': 0.25,
		        'maxDelayTime': 1
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.PingPongDelay} this
			 */
		    Tone.PingPongDelay.prototype.dispose = function () {
		        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
		        this._leftDelay.dispose();
		        this._leftDelay = null;
		        this._rightDelay.dispose();
		        this._rightDelay = null;
		        this._rightPreDelay.dispose();
		        this._rightPreDelay = null;
		        this._writable(['delayTime']);
		        this.delayTime.dispose();
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.PingPongDelay;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PitchShift does near-realtime pitch shifting to the incoming signal. 
			 *         The effect is achieved by speeding up or slowing down the delayTime
			 *         of a DelayNode using a sawtooth wave. 
			 *         Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).
			 *         Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).
			 *         
			 *  @extends {Tone.FeedbackEffect}
			 *  @param {Interval=} pitch The interval to transpose the incoming signal by. 
			 */
		    Tone.PitchShift = function () {
		        var options = this.optionsObject(arguments, ['pitch'], Tone.PitchShift.defaults);
		        Tone.FeedbackEffect.call(this, options);
		        /**
				 *  The pitch signal
				 *  @type  {Tone.Signal}
				 *  @private
				 */
		        this._frequency = new Tone.Signal(0);
		        /**
				 *  Uses two DelayNodes to cover up the jump in
				 *  the sawtooth wave. 
				 *  @type  {DelayNode}
				 *  @private
				 */
		        this._delayA = new Tone.Delay(0, 1);
		        /**
				 *  The first LFO.
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._lfoA = new Tone.LFO({
		            'min': 0,
		            'max': 0.1,
		            'type': 'sawtooth'
		        }).connect(this._delayA.delayTime);
		        /**
				 *  The second DelayNode
				 *  @type  {DelayNode}
				 *  @private
				 */
		        this._delayB = new Tone.Delay(0, 1);
		        /**
				 *  The first LFO.
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._lfoB = new Tone.LFO({
		            'min': 0,
		            'max': 0.1,
		            'type': 'sawtooth',
		            'phase': 180
		        }).connect(this._delayB.delayTime);
		        /**
				 *  Crossfade quickly between the two delay lines
				 *  to cover up the jump in the sawtooth wave
				 *  @type  {Tone.CrossFade}
				 *  @private
				 */
		        this._crossFade = new Tone.CrossFade();
		        /**
				 *  LFO which alternates between the two
				 *  delay lines to cover up the disparity in the
				 *  sawtooth wave. 
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._crossFadeLFO = new Tone.LFO({
		            'min': 0,
		            'max': 1,
		            'type': 'triangle',
		            'phase': 90
		        }).connect(this._crossFade.fade);
		        /**
				 *  The delay node
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._feedbackDelay = new Tone.Delay(options.delayTime);
		        /**
				 *  The amount of delay on the input signal
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = this._feedbackDelay.delayTime;
		        this._readOnly('delayTime');
		        /**
				 *  Hold the current pitch
				 *  @type {Number}
				 *  @private
				 */
		        this._pitch = options.pitch;
		        /**
				 *  Hold the current windowSize
				 *  @type {Number}
				 *  @private
				 */
		        this._windowSize = options.windowSize;
		        //connect the two delay lines up
		        this._delayA.connect(this._crossFade.a);
		        this._delayB.connect(this._crossFade.b);
		        //connect the frequency
		        this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);
		        //route the input
		        this.effectSend.fan(this._delayA, this._delayB);
		        this._crossFade.chain(this._feedbackDelay, this.effectReturn);
		        //start the LFOs at the same time
		        var now = this.now();
		        this._lfoA.start(now);
		        this._lfoB.start(now);
		        this._crossFadeLFO.start(now);
		        //set the initial value
		        this.windowSize = this._windowSize;
		    };
		    Tone.extend(Tone.PitchShift, Tone.FeedbackEffect);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.PitchShift.defaults = {
		        'pitch': 0,
		        'windowSize': 0.1,
		        'delayTime': 0,
		        'feedback': 0
		    };
		    /**
			 * Repitch the incoming signal by some interval (measured
			 * in semi-tones). 
			 * @memberOf Tone.PitchShift#
			 * @type {Interval}
			 * @name pitch
			 * @example
			 * pitchShift.pitch = -12; //down one octave
			 * pitchShift.pitch = 7; //up a fifth
			 */
		    Object.defineProperty(Tone.PitchShift.prototype, 'pitch', {
		        get: function () {
		            return this._pitch;
		        },
		        set: function (interval) {
		            this._pitch = interval;
		            var factor = 0;
		            if (interval < 0) {
		                this._lfoA.min = 0;
		                this._lfoA.max = this._windowSize;
		                this._lfoB.min = 0;
		                this._lfoB.max = this._windowSize;
		                factor = this.intervalToFrequencyRatio(interval - 1) + 1;
		            } else {
		                this._lfoA.min = this._windowSize;
		                this._lfoA.max = 0;
		                this._lfoB.min = this._windowSize;
		                this._lfoB.max = 0;
		                factor = this.intervalToFrequencyRatio(interval) - 1;
		            }
		            this._frequency.value = factor * (1.2 / this._windowSize);
		        }
		    });
		    /**
			 * The window size corresponds roughly to the sample length in a looping sampler. 
			 * Smaller values are desirable for a less noticeable delay time of the pitch shifted
			 * signal, but larger values will result in smoother pitch shifting for larger intervals. 
			 * A nominal range of 0.03 to 0.1 is recommended. 
			 * @memberOf Tone.PitchShift#
			 * @type {Time}
			 * @name windowSize
			 * @example
			 * pitchShift.windowSize = 0.1;
			 */
		    Object.defineProperty(Tone.PitchShift.prototype, 'windowSize', {
		        get: function () {
		            return this._windowSize;
		        },
		        set: function (size) {
		            this._windowSize = this.toSeconds(size);
		            this.pitch = this._pitch;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return  {Tone.PitchShift}  this
			 */
		    Tone.PitchShift.prototype.dispose = function () {
		        Tone.FeedbackEffect.prototype.dispose.call(this);
		        this._frequency.dispose();
		        this._frequency = null;
		        this._delayA.disconnect();
		        this._delayA = null;
		        this._delayB.disconnect();
		        this._delayB = null;
		        this._lfoA.dispose();
		        this._lfoA = null;
		        this._lfoB.dispose();
		        this._lfoB = null;
		        this._crossFade.dispose();
		        this._crossFade = null;
		        this._crossFadeLFO.dispose();
		        this._crossFadeLFO = null;
		        this._writable('delayTime');
		        this._feedbackDelay.dispose();
		        this._feedbackDelay = null;
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.PitchShift;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Base class for stereo feedback effects where the effectReturn
			 *         is fed back into the same channel. 
			 *
			 *	@constructor
			 *	@extends {Tone.FeedbackEffect}
			 */
		    Tone.StereoFeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  controls the amount of feedback
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the left side feeback
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._feedbackL = new Tone.Gain();
		        /**
				 *  the right side feeback
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._feedbackR = new Tone.Gain();
		        //connect it up
		        this.effectReturnL.chain(this._feedbackL, this.effectSendL);
		        this.effectReturnR.chain(this._feedbackR, this.effectSendR);
		        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.StereoFeedbackEffect, Tone.FeedbackEffect);
		    /**
			 *  clean up
			 *  @returns {Tone.StereoFeedbackEffect} this
			 */
		    Tone.StereoFeedbackEffect.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackL.dispose();
		        this._feedbackL = null;
		        this._feedbackR.dispose();
		        this._feedbackR = null;
		        return this;
		    };
		    return Tone.StereoFeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Applies a width factor to the mid/side seperation. 
			 *         0 is all mid and 1 is all side.
			 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
			 *         <br><br>
			 *         <code>
			 *         Mid *= 2*(1-width)<br>
			 *         Side *= 2*width
			 *         </code>
			 *
			 *  @extends {Tone.MidSideEffect}
			 *  @constructor
			 *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.
			 */
		    Tone.StereoWidener = function () {
		        var options = this.optionsObject(arguments, ['width'], Tone.StereoWidener.defaults);
		        Tone.MidSideEffect.call(this, options);
		        /**
				 *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
		        /**
				 *  Mid multiplier
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');
		        /**
				 *  Side multiplier
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');
		        /**
				 *  constant output of 2
				 *  @type {Tone}
				 *  @private
				 */
		        this._two = new Tone.Signal(2);
		        //the mid chain
		        this._two.connect(this._midMult, 0, 1);
		        this.width.connect(this._midMult, 0, 2);
		        //the side chain
		        this._two.connect(this._sideMult, 0, 1);
		        this.width.connect(this._sideMult, 0, 2);
		        //connect it to the effect send/return
		        this.midSend.chain(this._midMult, this.midReturn);
		        this.sideSend.chain(this._sideMult, this.sideReturn);
		        this._readOnly(['width']);
		    };
		    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);
		    /**
			 *  the default values
			 *  @static
			 *  @type {Object}
			 */
		    Tone.StereoWidener.defaults = { 'width': 0.5 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.StereoWidener} this
			 */
		    Tone.StereoWidener.prototype.dispose = function () {
		        Tone.MidSideEffect.prototype.dispose.call(this);
		        this._writable(['width']);
		        this.width.dispose();
		        this.width = null;
		        this._midMult.dispose();
		        this._midMult = null;
		        this._sideMult.dispose();
		        this._sideMult = null;
		        this._two.dispose();
		        this._two = null;
		        return this;
		    };
		    return Tone.StereoWidener;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Tremolo modulates the amplitude of an incoming signal using a Tone.LFO.
			 *         The type, frequency, and depth of the LFO is controllable.
			 *
			 *  @extends {Tone.StereoEffect}
			 *  @constructor
			 *  @param {Frequency} [frequency] The rate of the effect.
			 *  @param {NormalRange} [depth] The depth of the effect.
			 *  @example
			 * //create a tremolo and start it's LFO
			 * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();
			 * //route an oscillator through the tremolo and start it
			 * var oscillator = new Tone.Oscillator().connect(tremolo).start();
			 */
		    Tone.Tremolo = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'depth'
		        ], Tone.Tremolo.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  The tremelo LFO in the left channel
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._lfoL = new Tone.LFO({
		            'phase': options.spread,
		            'min': 1,
		            'max': 0
		        });
		        /**
				 *  The tremelo LFO in the left channel
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._lfoR = new Tone.LFO({
		            'phase': options.spread,
		            'min': 1,
		            'max': 0
		        });
		        /**
				 *  Where the gain is multiplied
				 *  @type  {Tone.Gain}
				 *  @private
				 */
		        this._amplitudeL = new Tone.Gain();
		        /**
				 *  Where the gain is multiplied
				 *  @type  {Tone.Gain}
				 *  @private
				 */
		        this._amplitudeR = new Tone.Gain();
		        /**
				 *  The frequency of the tremolo.
				 *  @type  {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The depth of the effect. A depth of 0, has no effect
				 *  on the amplitude, and a depth of 1 makes the amplitude
				 *  modulate fully between 0 and 1.
				 *  @type  {NormalRange}
				 *  @signal
				 */
		        this.depth = new Tone.Signal(options.depth, Tone.Type.NormalRange);
		        this._readOnly([
		            'frequency',
		            'depth'
		        ]);
		        this.effectSendL.chain(this._amplitudeL, this.effectReturnL);
		        this.effectSendR.chain(this._amplitudeR, this.effectReturnR);
		        this._lfoL.connect(this._amplitudeL.gain);
		        this._lfoR.connect(this._amplitudeR.gain);
		        this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);
		        this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);
		        this.type = options.type;
		        this.spread = options.spread;
		    };
		    Tone.extend(Tone.Tremolo, Tone.StereoEffect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Tremolo.defaults = {
		        'frequency': 10,
		        'type': 'sine',
		        'depth': 0.5,
		        'spread': 180
		    };
		    /**
			 * Start the tremolo.
			 * @param {Time} [time=now] When the tremolo begins.
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.start = function (time) {
		        this._lfoL.start(time);
		        this._lfoR.start(time);
		        return this;
		    };
		    /**
			 * Stop the tremolo.
			 * @param {Time} [time=now] When the tremolo stops.
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.stop = function (time) {
		        this._lfoL.stop(time);
		        this._lfoR.stop(time);
		        return this;
		    };
		    /**
			 * Sync the effect to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                              Transport has started.
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.Tremolo.prototype.sync = function (delay) {
		        this._lfoL.sync(delay);
		        this._lfoR.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the filter from the transport
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.unsync = function () {
		        this._lfoL.unsync();
		        this._lfoR.unsync();
		        return this;
		    };
		    /**
			 * The Tremolo's oscillator type.
			 * @memberOf Tone.Tremolo#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Tremolo.prototype, 'type', {
		        get: function () {
		            return this._lfoL.type;
		        },
		        set: function (type) {
		            this._lfoL.type = type;
		            this._lfoR.type = type;
		        }
		    });
		    /** 
			 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
			 * When set to 180, LFO's will be panned hard left and right respectively.
			 * @memberOf Tone.Tremolo#
			 * @type {Degrees}
			 * @name spread
			 */
		    Object.defineProperty(Tone.Tremolo.prototype, 'spread', {
		        get: function () {
		            return this._lfoR.phase - this._lfoL.phase;    //180
		        },
		        set: function (spread) {
		            this._lfoL.phase = 90 - spread / 2;
		            this._lfoR.phase = spread / 2 + 90;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'depth'
		        ]);
		        this._lfoL.dispose();
		        this._lfoL = null;
		        this._lfoR.dispose();
		        this._lfoR = null;
		        this._amplitudeL.dispose();
		        this._amplitudeL = null;
		        this._amplitudeR.dispose();
		        this._amplitudeR = null;
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.Tremolo;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO
			 *         modulates the delayTime of the delay, causing the pitch to rise
			 *         and fall. 
			 *  @extends {Tone.Effect}
			 *  @param {Frequency} frequency The frequency of the vibrato.
			 *  @param {NormalRange} depth The amount the pitch is modulated.
			 */
		    Tone.Vibrato = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'depth'
		        ], Tone.Vibrato.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The delay node used for the vibrato effect
				 *  @type {Tone.Delay}
				 *  @private
				 */
		        this._delayNode = new Tone.Delay(0, options.maxDelay);
		        /**
				 *  The LFO used to control the vibrato
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'type': options.type,
		            'min': 0,
		            'max': options.maxDelay,
		            'frequency': options.frequency,
		            'phase': -90    //offse the phase so the resting position is in the center
		        }).start().connect(this._delayNode.delayTime);
		        /**
				 *  The frequency of the vibrato
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._lfo.frequency;
		        /**
				 *  The depth of the vibrato. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.depth = this._lfo.amplitude;
		        this.depth.value = options.depth;
		        this._readOnly([
		            'frequency',
		            'depth'
		        ]);
		        this.effectSend.chain(this._delayNode, this.effectReturn);
		    };
		    Tone.extend(Tone.Vibrato, Tone.Effect);
		    /**
			 *  The defaults
			 *  @type  {Object}
			 *  @const
			 */
		    Tone.Vibrato.defaults = {
		        'maxDelay': 0.005,
		        'frequency': 5,
		        'depth': 0.1,
		        'type': 'sine'
		    };
		    /**
			 * Type of oscillator attached to the Vibrato.
			 * @memberOf Tone.Vibrato#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Vibrato.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Vibrato} this
			 */
		    Tone.Vibrato.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._delayNode.dispose();
		        this._delayNode = null;
		        this._lfo.dispose();
		        this._lfo = null;
		        this._writable([
		            'frequency',
		            'depth'
		        ]);
		        this.frequency = null;
		        this.depth = null;
		    };
		    return Tone.Vibrato;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Event abstracts away Tone.Transport.schedule and provides a schedulable
			 *          callback for a single or repeatable events along the timeline. 
			 *
			 *  @extends {Tone}
			 *  @param {function} callback The callback to invoke at the time. 
			 *  @param {*} value The value or values which should be passed to
			 *                      the callback function on invocation.  
			 *  @example
			 * var chord = new Tone.Event(function(time, chord){
			 * 	//the chord as well as the exact time of the event
			 * 	//are passed in as arguments to the callback function
			 * }, ["D4", "E4", "F4"]);
			 * //start the chord at the beginning of the transport timeline
			 * chord.start();
			 * //loop it every measure for 8 measures
			 * chord.loop = 8;
			 * chord.loopEnd = "1m";
			 */
		    Tone.Event = function () {
		        var options = this.optionsObject(arguments, [
		            'callback',
		            'value'
		        ], Tone.Event.defaults);
		        /**
				 *  Loop value
				 *  @type  {Boolean|Positive}
				 *  @private
				 */
		        this._loop = options.loop;
		        /**
				 *  The callback to invoke. 
				 *  @type  {Function}
				 */
		        this.callback = options.callback;
		        /**
				 *  The value which is passed to the
				 *  callback function.
				 *  @type  {*}
				 *  @private
				 */
		        this.value = options.value;
		        /**
				 *  When the note is scheduled to start.
				 *  @type  {Number}
				 *  @private
				 */
		        this._loopStart = this.toTicks(options.loopStart);
		        /**
				 *  When the note is scheduled to start.
				 *  @type  {Number}
				 *  @private
				 */
		        this._loopEnd = this.toTicks(options.loopEnd);
		        /**
				 *  Tracks the scheduled events
				 *  @type {Tone.TimelineState}
				 *  @private
				 */
		        this._state = new Tone.TimelineState(Tone.State.Stopped);
		        /**
				 *  The playback speed of the note. A speed of 1
				 *  is no change. 
				 *  @private
				 *  @type {Positive}
				 */
		        this._playbackRate = 1;
		        /**
				 *  A delay time from when the event is scheduled to start
				 *  @type {Ticks}
				 *  @private
				 */
		        this._startOffset = 0;
		        /**
				 *  The probability that the callback will be invoked
				 *  at the scheduled time. 
				 *  @type {NormalRange}
				 *  @example
				 * //the callback will be invoked 50% of the time
				 * event.probability = 0.5;
				 */
		        this.probability = options.probability;
		        /**
				 *  If set to true, will apply small (+/-0.02 seconds) random variation
				 *  to the callback time. If the value is given as a time, it will randomize
				 *  by that amount.
				 *  @example
				 * event.humanize = true;
				 *  @type {Boolean|Time}
				 */
		        this.humanize = options.humanize;
		        /**
				 *  If mute is true, the callback won't be
				 *  invoked.
				 *  @type {Boolean}
				 */
		        this.mute = options.mute;
		        //set the initial values
		        this.playbackRate = options.playbackRate;
		    };
		    Tone.extend(Tone.Event);
		    /**
			 *  The default values
			 *  @type  {Object}
			 *  @const
			 */
		    Tone.Event.defaults = {
		        'callback': Tone.noOp,
		        'loop': false,
		        'loopEnd': '1m',
		        'loopStart': 0,
		        'playbackRate': 1,
		        'value': null,
		        'probability': 1,
		        'mute': false,
		        'humanize': false
		    };
		    /**
			 *  Reschedule all of the events along the timeline
			 *  with the updated values.
			 *  @param {Time} after Only reschedules events after the given time.
			 *  @return  {Tone.Event}  this
			 *  @private
			 */
		    Tone.Event.prototype._rescheduleEvents = function (after) {
		        //if no argument is given, schedules all of the events
		        after = this.defaultArg(after, -1);
		        this._state.forEachFrom(after, function (event) {
		            var duration;
		            if (event.state === Tone.State.Started) {
		                if (!this.isUndef(event.id)) {
		                    Tone.Transport.clear(event.id);
		                }
		                var startTick = event.time + Math.round(this.startOffset / this._playbackRate);
		                if (this._loop) {
		                    duration = Infinity;
		                    if (this.isNumber(this._loop)) {
		                        duration = this._loop * this._getLoopDuration();
		                    }
		                    var nextEvent = this._state.getAfter(startTick);
		                    if (nextEvent !== null) {
		                        duration = Math.min(duration, nextEvent.time - startTick);
		                    }
		                    if (duration !== Infinity) {
		                        //schedule a stop since it's finite duration
		                        this._state.setStateAtTime(Tone.State.Stopped, startTick + duration + 1);
		                        duration = Tone.Time(duration, 'i');
		                    }
		                    var interval = Tone.Time(this._getLoopDuration(), 'i');
		                    event.id = Tone.Transport.scheduleRepeat(this._tick.bind(this), interval, Tone.TransportTime(startTick, 'i'), duration);
		                } else {
		                    event.id = Tone.Transport.schedule(this._tick.bind(this), startTick + 'i');
		                }
		            }
		        }.bind(this));
		        return this;
		    };
		    /**
			 *  Returns the playback state of the note, either "started" or "stopped".
			 *  @type {String}
			 *  @readOnly
			 *  @memberOf Tone.Event#
			 *  @name state
			 */
		    Object.defineProperty(Tone.Event.prototype, 'state', {
		        get: function () {
		            return this._state.getValueAtTime(Tone.Transport.ticks);
		        }
		    });
		    /**
			 *  The start from the scheduled start time
			 *  @type {Ticks}
			 *  @memberOf Tone.Event#
			 *  @name startOffset
			 *  @private
			 */
		    Object.defineProperty(Tone.Event.prototype, 'startOffset', {
		        get: function () {
		            return this._startOffset;
		        },
		        set: function (offset) {
		            this._startOffset = offset;
		        }
		    });
		    /**
			 *  Start the note at the given time. 
			 *  @param  {TimelinePosition}  time  When the note should start.
			 *  @return  {Tone.Event}  this
			 */
		    Tone.Event.prototype.start = function (time) {
		        time = this.toTicks(time);
		        if (this._state.getValueAtTime(time) === Tone.State.Stopped) {
		            this._state.add({
		                'state': Tone.State.Started,
		                'time': time,
		                'id': undefined
		            });
		            this._rescheduleEvents(time);
		        }
		        return this;
		    };
		    /**
			 *  Stop the Event at the given time.
			 *  @param  {TimelinePosition}  time  When the note should stop.
			 *  @return  {Tone.Event}  this
			 */
		    Tone.Event.prototype.stop = function (time) {
		        this.cancel(time);
		        time = this.toTicks(time);
		        if (this._state.getValueAtTime(time) === Tone.State.Started) {
		            this._state.setStateAtTime(Tone.State.Stopped, time);
		            var previousEvent = this._state.getBefore(time);
		            var reschedulTime = time;
		            if (previousEvent !== null) {
		                reschedulTime = previousEvent.time;
		            }
		            this._rescheduleEvents(reschedulTime);
		        }
		        return this;
		    };
		    /**
			 *  Cancel all scheduled events greater than or equal to the given time
			 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
			 *  @return  {Tone.Event}  this
			 */
		    Tone.Event.prototype.cancel = function (time) {
		        time = this.defaultArg(time, -Infinity);
		        time = this.toTicks(time);
		        this._state.forEachFrom(time, function (event) {
		            Tone.Transport.clear(event.id);
		        });
		        this._state.cancel(time);
		        return this;
		    };
		    /**
			 *  The callback function invoker. Also 
			 *  checks if the Event is done playing
			 *  @param  {Number}  time  The time of the event in seconds
			 *  @private
			 */
		    Tone.Event.prototype._tick = function (time) {
		        if (!this.mute && this._state.getValueAtTime(Tone.Transport.ticks) === Tone.State.Started) {
		            if (this.probability < 1 && Math.random() > this.probability) {
		                return;
		            }
		            if (this.humanize) {
		                var variation = 0.02;
		                if (!this.isBoolean(this.humanize)) {
		                    variation = this.toSeconds(this.humanize);
		                }
		                time += (Math.random() * 2 - 1) * variation;
		            }
		            this.callback(time, this.value);
		        }
		    };
		    /**
			 *  Get the duration of the loop.
			 *  @return  {Ticks}
			 *  @private
			 */
		    Tone.Event.prototype._getLoopDuration = function () {
		        return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);
		    };
		    /**
			 *  If the note should loop or not
			 *  between Tone.Event.loopStart and 
			 *  Tone.Event.loopEnd. An integer
			 *  value corresponds to the number of
			 *  loops the Event does after it starts.
			 *  @memberOf Tone.Event#
			 *  @type {Boolean|Positive}
			 *  @name loop
			 */
		    Object.defineProperty(Tone.Event.prototype, 'loop', {
		        get: function () {
		            return this._loop;
		        },
		        set: function (loop) {
		            this._loop = loop;
		            this._rescheduleEvents();
		        }
		    });
		    /**
			 * 	The playback rate of the note. Defaults to 1.
			 *  @memberOf Tone.Event#
			 *  @type {Positive}
			 *  @name playbackRate
			 *  @example
			 * note.loop = true;
			 * //repeat the note twice as fast
			 * note.playbackRate = 2;
			 */
		    Object.defineProperty(Tone.Event.prototype, 'playbackRate', {
		        get: function () {
		            return this._playbackRate;
		        },
		        set: function (rate) {
		            this._playbackRate = rate;
		            this._rescheduleEvents();
		        }
		    });
		    /**
			 *  The loopEnd point is the time the event will loop
			 *  if Tone.Event.loop is true.
			 *  @memberOf Tone.Event#
			 *  @type {TransportTime}
			 *  @name loopEnd
			 */
		    Object.defineProperty(Tone.Event.prototype, 'loopEnd', {
		        get: function () {
		            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
		        },
		        set: function (loopEnd) {
		            this._loopEnd = this.toTicks(loopEnd);
		            if (this._loop) {
		                this._rescheduleEvents();
		            }
		        }
		    });
		    /**
			 *  The time when the loop should start. 
			 *  @memberOf Tone.Event#
			 *  @type {TransportTime}
			 *  @name loopStart
			 */
		    Object.defineProperty(Tone.Event.prototype, 'loopStart', {
		        get: function () {
		            return Tone.TransportTime(this._loopStart, 'i').toNotation();
		        },
		        set: function (loopStart) {
		            this._loopStart = this.toTicks(loopStart);
		            if (this._loop) {
		                this._rescheduleEvents();
		            }
		        }
		    });
		    /**
			 *  The current progress of the loop interval.
			 *  Returns 0 if the event is not started yet or
			 *  it is not set to loop.
			 *  @memberOf Tone.Event#
			 *  @type {NormalRange}
			 *  @name progress
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Event.prototype, 'progress', {
		        get: function () {
		            if (this._loop) {
		                var ticks = Tone.Transport.ticks;
		                var lastEvent = this._state.get(ticks);
		                if (lastEvent !== null && lastEvent.state === Tone.State.Started) {
		                    var loopDuration = this._getLoopDuration();
		                    var progress = (ticks - lastEvent.time) % loopDuration;
		                    return progress / loopDuration;
		                } else {
		                    return 0;
		                }
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 *  Clean up
			 *  @return  {Tone.Event}  this
			 */
		    Tone.Event.prototype.dispose = function () {
		        this.cancel();
		        this._state.dispose();
		        this._state = null;
		        this.callback = null;
		        this.value = null;
		    };
		    return Tone.Event;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.Loop creates a looped callback at the 
			 *         specified interval. The callback can be 
			 *         started, stopped and scheduled along
			 *         the Transport's timeline. 
			 *  @example
			 * var loop = new Tone.Loop(function(time){
			 * 	//triggered every eighth note. 
			 * 	console.log(time);
			 * }, "8n").start(0);
			 * Tone.Transport.start();
			 *  @extends {Tone}
			 *  @param {Function} callback The callback to invoke with the event.
			 *  @param {Time} interval The time between successive callback calls. 
			 */
		    Tone.Loop = function () {
		        var options = this.optionsObject(arguments, [
		            'callback',
		            'interval'
		        ], Tone.Loop.defaults);
		        /**
				 *  The event which produces the callbacks
				 */
		        this._event = new Tone.Event({
		            'callback': this._tick.bind(this),
		            'loop': true,
		            'loopEnd': options.interval,
		            'playbackRate': options.playbackRate,
		            'probability': options.probability
		        });
		        /**
				 *  The callback to invoke with the next event in the pattern
				 *  @type {Function}
				 */
		        this.callback = options.callback;
		        //set the iterations
		        this.iterations = options.iterations;
		    };
		    Tone.extend(Tone.Loop);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Loop.defaults = {
		        'interval': '4n',
		        'callback': Tone.noOp,
		        'playbackRate': 1,
		        'iterations': Infinity,
		        'probability': true,
		        'mute': false
		    };
		    /**
			 *  Start the loop at the specified time along the Transport's
			 *  timeline.
			 *  @param  {TimelinePosition=}  time  When to start the Loop.
			 *  @return  {Tone.Loop}  this
			 */
		    Tone.Loop.prototype.start = function (time) {
		        this._event.start(time);
		        return this;
		    };
		    /**
			 *  Stop the loop at the given time.
			 *  @param  {TimelinePosition=}  time  When to stop the Arpeggio
			 *  @return  {Tone.Loop}  this
			 */
		    Tone.Loop.prototype.stop = function (time) {
		        this._event.stop(time);
		        return this;
		    };
		    /**
			 *  Cancel all scheduled events greater than or equal to the given time
			 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
			 *  @return  {Tone.Loop}  this
			 */
		    Tone.Loop.prototype.cancel = function (time) {
		        this._event.cancel(time);
		        return this;
		    };
		    /**
			 *  Internal function called when the notes should be called
			 *  @param  {Number}  time  The time the event occurs
			 *  @private
			 */
		    Tone.Loop.prototype._tick = function (time) {
		        this.callback(time);
		    };
		    /**
			 *  The state of the Loop, either started or stopped.
			 *  @memberOf Tone.Loop#
			 *  @type {String}
			 *  @name state
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'state', {
		        get: function () {
		            return this._event.state;
		        }
		    });
		    /**
			 *  The progress of the loop as a value between 0-1. 0, when
			 *  the loop is stopped or done iterating. 
			 *  @memberOf Tone.Loop#
			 *  @type {NormalRange}
			 *  @name progress
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'progress', {
		        get: function () {
		            return this._event.progress;
		        }
		    });
		    /**
			 *  The time between successive callbacks. 
			 *  @example
			 * loop.interval = "8n"; //loop every 8n
			 *  @memberOf Tone.Loop#
			 *  @type {Time}
			 *  @name interval
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'interval', {
		        get: function () {
		            return this._event.loopEnd;
		        },
		        set: function (interval) {
		            this._event.loopEnd = interval;
		        }
		    });
		    /**
			 *  The playback rate of the loop. The normal playback rate is 1 (no change). 
			 *  A `playbackRate` of 2 would be twice as fast. 
			 *  @memberOf Tone.Loop#
			 *  @type {Time}
			 *  @name playbackRate
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'playbackRate', {
		        get: function () {
		            return this._event.playbackRate;
		        },
		        set: function (rate) {
		            this._event.playbackRate = rate;
		        }
		    });
		    /**
			 *  Random variation +/-0.01s to the scheduled time. 
			 *  Or give it a time value which it will randomize by.
			 *  @type {Boolean|Time}
			 *  @memberOf Tone.Loop#
			 *  @name humanize
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'humanize', {
		        get: function () {
		            return this._event.humanize;
		        },
		        set: function (variation) {
		            this._event.humanize = variation;
		        }
		    });
		    /**
			 *  The probably of the callback being invoked.
			 *  @memberOf Tone.Loop#
			 *  @type {NormalRange}
			 *  @name probability
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'probability', {
		        get: function () {
		            return this._event.probability;
		        },
		        set: function (prob) {
		            this._event.probability = prob;
		        }
		    });
		    /**
			 *  Muting the Loop means that no callbacks are invoked.
			 *  @memberOf Tone.Loop#
			 *  @type {Boolean}
			 *  @name mute
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'mute', {
		        get: function () {
		            return this._event.mute;
		        },
		        set: function (mute) {
		            this._event.mute = mute;
		        }
		    });
		    /**
			 *  The number of iterations of the loop. The default
			 *  value is Infinity (loop forever).
			 *  @memberOf Tone.Loop#
			 *  @type {Positive}
			 *  @name iterations
			 */
		    Object.defineProperty(Tone.Loop.prototype, 'iterations', {
		        get: function () {
		            if (this._event.loop === true) {
		                return Infinity;
		            } else {
		                return this._event.loop;
		            }
		            return this._pattern.index;
		        },
		        set: function (iters) {
		            if (iters === Infinity) {
		                this._event.loop = true;
		            } else {
		                this._event.loop = iters;
		            }
		        }
		    });
		    /**
			 *  Clean up
			 *  @return  {Tone.Loop}  this
			 */
		    Tone.Loop.prototype.dispose = function () {
		        this._event.dispose();
		        this._event = null;
		        this.callback = null;
		    };
		    return Tone.Loop;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Part is a collection Tone.Events which can be
			 *         started/stoped and looped as a single unit.
			 *
			 *  @extends {Tone.Event}
			 *  @param {Function} callback The callback to invoke on each event
			 *  @param {Array} events the array of events
			 *  @example
			 * var part = new Tone.Part(function(time, note){
			 * 	//the notes given as the second element in the array
			 * 	//will be passed in as the second argument
			 * 	synth.triggerAttackRelease(note, "8n", time);
			 * }, [[0, "C2"], ["0:2", "C3"], ["0:3:2", "G2"]]);
			 *  @example
			 * //use an array of objects as long as the object has a "time" attribute
			 * var part = new Tone.Part(function(time, value){
			 * 	//the value is an object which contains both the note and the velocity
			 * 	synth.triggerAttackRelease(value.note, "8n", time, value.velocity);
			 * }, [{"time" : 0, "note" : "C3", "velocity": 0.9}, 
			 * 	   {"time" : "0:2", "note" : "C4", "velocity": 0.5}
			 * ]).start(0);
			 */
		    Tone.Part = function () {
		        var options = this.optionsObject(arguments, [
		            'callback',
		            'events'
		        ], Tone.Part.defaults);
		        /**
				 *  If the part is looping or not
				 *  @type  {Boolean|Positive}
				 *  @private
				 */
		        this._loop = options.loop;
		        /**
				 *  When the note is scheduled to start.
				 *  @type  {Ticks}
				 *  @private
				 */
		        this._loopStart = this.toTicks(options.loopStart);
		        /**
				 *  When the note is scheduled to start.
				 *  @type  {Ticks}
				 *  @private
				 */
		        this._loopEnd = this.toTicks(options.loopEnd);
		        /**
				 *  The playback rate of the part
				 *  @type  {Positive}
				 *  @private
				 */
		        this._playbackRate = options.playbackRate;
		        /**
				 *  private holder of probability value
				 *  @type {NormalRange}
				 *  @private
				 */
		        this._probability = options.probability;
		        /**
				 *  the amount of variation from the
				 *  given time. 
				 *  @type {Boolean|Time}
				 *  @private
				 */
		        this._humanize = options.humanize;
		        /**
				 *  The start offset
				 *  @type {Ticks}
				 *  @private
				 */
		        this._startOffset = 0;
		        /**
				 *  Keeps track of the current state
				 *  @type {Tone.TimelineState}
				 *  @private
				 */
		        this._state = new Tone.TimelineState(Tone.State.Stopped);
		        /**
				 *  An array of Objects. 
				 *  @type  {Array}
				 *  @private
				 */
		        this._events = [];
		        /**
				 *  The callback to invoke at all the scheduled events.
				 *  @type {Function}
				 */
		        this.callback = options.callback;
		        /**
				 *  If mute is true, the callback won't be
				 *  invoked.
				 *  @type {Boolean}
				 */
		        this.mute = options.mute;
		        //add the events
		        var events = this.defaultArg(options.events, []);
		        if (!this.isUndef(options.events)) {
		            for (var i = 0; i < events.length; i++) {
		                if (Array.isArray(events[i])) {
		                    this.add(events[i][0], events[i][1]);
		                } else {
		                    this.add(events[i]);
		                }
		            }
		        }
		    };
		    Tone.extend(Tone.Part, Tone.Event);
		    /**
			 *  The default values
			 *  @type  {Object}
			 *  @const
			 */
		    Tone.Part.defaults = {
		        'callback': Tone.noOp,
		        'loop': false,
		        'loopEnd': '1m',
		        'loopStart': 0,
		        'playbackRate': 1,
		        'probability': 1,
		        'humanize': false,
		        'mute': false
		    };
		    /**
			 *  Start the part at the given time. 
			 *  @param  {TransportTime}  time    When to start the part.
			 *  @param  {Time=}  offset  The offset from the start of the part
			 *                           to begin playing at.
			 *  @return  {Tone.Part}  this
			 */
		    Tone.Part.prototype.start = function (time, offset) {
		        var ticks = this.toTicks(time);
		        if (this._state.getValueAtTime(ticks) !== Tone.State.Started) {
		            if (this._loop) {
		                offset = this.defaultArg(offset, this._loopStart);
		            } else {
		                offset = this.defaultArg(offset, 0);
		            }
		            offset = this.toTicks(offset);
		            this._state.add({
		                'state': Tone.State.Started,
		                'time': ticks,
		                'offset': offset
		            });
		            this._forEach(function (event) {
		                this._startNote(event, ticks, offset);
		            });
		        }
		        return this;
		    };
		    /**
			 *  Start the event in the given event at the correct time given
			 *  the ticks and offset and looping.
			 *  @param  {Tone.Event}  event 
			 *  @param  {Ticks}  ticks
			 *  @param  {Ticks}  offset
			 *  @private
			 */
		    Tone.Part.prototype._startNote = function (event, ticks, offset) {
		        ticks -= offset;
		        if (this._loop) {
		            if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
		                if (event.startOffset < offset) {
		                    //start it on the next loop
		                    ticks += this._getLoopDuration();
		                }
		                event.start(Tone.TransportTime(ticks, 'i'));
		            } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
		                event.loop = false;
		                event.start(Tone.TransportTime(ticks, 'i'));
		            }
		        } else {
		            if (event.startOffset >= offset) {
		                event.start(Tone.TransportTime(ticks, 'i'));
		            }
		        }
		    };
		    /**
			 *  The start from the scheduled start time
			 *  @type {Ticks}
			 *  @memberOf Tone.Part#
			 *  @name startOffset
			 *  @private
			 */
		    Object.defineProperty(Tone.Part.prototype, 'startOffset', {
		        get: function () {
		            return this._startOffset;
		        },
		        set: function (offset) {
		            this._startOffset = offset;
		            this._forEach(function (event) {
		                event.startOffset += this._startOffset;
		            });
		        }
		    });
		    /**
			 *  Stop the part at the given time.
			 *  @param  {TimelinePosition}  time  When to stop the part.
			 *  @return  {Tone.Part}  this
			 */
		    Tone.Part.prototype.stop = function (time) {
		        var ticks = this.toTicks(time);
		        this._state.cancel(ticks);
		        this._state.setStateAtTime(Tone.State.Stopped, ticks);
		        this._forEach(function (event) {
		            event.stop(time);
		        });
		        return this;
		    };
		    /**
			 *  Get/Set an Event's value at the given time. 
			 *  If a value is passed in and no event exists at
			 *  the given time, one will be created with that value. 
			 *  If two events are at the same time, the first one will
			 *  be returned.
			 *  @example
			 * part.at("1m"); //returns the part at the first measure
			 *
			 * part.at("2m", "C2"); //set the value at "2m" to C2. 
			 * //if an event didn't exist at that time, it will be created.
			 *  @param {TransportTime} time The time of the event to get or set.
			 *  @param {*=} value If a value is passed in, the value of the
			 *                    event at the given time will be set to it.
			 *  @return {Tone.Event} the event at the time
			 */
		    Tone.Part.prototype.at = function (time, value) {
		        time = Tone.TransportTime(time);
		        var tickTime = Tone.Time(1, 'i').toSeconds();
		        for (var i = 0; i < this._events.length; i++) {
		            var event = this._events[i];
		            if (Math.abs(time.toTicks() - event.startOffset) < tickTime) {
		                if (!this.isUndef(value)) {
		                    event.value = value;
		                }
		                return event;
		            }
		        }
		        //if there was no event at that time, create one
		        if (!this.isUndef(value)) {
		            this.add(time, value);
		            //return the new event
		            return this._events[this._events.length - 1];
		        } else {
		            return null;
		        }
		    };
		    /**
			 *  Add a an event to the part. 
			 *  @param {Time} time The time the note should start.
			 *                            If an object is passed in, it should
			 *                            have a 'time' attribute and the rest
			 *                            of the object will be used as the 'value'.
			 *  @param  {Tone.Event|*}  value 
			 *  @returns {Tone.Part} this
			 *  @example
			 * part.add("1m", "C#+11");
			 */
		    Tone.Part.prototype.add = function (time, value) {
		        //extract the parameters
		        if (time.hasOwnProperty('time')) {
		            value = time;
		            time = value.time;
		        }
		        time = this.toTicks(time);
		        var event;
		        if (value instanceof Tone.Event) {
		            event = value;
		            event.callback = this._tick.bind(this);
		        } else {
		            event = new Tone.Event({
		                'callback': this._tick.bind(this),
		                'value': value
		            });
		        }
		        //the start offset
		        event.startOffset = time;
		        //initialize the values
		        event.set({
		            'loopEnd': this.loopEnd,
		            'loopStart': this.loopStart,
		            'loop': this.loop,
		            'humanize': this.humanize,
		            'playbackRate': this.playbackRate,
		            'probability': this.probability
		        });
		        this._events.push(event);
		        //start the note if it should be played right now
		        this._restartEvent(event);
		        return this;
		    };
		    /**
			 *  Restart the given event
			 *  @param  {Tone.Event}  event 
			 *  @private
			 */
		    Tone.Part.prototype._restartEvent = function (event) {
		        this._state.forEach(function (stateEvent) {
		            if (stateEvent.state === Tone.State.Started) {
		                this._startNote(event, stateEvent.time, stateEvent.offset);
		            } else {
		                //stop the note
		                event.stop(Tone.TransportTime(stateEvent.time, 'i'));
		            }
		        }.bind(this));
		    };
		    /**
			 *  Remove an event from the part. Will recursively iterate
			 *  into nested parts to find the event.
			 *  @param {Time} time The time of the event
			 *  @param {*} value Optionally select only a specific event value
			 *  @return  {Tone.Part}  this
			 */
		    Tone.Part.prototype.remove = function (time, value) {
		        //extract the parameters
		        if (time.hasOwnProperty('time')) {
		            value = time;
		            time = value.time;
		        }
		        time = this.toTicks(time);
		        for (var i = this._events.length - 1; i >= 0; i--) {
		            var event = this._events[i];
		            if (event instanceof Tone.Part) {
		                event.remove(time, value);
		            } else {
		                if (event.startOffset === time) {
		                    if (this.isUndef(value) || !this.isUndef(value) && event.value === value) {
		                        this._events.splice(i, 1);
		                        event.dispose();
		                    }
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Remove all of the notes from the group. 
			 *  @return  {Tone.Part}  this
			 */
		    Tone.Part.prototype.removeAll = function () {
		        this._forEach(function (event) {
		            event.dispose();
		        });
		        this._events = [];
		        return this;
		    };
		    /**
			 *  Cancel scheduled state change events: i.e. "start" and "stop".
			 *  @param {TimelinePosition} after The time after which to cancel the scheduled events.
			 *  @return  {Tone.Part}  this
			 */
		    Tone.Part.prototype.cancel = function (after) {
		        after = this.toTicks(after);
		        this._forEach(function (event) {
		            event.cancel(after);
		        });
		        this._state.cancel(after);
		        return this;
		    };
		    /**
			 *  Iterate over all of the events
			 *  @param {Function} callback
			 *  @param {Object} ctx The context
			 *  @private
			 */
		    Tone.Part.prototype._forEach = function (callback, ctx) {
		        ctx = this.defaultArg(ctx, this);
		        for (var i = this._events.length - 1; i >= 0; i--) {
		            var e = this._events[i];
		            if (e instanceof Tone.Part) {
		                e._forEach(callback, ctx);
		            } else {
		                callback.call(ctx, e);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Set the attribute of all of the events
			 *  @param  {String}  attr  the attribute to set
			 *  @param  {*}  value      The value to set it to
			 *  @private
			 */
		    Tone.Part.prototype._setAll = function (attr, value) {
		        this._forEach(function (event) {
		            event[attr] = value;
		        });
		    };
		    /**
			 *  Internal tick method
			 *  @param  {Number}  time  The time of the event in seconds
			 *  @private
			 */
		    Tone.Part.prototype._tick = function (time, value) {
		        if (!this.mute) {
		            this.callback(time, value);
		        }
		    };
		    /**
			 *  Determine if the event should be currently looping
			 *  given the loop boundries of this Part.
			 *  @param  {Tone.Event}  event  The event to test
			 *  @private
			 */
		    Tone.Part.prototype._testLoopBoundries = function (event) {
		        if (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd) {
		            event.cancel(0);
		        } else {
		            //reschedule it if it's stopped
		            if (event.state === Tone.State.Stopped) {
		                this._restartEvent(event);
		            }
		        }
		    };
		    /**
			 *  The probability of the notes being triggered.
			 *  @memberOf Tone.Part#
			 *  @type {NormalRange}
			 *  @name probability
			 */
		    Object.defineProperty(Tone.Part.prototype, 'probability', {
		        get: function () {
		            return this._probability;
		        },
		        set: function (prob) {
		            this._probability = prob;
		            this._setAll('probability', prob);
		        }
		    });
		    /**
			 *  If set to true, will apply small random variation
			 *  to the callback time. If the value is given as a time, it will randomize
			 *  by that amount.
			 *  @example
			 * event.humanize = true;
			 *  @type {Boolean|Time}
			 *  @name humanize
			 */
		    Object.defineProperty(Tone.Part.prototype, 'humanize', {
		        get: function () {
		            return this._humanize;
		        },
		        set: function (variation) {
		            this._humanize = variation;
		            this._setAll('humanize', variation);
		        }
		    });
		    /**
			 *  If the part should loop or not
			 *  between Tone.Part.loopStart and 
			 *  Tone.Part.loopEnd. An integer
			 *  value corresponds to the number of
			 *  loops the Part does after it starts.
			 *  @memberOf Tone.Part#
			 *  @type {Boolean|Positive}
			 *  @name loop
			 *  @example
			 * //loop the part 8 times
			 * part.loop = 8;
			 */
		    Object.defineProperty(Tone.Part.prototype, 'loop', {
		        get: function () {
		            return this._loop;
		        },
		        set: function (loop) {
		            this._loop = loop;
		            this._forEach(function (event) {
		                event._loopStart = this._loopStart;
		                event._loopEnd = this._loopEnd;
		                event.loop = loop;
		                this._testLoopBoundries(event);
		            });
		        }
		    });
		    /**
			 *  The loopEnd point determines when it will 
			 *  loop if Tone.Part.loop is true.
			 *  @memberOf Tone.Part#
			 *  @type {TransportTime}
			 *  @name loopEnd
			 */
		    Object.defineProperty(Tone.Part.prototype, 'loopEnd', {
		        get: function () {
		            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
		        },
		        set: function (loopEnd) {
		            this._loopEnd = this.toTicks(loopEnd);
		            if (this._loop) {
		                this._forEach(function (event) {
		                    event.loopEnd = loopEnd;
		                    this._testLoopBoundries(event);
		                });
		            }
		        }
		    });
		    /**
			 *  The loopStart point determines when it will 
			 *  loop if Tone.Part.loop is true.
			 *  @memberOf Tone.Part#
			 *  @type {TransportTime}
			 *  @name loopStart
			 */
		    Object.defineProperty(Tone.Part.prototype, 'loopStart', {
		        get: function () {
		            return Tone.TransportTime(this._loopStart, 'i').toNotation();
		        },
		        set: function (loopStart) {
		            this._loopStart = this.toTicks(loopStart);
		            if (this._loop) {
		                this._forEach(function (event) {
		                    event.loopStart = this.loopStart;
		                    this._testLoopBoundries(event);
		                });
		            }
		        }
		    });
		    /**
			 * 	The playback rate of the part
			 *  @memberOf Tone.Part#
			 *  @type {Positive}
			 *  @name playbackRate
			 */
		    Object.defineProperty(Tone.Part.prototype, 'playbackRate', {
		        get: function () {
		            return this._playbackRate;
		        },
		        set: function (rate) {
		            this._playbackRate = rate;
		            this._setAll('playbackRate', rate);
		        }
		    });
		    /**
			 * 	The number of scheduled notes in the part. 
			 *  @memberOf Tone.Part#
			 *  @type {Positive}
			 *  @name length
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Part.prototype, 'length', {
		        get: function () {
		            return this._events.length;
		        }
		    });
		    /**
			 *  Clean up
			 *  @return  {Tone.Part}  this
			 */
		    Tone.Part.prototype.dispose = function () {
		        this.removeAll();
		        this._state.dispose();
		        this._state = null;
		        this.callback = null;
		        this._events = null;
		        return this;
		    };
		    return Tone.Part;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.Pattern arpeggiates between the given notes
			 *         in a number of patterns. See Tone.CtrlPattern for
			 *         a full list of patterns.
			 *  @example
			 * var pattern = new Tone.Pattern(function(time, note){
			 *   //the order of the notes passed in depends on the pattern
			 * }, ["C2", "D4", "E5", "A6"], "upDown");
			 *  @extends {Tone.Loop}
			 *  @param {Function} callback The callback to invoke with the
			 *                             event.
			 *  @param {Array} values The values to arpeggiate over.
			 */
		    Tone.Pattern = function () {
		        var options = this.optionsObject(arguments, [
		            'callback',
		            'values',
		            'pattern'
		        ], Tone.Pattern.defaults);
		        Tone.Loop.call(this, options);
		        /**
				 *  The pattern manager
				 *  @type {Tone.CtrlPattern}
				 *  @private
				 */
		        this._pattern = new Tone.CtrlPattern({
		            'values': options.values,
		            'type': options.pattern,
		            'index': options.index
		        });
		    };
		    Tone.extend(Tone.Pattern, Tone.Loop);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Pattern.defaults = {
		        'pattern': Tone.CtrlPattern.Type.Up,
		        'values': []
		    };
		    /**
			 *  Internal function called when the notes should be called
			 *  @param  {Number}  time  The time the event occurs
			 *  @private
			 */
		    Tone.Pattern.prototype._tick = function (time) {
		        this.callback(time, this._pattern.value);
		        this._pattern.next();
		    };
		    /**
			 *  The current index in the values array.
			 *  @memberOf Tone.Pattern#
			 *  @type {Positive}
			 *  @name index
			 */
		    Object.defineProperty(Tone.Pattern.prototype, 'index', {
		        get: function () {
		            return this._pattern.index;
		        },
		        set: function (i) {
		            this._pattern.index = i;
		        }
		    });
		    /**
			 *  The array of events.
			 *  @memberOf Tone.Pattern#
			 *  @type {Array}
			 *  @name values
			 */
		    Object.defineProperty(Tone.Pattern.prototype, 'values', {
		        get: function () {
		            return this._pattern.values;
		        },
		        set: function (vals) {
		            this._pattern.values = vals;
		        }
		    });
		    /**
			 *  The current value of the pattern.
			 *  @memberOf Tone.Pattern#
			 *  @type {*}
			 *  @name value
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Pattern.prototype, 'value', {
		        get: function () {
		            return this._pattern.value;
		        }
		    });
		    /**
			 *  The pattern type. See Tone.CtrlPattern for the full list of patterns.
			 *  @memberOf Tone.Pattern#
			 *  @type {String}
			 *  @name pattern
			 */
		    Object.defineProperty(Tone.Pattern.prototype, 'pattern', {
		        get: function () {
		            return this._pattern.type;
		        },
		        set: function (pattern) {
		            this._pattern.type = pattern;
		        }
		    });
		    /**
			 *  Clean up
			 *  @return  {Tone.Pattern}  this
			 */
		    Tone.Pattern.prototype.dispose = function () {
		        Tone.Loop.prototype.dispose.call(this);
		        this._pattern.dispose();
		        this._pattern = null;
		    };
		    return Tone.Pattern;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A sequence is an alternate notation of a part. Instead
			 *         of passing in an array of [time, event] pairs, pass
			 *         in an array of events which will be spaced at the
			 *         given subdivision. Sub-arrays will subdivide that beat
			 *         by the number of items are in the array. 
			 *         Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)
			 *  @param  {Function}  callback  The callback to invoke with every note
			 *  @param  {Array}    events  The sequence
			 *  @param  {Time} subdivision  The subdivision between which events are placed. 
			 *  @extends {Tone.Part}
			 *  @example
			 * var seq = new Tone.Sequence(function(time, note){
			 * 	console.log(note);
			 * //straight quater notes
			 * }, ["C4", "E4", "G4", "A4"], "4n");
			 *  @example
			 * var seq = new Tone.Sequence(function(time, note){
			 * 	console.log(note);
			 * //subdivisions are given as subarrays
			 * }, ["C4", ["E4", "D4", "E4"], "G4", ["A4", "G4"]]);
			 */
		    Tone.Sequence = function () {
		        var options = this.optionsObject(arguments, [
		            'callback',
		            'events',
		            'subdivision'
		        ], Tone.Sequence.defaults);
		        //remove the events
		        var events = options.events;
		        delete options.events;
		        Tone.Part.call(this, options);
		        /**
				 *  The subdivison of each note
				 *  @type  {Ticks}
				 *  @private
				 */
		        this._subdivision = this.toTicks(options.subdivision);
		        //if no time was passed in, the loop end is the end of the cycle
		        if (this.isUndef(options.loopEnd) && !this.isUndef(events)) {
		            this._loopEnd = events.length * this._subdivision;
		        }
		        //defaults to looping
		        this._loop = true;
		        //add all of the events
		        if (!this.isUndef(events)) {
		            for (var i = 0; i < events.length; i++) {
		                this.add(i, events[i]);
		            }
		        }
		    };
		    Tone.extend(Tone.Sequence, Tone.Part);
		    /**
			 *  The default values.
			 *  @type  {Object}
			 */
		    Tone.Sequence.defaults = { 'subdivision': '4n' };
		    /**
			 *  The subdivision of the sequence. This can only be 
			 *  set in the constructor. The subdivision is the 
			 *  interval between successive steps. 
			 *  @type {Time}
			 *  @memberOf Tone.Sequence#
			 *  @name subdivision
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.Sequence.prototype, 'subdivision', {
		        get: function () {
		            return Tone.Time(this._subdivision, 'i').toNotation();
		        }
		    });
		    /**
			 *  Get/Set an index of the sequence. If the index contains a subarray, 
			 *  a Tone.Sequence representing that sub-array will be returned. 
			 *  @example
			 * var sequence = new Tone.Sequence(playNote, ["E4", "C4", "F#4", ["A4", "Bb3"]])
			 * sequence.at(0)// => returns "E4"
			 * //set a value
			 * sequence.at(0, "G3");
			 * //get a nested sequence
			 * sequence.at(3).at(1)// => returns "Bb3"
			 * @param {Positive} index The index to get or set
			 * @param {*} value Optionally pass in the value to set at the given index.
			 */
		    Tone.Sequence.prototype.at = function (index, value) {
		        //if the value is an array, 
		        if (this.isArray(value)) {
		            //remove the current event at that index
		            this.remove(index);
		        }
		        //call the parent's method
		        return Tone.Part.prototype.at.call(this, this._indexTime(index), value);
		    };
		    /**
			 *  Add an event at an index, if there's already something
			 *  at that index, overwrite it. If `value` is an array, 
			 *  it will be parsed as a subsequence.
			 *  @param {Number} index The index to add the event to
			 *  @param {*} value The value to add at that index
			 *  @returns {Tone.Sequence} this
			 */
		    Tone.Sequence.prototype.add = function (index, value) {
		        if (value === null) {
		            return this;
		        }
		        if (this.isArray(value)) {
		            //make a subsequence and add that to the sequence
		            var subSubdivision = Math.round(this._subdivision / value.length);
		            value = new Tone.Sequence(this._tick.bind(this), value, Tone.Time(subSubdivision, 'i'));
		        }
		        Tone.Part.prototype.add.call(this, this._indexTime(index), value);
		        return this;
		    };
		    /**
			 *  Remove a value from the sequence by index
			 *  @param {Number} index The index of the event to remove
			 *  @returns {Tone.Sequence} this
			 */
		    Tone.Sequence.prototype.remove = function (index, value) {
		        Tone.Part.prototype.remove.call(this, this._indexTime(index), value);
		        return this;
		    };
		    /**
			 *  Get the time of the index given the Sequence's subdivision
			 *  @param  {Number}  index 
			 *  @return  {Time}  The time of that index
			 *  @private
			 */
		    Tone.Sequence.prototype._indexTime = function (index) {
		        if (index instanceof Tone.TransportTime) {
		            return index;
		        } else {
		            return Tone.TransportTime(index * this._subdivision + this.startOffset, 'i');
		        }
		    };
		    /**
			 *  Clean up.
			 *  @return {Tone.Sequence} this
			 */
		    Tone.Sequence.prototype.dispose = function () {
		        Tone.Part.prototype.dispose.call(this);
		        return this;
		    };
		    return Tone.Sequence;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,
			 *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is 
			 *         a square and only odd-numbered harmonics are present. At all other widths 
			 *         even-numbered harmonics are present. Read more 
			 *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
			 *
			 *  @constructor
			 *  @extends {Tone.Oscillator}
			 *  @param {Frequency} [frequency] The frequency of the oscillator
			 *  @param {NormalRange} [width] The width of the pulse
			 *  @example
			 * var pulse = new Tone.PulseOscillator("E5", 0.4).toMaster().start();
			 */
		    Tone.PulseOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'width'
		        ], Tone.Oscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The width of the pulse. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
		        /**
				 *  gate the width amount
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._widthGate = new Tone.Gain();
		        /**
				 *  the sawtooth oscillator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._sawtooth = new Tone.Oscillator({
		            frequency: options.frequency,
		            detune: options.detune,
		            type: 'sawtooth',
		            phase: options.phase
		        });
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._sawtooth.frequency;
		        /**
				 *  The detune in cents. 
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._sawtooth.detune;
		        /**
				 *  Threshold the signal to turn it into a square
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = new Tone.WaveShaper(function (val) {
		            if (val < 0) {
		                return -1;
		            } else {
		                return 1;
		            }
		        });
		        //connections
		        this._sawtooth.chain(this._thresh, this.output);
		        this.width.chain(this._widthGate, this._thresh);
		        this._readOnly([
		            'width',
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.PulseOscillator, Tone.Oscillator);
		    /**
			 *  The default parameters.
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.PulseOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'width': 0.2
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} time 
			 *  @private
			 */
		    Tone.PulseOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._sawtooth.start(time);
		        this._widthGate.gain.setValueAtTime(1, time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time 
			 *  @private
			 */
		    Tone.PulseOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._sawtooth.stop(time);
		        //the width is still connected to the output. 
		        //that needs to be stopped also
		        this._widthGate.gain.setValueAtTime(0, time);
		    };
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.PulseOscillator#
			 * @type {Degrees}
			 * @name phase
			 */
		    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {
		        get: function () {
		            return this._sawtooth.phase;
		        },
		        set: function (phase) {
		            this._sawtooth.phase = phase;
		        }
		    });
		    /**
			 * The type of the oscillator. Always returns "pulse".
			 * @readOnly
			 * @memberOf Tone.PulseOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {
		        get: function () {
		            return 'pulse';
		        }
		    });
		    /**
			 * The partials of the waveform. Cannot set partials for this waveform type
			 * @memberOf Tone.PulseOscillator#
			 * @type {Array}
			 * @name partials
			 * @private
			 */
		    Object.defineProperty(Tone.PulseOscillator.prototype, 'partials', {
		        get: function () {
		            return [];
		        }
		    });
		    /**
			 *  Clean up method.
			 *  @return {Tone.PulseOscillator} this
			 */
		    Tone.PulseOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._sawtooth.dispose();
		        this._sawtooth = null;
		        this._writable([
		            'width',
		            'frequency',
		            'detune'
		        ]);
		        this.width.dispose();
		        this.width = null;
		        this._widthGate.dispose();
		        this._widthGate = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.PulseOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator 
			 *         at the modulationFrequency. This has the effect of continuously
			 *         changing the timbre of the oscillator by altering the harmonics 
			 *         generated.
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The starting frequency of the oscillator. 
			 *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. 
			 *  @example
			 *  var pwm = new Tone.PWMOscillator("Ab3", 0.3).toMaster().start();
			 */
		    Tone.PWMOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'modulationFrequency'
		        ], Tone.PWMOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  the pulse oscillator
				 *  @type {Tone.PulseOscillator}
				 *  @private
				 */
		        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);
		        //change the pulse oscillator type
		        this._pulse._sawtooth.type = 'sine';
		        /**
				 *  the modulator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._modulator = new Tone.Oscillator({
		            'frequency': options.frequency,
		            'detune': options.detune,
		            'phase': options.phase
		        });
		        /**
				 *  Scale the oscillator so it doesn't go silent 
				 *  at the extreme values.
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = new Tone.Multiply(2);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._modulator.frequency;
		        /**
				 *  The detune of the oscillator.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._modulator.detune;
		        /**
				 *  The modulation rate of the oscillator. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.modulationFrequency = this._pulse.frequency;
		        //connections
		        this._modulator.chain(this._scale, this._pulse.width);
		        this._pulse.connect(this.output);
		        this._readOnly([
		            'modulationFrequency',
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.PWMOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.PWMOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'modulationFrequency': 0.4
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now]
			 *  @private
			 */
		    Tone.PWMOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.start(time);
		        this._pulse.start(time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time (optional) timing parameter
			 *  @private
			 */
		    Tone.PWMOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.stop(time);
		        this._pulse.stop(time);
		    };
		    /**
			 * The type of the oscillator. Always returns "pwm".
			 * @readOnly
			 * @memberOf Tone.PWMOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {
		        get: function () {
		            return 'pwm';
		        }
		    });
		    /**
			 * The partials of the waveform. Cannot set partials for this waveform type
			 * @memberOf Tone.PWMOscillator#
			 * @type {Array}
			 * @name partials
			 * @private
			 */
		    Object.defineProperty(Tone.PWMOscillator.prototype, 'partials', {
		        get: function () {
		            return [];
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.PWMOscillator#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {
		        get: function () {
		            return this._modulator.phase;
		        },
		        set: function (phase) {
		            this._modulator.phase = phase;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.PWMOscillator} this
			 */
		    Tone.PWMOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._pulse.dispose();
		        this._pulse = null;
		        this._scale.dispose();
		        this._scale = null;
		        this._modulator.dispose();
		        this._modulator = null;
		        this._writable([
		            'modulationFrequency',
		            'frequency',
		            'detune'
		        ]);
		        this.frequency = null;
		        this.detune = null;
		        this.modulationFrequency = null;
		        return this;
		    };
		    return Tone.PWMOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.FMOscillator 
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The starting frequency of the oscillator. 
			 *  @param {String} type The type of the carrier oscillator.
			 *  @param {String} modulationType The type of the modulator oscillator.
			 *  @example
			 * //a sine oscillator frequency-modulated by a square wave
			 * var fmOsc = new Tone.FMOscillator("Ab3", "sine", "square").toMaster().start();
			 */
		    Tone.FMOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type',
		            'modulationType'
		        ], Tone.FMOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The carrier oscillator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._carrier = new Tone.Oscillator(options.frequency, options.type);
		        /**
				 *  The oscillator's frequency
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control signal.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._carrier.detune;
		        this.detune.value = options.detune;
		        /**
				 *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
				 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
				 *  modulating signal (ma) -- as in ma/mf. 
				 *	@type {Positive}
				 *	@signal
				 */
		        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
		        this.modulationIndex.units = Tone.Type.Positive;
		        /**
				 *  The modulating oscillator
				 *  @type  {Tone.Oscillator}
				 *  @private
				 */
		        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
		        /**
				 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
				 *  A harmonicity of 1 gives both oscillators the same frequency. 
				 *  Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch the modulator an octave below carrier
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  the node where the modulation happens
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._modulationNode = new Tone.Gain(0);
		        //connections
		        this.frequency.connect(this._carrier.frequency);
		        this.frequency.chain(this.harmonicity, this._modulator.frequency);
		        this.frequency.chain(this.modulationIndex, this._modulationNode);
		        this._modulator.connect(this._modulationNode.gain);
		        this._modulationNode.connect(this._carrier.frequency);
		        this._carrier.connect(this.output);
		        this.detune.connect(this._modulator.detune);
		        this.phase = options.phase;
		        this._readOnly([
		            'modulationIndex',
		            'frequency',
		            'detune',
		            'harmonicity'
		        ]);
		    };
		    Tone.extend(Tone.FMOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.FMOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'modulationIndex': 2,
		        'modulationType': 'square',
		        'harmonicity': 1
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now]
			 *  @private
			 */
		    Tone.FMOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.start(time);
		        this._carrier.start(time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time (optional) timing parameter
			 *  @private
			 */
		    Tone.FMOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.stop(time);
		        this._carrier.stop(time);
		    };
		    /**
			 * The type of the carrier oscillator
			 * @memberOf Tone.FMOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.FMOscillator.prototype, 'type', {
		        get: function () {
		            return this._carrier.type;
		        },
		        set: function (type) {
		            this._carrier.type = type;
		        }
		    });
		    /**
			 * The type of the modulator oscillator
			 * @memberOf Tone.FMOscillator#
			 * @type {String}
			 * @name modulationType
			 */
		    Object.defineProperty(Tone.FMOscillator.prototype, 'modulationType', {
		        get: function () {
		            return this._modulator.type;
		        },
		        set: function (type) {
		            this._modulator.type = type;
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.FMOscillator#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.FMOscillator.prototype, 'phase', {
		        get: function () {
		            return this._carrier.phase;
		        },
		        set: function (phase) {
		            this._carrier.phase = phase;
		            this._modulator.phase = phase;
		        }
		    });
		    /**
			 * The partials of the carrier waveform. A partial represents 
			 * the amplitude at a harmonic. The first harmonic is the 
			 * fundamental frequency, the second is the octave and so on
			 * following the harmonic series. 
			 * Setting this value will automatically set the type to "custom". 
			 * The value is an empty array when the type is not "custom". 
			 * @memberOf Tone.FMOscillator#
			 * @type {Array}
			 * @name partials
			 * @example
			 * osc.partials = [1, 0.2, 0.01];
			 */
		    Object.defineProperty(Tone.FMOscillator.prototype, 'partials', {
		        get: function () {
		            return this._carrier.partials;
		        },
		        set: function (partials) {
		            this._carrier.partials = partials;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.FMOscillator} this
			 */
		    Tone.FMOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._writable([
		            'modulationIndex',
		            'frequency',
		            'detune',
		            'harmonicity'
		        ]);
		        this.frequency.dispose();
		        this.frequency = null;
		        this.detune = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._carrier.dispose();
		        this._carrier = null;
		        this._modulator.dispose();
		        this._modulator = null;
		        this._modulationNode.dispose();
		        this._modulationNode = null;
		        this.modulationIndex.dispose();
		        this.modulationIndex = null;
		        return this;
		    };
		    return Tone.FMOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.AMOscillator 
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The starting frequency of the oscillator. 
			 *  @param {String} type The type of the carrier oscillator.
			 *  @param {String} modulationType The type of the modulator oscillator.
			 *  @example
			 * //a sine oscillator frequency-modulated by a square wave
			 * var fmOsc = new Tone.AMOscillator("Ab3", "sine", "square").toMaster().start();
			 */
		    Tone.AMOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type',
		            'modulationType'
		        ], Tone.AMOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The carrier oscillator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._carrier = new Tone.Oscillator(options.frequency, options.type);
		        /**
				 *  The oscillator's frequency
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._carrier.frequency;
		        /**
				 *  The detune control signal.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._carrier.detune;
		        this.detune.value = options.detune;
		        /**
				 *  The modulating oscillator
				 *  @type  {Tone.Oscillator}
				 *  @private
				 */
		        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
		        /**
				 *  convert the -1,1 output to 0,1
				 *  @type {Tone.AudioToGain}
				 *  @private
				 */
		        this._modulationScale = new Tone.AudioToGain();
		        /**
				 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
				 *  A harmonicity of 1 gives both oscillators the same frequency. 
				 *  Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch the modulator an octave below carrier
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  the node where the modulation happens
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._modulationNode = new Tone.Gain(0);
		        //connections
		        this.frequency.chain(this.harmonicity, this._modulator.frequency);
		        this.detune.connect(this._modulator.detune);
		        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
		        this._carrier.chain(this._modulationNode, this.output);
		        this.phase = options.phase;
		        this._readOnly([
		            'frequency',
		            'detune',
		            'harmonicity'
		        ]);
		    };
		    Tone.extend(Tone.AMOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.AMOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'modulationType': 'square',
		        'harmonicity': 1
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now]
			 *  @private
			 */
		    Tone.AMOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.start(time);
		        this._carrier.start(time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time (optional) timing parameter
			 *  @private
			 */
		    Tone.AMOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.stop(time);
		        this._carrier.stop(time);
		    };
		    /**
			 * The type of the carrier oscillator
			 * @memberOf Tone.AMOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.AMOscillator.prototype, 'type', {
		        get: function () {
		            return this._carrier.type;
		        },
		        set: function (type) {
		            this._carrier.type = type;
		        }
		    });
		    /**
			 * The type of the modulator oscillator
			 * @memberOf Tone.AMOscillator#
			 * @type {string}
			 * @name modulationType
			 */
		    Object.defineProperty(Tone.AMOscillator.prototype, 'modulationType', {
		        get: function () {
		            return this._modulator.type;
		        },
		        set: function (type) {
		            this._modulator.type = type;
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.AMOscillator#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.AMOscillator.prototype, 'phase', {
		        get: function () {
		            return this._carrier.phase;
		        },
		        set: function (phase) {
		            this._carrier.phase = phase;
		            this._modulator.phase = phase;
		        }
		    });
		    /**
			 * The partials of the carrier waveform. A partial represents 
			 * the amplitude at a harmonic. The first harmonic is the 
			 * fundamental frequency, the second is the octave and so on
			 * following the harmonic series. 
			 * Setting this value will automatically set the type to "custom". 
			 * The value is an empty array when the type is not "custom". 
			 * @memberOf Tone.AMOscillator#
			 * @type {Array}
			 * @name partials
			 * @example
			 * osc.partials = [1, 0.2, 0.01];
			 */
		    Object.defineProperty(Tone.AMOscillator.prototype, 'partials', {
		        get: function () {
		            return this._carrier.partials;
		        },
		        set: function (partials) {
		            this._carrier.partials = partials;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.AMOscillator} this
			 */
		    Tone.AMOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'detune',
		            'harmonicity'
		        ]);
		        this.frequency = null;
		        this.detune = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._carrier.dispose();
		        this._carrier = null;
		        this._modulator.dispose();
		        this._modulator = null;
		        this._modulationNode.dispose();
		        this._modulationNode = null;
		        this._modulationScale.dispose();
		        this._modulationScale = null;
		        return this;
		    };
		    return Tone.AMOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.FatOscillator 
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The starting frequency of the oscillator. 
			 *  @param {String} type The type of the carrier oscillator.
			 *  @param {String} modulationType The type of the modulator oscillator.
			 *  @example
			 * //a sine oscillator frequency-modulated by a square wave
			 * var fmOsc = new Tone.FatOscillator("Ab3", "sine", "square").toMaster().start();
			 */
		    Tone.FatOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type',
		            'spread'
		        ], Tone.FatOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The oscillator's frequency
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control signal.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  The array of oscillators
				 *  @type {Array}
				 *  @private
				 */
		        this._oscillators = [];
		        /**
				 *  The total spread of the oscillators
				 *  @type  {Cents}
				 *  @private
				 */
		        this._spread = options.spread;
		        /**
				 *  The type of the oscillator
				 *  @type {String}
				 *  @private
				 */
		        this._type = options.type;
		        /**
				 *  The phase of the oscillators
				 *  @type {Degrees}
				 *  @private
				 */
		        this._phase = options.phase;
		        /**
				 *  The partials array
				 *  @type {Array}
				 *  @private
				 */
		        this._partials = this.defaultArg(options.partials, []);
		        //set the count initially
		        this.count = options.count;
		        this._readOnly([
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.FatOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.FatOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'spread': 20,
		        'count': 3,
		        'type': 'sawtooth'
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now]
			 *  @private
			 */
		    Tone.FatOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._forEach(function (osc) {
		            osc.start(time);
		        });
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time (optional) timing parameter
			 *  @private
			 */
		    Tone.FatOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._forEach(function (osc) {
		            osc.stop(time);
		        });
		    };
		    /**
			 *  Iterate over all of the oscillators
			 *  @param  {Function}  iterator  The iterator function
			 *  @private
			 */
		    Tone.FatOscillator.prototype._forEach = function (iterator) {
		        for (var i = 0; i < this._oscillators.length; i++) {
		            iterator.call(this, this._oscillators[i], i);
		        }
		    };
		    /**
			 * The type of the carrier oscillator
			 * @memberOf Tone.FatOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.FatOscillator.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            this._type = type;
		            this._forEach(function (osc) {
		                osc.type = type;
		            });
		        }
		    });
		    /**
			 * The detune spread between the oscillators. If "count" is
			 * set to 3 oscillators and the "spread" is set to 40,
			 * the three oscillators would be detuned like this: [-20, 0, 20]
			 * for a total detune spread of 40 cents.
			 * @memberOf Tone.FatOscillator#
			 * @type {Cents}
			 * @name spread
			 */
		    Object.defineProperty(Tone.FatOscillator.prototype, 'spread', {
		        get: function () {
		            return this._spread;
		        },
		        set: function (spread) {
		            this._spread = spread;
		            if (this._oscillators.length > 1) {
		                var start = -spread / 2;
		                var step = spread / (this._oscillators.length - 1);
		                this._forEach(function (osc, i) {
		                    osc.detune.value = start + step * i;
		                });
		            }
		        }
		    });
		    /**
			 * The number of detuned oscillators
			 * @memberOf Tone.FatOscillator#
			 * @type {Number}
			 * @name count
			 */
		    Object.defineProperty(Tone.FatOscillator.prototype, 'count', {
		        get: function () {
		            return this._oscillators.length;
		        },
		        set: function (count) {
		            count = Math.max(count, 1);
		            if (this._oscillators.length !== count) {
		                // var partials = this.partials;
		                // var type = this.type;
		                //dispose the previous oscillators
		                this._forEach(function (osc) {
		                    osc.dispose();
		                });
		                this._oscillators = [];
		                for (var i = 0; i < count; i++) {
		                    var osc = new Tone.Oscillator();
		                    if (this.type === Tone.Oscillator.Type.Custom) {
		                        osc.partials = this._partials;
		                    } else {
		                        osc.type = this._type;
		                    }
		                    osc.phase = this._phase;
		                    osc.volume.value = -6 - count;
		                    this.frequency.connect(osc.frequency);
		                    this.detune.connect(osc.detune);
		                    osc.connect(this.output);
		                    this._oscillators[i] = osc;
		                }
		                //set the spread
		                this.spread = this._spread;
		                if (this.state === Tone.State.Started) {
		                    this._forEach(function (osc) {
		                        osc.start();
		                    });
		                }
		            }
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.FatOscillator#
			 * @type {Number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.FatOscillator.prototype, 'phase', {
		        get: function () {
		            return this._phase;
		        },
		        set: function (phase) {
		            this._phase = phase;
		            this._forEach(function (osc) {
		                osc.phase = phase;
		            });
		        }
		    });
		    /**
			 * The partials of the carrier waveform. A partial represents 
			 * the amplitude at a harmonic. The first harmonic is the 
			 * fundamental frequency, the second is the octave and so on
			 * following the harmonic series. 
			 * Setting this value will automatically set the type to "custom". 
			 * The value is an empty array when the type is not "custom". 
			 * @memberOf Tone.FatOscillator#
			 * @type {Array}
			 * @name partials
			 * @example
			 * osc.partials = [1, 0.2, 0.01];
			 */
		    Object.defineProperty(Tone.FatOscillator.prototype, 'partials', {
		        get: function () {
		            return this._partials;
		        },
		        set: function (partials) {
		            this._partials = partials;
		            this._type = Tone.Oscillator.Type.Custom;
		            this._forEach(function (osc) {
		                osc.partials = partials;
		            });
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.FatOscillator} this
			 */
		    Tone.FatOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'detune'
		        ]);
		        this.frequency.dispose();
		        this.frequency = null;
		        this.detune.dispose();
		        this.detune = null;
		        this._forEach(function (osc) {
		            osc.dispose();
		        });
		        this._oscillators = null;
		        this._partials = null;
		        return this;
		    };
		    return Tone.FatOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,
			 *         Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator
			 *         into one class. The oscillator class can be changed by setting the `type`. 
			 *         `omniOsc.type = "pwm"` will set it to the Tone.PWMOscillator. Prefixing
			 *         any of the basic types ("sine", "square4", etc.) with "fm", "am", or "fat"
			 *         will use the FMOscillator, AMOscillator or FatOscillator respectively. 
			 *         For example: `omniOsc.type = "fatsawtooth"` will create set the oscillator
			 *         to a FatOscillator of type "sawtooth". 
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The initial frequency of the oscillator.
			 *  @param {String} type The type of the oscillator.
			 *  @example
			 *  var omniOsc = new Tone.OmniOscillator("C#4", "pwm");
			 */
		    Tone.OmniOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type'
		        ], Tone.OmniOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  the type of the oscillator source
				 *  @type {String}
				 *  @private
				 */
		        this._sourceType = undefined;
		        /**
				 *  the oscillator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._oscillator = null;
		        //set the oscillator
		        this.type = options.type;
		        this._readOnly([
		            'frequency',
		            'detune'
		        ]);
		        //set the options
		        this.set(options);
		    };
		    Tone.extend(Tone.OmniOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.OmniOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'type': 'sine',
		        'phase': 0
		    };
		    /**
			 *  @enum {String}
			 *  @private
			 */
		    var OmniOscType = {
		        Pulse: 'PulseOscillator',
		        PWM: 'PWMOscillator',
		        Osc: 'Oscillator',
		        FM: 'FMOscillator',
		        AM: 'AMOscillator',
		        Fat: 'FatOscillator'
		    };
		    /**
			 *  start the oscillator
			 *  @param {Time} [time=now] the time to start the oscillator
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._start = function (time) {
		        this._oscillator.start(time);
		    };
		    /**
			 *  start the oscillator
			 *  @param {Time} [time=now] the time to start the oscillator
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._stop = function (time) {
		        this._oscillator.stop(time);
		    };
		    /**
			 * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
			 * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
			 * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
			 * oscillator's class are accessible when the oscillator is set to that type, but throws an error 
			 * when it's not.
			 * 
			 * @memberOf Tone.OmniOscillator#
			 * @type {String}
			 * @name type
			 * @example
			 * omniOsc.type = "pwm";
			 * //modulationFrequency is parameter which is available
			 * //only when the type is "pwm". 
			 * omniOsc.modulationFrequency.value = 0.5;
			 * @example
			 * //an square wave frequency modulated by a sawtooth
			 * omniOsc.type = "fmsquare";
			 * omniOsc.modulationType = "sawtooth";
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {
		        get: function () {
		            var prefix = '';
		            if (this._sourceType === OmniOscType.FM) {
		                prefix = 'fm';
		            } else if (this._sourceType === OmniOscType.AM) {
		                prefix = 'am';
		            } else if (this._sourceType === OmniOscType.Fat) {
		                prefix = 'fat';
		            }
		            return prefix + this._oscillator.type;
		        },
		        set: function (type) {
		            if (type.substr(0, 2) === 'fm') {
		                this._createNewOscillator(OmniOscType.FM);
		                this._oscillator.type = type.substr(2);
		            } else if (type.substr(0, 2) === 'am') {
		                this._createNewOscillator(OmniOscType.AM);
		                this._oscillator.type = type.substr(2);
		            } else if (type.substr(0, 3) === 'fat') {
		                this._createNewOscillator(OmniOscType.Fat);
		                this._oscillator.type = type.substr(3);
		            } else if (type === 'pwm') {
		                this._createNewOscillator(OmniOscType.PWM);
		            } else if (type === 'pulse') {
		                this._createNewOscillator(OmniOscType.Pulse);
		            } else {
		                this._createNewOscillator(OmniOscType.Osc);
		                this._oscillator.type = type;
		            }
		        }
		    });
		    /**
			 * The partials of the waveform. A partial represents 
			 * the amplitude at a harmonic. The first harmonic is the 
			 * fundamental frequency, the second is the octave and so on
			 * following the harmonic series. 
			 * Setting this value will automatically set the type to "custom". 
			 * The value is an empty array when the type is not "custom". 
			 * This is not available on "pwm" and "pulse" oscillator types.
			 * @memberOf Tone.OmniOscillator#
			 * @type {Array}
			 * @name partials
			 * @example
			 * osc.partials = [1, 0.2, 0.01];
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'partials', {
		        get: function () {
		            return this._oscillator.partials;
		        },
		        set: function (partials) {
		            this._oscillator.partials = partials;
		        }
		    });
		    /**
			 *  Set a member/attribute of the oscillator. 
			 *  @param {Object|String} params
			 *  @param {number=} value
			 *  @param {Time=} rampTime
			 *  @returns {Tone.OmniOscillator} this
			 */
		    Tone.OmniOscillator.prototype.set = function (params, value) {
		        //make sure the type is set first
		        if (params === 'type') {
		            this.type = value;
		        } else if (this.isObject(params) && params.hasOwnProperty('type')) {
		            this.type = params.type;
		        }
		        //then set the rest
		        Tone.prototype.set.apply(this, arguments);
		        return this;
		    };
		    /**
			 *  connect the oscillator to the frequency and detune signals
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._createNewOscillator = function (oscType) {
		        if (oscType !== this._sourceType) {
		            this._sourceType = oscType;
		            var OscillatorConstructor = Tone[oscType];
		            //short delay to avoid clicks on the change
		            var now = this.now() + this.blockTime;
		            if (this._oscillator !== null) {
		                var oldOsc = this._oscillator;
		                oldOsc.stop(now);
		                //dispose the old one
		                setTimeout(function () {
		                    oldOsc.dispose();
		                    oldOsc = null;
		                }, this.blockTime * 1000);
		            }
		            this._oscillator = new OscillatorConstructor();
		            this.frequency.connect(this._oscillator.frequency);
		            this.detune.connect(this._oscillator.detune);
		            this._oscillator.connect(this.output);
		            if (this.state === Tone.State.Started) {
		                this._oscillator.start(now);
		            }
		        }
		    };
		    /**
			 * The phase of the oscillator in degrees. 
			 * @memberOf Tone.OmniOscillator#
			 * @type {Degrees}
			 * @name phase
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {
		        get: function () {
		            return this._oscillator.phase;
		        },
		        set: function (phase) {
		            this._oscillator.phase = phase;
		        }
		    });
		    /**
			 * The width of the oscillator (only if the oscillator is set to "pulse")
			 * @memberOf Tone.OmniOscillator#
			 * @type {NormalRange}
			 * @signal
			 * @name width
			 * @example
			 * var omniOsc = new Tone.OmniOscillator(440, "pulse");
			 * //can access the width attribute only if type === "pulse"
			 * omniOsc.width.value = 0.2; 
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {
		        get: function () {
		            if (this._sourceType === OmniOscType.Pulse) {
		                return this._oscillator.width;
		            }
		        }
		    });
		    /**
			 * The number of detuned oscillators
			 * @memberOf Tone.OmniOscillator#
			 * @type {Number}
			 * @name count
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'count', {
		        get: function () {
		            if (this._sourceType === OmniOscType.Fat) {
		                return this._oscillator.count;
		            }
		        },
		        set: function (count) {
		            if (this._sourceType === OmniOscType.Fat) {
		                this._oscillator.count = count;
		            }
		        }
		    });
		    /**
			 * The detune spread between the oscillators. If "count" is
			 * set to 3 oscillators and the "spread" is set to 40,
			 * the three oscillators would be detuned like this: [-20, 0, 20]
			 * for a total detune spread of 40 cents. See Tone.FatOscillator
			 * for more info.
			 * @memberOf Tone.OmniOscillator#
			 * @type {Cents}
			 * @name spread
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'spread', {
		        get: function () {
		            if (this._sourceType === OmniOscType.Fat) {
		                return this._oscillator.spread;
		            }
		        },
		        set: function (spread) {
		            if (this._sourceType === OmniOscType.Fat) {
		                this._oscillator.spread = spread;
		            }
		        }
		    });
		    /**
			 * The type of the modulator oscillator. Only if the oscillator
			 * is set to "am" or "fm" types. see. Tone.AMOscillator or Tone.FMOscillator
			 * for more info. 
			 * @memberOf Tone.OmniOscillator#
			 * @type {String}
			 * @name modulationType
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationType', {
		        get: function () {
		            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
		                return this._oscillator.modulationType;
		            }
		        },
		        set: function (mType) {
		            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
		                this._oscillator.modulationType = mType;
		            }
		        }
		    });
		    /**
			 * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
			 * ratio of the frequency of the modulating signal (mf) to the amplitude of the 
			 * modulating signal (ma) -- as in ma/mf. 
			 * See Tone.FMOscillator for more info. 
			 * @type {Positive}
			 * @signal
			 * @name modulationIndex
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationIndex', {
		        get: function () {
		            if (this._sourceType === OmniOscType.FM) {
		                return this._oscillator.modulationIndex;
		            }
		        }
		    });
		    /**
			 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
			 *  A harmonicity of 1 gives both oscillators the same frequency. 
			 *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator
			 *  for more info. 
			 *  @memberOf Tone.OmniOscillator#
			 *  @signal
			 *  @type {Positive}
			 *  @name harmonicity
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'harmonicity', {
		        get: function () {
		            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
		                return this._oscillator.harmonicity;
		            }
		        }
		    });
		    /**
			 * The modulationFrequency Signal of the oscillator 
			 * (only if the oscillator type is set to pwm). See 
			 * Tone.PWMOscillator for more info. 
			 * @memberOf Tone.OmniOscillator#
			 * @type {Frequency}
			 * @signal
			 * @name modulationFrequency
			 * @example
			 * var omniOsc = new Tone.OmniOscillator(440, "pwm");
			 * //can access the modulationFrequency attribute only if type === "pwm"
			 * omniOsc.modulationFrequency.value = 0.2; 
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {
		        get: function () {
		            if (this._sourceType === OmniOscType.PWM) {
		                return this._oscillator.modulationFrequency;
		            }
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.OmniOscillator} this
			 */
		    Tone.OmniOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'detune'
		        ]);
		        this.detune.dispose();
		        this.detune = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this._oscillator.dispose();
		        this._oscillator = null;
		        this._sourceType = null;
		        return this;
		    };
		    return Tone.OmniOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base-class for all instruments
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.Instrument = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.Instrument.defaults);
		        /**
				 *  The output and volume triming node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
		        this._volume = this.output = new Tone.Volume(options.volume);
		        /**
				 * The volume of the output in decibels.
				 * @type {Decibels}
				 * @signal
				 * @example
				 * source.volume.value = -6;
				 */
		        this.volume = this._volume.volume;
		        this._readOnly('volume');
		    };
		    Tone.extend(Tone.Instrument);
		    /**
			 *  the default attributes
			 *  @type {object}
			 */
		    Tone.Instrument.defaults = {
		        /** the volume of the output in decibels */
		        'volume': 0
		    };
		    /**
			 *  @abstract
			 *  @param {string|number} note the note to trigger
			 *  @param {Time} [time=now] the time to trigger the ntoe
			 *  @param {number} [velocity=1] the velocity to trigger the note
			 */
		    Tone.Instrument.prototype.triggerAttack = Tone.noOp;
		    /**
			 *  @abstract
			 *  @param {Time} [time=now] when to trigger the release
			 */
		    Tone.Instrument.prototype.triggerRelease = Tone.noOp;
		    /**
			 *  Trigger the attack and then the release after the duration. 
			 *  @param  {Frequency} note     The note to trigger.
			 *  @param  {Time} duration How long the note should be held for before
			 *                          triggering the release.
			 *  @param {Time} [time=now]  When the note should be triggered.
			 *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.
			 *  @returns {Tone.Instrument} this
			 *  @example
			 * //trigger "C4" for the duration of an 8th note
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
		        if (this.isUndef(time)) {
		            time = this.now() + this.blockTime;
		        } else {
		            time = this.toSeconds(time);
		        }
		        duration = this.toSeconds(duration);
		        this.triggerAttack(note, time, velocity);
		        this.triggerRelease(time + duration);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Instrument} this
			 */
		    Tone.Instrument.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._volume.dispose();
		        this._volume = null;
		        this._writable(['volume']);
		        this.volume = null;
		        return this;
		    };
		    return Tone.Instrument;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  This is an abstract base class for other monophonic instruments to 
			 *          extend. IMPORTANT: It does not make any sound on its own and
			 *          shouldn't be directly instantiated.
			 *
			 *  @constructor
			 *  @abstract
			 *  @extends {Tone.Instrument}
			 */
		    Tone.Monophonic = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.Monophonic.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The glide time between notes. 
				 *  @type {Time}
				 */
		        this.portamento = options.portamento;
		    };
		    Tone.extend(Tone.Monophonic, Tone.Instrument);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Monophonic.defaults = { 'portamento': 0 };
		    /**
			 *  Trigger the attack of the note optionally with a given velocity. 
			 *  
			 *  
			 *  @param  {Frequency} note     The note to trigger.
			 *  @param  {Time} [time=now]     When the note should start.
			 *  @param  {number} [velocity=1] velocity The velocity scaler 
			 *                                determines how "loud" the note 
			 *                                will be triggered.
			 *  @returns {Tone.Monophonic} this
			 *  @example
			 * synth.triggerAttack("C4");
			 *  @example
			 * //trigger the note a half second from now at half velocity
			 * synth.triggerAttack("C4", "+0.5", 0.5);
			 */
		    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {
		        if (this.isUndef(time)) {
		            time = this.now() + this.blockTime;
		        } else {
		            time = this.toSeconds(time);
		        }
		        this._triggerEnvelopeAttack(time, velocity);
		        this.setNote(note, time);
		        return this;
		    };
		    /**
			 *  Trigger the release portion of the envelope
			 *  @param  {Time} [time=now] If no time is given, the release happens immediatly
			 *  @returns {Tone.Monophonic} this
			 *  @example
			 * synth.triggerRelease();
			 */
		    Tone.Monophonic.prototype.triggerRelease = function (time) {
		        if (this.isUndef(time)) {
		            time = this.now() + this.blockTime;
		        } else {
		            time = this.toSeconds(time);
		        }
		        this._triggerEnvelopeRelease(time);
		        return this;
		    };
		    /**
			 *  override this method with the actual method
			 *  @abstract
			 *  @private
			 */
		    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {
		    };
		    /**
			 *  override this method with the actual method
			 *  @abstract
			 *  @private
			 */
		    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {
		    };
		    /**
			 *  Set the note at the given time. If no time is given, the note
			 *  will set immediately. 
			 *  @param {Frequency} note The note to change to.
			 *  @param  {Time} [time=now] The time when the note should be set. 
			 *  @returns {Tone.Monophonic} this
			 * @example
			 * //change to F#6 in one quarter note from now.
			 * synth.setNote("F#6", "+4n");
			 * @example
			 * //change to Bb4 right now
			 * synth.setNote("Bb4");
			 */
		    Tone.Monophonic.prototype.setNote = function (note, time) {
		        time = this.toSeconds(time);
		        if (this.portamento > 0) {
		            var currentNote = this.frequency.value;
		            this.frequency.setValueAtTime(currentNote, time);
		            var portTime = this.toSeconds(this.portamento);
		            this.frequency.exponentialRampToValueAtTime(note, time + portTime);
		        } else {
		            this.frequency.setValueAtTime(note, time);
		        }
		        return this;
		    };
		    return Tone.Monophonic;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Synth is composed simply of a Tone.OmniOscillator
			 *          routed through a Tone.AmplitudeEnvelope. 
			 *          <img src="https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.Synth().toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.Synth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.Synth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.OmniOscillator}
				 */
		        this.oscillator = new Tone.OmniOscillator(options.oscillator);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 *  The detune control.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this.oscillator.detune;
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the oscillators to the output
		        this.oscillator.chain(this.envelope, this.output);
		        //start the oscillators
		        this.oscillator.start();
		        this._readOnly([
		            'oscillator',
		            'frequency',
		            'detune',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.Synth, Tone.Monophonic);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Synth.defaults = {
		        'oscillator': { 'type': 'triangle' },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0.3,
		            'release': 1
		        }
		    };
		    /**
			 *  start the attack portion of the envelope
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {number} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.Synth} this
			 *  @private
			 */
		    Tone.Synth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelope
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.Synth} this
			 *  @private
			 */
		    Tone.Synth.prototype._triggerEnvelopeRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Synth} this
			 */
		    Tone.Synth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'frequency',
		            'detune',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.Synth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  AMSynth uses the output of one Tone.Synth to modulate the
			 *          amplitude of another Tone.Synth. The harmonicity (the ratio between
			 *          the two signals) affects the timbre of the output signal greatly.
			 *          Read more about Amplitude Modulation Synthesis on 
			 *          [SoundOnSound](http://www.soundonsound.com/sos/mar00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                            see defaults below
			 *  @example
			 * var synth = new Tone.AMSynth().toMaster();
			 * synth.triggerAttackRelease("C4", "4n");
			 */
		    Tone.AMSynth = function (options) {
		        options = this.defaultArg(options, Tone.AMSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice. 
				 *  @type {Tone.Synth}
				 *  @private
				 */
		        this._carrier = new Tone.Synth();
		        this._carrier.volume.value = -10;
		        /**
				 *  The carrier's oscillator
				 *  @type {Tone.Oscillator}
				 */
		        this.oscillator = this._carrier.oscillator;
		        /**
				 *  The carrier's envelope
				 *  @type {Tone.Oscillator}
				 */
		        this.envelope = this._carrier.envelope.set(options.envelope);
		        /**
				 *  The modulator voice. 
				 *  @type {Tone.Synth}
				 *  @private
				 */
		        this._modulator = new Tone.Synth();
		        this._modulator.volume.value = -10;
		        /**
				 *  The modulator's oscillator which is applied
				 *  to the amplitude of the oscillator
				 *  @type {Tone.Oscillator}
				 */
		        this.modulation = this._modulator.oscillator.set(options.modulation);
		        /**
				 *  The modulator's envelope
				 *  @type {Tone.Oscillator}
				 */
		        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
		        /**
				 *  The frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  The detune in cents
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  convert the -1,1 output to 0,1
				 *  @type {Tone.AudioToGain}
				 *  @private
				 */
		        this._modulationScale = new Tone.AudioToGain();
		        /**
				 *  the node where the modulation happens
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._modulationNode = new Tone.Gain();
		        //control the two voices frequency
		        this.frequency.connect(this._carrier.frequency);
		        this.frequency.chain(this.harmonicity, this._modulator.frequency);
		        this.detune.fan(this._carrier.detune, this._modulator.detune);
		        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
		        this._carrier.chain(this._modulationNode, this.output);
		        this._readOnly([
		            'frequency',
		            'harmonicity',
		            'oscillator',
		            'envelope',
		            'modulation',
		            'modulationEnvelope',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.AMSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AMSynth.defaults = {
		        'harmonicity': 3,
		        'detune': 0,
		        'oscillator': { 'type': 'sine' },
		        'envelope': {
		            'attack': 0.01,
		            'decay': 0.01,
		            'sustain': 1,
		            'release': 0.5
		        },
		        'modulation': { 'type': 'square' },
		        'modulationEnvelope': {
		            'attack': 0.5,
		            'decay': 0,
		            'sustain': 1,
		            'release': 0.5
		        }
		    };
		    /**
			 *  trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {NormalRange} [velocity=1] the velocity of the note
			 *  @private
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        this.modulationEnvelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @private
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        this.modulationEnvelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'harmonicity',
		            'oscillator',
		            'envelope',
		            'modulation',
		            'modulationEnvelope',
		            'detune'
		        ]);
		        this._carrier.dispose();
		        this._carrier = null;
		        this._modulator.dispose();
		        this._modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.detune.dispose();
		        this.detune = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationScale.dispose();
		        this._modulationScale = null;
		        this._modulationNode.dispose();
		        this._modulationNode = null;
		        this.oscillator = null;
		        this.envelope = null;
		        this.modulationEnvelope = null;
		        this.modulation = null;
		        return this;
		    };
		    return Tone.AMSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.
			 *          The amplitude of the Tone.Oscillator and the cutoff frequency of the 
			 *          Tone.Filter are controlled by Tone.Envelopes. 
			 *          <img src="https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240">
			 *          
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.MonoSynth({
			 * 	"oscillator" : {
			 * 		"type" : "square"
			 *  },
			 *  "envelope" : {
			 *  	"attack" : 0.1
			 *  }
			 * }).toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.MonoSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.MonoSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.OmniOscillator}
				 */
		        this.oscillator = new Tone.OmniOscillator(options.oscillator);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 *  The detune control.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this.oscillator.detune;
		        /**
				 *  The filter.
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        /**
				 *  The filter envelope.
				 *  @type {Tone.FrequencyEnvelope}
				 */
		        this.filterEnvelope = new Tone.FrequencyEnvelope(options.filterEnvelope);
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the oscillators to the output
		        this.oscillator.chain(this.filter, this.envelope, this.output);
		        //start the oscillators
		        this.oscillator.start();
		        //connect the filter envelope
		        this.filterEnvelope.connect(this.filter.frequency);
		        this._readOnly([
		            'oscillator',
		            'frequency',
		            'detune',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.MonoSynth, Tone.Monophonic);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MonoSynth.defaults = {
		        'frequency': 'C4',
		        'detune': 0,
		        'oscillator': { 'type': 'square' },
		        'filter': {
		            'Q': 6,
		            'type': 'lowpass',
		            'rolloff': -24
		        },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0.9,
		            'release': 1
		        },
		        'filterEnvelope': {
		            'attack': 0.06,
		            'decay': 0.2,
		            'sustain': 0.5,
		            'release': 2,
		            'baseFrequency': 200,
		            'octaves': 7,
		            'exponent': 2
		        }
		    };
		    /**
			 *  start the attack portion of the envelope
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.MonoSynth} this
			 *  @private
			 */
		    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        this.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelope
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.MonoSynth} this
			 *  @private
			 */
		    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        this.filterEnvelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.MonoSynth} this
			 */
		    Tone.MonoSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'frequency',
		            'detune',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.filterEnvelope.dispose();
		        this.filterEnvelope = null;
		        this.filter.dispose();
		        this.filter = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.MonoSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.DuoSynth is a monophonic synth composed of two 
			 *          MonoSynths run in parallel with control over the 
			 *          frequency ratio between the two voices and vibrato effect.
			 *          <img src="https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var duoSynth = new Tone.DuoSynth().toMaster();
			 * duoSynth.triggerAttackRelease("C4", "2n");
			 */
		    Tone.DuoSynth = function (options) {
		        options = this.defaultArg(options, Tone.DuoSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  the first voice
				 *  @type {Tone.MonoSynth}
				 */
		        this.voice0 = new Tone.MonoSynth(options.voice0);
		        this.voice0.volume.value = -10;
		        /**
				 *  the second voice
				 *  @type {Tone.MonoSynth}
				 */
		        this.voice1 = new Tone.MonoSynth(options.voice1);
		        this.voice1.volume.value = -10;
		        /**
				 *  The vibrato LFO. 
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);
		        this._vibrato.start();
		        /**
				 * the vibrato frequency
				 * @type {Frequency}
				 * @signal
				 */
		        this.vibratoRate = this._vibrato.frequency;
		        /**
				 *  the vibrato gain
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._vibratoGain = new Tone.Gain(options.vibratoAmount, Tone.Type.Positive);
		        /**
				 * The amount of vibrato
				 * @type {Positive}
				 * @signal
				 */
		        this.vibratoAmount = this._vibratoGain.gain;
		        /**
				 *  the frequency control
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * duoSynth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        //control the two voices frequency
		        this.frequency.connect(this.voice0.frequency);
		        this.frequency.chain(this.harmonicity, this.voice1.frequency);
		        this._vibrato.connect(this._vibratoGain);
		        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);
		        this.voice0.connect(this.output);
		        this.voice1.connect(this.output);
		        this._readOnly([
		            'voice0',
		            'voice1',
		            'frequency',
		            'vibratoAmount',
		            'vibratoRate'
		        ]);
		    };
		    Tone.extend(Tone.DuoSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.DuoSynth.defaults = {
		        'vibratoAmount': 0.5,
		        'vibratoRate': 5,
		        'harmonicity': 1.5,
		        'voice0': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        },
		        'voice1': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        }
		    };
		    /**
			 *  start the attack portion of the envelopes
			 *  
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.DuoSynth} this
			 *  @private
			 */
		    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        time = this.toSeconds(time);
		        this.voice0.envelope.triggerAttack(time, velocity);
		        this.voice1.envelope.triggerAttack(time, velocity);
		        this.voice0.filterEnvelope.triggerAttack(time);
		        this.voice1.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelopes
			 *  
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.DuoSynth} this
			 *  @private
			 */
		    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.voice0.triggerRelease(time);
		        this.voice1.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.DuoSynth} this
			 */
		    Tone.DuoSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'voice0',
		            'voice1',
		            'frequency',
		            'vibratoAmount',
		            'vibratoRate'
		        ]);
		        this.voice0.dispose();
		        this.voice0 = null;
		        this.voice1.dispose();
		        this.voice1 = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this._vibratoGain.dispose();
		        this._vibratoGain = null;
		        this._vibrato = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this.vibratoAmount.dispose();
		        this.vibratoAmount = null;
		        this.vibratoRate = null;
		        return this;
		    };
		    return Tone.DuoSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  FMSynth is composed of two Tone.Synths where one Tone.Synth modulates
			 *          the frequency of a second Tone.Synth. A lot of spectral content 
			 *          can be explored using the modulationIndex parameter. Read more about
			 *          frequency modulation synthesis on [SoundOnSound](http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var fmSynth = new Tone.FMSynth().toMaster();
			 * fmSynth.triggerAttackRelease("C5", "4n");
			 */
		    Tone.FMSynth = function (options) {
		        options = this.defaultArg(options, Tone.FMSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice.
				 *  @type {Tone.Synth}
				 *  @private
				 */
		        this._carrier = new Tone.Synth(options.carrier);
		        this._carrier.volume.value = -10;
		        /**
				 *  The carrier's oscillator
				 *  @type {Tone.Oscillator}
				 */
		        this.oscillator = this._carrier.oscillator;
		        /**
				 *  The carrier's envelope
				 *  @type {Tone.Oscillator}
				 */
		        this.envelope = this._carrier.envelope.set(options.envelope);
		        /**
				 *  The modulator voice.
				 *  @type {Tone.Synth}
				 *  @private
				 */
		        this._modulator = new Tone.Synth(options.modulator);
		        this._modulator.volume.value = -10;
		        /**
				 *  The modulator's oscillator which is applied
				 *  to the amplitude of the oscillator
				 *  @type {Tone.Oscillator}
				 */
		        this.modulation = this._modulator.oscillator.set(options.modulation);
		        /**
				 *  The modulator's envelope
				 *  @type {Tone.Oscillator}
				 */
		        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  The detune in cents
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  The modulation index which essentially the depth or amount of the modulation. It is the 
				 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
				 *  modulating signal (ma) -- as in ma/mf. 
				 *	@type {Positive}
				 *	@signal
				 */
		        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
		        this.modulationIndex.units = Tone.Type.Positive;
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = new Tone.Gain(0);
		        //control the two voices frequency
		        this.frequency.connect(this._carrier.frequency);
		        this.frequency.chain(this.harmonicity, this._modulator.frequency);
		        this.frequency.chain(this.modulationIndex, this._modulationNode);
		        this.detune.fan(this._carrier.detune, this._modulator.detune);
		        this._modulator.connect(this._modulationNode.gain);
		        this._modulationNode.connect(this._carrier.frequency);
		        this._carrier.connect(this.output);
		        this._readOnly([
		            'frequency',
		            'harmonicity',
		            'modulationIndex',
		            'oscillator',
		            'envelope',
		            'modulation',
		            'modulationEnvelope',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.FMSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FMSynth.defaults = {
		        'harmonicity': 3,
		        'modulationIndex': 10,
		        'detune': 0,
		        'oscillator': { 'type': 'sine' },
		        'envelope': {
		            'attack': 0.01,
		            'decay': 0.01,
		            'sustain': 1,
		            'release': 0.5
		        },
		        'modulation': { 'type': 'square' },
		        'modulationEnvelope': {
		            'attack': 0.5,
		            'decay': 0,
		            'sustain': 1,
		            'release': 0.5
		        }
		    };
		    /**
			 * 	trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {number} [velocity=1] the velocity of the note
			 *  @returns {Tone.FMSynth} this
			 *  @private
			 */
		    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        time = this.toSeconds(time);
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        this.modulationEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.FMSynth} this
			 *  @private
			 */
		    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {
		        time = this.toSeconds(time);
		        this.envelope.triggerRelease(time);
		        this.modulationEnvelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.FMSynth} this
			 */
		    Tone.FMSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'harmonicity',
		            'modulationIndex',
		            'oscillator',
		            'envelope',
		            'modulation',
		            'modulationEnvelope',
		            'detune'
		        ]);
		        this._carrier.dispose();
		        this._carrier = null;
		        this._modulator.dispose();
		        this._modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.detune.dispose();
		        this.detune = null;
		        this.modulationIndex.dispose();
		        this.modulationIndex = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationNode.dispose();
		        this._modulationNode = null;
		        this.oscillator = null;
		        this.envelope = null;
		        this.modulationEnvelope = null;
		        this.modulation = null;
		        return this;
		    };
		    return Tone.FMSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.MembraneSynth makes kick and tom sounds using a single oscillator
			 *          with an amplitude envelope and frequency ramp. A Tone.OmniOscillator
			 *          is routed through a Tone.AmplitudeEnvelope to the output. The drum
			 *          quality of the sound comes from the frequency envelope applied
			 *          during during Tone.MembraneSynth.triggerAttack(note). The frequency
			 *          envelope starts at <code>note * .octaves</code> and ramps to 
			 *          <code>note</code> over the duration of <code>.pitchDecay</code>. 
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.MembraneSynth().toMaster();
			 * synth.triggerAttackRelease("C2", "8n");
			 */
		    Tone.MembraneSynth = function (options) {
		        options = this.defaultArg(options, Tone.MembraneSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.OmniOscillator}
				 */
		        this.oscillator = new Tone.OmniOscillator(options.oscillator).start();
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        /**
				 *  The number of octaves the pitch envelope ramps.
				 *  @type {Positive}
				 */
		        this.octaves = options.octaves;
		        /**
				 *  The amount of time the frequency envelope takes. 
				 *  @type {Time}
				 */
		        this.pitchDecay = options.pitchDecay;
		        this.oscillator.chain(this.envelope, this.output);
		        this._readOnly([
		            'oscillator',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.MembraneSynth, Tone.Instrument);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MembraneSynth.defaults = {
		        'pitchDecay': 0.05,
		        'octaves': 10,
		        'oscillator': { 'type': 'sine' },
		        'envelope': {
		            'attack': 0.001,
		            'decay': 0.4,
		            'sustain': 0.01,
		            'release': 1.4,
		            'attackCurve': 'exponential'
		        }
		    };
		    /**
			 *  Trigger the note at the given time with the given velocity. 
			 *  
			 *  @param  {Frequency} note     the note
			 *  @param  {Time} [time=now]     the time, if not given is now
			 *  @param  {number} [velocity=1] velocity defaults to 1
			 *  @returns {Tone.MembraneSynth} this
			 *  @example
			 *  kick.triggerAttack(60);
			 */
		    Tone.MembraneSynth.prototype.triggerAttack = function (note, time, velocity) {
		        time = this.toSeconds(time);
		        note = this.toFrequency(note);
		        var maxNote = note * this.octaves;
		        this.oscillator.frequency.setValueAtTime(maxNote, time);
		        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  Trigger the release portion of the note.
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.MembraneSynth} this
			 */
		    Tone.MembraneSynth.prototype.triggerRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.MembraneSynth} this
			 */
		    Tone.MembraneSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        return this;
		    };
		    return Tone.MembraneSynth;
		});
		Module(function (Tone) {
		    /**
			 *  Inharmonic ratio of frequencies based on the Roland TR-808
			 *  Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var inharmRatios = [
		        1,
		        1.483,
		        1.932,
		        2.546,
		        2.63,
		        3.897
		    ];
		    /**
			 *  @class  A highly inharmonic and spectrally complex source with a highpass filter
			 *          and amplitude envelope which is good for making metalophone sounds. Based
			 *          on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).
			 *          Inspiration from [Sound on Sound](http://www.soundonsound.com/sos/jul02/articles/synthsecrets0702.asp).
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] The options availble for the synth
			 *                             see defaults below
			 */
		    Tone.MetalSynth = function (options) {
		        options = this.defaultArg(options, Tone.MetalSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The frequency of the cymbal
				 *  @type  {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The array of FMOscillators
				 *  @type  {Array}
				 *  @private
				 */
		        this._oscillators = [];
		        /**
				 *  The frequency multipliers
				 *  @type {Array}
				 *  @private
				 */
		        this._freqMultipliers = [];
		        /**
				 *  The amplitude for the body
				 *  @type {Tone.Gain}
				 *  @private
				 */
		        this._amplitue = new Tone.Gain(0).connect(this.output);
		        /**
				 *  highpass the output
				 *  @type {Tone.Filter}
				 *  @private
				 */
		        this._highpass = new Tone.Filter({
		            'type': 'highpass',
		            'Q': -3.0102999566398125
		        }).connect(this._amplitue);
		        /**
				 *  The number of octaves the highpass
				 *  filter frequency ramps
				 *  @type {Number}
				 *  @private
				 */
		        this._octaves = options.octaves;
		        /**
				 *  Scale the body envelope
				 *  for the bandpass
				 *  @type {Tone.Scale}
				 *  @private
				 */
		        this._filterFreqScaler = new Tone.Scale(options.resonance, 7000);
		        /**
				 *  The envelope which is connected both to the 
				 *  amplitude and highpass filter's cutoff frequency
				 *  @type  {Tone.Envelope}
				 */
		        this.envelope = new Tone.Envelope({
		            'attack': options.envelope.attack,
		            'attackCurve': 'linear',
		            'decay': options.envelope.decay,
		            'sustain': 0,
		            'release': options.envelope.release
		        }).chain(this._filterFreqScaler, this._highpass.frequency);
		        this.envelope.connect(this._amplitue.gain);
		        for (var i = 0; i < inharmRatios.length; i++) {
		            var osc = new Tone.FMOscillator({
		                'type': 'square',
		                'modulationType': 'square',
		                'harmonicity': options.harmonicity,
		                'modulationIndex': options.modulationIndex
		            });
		            osc.connect(this._highpass).start(0);
		            this._oscillators[i] = osc;
		            var mult = new Tone.Multiply(inharmRatios[i]);
		            this._freqMultipliers[i] = mult;
		            this.frequency.chain(mult, osc.frequency);
		        }
		        //set the octaves
		        this.octaves = options.octaves;
		    };
		    Tone.extend(Tone.MetalSynth, Tone.Instrument);
		    /**
			 *  default values
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.MetalSynth.defaults = {
		        'frequency': 200,
		        'envelope': {
		            'attack': 0.001,
		            'decay': 1.4,
		            'release': 0.2
		        },
		        'harmonicity': 5.1,
		        'modulationIndex': 32,
		        'resonance': 4000,
		        'octaves': 1.5
		    };
		    /**
			 *  Trigger the attack.
			 *  @param  {Time}  time      When the attack should be triggered.
			 *  @param  {NormalRange=1}  velocity  The velocity that the envelope should be triggered at.
			 *  @return  {Tone.MetalSynth}  this
			 */
		    Tone.MetalSynth.prototype.triggerAttack = function (time, vel) {
		        time = this.toSeconds(time);
		        vel = this.defaultArg(vel, 1);
		        this.envelope.triggerAttack(time, vel);
		        return this;
		    };
		    /**
			 *  Trigger the release of the envelope.
			 *  @param  {Time}  time      When the release should be triggered.
			 *  @return  {Tone.MetalSynth}  this
			 */
		    Tone.MetalSynth.prototype.triggerRelease = function (time) {
		        time = this.toSeconds(time);
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  Trigger the attack and release of the envelope after the given 
			 *  duration. 
			 *  @param  {Time}  duration  The duration before triggering the release
			 *  @param  {Time}  time      When the attack should be triggered.
			 *  @param  {NormalRange=1}  velocity  The velocity that the envelope should be triggered at.
			 *  @return  {Tone.MetalSynth}  this
			 */
		    Tone.MetalSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
		        time = this.toSeconds(time);
		        duration = this.toSeconds(duration);
		        this.triggerAttack(time, velocity);
		        this.triggerRelease(time + duration);
		        return this;
		    };
		    /**
			 *  The modulationIndex of the oscillators which make up the source.
			 *  see Tone.FMOscillator.modulationIndex
			 *  @memberOf Tone.MetalSynth#
			 *  @type {Positive}
			 *  @name  modulationIndex
			 */
		    Object.defineProperty(Tone.MetalSynth.prototype, 'modulationIndex', {
		        get: function () {
		            return this._oscillators[0].modulationIndex.value;
		        },
		        set: function (val) {
		            for (var i = 0; i < this._oscillators.length; i++) {
		                this._oscillators[i].modulationIndex.value = val;
		            }
		        }
		    });
		    /**
			 *  The harmonicity of the oscillators which make up the source.
			 *  see Tone.FMOscillator.harmonicity
			 *  @memberOf Tone.MetalSynth#
			 *  @type {Positive}
			 *  @name  harmonicity
			 */
		    Object.defineProperty(Tone.MetalSynth.prototype, 'harmonicity', {
		        get: function () {
		            return this._oscillators[0].harmonicity.value;
		        },
		        set: function (val) {
		            for (var i = 0; i < this._oscillators.length; i++) {
		                this._oscillators[i].harmonicity.value = val;
		            }
		        }
		    });
		    /**
			 *  The frequency of the highpass filter attached to the envelope
			 *  @memberOf Tone.MetalSynth#
			 *  @type {Frequency}
			 *  @name  resonance
			 */
		    Object.defineProperty(Tone.MetalSynth.prototype, 'resonance', {
		        get: function () {
		            return this._filterFreqScaler.min;
		        },
		        set: function (val) {
		            this._filterFreqScaler.min = val;
		            this.octaves = this._octaves;
		        }
		    });
		    /**
			 *  The number of octaves above the "resonance" frequency
			 *  that the filter ramps during the attack/decay envelope
			 *  @memberOf Tone.MetalSynth#
			 *  @type {Number}
			 *  @name  octaves
			 */
		    Object.defineProperty(Tone.MetalSynth.prototype, 'octaves', {
		        get: function () {
		            return this._octaves;
		        },
		        set: function (octs) {
		            this._octaves = octs;
		            this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, octs);
		        }
		    });
		    /**
			 *  Clean up
			 *  @returns {Tone.MetalSynth} this
			 */
		    Tone.MetalSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        for (var i = 0; i < this._oscillators.length; i++) {
		            this._oscillators[i].dispose();
		            this._freqMultipliers[i].dispose();
		        }
		        this._oscillators = null;
		        this._freqMultipliers = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this._filterFreqScaler.dispose();
		        this._filterFreqScaler = null;
		        this._amplitue.dispose();
		        this._amplitue = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this._highpass.dispose();
		        this._highpass = null;
		    };
		    return Tone.MetalSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.
			 *          Tone.Noise supports the noise types: "pink", "white", and "brown". Read more about
			 *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {string} type the noise type (white|pink|brown)
			 *  @example
			 * //initialize the noise and start
			 * var noise = new Tone.Noise("pink").start();
			 * 
			 * //make an autofilter to shape the noise
			 * var autoFilter = new Tone.AutoFilter({
			 * 	"frequency" : "8m", 
			 * 	"min" : 800, 
			 * 	"max" : 15000
			 * }).connect(Tone.Master);
			 * 
			 * //connect the noise
			 * noise.connect(autoFilter);
			 * //start the autofilter LFO
			 * autoFilter.start()
			 */
		    Tone.Noise = function () {
		        var options = this.optionsObject(arguments, ['type'], Tone.Noise.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  @private
				 *  @type {AudioBufferSourceNode}
				 */
		        this._source = null;
		        /**
				 *  the buffer
				 *  @private
				 *  @type {AudioBuffer}
				 */
		        this._buffer = null;
		        /**
				 *  The playback rate of the noise. Affects
				 *  the "frequency" of the noise.
				 *  @type {Positive}
				 *  @signal
				 */
		        this._playbackRate = options.playbackRate;
		        this.type = options.type;
		    };
		    Tone.extend(Tone.Noise, Tone.Source);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Noise.defaults = {
		        'type': 'white',
		        'playbackRate': 1
		    };
		    /**
			 * The type of the noise. Can be "white", "brown", or "pink". 
			 * @memberOf Tone.Noise#
			 * @type {string}
			 * @name type
			 * @example
			 * noise.type = "white";
			 */
		    Object.defineProperty(Tone.Noise.prototype, 'type', {
		        get: function () {
		            if (this._buffer === _whiteNoise) {
		                return 'white';
		            } else if (this._buffer === _brownNoise) {
		                return 'brown';
		            } else if (this._buffer === _pinkNoise) {
		                return 'pink';
		            }
		        },
		        set: function (type) {
		            if (this.type !== type) {
		                switch (type) {
		                case 'white':
		                    this._buffer = _whiteNoise;
		                    break;
		                case 'pink':
		                    this._buffer = _pinkNoise;
		                    break;
		                case 'brown':
		                    this._buffer = _brownNoise;
		                    break;
		                default:
		                    throw new TypeError('Tone.Noise: invalid type: ' + type);
		                }
		                //if it's playing, stop and restart it
		                if (this.state === Tone.State.Started) {
		                    var now = this.now() + this.blockTime;
		                    //remove the listener
		                    this._stop(now);
		                    this._start(now);
		                }
		            }
		        }
		    });
		    /**
			 *  The playback rate of the noise. Affects
			 *  the "frequency" of the noise.
			 *  @type {Positive}
			 *  @signal
			 */
		    Object.defineProperty(Tone.Noise.prototype, 'playbackRate', {
		        get: function () {
		            return this._playbackRate;
		        },
		        set: function (rate) {
		            this._playbackRate = rate;
		            if (this._source) {
		                this._source.playbackRate.value = rate;
		            }
		        }
		    });
		    /**
			 *  internal start method
			 *
			 *  @param {Time} time
			 *  @private
			 */
		    Tone.Noise.prototype._start = function (time) {
		        this._source = this.context.createBufferSource();
		        this._source.buffer = this._buffer;
		        this._source.loop = true;
		        this._source.playbackRate.value = this._playbackRate;
		        this._source.connect(this.output);
		        this._source.start(this.toSeconds(time), Math.random() * (this._buffer.duration - 0.001));
		    };
		    /**
			 *  internal stop method
			 *
			 *  @param {Time} time
			 *  @private
			 */
		    Tone.Noise.prototype._stop = function (time) {
		        if (this._source) {
		            this._source.stop(this.toSeconds(time));
		        }
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Noise} this
			 */
		    Tone.Noise.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._source !== null) {
		            this._source.disconnect();
		            this._source = null;
		        }
		        this._buffer = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // THE BUFFERS
		    // borrowed heavily from http://noisehack.com/generate-noise-web-audio-api/
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *	static noise buffers
			 *
			 *  @static
			 *  @private
			 *  @type {AudioBuffer}
			 */
		    var _pinkNoise = null, _brownNoise = null, _whiteNoise = null;
		    Tone._initAudioContext(function (audioContext) {
		        var sampleRate = audioContext.sampleRate;
		        //four seconds per buffer
		        var bufferLength = sampleRate * 4;
		        //fill the buffers
		        _pinkNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                var b0, b1, b2, b3, b4, b5, b6;
		                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
		                for (var i = 0; i < bufferLength; i++) {
		                    var white = Math.random() * 2 - 1;
		                    b0 = 0.99886 * b0 + white * 0.0555179;
		                    b1 = 0.99332 * b1 + white * 0.0750759;
		                    b2 = 0.969 * b2 + white * 0.153852;
		                    b3 = 0.8665 * b3 + white * 0.3104856;
		                    b4 = 0.55 * b4 + white * 0.5329522;
		                    b5 = -0.7616 * b5 - white * 0.016898;
		                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
		                    channel[i] *= 0.11;
		                    // (roughly) compensate for gain
		                    b6 = white * 0.115926;
		                }
		            }
		            return buffer;
		        }();
		        _brownNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                var lastOut = 0;
		                for (var i = 0; i < bufferLength; i++) {
		                    var white = Math.random() * 2 - 1;
		                    channel[i] = (lastOut + 0.02 * white) / 1.02;
		                    lastOut = channel[i];
		                    channel[i] *= 3.5;    // (roughly) compensate for gain
		                }
		            }
		            return buffer;
		        }();
		        _whiteNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                for (var i = 0; i < bufferLength; i++) {
		                    channel[i] = Math.random() * 2 - 1;
		                }
		            }
		            return buffer;
		        }();
		    });
		    return Tone.Noise;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), 
			 *          and two envelopes (Tone.Envelop). One envelope controls the amplitude
			 *          of the noise and the other is controls the cutoff frequency of the filter. 
			 *          <img src="https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242">
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 * @example
			 * var noiseSynth = new Tone.NoiseSynth().toMaster();
			 * noiseSynth.triggerAttackRelease("8n");
			 */
		    Tone.NoiseSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.NoiseSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The noise source.
				 *  @type {Tone.Noise}
				 *  @example
				 * noiseSynth.set("noise.type", "brown");
				 */
		        this.noise = new Tone.Noise();
		        /**
				 *  The amplitude envelope. 
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the noise to the output
		        this.noise.chain(this.envelope, this.output);
		        //start the noise
		        this.noise.start();
		        this._readOnly([
		            'noise',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.NoiseSynth, Tone.Instrument);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.NoiseSynth.defaults = {
		        'noise': { 'type': 'white' },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0
		        }
		    };
		    /**
			 *  Start the attack portion of the envelopes. Unlike other 
			 *  instruments, Tone.NoiseSynth doesn't have a note. 
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {number} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.NoiseSynth} this
			 *  @example
			 * noiseSynth.triggerAttack();
			 */
		    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  Start the release portion of the envelopes.
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.triggerRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  Trigger the attack and then the release. 
			 *  @param  {Time} duration the duration of the note
			 *  @param  {Time} [time=now]     the time of the attack
			 *  @param  {number} [velocity=1] the velocity
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
		        time = this.toSeconds(time);
		        duration = this.toSeconds(duration);
		        this.triggerAttack(time, velocity);
		        this.triggerRelease(time + duration);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'noise',
		            'envelope'
		        ]);
		        this.noise.dispose();
		        this.noise = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        return this;
		    };
		    return Tone.NoiseSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Karplus-String string synthesis. Often out of tune. 
			 *         Will change when the AudioWorkerNode is available across
			 *         browsers. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] see the defaults
			 *  @example
			 * var plucky = new Tone.PluckSynth().toMaster();
			 * plucky.triggerAttack("C4");
			 */
		    Tone.PluckSynth = function (options) {
		        options = this.defaultArg(options, Tone.PluckSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  @type {Tone.Noise}
				 *  @private
				 */
		        this._noise = new Tone.Noise('pink');
		        /**
				 *  The amount of noise at the attack. 
				 *  Nominal range of [0.1, 20]
				 *  @type {number}
				 */
		        this.attackNoise = options.attackNoise;
		        /**
				 *  the LFCF
				 *  @type {Tone.LowpassCombFilter}
				 *  @private
				 */
		        this._lfcf = new Tone.LowpassCombFilter({
		            'resonance': options.resonance,
		            'dampening': options.dampening
		        });
		        /**
				 *  The resonance control. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = this._lfcf.resonance;
		        /**
				 *  The dampening control. i.e. the lowpass filter frequency of the comb filter
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = this._lfcf.dampening;
		        //connections
		        this._noise.connect(this._lfcf);
		        this._lfcf.connect(this.output);
		        this._readOnly([
		            'resonance',
		            'dampening'
		        ]);
		    };
		    Tone.extend(Tone.PluckSynth, Tone.Instrument);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.PluckSynth.defaults = {
		        'attackNoise': 1,
		        'dampening': 4000,
		        'resonance': 0.9
		    };
		    /**
			 *  Trigger the note. 
			 *  @param {Frequency} note The note to trigger.
			 *  @param {Time} [time=now] When the note should be triggered.
			 *  @returns {Tone.PluckSynth} this
			 */
		    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {
		        note = this.toFrequency(note);
		        time = this.toSeconds(time);
		        var delayAmount = 1 / note;
		        this._lfcf.delayTime.setValueAtTime(delayAmount, time);
		        this._noise.start(time);
		        this._noise.stop(time + delayAmount * this.attackNoise);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.PluckSynth} this
			 */
		    Tone.PluckSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._noise.dispose();
		        this._lfcf.dispose();
		        this._noise = null;
		        this._lfcf = null;
		        this._writable([
		            'resonance',
		            'dampening'
		        ]);
		        this.dampening = null;
		        this.resonance = null;
		        return this;
		    };
		    return Tone.PluckSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.PolySynth handles voice creation and allocation for any
			 *          instruments passed in as the second paramter. PolySynth is 
			 *          not a synthesizer by itself, it merely manages voices of 
			 *          one of the other types of synths, allowing any of the 
			 *          monophonic synthesizers to be polyphonic. 
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {number|Object} [polyphony=4] The number of voices to create
			 *  @param {function} [voice=Tone.Synth] The constructor of the voices
			 *                                            uses Tone.Synth by default. 
			 *  @example
			 * //a polysynth composed of 6 Voices of Synth
			 * var synth = new Tone.PolySynth(6, Tone.Synth).toMaster();
			 * //set the attributes using the set interface
			 * synth.set("detune", -1200);
			 * //play a chord
			 * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
			 */
		    Tone.PolySynth = function () {
		        Tone.Instrument.call(this);
		        var options = this.optionsObject(arguments, [
		            'polyphony',
		            'voice'
		        ], Tone.PolySynth.defaults);
		        options = this.defaultArg(options, Tone.Instrument.defaults);
		        //max polyphony
		        options.polyphony = Math.min(Tone.PolySynth.MAX_POLYPHONY, options.polyphony);
		        /**
				 *  the array of voices
				 *  @type {Array}
				 */
		        this.voices = new Array(options.polyphony);
		        /**
				 *  The queue of voices with data about last trigger
				 *  and the triggered note
				 *  @private
				 *  @type {Array}
				 */
		        this._triggers = new Array(options.polyphony);
		        /**
				 *  The detune in cents
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        this._readOnly('detune');
		        //create the voices
		        for (var i = 0; i < options.polyphony; i++) {
		            var v = new options.voice(arguments[2], arguments[3]);
		            this.voices[i] = v;
		            v.connect(this.output);
		            if (v.hasOwnProperty('detune')) {
		                this.detune.connect(v.detune);
		            }
		            this._triggers[i] = {
		                release: -1,
		                note: null,
		                voice: v
		            };
		        }
		        //set the volume initially
		        this.volume.value = options.volume;
		    };
		    Tone.extend(Tone.PolySynth, Tone.Instrument);
		    /**
			 *  the defaults
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.PolySynth.defaults = {
		        'polyphony': 4,
		        'volume': 0,
		        'detune': 0,
		        'voice': Tone.Synth
		    };
		    /**
			 *  Trigger the attack portion of the note
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} [time=now]  The start time of the note.
			 *  @param {number} [velocity=1] The velocity of the note.
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * //trigger a chord immediately with a velocity of 0.2
			 * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
			 */
		    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {
		        if (!Array.isArray(notes)) {
		            notes = [notes];
		        }
		        time = this.toSeconds(time);
		        for (var i = 0; i < notes.length; i++) {
		            var val = notes[i];
		            //trigger the oldest voice
		            var oldest = this._triggers[0];
		            var oldestIndex = 0;
		            for (var j = 1; j < this._triggers.length; j++) {
		                if (this._triggers[j].release < oldest.release) {
		                    oldest = this._triggers[j];
		                    oldestIndex = j;
		                }
		            }
		            oldest.release = Infinity;
		            oldest.note = JSON.stringify(val);
		            oldest.voice.triggerAttack(val, time, velocity);
		        }
		        return this;
		    };
		    /**
			 *  Trigger the attack and release after the specified duration
			 *  
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} duration the duration of the note
			 *  @param  {Time} [time=now]     if no time is given, defaults to now
			 *  @param  {number} [velocity=1] the velocity of the attack (0-1)
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * //trigger a chord for a duration of a half note 
			 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
			 *  @example
			 * //can pass in an array of durations as well
			 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], ["2n", "4n", "4n"]);
			 */
		    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {
		        time = this.toSeconds(time);
		        this.triggerAttack(notes, time, velocity);
		        if (this.isArray(duration) && this.isArray(notes)) {
		            for (var i = 0; i < notes.length; i++) {
		                var d = duration[Math.min(i, duration.length - 1)];
		                this.triggerRelease(notes[i], time + this.toSeconds(d));
		            }
		        } else {
		            this.triggerRelease(notes, time + this.toSeconds(duration));
		        }
		        return this;
		    };
		    /**
			 *  Trigger the release of the note. Unlike monophonic instruments, 
			 *  a note (or array of notes) needs to be passed in as the first argument.
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} [time=now]  When the release will be triggered. 
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * poly.triggerRelease(["Ab3", "C4", "F5"], "+2n");
			 */
		    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {
		        if (!Array.isArray(notes)) {
		            notes = [notes];
		        }
		        time = this.toSeconds(time);
		        for (var i = 0; i < notes.length; i++) {
		            //get the voice
		            var stringified = JSON.stringify(notes[i]);
		            for (var v = 0; v < this._triggers.length; v++) {
		                var desc = this._triggers[v];
		                if (desc.note === stringified && desc.release > time) {
		                    desc.voice.triggerRelease(time);
		                    desc.release = time;
		                }
		            }
		        }
		        return this;
		    };
		    /**
			 *  Set a member/attribute of the voices. 
			 *  @param {Object|string} params
			 *  @param {number=} value
			 *  @param {Time=} rampTime
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * poly.set({
			 * 	"filter" : {
			 * 		"type" : "highpass"
			 * 	},
			 * 	"envelope" : {
			 * 		"attack" : 0.25
			 * 	}
			 * });
			 */
		    Tone.PolySynth.prototype.set = function (params, value, rampTime) {
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].set(params, value, rampTime);
		        }
		        return this;
		    };
		    /**
			 *  Get the synth's attributes. Given no arguments get
			 *  will return all available object properties and their corresponding
			 *  values. Pass in a single attribute to retrieve or an array
			 *  of attributes. The attribute strings can also include a "."
			 *  to access deeper properties.
			 *  @param {Array=} params the parameters to get, otherwise will return 
			 *  					   all available.
			 */
		    Tone.PolySynth.prototype.get = function (params) {
		        return this.voices[0].get(params);
		    };
		    /**
			 *  Trigger the release portion of all the currently active voices.
			 *  @param {Time} [time=now] When the notes should be released.
			 *  @return {Tone.PolySynth} this
			 */
		    Tone.PolySynth.prototype.releaseAll = function (time) {
		        time = this.toSeconds(time);
		        for (var i = 0; i < this._triggers.length; i++) {
		            var desc = this._triggers[i];
		            if (desc.release > time) {
		                desc.release = time;
		                desc.voice.triggerRelease(time);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.PolySynth} this
			 */
		    Tone.PolySynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].dispose();
		            this.voices[i] = null;
		        }
		        this._writable('detune');
		        this.detune.dispose();
		        this.detune = null;
		        this.voices = null;
		        this._triggers = null;
		        return this;
		    };
		    /**
			 *  The maximum number of notes that can be allocated 
			 *  to a polysynth. 
			 *  @type  {Number}
			 *  @static
			 */
		    Tone.PolySynth.MAX_POLYPHONY = 20;
		    return Tone.PolySynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Player is an audio file player with start, loop, and stop functions.
			 *  
			 *  @constructor
			 *  @extends {Tone.Source} 
			 *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from
			 *                                  which to load the AudioBuffer
			 *  @param {function=} onload The function to invoke when the buffer is loaded. 
			 *                            Recommended to use Tone.Buffer.on('load') instead.
			 *  @example
			 * var player = new Tone.Player("./path/to/sample.mp3").toMaster();
			 * //play as soon as the buffer is loaded
			 * player.autostart = true;
			 */
		    Tone.Player = function (url) {
		        var options;
		        if (url instanceof Tone.Buffer) {
		            url = url.get();
		            options = Tone.Player.defaults;
		        } else {
		            options = this.optionsObject(arguments, [
		                'url',
		                'onload'
		            ], Tone.Player.defaults);
		        }
		        Tone.Source.call(this, options);
		        /**
				 *  @private
				 *  @type {AudioBufferSourceNode}
				 */
		        this._source = null;
		        /**
				 *  If the file should play as soon
				 *  as the buffer is loaded. 
				 *  @type {boolean}
				 *  @example
				 * //will play as soon as it's loaded
				 * var player = new Tone.Player({
				 * 	"url" : "./path/to/sample.mp3",
				 * 	"autostart" : true,
				 * }).toMaster();
				 */
		        this.autostart = options.autostart;
		        /**
				 *  the buffer
				 *  @private
				 *  @type {Tone.Buffer}
				 */
		        this._buffer = new Tone.Buffer({
		            'url': options.url,
		            'onload': this._onload.bind(this, options.onload),
		            'reverse': options.reverse
		        });
		        if (url instanceof AudioBuffer) {
		            this._buffer.set(url);
		        }
		        /**
				 *  if the buffer should loop once it's over
				 *  @type {boolean}
				 *  @private
				 */
		        this._loop = options.loop;
		        /**
				 *  if 'loop' is true, the loop will start at this position
				 *  @type {Time}
				 *  @private
				 */
		        this._loopStart = options.loopStart;
		        /**
				 *  if 'loop' is true, the loop will end at this position
				 *  @type {Time}
				 *  @private
				 */
		        this._loopEnd = options.loopEnd;
		        /**
				 *  the playback rate
				 *  @private
				 *  @type {number}
				 */
		        this._playbackRate = options.playbackRate;
		        /**
				 *  Enabling retrigger will allow a player to be restarted
				 *  before the the previous 'start' is done playing. Otherwise, 
				 *  successive calls to Tone.Player.start will only start
				 *  the sample if it had played all the way through. 
				 *  @type {boolean}
				 */
		        this.retrigger = options.retrigger;
		    };
		    Tone.extend(Tone.Player, Tone.Source);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Player.defaults = {
		        'onload': Tone.noOp,
		        'playbackRate': 1,
		        'loop': false,
		        'autostart': false,
		        'loopStart': 0,
		        'loopEnd': 0,
		        'retrigger': false,
		        'reverse': false
		    };
		    /**
			 *  Load the audio file as an audio buffer.
			 *  Decodes the audio asynchronously and invokes
			 *  the callback once the audio buffer loads. 
			 *  Note: this does not need to be called if a url
			 *  was passed in to the constructor. Only use this
			 *  if you want to manually load a new url. 
			 * @param {string} url The url of the buffer to load.
			 *                     Filetype support depends on the
			 *                     browser.
			 *  @param  {function=} callback The function to invoke once
			 *                               the sample is loaded.
			 *  @returns {Promise}
			 */
		    Tone.Player.prototype.load = function (url, callback) {
		        return this._buffer.load(url, this._onload.bind(this, callback));
		    };
		    /**
			 * Internal callback when the buffer is loaded.
			 * @private
			 */
		    Tone.Player.prototype._onload = function (callback) {
		        callback = this.defaultArg(callback, Tone.noOp);
		        callback(this);
		        if (this.autostart) {
		            this.start();
		        }
		    };
		    /**
			 *  Play the buffer at the given startTime. Optionally add an offset
			 *  and/or duration which will play the buffer from a position
			 *  within the buffer for the given duration. 
			 *  
			 *  @param  {Time} [startTime=now] When the player should start.
			 *  @param  {Time} [offset=0] The offset from the beginning of the sample
			 *                                 to start at. 
			 *  @param  {Time=} duration How long the sample should play. If no duration
			 *                                is given, it will default to the full length 
			 *                                of the sample (minus any offset)
			 *  @returns {Tone.Player} this
			 *  @memberOf Tone.Player#
			 *  @method start
			 *  @name start
			 */
		    /**
			 *  Internal start method
			 *  @private
			 */
		    Tone.Player.prototype._start = function (startTime, offset, duration) {
		        if (this._buffer.loaded) {
		            //if it's a loop the default offset is the loopstart point
		            if (this._loop) {
		                offset = this.defaultArg(offset, this._loopStart);
		            } else {
		                //otherwise the default offset is 0
		                offset = this.defaultArg(offset, 0);
		            }
		            offset = this.toSeconds(offset);
		            //make sure it has a positive duration
		            duration = this.defaultArg(duration, Math.max(this._buffer.duration - offset, 0));
		            duration = this.toSeconds(duration);
		            //the values in seconds
		            startTime = this.toSeconds(startTime);
		            //make the source
		            this._source = this.context.createBufferSource();
		            this._source.buffer = this._buffer.get();
		            //set the looping properties
		            if (this._loop) {
		                this._source.loop = this._loop;
		                this._source.loopStart = this.toSeconds(this._loopStart);
		                this._source.loopEnd = this.toSeconds(this._loopEnd);
		            } else {
		                //if it's not looping, set the state change at the end of the sample
		                this._state.setStateAtTime(Tone.State.Stopped, startTime + duration);
		            }
		            //and other properties
		            this._source.playbackRate.value = this._playbackRate;
		            this._source.connect(this.output);
		            //start it
		            if (this._loop) {
		                //modify the offset if it's greater than the loop time
		                var loopEnd = this._source.loopEnd || this._buffer.duration;
		                var loopStart = this._source.loopStart;
		                var loopDuration = loopEnd - loopStart;
		                if (offset > loopEnd) {
		                    //move the offset back
		                    while (offset > loopEnd) {
		                        offset -= loopDuration;
		                    }
		                }
		                this._source.start(startTime, offset);
		            } else {
		                this._source.start(startTime, offset, duration);
		            }
		        } else {
		            throw Error('Tone.Player: tried to start Player before the buffer was loaded');
		        }
		        return this;
		    };
		    /**
			 *  Stop playback.
			 *  @private
			 *  @param  {Time} [time=now]
			 *  @returns {Tone.Player} this
			 */
		    Tone.Player.prototype._stop = function (time) {
		        if (this._source) {
		            this._source.stop(this.toSeconds(time));
		            this._source = null;
		        }
		        return this;
		    };
		    /**
			 *  Seek to a specific time in the player's buffer. If the 
			 *  source is no longer playing at that time, it will stop.
			 *  If you seek to a time that 
			 *  @param {Time} offset The time to seek to.
			 *  @param {Time=} time The time for the seek event to occur.
			 *  @return {Tone.Player} this
			 *  @example
			 * source.start(0.2);
			 * source.stop(0.4);
			 */
		    Tone.Player.prototype.seek = function (offset, time) {
		        time = this.toSeconds(time);
		        if (this._state.getValueAtTime(time) === Tone.State.Started) {
		            offset = this.toSeconds(offset);
		            // if it's currently playing, stop it
		            this._stop(time);
		            //restart it at the given time
		            this._start(time, offset);
		        }
		        return this;
		    };
		    /**
			 *  Set the loop start and end. Will only loop if loop is 
			 *  set to true. 
			 *  @param {Time} loopStart The loop end time
			 *  @param {Time} loopEnd The loop end time
			 *  @returns {Tone.Player} this
			 *  @example
			 * //loop 0.1 seconds of the file. 
			 * player.setLoopPoints(0.2, 0.3);
			 * player.loop = true;
			 */
		    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {
		        this.loopStart = loopStart;
		        this.loopEnd = loopEnd;
		        return this;
		    };
		    /**
			 * If loop is true, the loop will start at this position. 
			 * @memberOf Tone.Player#
			 * @type {Time}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loopStart', {
		        get: function () {
		            return this._loopStart;
		        },
		        set: function (loopStart) {
		            this._loopStart = loopStart;
		            if (this._source) {
		                this._source.loopStart = this.toSeconds(loopStart);
		            }
		        }
		    });
		    /**
			 * If loop is true, the loop will end at this position.
			 * @memberOf Tone.Player#
			 * @type {Time}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {
		        get: function () {
		            return this._loopEnd;
		        },
		        set: function (loopEnd) {
		            this._loopEnd = loopEnd;
		            if (this._source) {
		                this._source.loopEnd = this.toSeconds(loopEnd);
		            }
		        }
		    });
		    /**
			 * The audio buffer belonging to the player. 
			 * @memberOf Tone.Player#
			 * @type {Tone.Buffer}
			 * @name buffer
			 */
		    Object.defineProperty(Tone.Player.prototype, 'buffer', {
		        get: function () {
		            return this._buffer;
		        },
		        set: function (buffer) {
		            this._buffer.set(buffer);
		        }
		    });
		    /**
			 * If the buffer should loop once it's over. 
			 * @memberOf Tone.Player#
			 * @type {boolean}
			 * @name loop
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loop', {
		        get: function () {
		            return this._loop;
		        },
		        set: function (loop) {
		            this._loop = loop;
		            if (this._source) {
		                this._source.loop = loop;
		            }
		        }
		    });
		    /**
			 * The playback speed. 1 is normal speed. This is not a signal because
			 * Safari and iOS currently don't support playbackRate as a signal.
			 * @memberOf Tone.Player#
			 * @type {number}
			 * @name playbackRate
			 */
		    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {
		        get: function () {
		            return this._playbackRate;
		        },
		        set: function (rate) {
		            this._playbackRate = rate;
		            if (this._source) {
		                this._source.playbackRate.value = rate;
		            }
		        }
		    });
		    /**
			 * The direction the buffer should play in
			 * @memberOf Tone.Player#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Player.prototype, 'reverse', {
		        get: function () {
		            return this._buffer.reverse;
		        },
		        set: function (rev) {
		            this._buffer.reverse = rev;
		        }
		    });
		    /**
			 *  Dispose and disconnect.
			 *  @return {Tone.Player} this
			 */
		    Tone.Player.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._source !== null) {
		            this._source.disconnect();
		            this._source = null;
		        }
		        this._buffer.dispose();
		        this._buffer = null;
		        return this;
		    };
		    return Tone.Player;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Sampler wraps Tone.Player in an AmplitudeEnvelope.
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {String} url the url of the audio file
			 *  @param {Function=} onload The callback to invoke when the sample is loaded.
			 *  @example
			 * var sampler = new Sampler("./audio/casio/A1.mp3", function(){
			 * 	//repitch the sample down a half step
			 * 	sampler.triggerAttack(-1);
			 * }).toMaster();
			 */
		    Tone.Sampler = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload'
		        ], Tone.Sampler.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The sample player.
				 *  @type {Tone.Player}
				 */
		        this.player = new Tone.Player(options.url, options.onload);
		        this.player.retrigger = true;
		        /**
				 *  The amplitude envelope. 
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        this.player.chain(this.envelope, this.output);
		        this._readOnly([
		            'player',
		            'envelope'
		        ]);
		        this.loop = options.loop;
		        this.reverse = options.reverse;
		    };
		    Tone.extend(Tone.Sampler, Tone.Instrument);
		    /**
			 *  the default parameters
			 *  @static
			 */
		    Tone.Sampler.defaults = {
		        'onload': Tone.noOp,
		        'loop': false,
		        'reverse': false,
		        'envelope': {
		            'attack': 0.001,
		            'decay': 0,
		            'sustain': 1,
		            'release': 0.1
		        }
		    };
		    /**
			 *  Trigger the start of the sample. 
			 *  @param {Interval} [pitch=0] The amount the sample should
			 *                              be repitched. 
			 *  @param {Time} [time=now] The time when the sample should start
			 *  @param {NormalRange} [velocity=1] The velocity of the note
			 *  @returns {Tone.Sampler} this
			 *  @example
			 * sampler.triggerAttack(0, "+0.1", 0.5);
			 */
		    Tone.Sampler.prototype.triggerAttack = function (pitch, time, velocity) {
		        time = this.toSeconds(time);
		        pitch = this.defaultArg(pitch, 0);
		        this.player.playbackRate = this.intervalToFrequencyRatio(pitch);
		        this.player.start(time);
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  Start the release portion of the sample. Will stop the sample once the 
			 *  envelope has fully released. 
			 *  
			 *  @param {Time} [time=now] The time when the note should release
			 *  @returns {Tone.Sampler} this
			 *  @example
			 * sampler.triggerRelease();
			 */
		    Tone.Sampler.prototype.triggerRelease = function (time) {
		        time = this.toSeconds(time);
		        this.envelope.triggerRelease(time);
		        this.player.stop(this.toSeconds(this.envelope.release) + time);
		        return this;
		    };
		    /**
			 *  Trigger the attack and then the release after the duration. 
			 *  @param  {Interval} interval     The interval in half-steps that the
			 *                                  sample should be pitch shifted.
			 *  @param  {Time} duration How long the note should be held for before
			 *                          triggering the release.
			 *  @param {Time} [time=now]  When the note should be triggered.
			 *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.
			 *  @returns {Tone.Sampler} this
			 *  @example
			 * //trigger the unpitched note for the duration of an 8th note
			 * synth.triggerAttackRelease(0, "8n");
			 *  @memberOf Tone.Sampler#
			 *  @name triggerAttackRelease
			 *  @method triggerAttackRelease
			 */
		    /**
			 * If the output sample should loop or not.
			 * @memberOf Tone.Sampler#
			 * @type {number|string}
			 * @name loop
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'loop', {
		        get: function () {
		            return this.player.loop;
		        },
		        set: function (loop) {
		            this.player.loop = loop;
		        }
		    });
		    /**
			 * The direction the buffer should play in
			 * @memberOf Tone.Sampler#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'reverse', {
		        get: function () {
		            return this.player.reverse;
		        },
		        set: function (rev) {
		            this.player.reverse = rev;
		        }
		    });
		    /**
			 * The buffer to play.
			 * @memberOf Tone.Sampler#
			 * @type {Tone.Buffer}
			 * @name buffer
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'buffer', {
		        get: function () {
		            return this.player.buffer;
		        },
		        set: function (buff) {
		            this.player.buffer = buff;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Sampler} this
			 */
		    Tone.Sampler.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'player',
		            'envelope'
		        ]);
		        this.player.dispose();
		        this.player = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        return this;
		    };
		    return Tone.Sampler;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. 
			 *         See also Tone.AudioToGain. 
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var g2a = new Tone.GainToAudio();
			 */
		    Tone.GainToAudio = function () {
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
		            return Math.abs(x) * 2 - 1;
		        });
		    };
		    Tone.extend(Tone.GainToAudio, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.GainToAudio} this
			 */
		    Tone.GainToAudio.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._norm.dispose();
		        this._norm = null;
		        return this;
		    };
		    return Tone.GainToAudio;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} inputMin the min input value
			 *  @param {number} inputMax the max input value
			 *  @example
			 * var norm = new Tone.Normalize(2, 4);
			 * var sig = new Tone.Signal(3).connect(norm);
			 * //output of norm is 0.5. 
			 */
		    Tone.Normalize = function (inputMin, inputMax) {
		        /**
				 *  the min input value
				 *  @type {number}
				 *  @private
				 */
		        this._inputMin = this.defaultArg(inputMin, 0);
		        /**
				 *  the max input value
				 *  @type {number}
				 *  @private
				 */
		        this._inputMax = this.defaultArg(inputMax, 1);
		        /**
				 *  subtract the min from the input
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._sub = this.input = new Tone.Add(0);
		        /**
				 *  divide by the difference between the input and output
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._div = this.output = new Tone.Multiply(1);
		        this._sub.connect(this._div);
		        this._setRange();
		    };
		    Tone.extend(Tone.Normalize, Tone.SignalBase);
		    /**
			 * The minimum value the input signal will reach.
			 * @memberOf Tone.Normalize#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.Normalize.prototype, 'min', {
		        get: function () {
		            return this._inputMin;
		        },
		        set: function (min) {
		            this._inputMin = min;
		            this._setRange();
		        }
		    });
		    /**
			 * The maximum value the input signal will reach.
			 * @memberOf Tone.Normalize#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.Normalize.prototype, 'max', {
		        get: function () {
		            return this._inputMax;
		        },
		        set: function (max) {
		            this._inputMax = max;
		            this._setRange();
		        }
		    });
		    /**
			 *  set the values
			 *  @private
			 */
		    Tone.Normalize.prototype._setRange = function () {
		        this._sub.value = -this._inputMin;
		        this._div.value = 1 / (this._inputMax - this._inputMin);
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Normalize} this
			 */
		    Tone.Normalize.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sub.dispose();
		        this._sub = null;
		        this._div.dispose();
		        this._div = null;
		        return this;
		    };
		    return Tone.Normalize;
		});
		Module(function (Tone) {
		    /**
			 *  @class Wrapper around the native BufferSourceNode.
			 *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play
			 *  @param  {Function}  onended  The callback to invoke when the 
			 *                               buffer is done playing.
			 */
		    Tone.BufferSource = function () {
		        var options = this.optionsObject(arguments, [
		            'buffer',
		            'onended'
		        ], Tone.BufferSource.defaults);
		        /**
				 *  The callback to invoke after the 
				 *  buffer source is done playing. 
				 *  @type  {Function}
				 */
		        this.onended = options.onended;
		        /**
				 *  The time that the buffer was started.
				 *  @type  {Number}
				 *  @private
				 */
		        this._startTime = -1;
		        /**
				 *  The time that the buffer is scheduled to stop.
				 *  @type  {Number}
				 *  @private
				 */
		        this._stopTime = -1;
		        /**
				 *  The gain node which envelopes the BufferSource
				 *  @type  {Tone.Gain}
				 *  @private
				 */
		        this._gainNode = this.output = new Tone.Gain();
		        /**
				 *  The buffer source
				 *  @type  {AudioBufferSourceNode}
				 *  @private
				 */
		        this._source = this.context.createBufferSource();
		        this._source.connect(this._gainNode);
		        /**
				 *  The playbackRate of the buffer
				 *  @type {Positive}
				 *  @signal
				 */
		        this.playbackRate = new Tone.Param(this._source.playbackRate, Tone.Type.Positive);
		        /**
				 *  The fadeIn time of the amplitude envelope.
				 *  @type {Time}
				 */
		        this.fadeIn = options.fadeIn;
		        /**
				 *  The fadeOut time of the amplitude envelope.
				 *  @type {Time}
				 */
		        this.fadeOut = options.fadeOut;
		        /**
				 *  The value that the buffer ramps to
				 *  @type {Gain}
				 *  @private
				 */
		        this._gain = 1;
		        /**
				 * The onended timeout
				 * @type {Number}
				 * @private
				 */
		        this._onendedTimeout = -1;
		        //set the buffer initially
		        if (!this.isUndef(options.buffer)) {
		            this.buffer = options.buffer;
		        }
		        this.loop = options.loop;
		    };
		    Tone.extend(Tone.BufferSource);
		    /**
			 *  The defaults
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.BufferSource.defaults = {
		        'onended': Tone.noOp,
		        'fadeIn': 0,
		        'fadeOut': 0
		    };
		    /**
			 *  Returns the playback state of the source, either "started" or "stopped".
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.BufferSource#
			 *  @name state
			 */
		    Object.defineProperty(Tone.BufferSource.prototype, 'state', {
		        get: function () {
		            var now = this.now();
		            if (this._startTime !== -1 && now >= this._startTime && now < this._stopTime) {
		                return Tone.State.Started;
		            } else {
		                return Tone.State.Stopped;
		            }
		        }
		    });
		    /**
			 *  Start the buffer
			 *  @param  {Time} [startTime=now] When the player should start.
			 *  @param  {Time} [offset=0] The offset from the beginning of the sample
			 *                                 to start at. 
			 *  @param  {Time=} duration How long the sample should play. If no duration
			 *                                is given, it will default to the full length 
			 *                                of the sample (minus any offset)
			 *  @param  {Gain}  [gain=1]  The gain to play the buffer back at.
			 *  @param  {Time=}  fadeInTime  The optional fadeIn ramp time.
			 *  @return  {Tone.BufferSource}  this
			 */
		    Tone.BufferSource.prototype.start = function (time, offset, duration, gain, fadeInTime) {
		        if (this._startTime !== -1) {
		            throw new Error('Tone.BufferSource: can only be started once.');
		        }
		        if (this.buffer) {
		            time = this.toSeconds(time);
		            //if it's a loop the default offset is the loopstart point
		            if (this.loop) {
		                offset = this.defaultArg(offset, this.loopStart);
		            } else {
		                //otherwise the default offset is 0
		                offset = this.defaultArg(offset, 0);
		            }
		            offset = this.toSeconds(offset);
		            //the values in seconds
		            time = this.toSeconds(time);
		            this._source.start(time, offset);
		            gain = this.defaultArg(gain, 1);
		            this._gain = gain;
		            //the fadeIn time
		            if (this.isUndef(fadeInTime)) {
		                fadeInTime = this.toSeconds(this.fadeIn);
		            } else {
		                fadeInTime = this.toSeconds(fadeInTime);
		            }
		            if (fadeInTime > 0) {
		                this._gainNode.gain.setValueAtTime(0, time);
		                this._gainNode.gain.linearRampToValueAtTime(this._gain, time + fadeInTime);
		            } else {
		                this._gainNode.gain.setValueAtTime(gain, time);
		            }
		            this._startTime = time + fadeInTime;
		            if (!this.isUndef(duration)) {
		                duration = this.defaultArg(duration, this.buffer.duration - offset);
		                duration = this.toSeconds(duration);
		                this.stop(time + duration + fadeInTime, fadeInTime);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Stop the buffer. Optionally add a ramp time to fade the 
			 *  buffer out. 
			 *  @param  {Time=}  time         The time the buffer should stop.
			 *  @param  {Time=}  fadeOutTime  How long the gain should fade out for
			 *  @return  {Tone.BufferSource}  this
			 */
		    Tone.BufferSource.prototype.stop = function (time, fadeOutTime) {
		        if (this.buffer) {
		            time = this.toSeconds(time);
		            //the fadeOut time
		            if (this.isUndef(fadeOutTime)) {
		                fadeOutTime = this.toSeconds(this.fadeOut);
		            } else {
		                fadeOutTime = this.toSeconds(fadeOutTime);
		            }
		            this._stopTime = time + fadeOutTime;
		            //cancel the end curve
		            this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
		            //set a new one
		            if (fadeOutTime > 0) {
		                this._gainNode.gain.setValueAtTime(this._gain, time);
		                this._gainNode.gain.linearRampToValueAtTime(0, time + fadeOutTime);
		                time += fadeOutTime;
		            } else {
		                this._gainNode.gain.setValueAtTime(0, time);
		            }
		            // fix for safari bug and old FF
		            if (!this.isNumber(this._source.playbackState) || this._source.playbackState === 2) {
		                this._source.stop(time);
		            }
		            clearTimeout(this._onendedTimeout);
		            this._onendedTimeout = setTimeout(this._onended.bind(this), (this._stopTime - this.now()) * 1000);
		        }
		        return this;
		    };
		    /**
			 *  Internal callback when the buffer is ended. 
			 *  Invokes `onended` and disposes the node.
			 *  @private
			 */
		    Tone.BufferSource.prototype._onended = function () {
		        this.onended(this);
		        this.dispose();
		    };
		    /**
			 * If loop is true, the loop will start at this position. 
			 * @memberOf Tone.BufferSource#
			 * @type {Time}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.BufferSource.prototype, 'loopStart', {
		        get: function () {
		            return this._source.loopStart;
		        },
		        set: function (loopStart) {
		            this._source.loopStart = this.toSeconds(loopStart);
		        }
		    });
		    /**
			 * If loop is true, the loop will end at this position.
			 * @memberOf Tone.BufferSource#
			 * @type {Time}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.BufferSource.prototype, 'loopEnd', {
		        get: function () {
		            return this._source.loopEnd;
		        },
		        set: function (loopEnd) {
		            this._source.loopEnd = this.toSeconds(loopEnd);
		        }
		    });
		    /**
			 * The audio buffer belonging to the player. 
			 * @memberOf Tone.BufferSource#
			 * @type {AudioBuffer}
			 * @name buffer
			 */
		    Object.defineProperty(Tone.BufferSource.prototype, 'buffer', {
		        get: function () {
		            if (this._source) {
		                return this._source.buffer;
		            } else {
		                return null;
		            }
		        },
		        set: function (buffer) {
		            if (buffer instanceof Tone.Buffer) {
		                this._source.buffer = buffer.get();
		            } else {
		                this._source.buffer = buffer;
		            }
		        }
		    });
		    /**
			 * If the buffer should loop once it's over. 
			 * @memberOf Tone.BufferSource#
			 * @type {boolean}
			 * @name loop
			 */
		    Object.defineProperty(Tone.BufferSource.prototype, 'loop', {
		        get: function () {
		            return this._source.loop;
		        },
		        set: function (loop) {
		            this._source.loop = loop;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return  {Tone.BufferSource}  this
			 */
		    Tone.BufferSource.prototype.dispose = function () {
		        this.onended = null;
		        if (this._source) {
		            this._source.disconnect();
		            this._source = null;
		        }
		        if (this._gainNode) {
		            this._gainNode.dispose();
		            this._gainNode = null;
		        }
		        this._startTime = -1;
		        this.playbackRate = null;
		        this.output = null;
		        clearTimeout(this._onendedTimeout);
		        return this;
		    };
		    return Tone.BufferSource;
		});
		Module(function (Tone) {
		    /**
			 *  @class Tone.MultiPlayer is well suited for one-shots, multi-sampled instruments
			 *         or any time you need to play a bunch of audio buffers. 
			 *  @param  {Object|Array|Tone.Buffers}  buffers  The buffers which are available
			 *                                                to the MultiPlayer
			 *  @param {Function} onload The callback to invoke when all of the buffers are loaded.
			 *  @extends {Tone}
			 *  @example
			 * var multiPlayer = new MultiPlayer({
			 * 	"kick" : "path/to/kick.mp3",
			 * 	"snare" : "path/to/snare.mp3",
			 * }, function(){
			 * 	multiPlayer.start("kick");
			 * });
			 *  @example
			 * //can also store the values in an array
			 * var multiPlayer = new MultiPlayer(["path/to/kick.mp3", "path/to/snare.mp3"], 
			 * function(){
			 * 	//if an array is passed in, the samples are referenced to by index
			 * 	multiPlayer.start(1);
			 * });
			 */
		    Tone.MultiPlayer = function () {
		        var options = this.optionsObject(arguments, [
		            'urls',
		            'onload'
		        ], Tone.MultiPlayer.defaults);
		        if (options.urls instanceof Tone.Buffers) {
		            /**
					 *  All the buffers belonging to the player.
					 *  @type  {Tone.Buffers}
					 */
		            this.buffers = options.urls;
		        } else {
		            this.buffers = new Tone.Buffers(options.urls, options.onload);
		        }
		        /**
				 *  Keeps track of the currently playing sources.
				 *  @type  {Object}
				 *  @private
				 */
		        this._activeSources = {};
		        /**
				 *  The fade in envelope which is applied
				 *  to the beginning of the BufferSource
				 *  @type  {Time}
				 */
		        this.fadeIn = options.fadeIn;
		        /**
				 *  The fade out envelope which is applied
				 *  to the end of the BufferSource
				 *  @type  {Time}
				 */
		        this.fadeOut = options.fadeOut;
		        /**
				 *  The output volume node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
		        this._volume = this.output = new Tone.Volume(options.volume);
		        /**
				 * The volume of the output in decibels.
				 * @type {Decibels}
				 * @signal
				 * @example
				 * source.volume.value = -6;
				 */
		        this.volume = this._volume.volume;
		        this._readOnly('volume');
		        //make the output explicitly stereo
		        this._volume.output.output.channelCount = 2;
		        this._volume.output.output.channelCountMode = 'explicit';
		        //mute initially
		        this.mute = options.mute;
		    };
		    Tone.extend(Tone.MultiPlayer, Tone.Source);
		    /**
			 *  The defaults
			 *  @type  {Object}
			 */
		    Tone.MultiPlayer.defaults = {
		        'onload': Tone.noOp,
		        'fadeIn': 0,
		        'fadeOut': 0
		    };
		    /**
			 * Make the source from the buffername
			 * @param  {String} bufferName
			 * @return {Tone.BufferSource}
			 * @private
			 */
		    Tone.MultiPlayer.prototype._makeSource = function (bufferName) {
		        var buffer;
		        if (this.isString(bufferName) || this.isNumber(bufferName)) {
		            buffer = this.buffers.get(bufferName).get();
		        } else if (bufferName instanceof Tone.Buffer) {
		            buffer = bufferName.get();
		        } else if (bufferName instanceof AudioBuffer) {
		            buffer = bufferName;
		        }
		        var source = new Tone.BufferSource(buffer).connect(this.output);
		        if (!this._activeSources.hasOwnProperty(bufferName)) {
		            this._activeSources[bufferName] = [];
		        }
		        this._activeSources[bufferName].push(source);
		        return source;
		    };
		    /**
			 *  Start a buffer by name. The `start` method allows a number of options
			 *  to be passed in such as offset, interval, and gain. This is good for multi-sampled 
			 *  instruments and sound sprites where samples are repitched played back at different velocities.
			 *  @param  {String}  bufferName    The name of the buffer to start.
			 *  @param  {Time}  time      When to start the buffer.
			 *  @param  {Time}  [offset=0]    The offset into the buffer to play from.
			 *  @param  {Time=}  duration   How long to play the buffer for.
			 *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.
			 *  @param  {Gain}  [gain=1]      The gain to play the sample at.
			 *  @return  {Tone.MultiPlayer}  this
			 */
		    Tone.MultiPlayer.prototype.start = function (bufferName, time, offset, duration, pitch, gain) {
		        time = this.toSeconds(time);
		        var source = this._makeSource(bufferName);
		        source.start(time, offset, duration, this.defaultArg(gain, 1), this.fadeIn);
		        if (duration) {
		            source.stop(time + this.toSeconds(duration), this.fadeOut);
		        }
		        pitch = this.defaultArg(pitch, 0);
		        source.playbackRate.value = this.intervalToFrequencyRatio(pitch);
		        return this;
		    };
		    /**
			 *  Start a looping buffer by name. Similar to `start`, but the buffer
			 *  is looped instead of played straight through. Can still be stopped with `stop`. 
			 *  @param  {String}  bufferName    The name of the buffer to start.
			 *  @param  {Time}  time      When to start the buffer.
			 *  @param  {Time}  [offset=0]    The offset into the buffer to play from.
			 *  @param  {Time=}  loopStart   The start of the loop.
			 *  @param  {Time=}  loopEnd	The end of the loop.
			 *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.
			 *  @param  {Gain}  [gain=1]      The gain to play the sample at.
			 *  @return  {Tone.MultiPlayer}  this
			 */
		    Tone.MultiPlayer.prototype.startLoop = function (bufferName, time, offset, loopStart, loopEnd, pitch, gain) {
		        time = this.toSeconds(time);
		        var source = this._makeSource(bufferName);
		        source.loop = true;
		        source.loopStart = this.toSeconds(this.defaultArg(loopStart, 0));
		        source.loopEnd = this.toSeconds(this.defaultArg(loopEnd, 0));
		        source.start(time, offset, undefined, this.defaultArg(gain, 1), this.fadeIn);
		        pitch = this.defaultArg(pitch, 0);
		        source.playbackRate.value = this.intervalToFrequencyRatio(pitch);
		        return this;
		    };
		    /**
			 *  Stop the first played instance of the buffer name.
			 *  @param  {String}  bufferName  The buffer to stop.
			 *  @param  {Time=}  time    When to stop the buffer
			 *  @return  {Tone.MultiPlayer}  this
			 */
		    Tone.MultiPlayer.prototype.stop = function (bufferName, time) {
		        if (this._activeSources[bufferName] && this._activeSources[bufferName].length) {
		            time = this.toSeconds(time);
		            this._activeSources[bufferName].shift().stop(time, this.fadeOut);
		        } else {
		            throw new Error('Tone.MultiPlayer: cannot stop a buffer that hasn\'t been started or is already stopped');
		        }
		        return this;
		    };
		    /**
			 *  Stop all currently playing buffers at the given time.
			 *  @param  {Time=}  time  When to stop the buffers.
			 *  @return  {Tone.MultiPlayer}  this
			 */
		    Tone.MultiPlayer.prototype.stopAll = function (time) {
		        time = this.toSeconds(time);
		        for (var bufferName in this._activeSources) {
		            var sources = this._activeSources[bufferName];
		            for (var i = 0; i < sources.length; i++) {
		                sources[i].stop(time);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Add another buffer to the available buffers.
			 *  @param {String} name The name to that the buffer is refered
			 *                       to in start/stop methods. 
			 *  @param {String|Tone.Buffer} url The url of the buffer to load
			 *                                  or the buffer.
			 *  @param {Function} callback The function to invoke after the buffer is loaded.
			 */
		    Tone.MultiPlayer.prototype.add = function (name, url, callback) {
		        this.buffers.add(name, url, callback);
		        return this;
		    };
		    /**
			 *  Returns the playback state of the source. "started"
			 *  if there are any buffers playing. "stopped" otherwise.
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.MultiPlayer#
			 *  @name state
			 */
		    Object.defineProperty(Tone.MultiPlayer.prototype, 'state', {
		        get: function () {
		            return this._activeSources.length > 0 ? Tone.State.Started : Tone.State.Stopped;
		        }
		    });
		    /**
			 * Mute the output. 
			 * @memberOf Tone.MultiPlayer#
			 * @type {boolean}
			 * @name mute
			 * @example
			 * //mute the output
			 * source.mute = true;
			 */
		    Object.defineProperty(Tone.MultiPlayer.prototype, 'mute', {
		        get: function () {
		            return this._volume.mute;
		        },
		        set: function (mute) {
		            this._volume.mute = mute;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return  {Tone.MultiPlayer}  this
			 */
		    Tone.MultiPlayer.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._volume.dispose();
		        this._volume = null;
		        this._writable('volume');
		        this.volume = null;
		        for (var bufferName in this._activeSources) {
		            this._activeSources[bufferName].forEach(function (source) {
		                source.dispose();
		            });
		        }
		        this.buffers.dispose();
		        this.buffers = null;
		        this._activeSources = null;
		        return this;
		    };
		    return Tone.MultiPlayer;
		});
		Module(function (Tone) {
		    /**
			 * @class Tone.GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).
			 *        Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the 
			 *        amount of time each small chunk of audio is played for and the overlap is the 
			 *        amount of crossfading transition time between successive grains.
			 * @extends {Tone}
			 * @param {String|Tone.Buffer} url	The url to load, or the Tone.Buffer to play.
			 * @param {Function=} callback The callback to invoke after the url is loaded.
			 */
		    Tone.GrainPlayer = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload'
		        ], Tone.GrainPlayer.defaults);
		        Tone.Source.call(this);
		        /**
				 *  The audio buffer belonging to the player.
				 *  @type  {Tone.Buffer}
				 */
		        this.buffer = new Tone.Buffer(options.url, options.onload);
		        /**
				 *  Plays the buffer with a small envelope
				 *  @type  {Tone.MultiPlayer}
				 *  @private
				 */
		        this._player = this.output = new Tone.MultiPlayer();
		        /**
				 *  Create a repeating tick to schedule
				 *  the grains.
				 *  @type  {Tone.Clock}
				 *  @private
				 */
		        this._clock = new Tone.Clock(this._tick.bind(this), 1);
		        /**
				 *  @type  {Number}
				 *  @private
				 */
		        this._loopStart = 0;
		        /**
				 *  @type  {Number}
				 *  @private
				 */
		        this._loopEnd = 0;
		        /**
				 *  @type  {Number}
				 *  @private
				 */
		        this._playbackRate = options.playbackRate;
		        /**
				 *  @type  {Number}
				 *  @private
				 */
		        this._grainSize = options.grainSize;
		        /**
				 *  @private
				 *  @type {Number}
				 */
		        this._overlap = options.overlap;
		        /**
				 *  Adjust the pitch independently of the playbackRate.
				 *  @type  {Cents}
				 */
		        this.detune = options.detune;
		        /**
				 *  The amount of time randomly added
				 *  or subtracted from the grain's offset
				 *  @type  {Time}
				 */
		        this.drift = options.drift;
		        //setup
		        this.overlap = options.overlap;
		        this.loop = options.loop;
		        this.playbackRate = options.playbackRate;
		        this.grainSize = options.grainSize;
		        this.loopStart = options.loopStart;
		        this.loopEnd = options.loopEnd;
		        this.reverse = options.reverse;
		    };
		    Tone.extend(Tone.GrainPlayer, Tone.Source);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.GrainPlayer.defaults = {
		        'onload': Tone.noOp,
		        'overlap': 0.1,
		        'grainSize': 0.2,
		        'drift': 0,
		        'playbackRate': 1,
		        'detune': 0,
		        'loop': false,
		        'loopStart': 0,
		        'loopEnd': 0,
		        'reverse': false
		    };
		    /**
			 *  Play the buffer at the given startTime. Optionally add an offset
			 *  from the start of the buffer to play from.
			 *  
			 *  @param  {Time} [startTime=now] When the player should start.
			 *  @param  {Time} [offset=0] The offset from the beginning of the sample
			 *                                 to start at. 
			 * @return {Tone.GrainPlayer} this
			 */
		    /**
			 *  Internal start method
			 *  @param {Time} time
			 *  @param {Time} offset
			 *  @private
			 */
		    Tone.GrainPlayer.prototype._start = function (time, offset) {
		        offset = this.defaultArg(offset, 0);
		        offset = this.toSeconds(offset);
		        time = this.toSeconds(time);
		        this._offset = offset;
		        this._clock.start(time);
		    };
		    /**
			 *  Internal start method
			 *  @param {Time} time
			 *  @private
			 */
		    Tone.GrainPlayer.prototype._stop = function (time) {
		        this._clock.stop(time);
		        this._player.stop(this.buffer, time);
		        this._offset = 0;
		    };
		    /**
			 *  Invoked on each clock tick. scheduled a new
			 *  grain at this time.
			 *  @param  {Time}  time 
			 *  @private
			 */
		    Tone.GrainPlayer.prototype._tick = function (time) {
		        var bufferDuration = this.buffer.duration;
		        if (this.loop && this._loopEnd > 0) {
		            bufferDuration = this._loopEnd;
		        }
		        var drift = (Math.random() * 2 - 1) * this.drift;
		        var offset = this._offset - this._overlap + drift;
		        var detune = this.detune / 100;
		        var originalFadeIn = this._player.fadeIn;
		        if (this.loop && this._offset > bufferDuration) {
		            //play the end
		            var endSegmentDuration = this._offset - bufferDuration;
		            this._player.start(this.buffer, time, offset, endSegmentDuration + this._overlap, detune);
		            //and play the beginning 
		            offset = this._offset % bufferDuration;
		            this._offset = this._loopStart;
		            this._player.fadeIn = 0;
		            this._player.start(this.buffer, time + endSegmentDuration, this._offset, offset + this._overlap, detune);
		        } else if (this._offset > bufferDuration) {
		            //set the state to stopped. 
		            this.stop(time);
		        } else {
		            if (offset < 0) {
		                this._player.fadeIn = Math.max(this._player.fadeIn + offset, 0);
		                offset = 0;
		            }
		            this._player.start(this.buffer, time, offset, this.grainSize + this._overlap, detune);
		        }
		        this._player.fadeIn = originalFadeIn;
		        //increment the offset
		        var duration = this._clock._nextTick - time;
		        this._offset += duration * this._playbackRate;
		    };
		    /**
			 *  Jump to a specific time and play it.
			 *  @param  {Time}  offset  The offset to jump to.
			 *  @param {Time=} time When to make the jump.
			 *  @return  {[type]}  [description]
			 */
		    Tone.GrainPlayer.prototype.scrub = function (offset, time) {
		        this._offset = this.toSeconds(offset);
		        this._tick(this.toSeconds(time));
		        return this;
		    };
		    /**
			 * The playback rate of the sample
			 * @memberOf Tone.GrainPlayer#
			 * @type {Positive}
			 * @name playbackRate
			 */
		    Object.defineProperty(Tone.GrainPlayer.prototype, 'playbackRate', {
		        get: function () {
		            return this._playbackRate;
		        },
		        set: function (rate) {
		            this._playbackRate = rate;
		            this.grainSize = this._grainSize;
		        }
		    });
		    /**
			 * The loop start time. 
			 * @memberOf Tone.GrainPlayer#
			 * @type {Time}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopStart', {
		        get: function () {
		            return this._loopStart;
		        },
		        set: function (time) {
		            this._loopStart = this.toSeconds(time);
		        }
		    });
		    /**
			 * The loop end time. 
			 * @memberOf Tone.GrainPlayer#
			 * @type {Time}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopEnd', {
		        get: function () {
		            return this._loopEnd;
		        },
		        set: function (time) {
		            this._loopEnd = this.toSeconds(time);
		        }
		    });
		    /**
			 * The direction the buffer should play in
			 * @memberOf Tone.GrainPlayer#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.GrainPlayer.prototype, 'reverse', {
		        get: function () {
		            return this.buffer.reverse;
		        },
		        set: function (rev) {
		            this.buffer.reverse = rev;
		        }
		    });
		    /**
			 * The size of each chunk of audio that the 
			 * buffer is chopped into and played back at.
			 * @memberOf Tone.GrainPlayer#
			 * @type {Time}
			 * @name grainSize
			 */
		    Object.defineProperty(Tone.GrainPlayer.prototype, 'grainSize', {
		        get: function () {
		            return this._grainSize;
		        },
		        set: function (size) {
		            this._grainSize = this.toSeconds(size);
		            this._clock.frequency.value = this._playbackRate / this._grainSize;
		        }
		    });
		    /**
			 * This is the duration of the cross-fade between 
			 * sucessive grains.
			 * @memberOf Tone.GrainPlayer#
			 * @type {Time}
			 * @name overlap
			 */
		    Object.defineProperty(Tone.GrainPlayer.prototype, 'overlap', {
		        get: function () {
		            return this._overlap;
		        },
		        set: function (time) {
		            time = this.toSeconds(time);
		            this._overlap = time;
		            if (this._overlap < 0) {
		                this._player.fadeIn = 0.01;
		                this._player.fadeOut = 0.01;
		            } else {
		                this._player.fadeIn = time;
		                this._player.fadeOut = time;
		            }
		        }
		    });
		    /**
			 * Clean up
			 * @return {Tone.GrainPlayer} this
			 */
		    Tone.GrainPlayer.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this.buffer.dispose();
		        this.buffer = null;
		        this._player.dispose();
		        this._player = null;
		        this._clock.dispose();
		        this._clock = null;
		        return this;
		    };
		    return Tone.GrainPlayer;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.UserMedia uses MediaDevices.getUserMedia to open up
			 *          and external microphone or audio input. Check 
			 *          [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)
			 *          to see which browsers are supported. Access to an external input
			 *          is limited to secure (HTTPS) connections.
			 *         
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Decibels=} volume The level of the input
			 *  @example
			 * //list the inputs and open the third one
			 * var motu = new Tone.UserMedia();
			 * 
			 * //opening the input asks the user to activate their mic
			 * motu.open().then(function(){
			 * 	//opening is activates the microphone
			 * 	//starting lets audio through
			 * 	motu.start(10);
			 * });
			 */
		    Tone.UserMedia = function () {
		        var options = this.optionsObject(arguments, ['volume'], Tone.UserMedia.defaults);
		        /**
				 *  The MediaStreamNode 
				 *  @type {MediaStreamAudioSourceNode}
				 *  @private
				 */
		        this._mediaStream = null;
		        /**
				 *  The media stream created by getUserMedia.
				 *  @type {LocalMediaStream}
				 *  @private
				 */
		        this._stream = null;
		        /**
				 *  The open device
				 *  @type  {MediaDeviceInfo}
				 *  @private
				 */
		        this._device = null;
		        /**
				 *  The output volume node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
		        this._volume = this.output = new Tone.Volume(options.volume);
		        /**
				 * The volume of the output in decibels.
				 * @type {Decibels}
				 * @signal
				 * @example
				 * input.volume.value = -6;
				 */
		        this.volume = this._volume.volume;
		        this._readOnly('volume');
		        this.mute = options.mute;
		    };
		    Tone.extend(Tone.UserMedia);
		    /**
			 * the default parameters
			 * @type {Object}
			 */
		    Tone.UserMedia.defaults = {
		        'volume': 0,
		        'mute': false
		    };
		    /**
			 *  Open the media stream. If a string is passed in, it is assumed
			 *  to be the label or id of the stream, if a number is passed in,
			 *  it is the input number of the stream.
			 *  @param  {String|Number} [labelOrId="default"] The label or id of the audio input media device. 
			 *                                                With no argument, the default stream is opened.
			 *  @return {Promise} The promise is resolved when the stream is open.
			 */
		    Tone.UserMedia.prototype.open = function (labelOrId) {
		        labelOrId = this.defaultArg(labelOrId, 'default');
		        return this.enumerateDevices().then(function (devices) {
		            var device;
		            if (this.isNumber(labelOrId)) {
		                device = devices[labelOrId];
		            } else {
		                device = devices.find(function (device) {
		                    return device.label === labelOrId || device.deviceId === labelOrId;
		                });
		                if (!device) {
		                    //otherwise just take the first one
		                    device = devices[0];
		                }
		            }
		            //didn't find a matching device
		            if (!device) {
		                throw new Error('Tone.UserMedia: no matching audio inputs.');
		            }
		            this._device = device;
		            //do getUserMedia
		            var constraints = {
		                audio: {
		                    'deviceId': device.deviceId,
		                    'echoCancellation': false,
		                    'sampleRate': this.context.sampleRate
		                }
		            };
		            return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
		                //start a new source only if the previous one is closed
		                if (!this._stream) {
		                    this._stream = stream;
		                    //Wrap a MediaStreamSourceNode around the live input stream.
		                    this._mediaStream = this.context.createMediaStreamSource(stream);
		                    //Connect the MediaStreamSourceNode to a gate gain node
		                    this._mediaStream.connect(this.output);
		                }
		                return this;
		            }.bind(this));
		        }.bind(this));
		    };
		    /**
			 *  Close the media stream
			 *  @return {Tone.UserMedia} this
			 */
		    Tone.UserMedia.prototype.close = function () {
		        if (this._stream) {
		            this._stream.getAudioTracks().forEach(function (track) {
		                track.stop();
		            });
		            this._stream = null;
		            //remove the old media stream
		            this._mediaStream.disconnect();
		            this._mediaStream = null;
		        }
		        this._device = null;
		        return this;
		    };
		    /**
			 *  Returns a promise which resolves with the list of audio input devices available.
			 *  @return {Promise} The promise that is resolved with the devices
			 *  @example
			 * extInput.enumerateDevices().then(function(devices){
			 * 	console.log(devices)
			 * })
			 */
		    Tone.UserMedia.prototype.enumerateDevices = function () {
		        return navigator.mediaDevices.enumerateDevices().then(function (devices) {
		            return devices.filter(function (device) {
		                return device.kind === 'audioinput';
		            });
		        });
		    };
		    /**
			 *  Returns the playback state of the source, "started" when the microphone is open
			 *  and "stopped" when the mic is closed.
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.UserMedia#
			 *  @name state
			 */
		    Object.defineProperty(Tone.UserMedia.prototype, 'state', {
		        get: function () {
		            return this._stream && this._stream.active ? Tone.State.Started : Tone.State.Stopped;
		        }
		    });
		    /**
			 * 	Returns an identifier for the represented device that is 
			 * 	persisted across sessions. It is un-guessable by other applications and 
			 * 	unique to the origin of the calling application. It is reset when the 
			 * 	user clears cookies (for Private Browsing, a different identifier is 
			 * 	used that is not persisted across sessions). Returns undefined when the 
			 * 	device is not open.
			 *  @type {String}
			 *  @readOnly
			 *  @memberOf Tone.UserMedia#
			 *  @name deviceId
			 */
		    Object.defineProperty(Tone.UserMedia.prototype, 'deviceId', {
		        get: function () {
		            if (this._device) {
		                return this._device.deviceId;
		            }
		        }
		    });
		    /**
			 * 	Returns a group identifier. Two devices have the 
			 * 	same group identifier if they belong to the same physical device.
			 * 	Returns undefined when the device is not open.
			 *  @type {String}
			 *  @readOnly
			 *  @memberOf Tone.UserMedia#
			 *  @name groupId
			 */
		    Object.defineProperty(Tone.UserMedia.prototype, 'groupId', {
		        get: function () {
		            if (this._device) {
		                return this._device.groupId;
		            }
		        }
		    });
		    /**
			 * 	Returns a label describing this device (for example "Built-in Microphone"). 
			 * 	Returns undefined when the device is not open or label is not available
			 * 	because of permissions.
			 *  @type {String}
			 *  @readOnly
			 *  @memberOf Tone.UserMedia#
			 *  @name groupId
			 */
		    Object.defineProperty(Tone.UserMedia.prototype, 'label', {
		        get: function () {
		            if (this._device) {
		                return this._device.label;
		            }
		        }
		    });
		    /**
			 * Mute the output. 
			 * @memberOf Tone.UserMedia#
			 * @type {boolean}
			 * @name mute
			 * @example
			 * //mute the output
			 * userMedia.mute = true;
			 */
		    Object.defineProperty(Tone.UserMedia.prototype, 'mute', {
		        get: function () {
		            return this._volume.mute;
		        },
		        set: function (mute) {
		            this._volume.mute = mute;
		        }
		    });
		    /**
			 * Clean up.
			 * @return {Tone.UserMedia} this
			 */
		    Tone.UserMedia.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.close();
		        this._writable('volume');
		        this._volume.dispose();
		        this._volume = null;
		        this.volume = null;
		        return this;
		    };
		    /**
			 *  If getUserMedia is supported by the browser.
			 *  @type  {Boolean}
			 *  @memberOf Tone.UserMedia#
			 *  @name supported
			 *  @static
			 *  @readOnly
			 */
		    Object.defineProperty(Tone.UserMedia, 'supported', {
		        get: function () {
		            return !Tone.prototype.isUndef(navigator.mediaDevices) && Tone.prototype.isFunction(navigator.mediaDevices.getUserMedia);
		        }
		    });
		    return Tone.UserMedia;
		});
		
		return Tone;
	}));

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _jquery = __webpack_require__(3);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DEFAULT_BASE_NOTE = 48;
	var DEFAULT_SONG_RATE = 450;
	
	var MODES = { player: 1, song: 2 };
	
	var TEMPOS = {
	  0: 200,
	  1: 400,
	  2: 800
	};
	
	var CURSOR_WIDTH = 26;
	var CW = 1;
	var CCW = -1;
	var CURSOR_LEFT = 0;
	var CURSOR_RIGHT = 1;
	var STEPS = 16;
	var NOTE_DURATION = 200; // 0.2 second delay set in SuperCollider
	
	var Player = function () {
	  function Player(id, options, notes, sendNote) {
	    _classCallCheck(this, Player);
	
	    this.id = id;
	    this.baseNote = options.baseNote || DEFAULT_BASE_NOTE;
	    this.songRate = options.songRate || DEFAULT_SONG_RATE;
	    this.songTempo = options.songTempo || 1;
	    this.canvasTop = options.canvasTop;
	    this.mode = options.mode || MODES.song;
	    this.timeout = 0;
	    // socket callback
	    this.sendNote = sendNote;
	    // song mode
	    this.song = options.song || TEST_SONG;
	    this.songIndex = 0;
	    this.dir = options.dir || CW;
	    // movement logic
	    this.playing = false;
	    this.meter = null;
	    this.rotationCount = 0;
	    this.toFlip = false;
	    this.leftHand = null;
	    this.rightHand = null;
	    this.scale = options.scale;
	    this.color = '#57AA83' || options.color;
	    this.states = {
	      1: {
	        rotation: CW,
	        orientation: CURSOR_RIGHT
	      },
	      2: {
	        rotation: CCW,
	        orientation: CURSOR_LEFT
	      },
	      3: {
	        rotation: CW,
	        orientation: CURSOR_RIGHT
	      },
	      4: {
	        rotation: CCW,
	        orientation: CURSOR_LEFT
	      }
	    };
	
	    // create player span
	    (0, _jquery2.default)('.players').append('<div class="player" id="' + this.id + '"><span><div class="cursor-wrapper"><div class="cursor"></div><div class="cursor-right"></div></div></span></div>');
	    this.jQuery = (0, _jquery2.default)('#' + this.id + ' span');
	    this.cursorRight = this.jQuery.find('.cursor-right');
	    this.cursorLeft = this.jQuery.find('.cursor');
	
	    this.jQuery.css('-webkit-transition', '-webkit-transform ' + this.songRate + 'ms linear');
	    this.jQuery.css('transition', 'transform ' + this.songRate + 'ms linear');
	    this.cursorRight.css('background-color', options.color.hex);
	    this.cursorLeft.css('background-color', options.color.hex);
	  }
	
	  _createClass(Player, [{
	    key: 'tempo',
	    value: function tempo(tempoValue) {
	      this.songTempo = tempoValue;
	      this.songRate = TEMPOS[tempoValue];
	      this.jQuery.css('-webkit-transition', '-webkit-transform ' + this.songRate + 'ms linear');
	      this.jQuery.css('transition', 'transform ' + this.songRate + 'ms linear');
	    }
	  }, {
	    key: 'start',
	    value: function start() {
	      if (!this.playing) {
	        this.playNextNote();
	        this.playing = true;
	      }
	    }
	  }, {
	    key: 'playNextNote',
	    value: function (_playNextNote) {
	      function playNextNote() {
	        return _playNextNote.apply(this, arguments);
	      }
	
	      playNextNote.toString = function () {
	        return _playNextNote.toString();
	      };
	
	      return playNextNote;
	    }(function () {
	      var self = this;
	      var current, next, next_2;
	      current = self.song[self.songIndex];
	      next = self.song[(self.songIndex + 1) % self.song.length];
	      next_2 = self.song[(self.songIndex + 2) % self.song.length];
	
	      // sets last note for reference if there is a string of the same notes
	      if (current !== next && next === next_2) {
	        self.lastNote = current;
	      }
	      // get actual note mappings
	      var midiNote = (current < 7 ? 0 : current > 13 ? 24 : 12) + self.baseNote + self.scale[current % 7];
	
	      // initial setup
	      if (!self.leftHand && !self.rightHand) {
	        if (current <= next) {
	          self.state = 1;
	        } else if (current > next) {
	          self.state = 2;
	        }
	      } else {
	        switch (self.state) {
	          case 1:
	            self.state = self.toFlip ? 2 : 1;
	            break;
	          case 2:
	            self.state = self.toFlip ? 1 : 2;
	            break;
	          case 3:
	            self.state = self.toFlip ? 4 : 3;
	            break;
	          case 4:
	            self.state = self.toFlip ? 3 : 4;
	            break;
	          default:
	            console.error('invalid state reached');
	            break;
	        }
	        self.toFlip = false;
	      }
	
	      if (current < next && next < next_2) {
	        self.toFlip = true;
	      } else if (current > next && next > next_2) {
	        self.toFlip = true;
	      } else if (current === next && next !== next_2) {
	        if (self.lastNote) {
	          if (self.lastNote < next && next < next_2) {
	            self.toFlip = true;
	          } else if (self.lastNote > next && next > next_2) {
	            self.toFlip = true;
	          }
	        } else {
	          // by default we only start CW
	          // TODO: fix this
	          if (next > next_2) {
	            self.toFlip = true;
	          }
	        }
	      }
	
	      if (current < next) {
	        self.leftHand = notes[current];
	        self.rightHand = notes[next];
	      } else if (current > next) {
	        self.leftHand = notes[next];
	        self.rightHand = notes[current];
	      } else if (current === next) {
	        self.rightHand = notes[current];
	        self.leftHand = notes[current];
	      }
	
	      if (self.song.length > 0) {
	        // play and animate note
	        self.sendNote(midiNote);
	        // animateNote(current, 150);
	      }
	
	      // render cursor
	      self.render();
	
	      // recursive call at SONG_RATE
	      self.meter = setTimeout(playNextNote, self.songRate);
	      self.songIndex++;
	      if (self.songIndex === self.song.length) self.songIndex = 0;
	    })
	  }, {
	    key: 'render',
	    value: function render() {
	      if (this.song.length === 0) {
	        // no notes played
	        this.cursorRight.css('display', 'none');
	        this.cursorLeft.css('display', 'none');
	        return;
	      }
	      if (!this.rightHand && !this.leftHand) {
	        // first pass through
	        return;
	      }
	      var params = this.states[this.state];
	      if (this.rightHand !== this.leftHand) {
	        this.rotationCount += params.rotation;
	        this.jQuery.css('-webkit-transform', 'rotate(' + this.rotationCount * 180 + 'deg)');
	        this.jQuery.css('transform:', 'rotate(' + this.rotationCount * 180 + 'deg)');
	      }
	
	      if (params.orientation === CURSOR_LEFT) {
	        this.cursorRight.css('display', 'initial');
	        this.cursorLeft.css('display', 'none');
	      } else {
	        this.cursorRight.css('display', 'none');
	        this.cursorLeft.css('display', 'initial');
	      }
	      var diameter = this.rightHand.center - this.leftHand.center;
	      var top = this.canvasTop + this.leftHand.width / 4 - diameter / 2;
	      var left = this.leftHand.center;
	      this.jQuery.css('top', top);
	      this.jQuery.css('left', left);
	      this.jQuery.css('height', diameter);
	      this.jQuery.css('width', diameter);
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      clearTimeout(this.meter);
	      this.playing = false;
	    }
	  }, {
	    key: 'remove',
	    value: function remove() {
	      (0, _jquery2.default)('#' + this.id).remove();
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this.lastNote = null;
	      this.leftHand = null;
	      this.rightHand = null;
	      this.songIndex = 0;
	      this.meter = null;
	      this.toFlip = false;
	      this.rotationCount = this.rotationCount + (this.rotationCount % 2 ? 1 : 0);
	    }
	  }]);
	
	  return Player;
	}();
	
	exports.default = Player;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjI2YmQ2MjU3NGZiMWJlOTQ2OWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvc3R5bGVzLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuaW1hdGVOb3Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc291bmRHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi90b25lL2J1aWxkL1RvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1BsYXllci5qcyJdLCJuYW1lcyI6WyJRVUFOVElaRSIsIlRJTUVPVVQiLCJURU1QT1MiLCJDQU5WQVNfVE9QIiwiREVGQVVMVF9CQVNFX05PVEUiLCJERUZBVUxUX1NPTkdfUkFURSIsIlNURVBTIiwiTUFKT1JfU0NBTEUiLCJNSU5PUl9TQ0FMRSIsIm5vdGVzIiwibWlkaV90b19mcmVxIiwibWlkaSIsImZyZXEiLCJNYXRoIiwicG93IiwiY29uc29sZSIsImxvZyIsImRvY3VtZW50IiwicmVhZHkiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsInBsYXllcnMiLCJURVNUX1NPTkciLCJiYWNoIiwiYmFzZU5vdGUiLCJzb25nUmF0ZSIsInNvbmdUZW1wbyIsImNhbnZhc1RvcCIsIm1vZGUiLCJzb25nIiwic2NhbGUiLCJkaXIiLCJjb2xvciIsInN0YXJ0Iiwic29ja2V0IiwiV2ViU29ja2V0Iiwib25tZXNzYWdlIiwiZXZ0IiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJ0eXBlIiwiaWQiLCJmb3JFYWNoIiwibm90ZSIsIml0ZXIiLCJwdXNoIiwicGxheWVyIiwidGVtcG8iLCJzZW5kTm90ZSIsInN0b3AiLCJyZXNldCIsInRvU3RhcnQiLCJyZW1vdmUiLCJsb29wQ291bnQiLCJsb29wUGxheWVycyIsInRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsIm9uIiwiYXR0ciIsImNyZWF0ZU5vdGVzIiwicmVuZGVyTm90ZXMiLCJpbml0aWFsaXplU2V0dGluZ3MiLCJhbmltYXRlTm90ZSIsInN0ZXBzIiwidG9wIiwibWF4V2lkdGgiLCJpbm5lcldpZHRoIiwiaSIsIm5vdGVXaWR0aCIsImxlbmd0aCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsImNlbnRlciIsIm5vdGVIZWlnaHQiLCJodG1sIiwibm90ZXNIVE1MIiwicGFyc2VJbnQiLCJ0b1N0cmluZyIsImNzcyIsImR1cmF0aW9uIiwiYWN0aXZlTm90ZSIsImFkZENsYXNzIiwic2V0VGltZW91dCIsInJlbW92ZUNsYXNzIiwidHJpZ2dlckF0dGFja1JlbGVhc2UiLCJ2b2wiLCJWb2x1bWUiLCJmcmVldmVyYiIsIkZyZWV2ZXJiIiwidG9NYXN0ZXIiLCJzeW50aCIsIlBvbHlTeW50aCIsIkZNU3ludGgiLCJjaGFpbiIsImNvbm5lY3QiLCJub3RlTGVuZ3RoIiwiTU9ERVMiLCJDVVJTT1JfV0lEVEgiLCJDVyIsIkNDVyIsIkNVUlNPUl9MRUZUIiwiQ1VSU09SX1JJR0hUIiwiTk9URV9EVVJBVElPTiIsIlBsYXllciIsIm9wdGlvbnMiLCJzb25nSW5kZXgiLCJwbGF5aW5nIiwibWV0ZXIiLCJyb3RhdGlvbkNvdW50IiwidG9GbGlwIiwibGVmdEhhbmQiLCJyaWdodEhhbmQiLCJzdGF0ZXMiLCJyb3RhdGlvbiIsIm9yaWVudGF0aW9uIiwiYXBwZW5kIiwialF1ZXJ5IiwiY3Vyc29yUmlnaHQiLCJmaW5kIiwiY3Vyc29yTGVmdCIsImhleCIsInRlbXBvVmFsdWUiLCJwbGF5TmV4dE5vdGUiLCJzZWxmIiwiY3VycmVudCIsIm5leHQiLCJuZXh0XzIiLCJsYXN0Tm90ZSIsIm1pZGlOb3RlIiwic3RhdGUiLCJlcnJvciIsInJlbmRlciIsInBhcmFtcyIsImRpYW1ldGVyIiwiY2xlYXJUaW1lb3V0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUYscUJBQW9COztBQUVwQjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBLGlCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0QsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWU7O0FBRWYsVUFBUzs7QUFFVDtBQUNBLFNBQVEsaUNBQWlDO0FBQ3pDLFNBQVEsb0JBQW9CO0FBQzVCLFNBQVEsc0NBQXNDO0FBQzlDLFNBQVE7QUFDUixHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsYUFBYSxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFLFVBQVU7QUFDM0UsdUNBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGlDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsV0FBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLFdBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQSxhQUFZLDRCQUE0QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSw0REFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxxRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILFNBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsaURBQWlEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWlEO0FBQ2pELFdBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsTUFBTTtBQUNqQixZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsRUFBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFNBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTs7QUFFQSxlQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQiwyQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSwyQ0FBMEM7QUFDMUMsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF3QyxzQ0FBc0M7QUFDOUUscUNBQW9DLHVDQUF1QztBQUMzRSxxQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsUUFBTztBQUNQO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBb0M7QUFDcEMsc0NBQXFDO0FBQ3JDLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsYUFBYTtBQUNwQyxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7QUFDRjs7QUFFQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixnQkFBZ0I7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFVBQVUsU0FBUyxNQUFNLGFBQWE7QUFDM0UsY0FBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBLFNBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osa0RBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUEsa0NBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsS0FBSTtBQUNKOztBQUVBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSx1QkFBc0I7QUFDdEIsNEJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CLDZEQUE0RCxlQUFlO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGVBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0EsZUFBYyxtQ0FBbUM7QUFDakQsZ0JBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBLEVBQUM7Ozs7Ozs7Ozs7OztTQ3grVGU2QyxXLEdBQUFBLFc7U0FrQkFDLFcsR0FBQUEsVztTQXVDQUMsa0IsR0FBQUEsa0I7U0FLQUMsVyxHQUFBQSxXOztBQWpFaEI7Ozs7OztBQUVBO0FBQ08sVUFBU0gsV0FBVCxDQUFxQnBELEtBQXJCLEVBQTRCZSxRQUE1QixFQUFzQ3lDLEtBQXRDLEVBQTZDbkMsS0FBN0MsRUFBb0RvQyxHQUFwRCxFQUF5RDtBQUM5RG5ELFdBQVFDLEdBQVIsQ0FBWSxLQUFaLEVBQWtCa0QsR0FBbEI7QUFDQSxPQUFJQyxXQUFXaEQsT0FBT2lELFVBQXRCO0FBQ0EsUUFBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlKLEtBQXBCLEVBQTJCSSxHQUEzQixFQUFnQztBQUM5QixTQUFJQyxZQUFZSCxXQUFXRixLQUEzQjtBQUNBeEQsV0FBTTRELENBQU4sSUFBVztBQUNUMUIsV0FBSTBCLENBREs7QUFFVDFELGFBQU1hLFlBQVk2QyxJQUFJLENBQUosR0FBUSxDQUFSLEdBQWFBLElBQUksRUFBSixHQUFTLEVBQVQsR0FBYyxFQUF2QyxJQUE4Q3ZDLE1BQU91QyxJQUFJdkMsTUFBTXlDLE1BQWpCLENBRjNDO0FBR1RDLGFBQU1GLFlBQVlELENBSFQ7QUFJVEksY0FBT0gsU0FKRTtBQUtUSSxlQUFRSixZQUFZLENBTFg7QUFNVEosWUFBS0ksWUFBWSxDQU5SO0FBT1RLLGVBQVFMLFlBQVlELENBQVosR0FBZ0JDLFlBQVk7QUFQM0IsTUFBWDtBQVNEO0FBQ0RSLGVBQVlyRCxLQUFaLEVBQW1Cd0QsS0FBbkIsRUFBMEJDLEdBQTFCO0FBQ0Q7O0FBRU0sVUFBU0osV0FBVCxDQUFxQnJELEtBQXJCLEVBQTRCd0QsS0FBNUIsRUFBbUNDLEdBQW5DLEVBQXdDO0FBQzdDLE9BQUlVLFVBQUo7QUFDQSx5QkFBRSxTQUFGLEVBQWFDLElBQWIsQ0FDRyxZQUFXO0FBQ1YsU0FBSUMsWUFBWSxFQUFoQjtBQUNBckUsV0FBTW1DLE9BQU4sQ0FBYyxVQUFTQyxJQUFULEVBQWVDLElBQWYsRUFBcUI7QUFDakMsV0FBSWQsUUFBUStDLFNBQVUsT0FBT2pDLE9BQU9tQixLQUFkLElBQXVCLEVBQWpDLEVBQXNDZSxRQUF0QyxDQUErQyxFQUEvQyxDQUFaO0FBQ0FKLG9CQUFhL0IsS0FBSzZCLE1BQWxCO0FBQ0FJLG9CQUNFLFVBQ0EsZUFEQSxHQUVBLE1BRkEsR0FFU2hDLElBRlQsR0FFZ0IsSUFGaEIsR0FHQSxTQUhBLEdBSUEsT0FKQSxHQUlVRCxLQUFLMkIsSUFKZixHQUlzQixLQUp0QixHQUtBLE1BTEEsR0FLUzNCLEtBQUtxQixHQUxkLEdBS29CLEtBTHBCLEdBTUEsUUFOQSxHQU1XckIsS0FBSzRCLEtBTmhCLEdBTXdCLEtBTnhCLEdBT0EsU0FQQSxHQU9ZNUIsS0FBSzZCLE1BUGpCLEdBTzBCLEtBUDFCLEdBUUEsSUFSQSxHQVNBLFNBVkY7QUFZRCxNQWZEO0FBZ0JBLFlBQU9JLFNBQVA7QUFDRCxJQW5CRCxFQURGO0FBc0JBLHlCQUFFLFFBQUYsRUFBWUQsSUFBWixDQUNHLFlBQVc7QUFDVjlELGFBQVFDLEdBQVIsQ0FBWSxLQUFaLEVBQWtCa0QsR0FBbEI7QUFDQSxZQUNFLGtDQUNBLFNBREEsR0FFQSxNQUZBLEdBRVNBLEdBRlQsR0FFZSxLQUZmLEdBR0EsU0FIQSxHQUdZVSxVQUhaLEdBR3lCLEtBSHpCLEdBSUEsSUFKQSxHQUtBLFNBTkY7QUFRRCxJQVZELEVBREY7QUFhRDs7QUFFTSxVQUFTYixrQkFBVCxDQUE0QkcsR0FBNUIsRUFBaUM7QUFDdENuRCxXQUFRQyxHQUFSLENBQVksS0FBWixFQUFrQmtELEdBQWxCO0FBQ0EseUJBQUUsT0FBRixFQUFXZSxHQUFYLENBQWUsS0FBZixFQUFzQmYsR0FBdEI7QUFDRDs7QUFFTSxVQUFTRixXQUFULENBQXFCbkIsSUFBckIsRUFBMkJxQyxRQUEzQixFQUFxQztBQUMxQztBQUNBLE9BQUlDLGFBQWEsc0JBQUUsTUFBTXRDLElBQVIsQ0FBakI7QUFDQXNDLGNBQVdDLFFBQVgsQ0FBb0IsUUFBcEI7QUFDQUMsY0FBVyxZQUFXO0FBQ3BCRixnQkFBV0csV0FBWCxDQUF1QixRQUF2QjtBQUNELElBRkQsRUFFR0osUUFGSDtBQUdELEU7Ozs7Ozs7Ozs7O1NDeERlSyxvQixHQUFBQSxvQjs7QUFoQmhCOzs7Ozs7QUFFQSxLQUFJQyxNQUFNLElBQUksZUFBS0MsTUFBVCxDQUFnQixFQUFoQixDQUFWO0FBQ0EsS0FBSUMsV0FBVyxJQUFJLGVBQUtDLFFBQVQsQ0FBa0IsR0FBbEIsRUFBdUIsSUFBdkIsRUFBNkJDLFFBQTdCLEVBQWY7QUFDQSxLQUFJQyxRQUFRLElBQUksZUFBS0MsU0FBVCxDQUFtQixDQUFuQixFQUFzQixlQUFLQyxPQUEzQixFQUFvQztBQUM1QyxtQkFBYztBQUNWLHFCQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWI7QUFERixNQUQ4QjtBQUk1QyxpQkFBWTtBQUNSLG1CQUFVLElBREY7QUFFUixrQkFBUztBQUZELE1BSmdDO0FBUTVDLGVBQVU7QUFSa0MsRUFBcEMsRUFVVEMsS0FWUyxDQVVIUixHQVZHLEVBVUVTLE9BVkYsQ0FVVVAsUUFWVixFQVVvQkUsUUFWcEIsRUFBWjs7QUFZTyxVQUFTTCxvQkFBVCxDQUE4QjFDLElBQTlCLEVBQW9DSSxLQUFwQyxFQUEyQztBQUNoRCxTQUFJaUQsYUFBYWpELFNBQVMsSUFBMUI7QUFDQTRDLFdBQU1OLG9CQUFOLENBQTJCMUMsSUFBM0IsRUFBaUNxRCxVQUFqQztBQUNELEU7Ozs7OztBQ25CRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxjQUFjO0FBQzVCLGVBQWMsUUFBUTtBQUN0QixlQUFjLE1BQU07QUFDcEIsaUJBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsMEJBQTBCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUIsZUFBYyx3QkFBd0I7QUFDdEM7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBLGVBQWM7QUFDZDtBQUNBLGVBQWM7QUFDZDtBQUNBLGVBQWM7QUFDZDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxTQUFTO0FBQ3ZCLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsOEJBQThCO0FBQzdDLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsaUJBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0EsaUJBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLDZCQUE2QjtBQUMzQyxpQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyw2QkFBNkI7QUFDM0MsaUJBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsNkJBQTZCO0FBQzNDLGlCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsRUFBRTtBQUNqQixnQkFBZSxFQUFFO0FBQ2pCLGdCQUFlLEU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE1BQU07QUFDckI7QUFDQSxlQUFjLFFBQVE7QUFDdEI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1YsNkJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLEVBQUU7QUFDaEIsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsRUFBRTtBQUNoQixpQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxFQUFFO0FBQ2hCLGlCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBK0Q7QUFDL0QsZUFBYyxFQUFFO0FBQ2hCLGlCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsRUFBRTtBQUNoQixpQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLEVBQUU7QUFDaEIsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxFQUFFO0FBQ2hCLGlCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBLFdBQVU7QUFDVixxREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxZQUFZO0FBQzNCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE9BQU87QUFDdEI7QUFDQSx1Q0FBc0M7QUFDdEMsd0NBQXVDO0FBQ3ZDLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGdGQUErRTtBQUMvRTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxzQ0FBc0M7QUFDcEQsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixpQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsZUFBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsbURBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsZ0JBQWUsS0FBSztBQUNwQixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxjQUFjO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWUsZ0JBQWdCO0FBQy9CLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsTUFBTTtBQUNwQixlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxVQUFVO0FBQ3hCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLFFBQVE7QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxNQUFNO0FBQ3BCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLEtBQUs7QUFDcEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixjO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLEtBQUs7QUFDcEIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxLQUFLO0FBQ3BCLGdCQUFlLFFBQVE7QUFDdkIsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsS0FBSztBQUNwQixnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQixjQUFjO0FBQzlCO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLEtBQUs7QUFDcEIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0IsY0FBYztBQUM5QjtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBLDhCQUE2QjtBQUM3QixnQkFBZTtBQUNmLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFlBQVk7QUFDM0IsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLFVBQVU7QUFDeEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFM7QUFDZjtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE1BQU07QUFDcEIsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsVTtBQUNoQjtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsYTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixlQUFlO0FBQy9CO0FBQ0Esd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsaUJBQWdCLGVBQWU7QUFDL0I7QUFDQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsVUFBVTtBQUN4QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE1BQU07QUFDcEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsUUFBUTtBQUN0QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsS0FBSztBQUNwQixnQkFBZSxVQUFVO0FBQ3pCO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsVUFBVTtBQUN4QixrQkFBaUI7QUFDakI7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLEtBQUs7QUFDcEIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFp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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QixnQkFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxlQUFj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QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7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QSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtB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QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBLGVBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixpQkFBZ0IsT0FBTztBQUN2QixlQUFjLE9BQU87QUFDckI7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsa0VBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsZUFBYyxTQUFTO0FBQ3ZCLGVBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxlQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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TCxHQUFnQixJQUFoQjtBQUNBLFlBQUtDLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxZQUFLTixTQUFMLEdBQWlCLENBQWpCO0FBQ0EsWUFBS0UsS0FBTCxHQUFhLElBQWI7QUFDQSxZQUFLRSxNQUFMLEdBQWMsS0FBZDtBQUNBLFlBQUtELGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxJQUFzQixLQUFLQSxhQUFMLEdBQXFCLENBQXJCLEdBQXlCLENBQXpCLEdBQTZCLENBQW5ELENBQXJCO0FBQ0Q7Ozs7OzttQkFqTmtCTCxNIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcInB1YmxpYy9kaXN0L1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGIyNmJkNjI1NzRmYjFiZTk0NjlkIiwiaW1wb3J0ICcuLi9hc3NldHMvc3R5bGVzLnNjc3MnO1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuaW1wb3J0IHsgY3JlYXRlTm90ZXMsIGluaXRpYWxpemVTZXR0aW5ncywgYW5pbWF0ZU5vdGUgfSBmcm9tICcuL2FuaW1hdGVOb3Rlcyc7XG5pbXBvcnQgeyB0cmlnZ2VyQXR0YWNrUmVsZWFzZSB9IGZyb20gJy4vc291bmRHZW5lcmF0b3InO1xuaW1wb3J0IFBsYXllciBmcm9tICcuL1BsYXllcic7XG5cbi8qXG4gIGZlYXR1cmUgZmxhZ3NcbiAqL1xuXG4vLyBjb3VudGVycG9pbnRcbnZhciBRVUFOVElaRSA9IHRydWU7XG52YXIgVElNRU9VVCA9IGZhbHNlO1xuXG4vLyBkdXBsaWNhdGUgY29uc3RhbnRzOlxudmFyIFRFTVBPUyA9IHtcbiAgMDogMjAwLFxuICAxOiA0MDAsXG4gIDI6IDgwMFxufVxudmFyIENBTlZBU19UT1AgPSBudWxsO1xudmFyIERFRkFVTFRfQkFTRV9OT1RFID0gNDg7XG52YXIgREVGQVVMVF9TT05HX1JBVEUgPSA0NTA7XG52YXIgU1RFUFMgPSAxNjtcblxudmFyIE1BSk9SX1NDQUxFID0gWzAsIDIsIDQsIDUsIDcsIDksIDExXTtcbnZhciBNSU5PUl9TQ0FMRSA9IFswLCAyLCAzLCA1LCA3LCA4LCAxMF07XG5cbnZhciBub3RlcyA9IFtdO1xuXG5mdW5jdGlvbiBtaWRpX3RvX2ZyZXEobWlkaSkge1xuICB2YXIgZnJlcSA9IE1hdGgucG93KDIsKChtaWRpLTY5KS8xMikpICogNDQwO1xuICBjb25zb2xlLmxvZygnZnJlcScsZnJlcSk7XG4gIHJldHVybiBmcmVxO1xufVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgQ0FOVkFTX1RPUCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG5cbiAgdmFyIHBsYXllcnMgPSB7fTtcblxuICB2YXIgVEVTVF9TT05HID0gWzcsIDExLCA5LCAxMSwgNywgMTIsIDEwLCAxMl07XG5cbiAgdmFyIGJhY2ggPSBuZXcgUGxheWVyKCdiYWNoJywge1xuICAgIGJhc2VOb3RlOiBERUZBVUxUX0JBU0VfTk9URSxcbiAgICBzb25nUmF0ZTogREVGQVVMVF9TT05HX1JBVEUsXG4gICAgc29uZ1RlbXBvOiAxLFxuICAgIGNhbnZhc1RvcDogQ0FOVkFTX1RPUCxcbiAgICBtb2RlOiAwLFxuICAgIHNvbmc6IFRFU1RfU09ORyxcbiAgICBzY2FsZTogTUlOT1JfU0NBTEUsXG4gICAgZGlyOiAwLFxuICAgIGNvbG9yOiAnI2ZmMDAwMCdcbiAgfSwgdHJpZ2dlckF0dGFja1JlbGVhc2UpO1xuICBiYWNoLnN0YXJ0KCk7XG5cbiAgY29uc29sZS5sb2coJ2JhY2gnLGJhY2gpO1xuICAvLyB2aWV3IHdlYiBzb2NrZXRcbiAgdmFyIHNvY2tldCA9IG5ldyBXZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjgwODIvJyk7XG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpO1xuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdub3RlcycpIHtcbiAgICAgIGlmICghcGxheWVyc1ttZXNzYWdlLmlkXSkge1xuICAgICAgICAvLyBpZiBwbGF5ZXIgZG9lc24ndCBleGlzdCwgY3JlYXRlIG5ldyBwbGF5ZXJcbiAgICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXSA9IG1lc3NhZ2VcbiAgICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS5pZCA9IG1lc3NhZ2UuaWRcbiAgICAgICAgdmFyIG5vdGVzID0gW107XG4gICAgICAgIHZhciBkaXI7XG4gICAgICAgIG1lc3NhZ2Uubm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlLCBpdGVyKSB7XG4gICAgICAgICAgaWYgKGl0ZXIgPT09IDApIHtcbiAgICAgICAgICAgIGRpciA9IG5vdGUuZGlyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3Rlcy5wdXNoKG5vdGUubWlkaSlcbiAgICAgICAgfSlcbiAgICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS5ub3RlcyA9IG5vdGVzO1xuICAgICAgICBwbGF5ZXJzW21lc3NhZ2UuaWRdLnBsYXllciA9IG5ldyBQbGF5ZXIocGxheWVyc1ttZXNzYWdlLmlkXS5pZCwge1xuICAgICAgICAgIHNvbmdUZW1wbzogbWVzc2FnZS50ZW1wbyxcbiAgICAgICAgICBzb25nUmF0ZTogVEVNUE9TW21lc3NhZ2UudGVtcG9dLFxuICAgICAgICAgIHNvbmc6IHBsYXllcnNbbWVzc2FnZS5pZF0ubm90ZXMsXG4gICAgICAgICAgY29sb3I6IG1lc3NhZ2UuY29sb3IsXG4gICAgICAgICAgZGlyOiBkaXJcbiAgICAgICAgfSwgc2VuZE5vdGUpO1xuICAgICAgICBwbGF5ZXJzW21lc3NhZ2UuaWRdLnBsYXllci5zdG9wKCk7XG4gICAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0ucGxheWVyLnJlc2V0KCk7XG4gICAgICAgIGlmIChRVUFOVElaRSkge1xuICAgICAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0udG9TdGFydCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS5wbGF5ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwbGF5ZXIgZXhpc3RzIGFscmVhZHlcbiAgICAgICAgdmFyIG5vdGVzID0gW107XG4gICAgICAgIG1lc3NhZ2Uubm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlLCBpdGVyKSB7XG4gICAgICAgICAgaWYgKGl0ZXIgPT09IDApIHtcbiAgICAgICAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0uZGlyID0gbm90ZS5kaXJcbiAgICAgICAgICB9XG4gICAgICAgICAgbm90ZXMucHVzaChub3RlLm1pZGkpXG4gICAgICAgIH0pXG4gICAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0ucGxheWVyLnN0b3AoKTtcbiAgICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS5wbGF5ZXIucmVzZXQoKTtcbiAgICAgICAgaWYgKFFVQU5USVpFKSB7XG4gICAgICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS50b1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwbGF5ZXJzW21lc3NhZ2UuaWRdLnBsYXllci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0ucGxheWVyLnNvbmcgPSBub3RlcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3RlbXBvJykge1xuICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS5wbGF5ZXIudGVtcG8obWVzc2FnZS50ZW1wbyk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzdGFydCcpIHtcbiAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0ucGxheWVyLnN0YXJ0KCk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzdG9wJykge1xuICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS5wbGF5ZXIuc3RvcCgpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICAvLyByZW1vdmUgcGxheWVyIGlmIHRoZXkgZXhpc3RcbiAgICAgIGlmIChwbGF5ZXJzW21lc3NhZ2UuaWRdKSB7XG4gICAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0ucGxheWVyLnN0b3AoKTtcbiAgICAgICAgcGxheWVyc1ttZXNzYWdlLmlkXS5wbGF5ZXIucmVtb3ZlKCk7XG4gICAgICAgIHBsYXllcnNbbWVzc2FnZS5pZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBzZW5kTm90ZShub3RlLCB0ZW1wbykge1xuICAgIC8vIHF1YXJ0ZXJub3RlIGJ5IGRlZmF1bHRcbiAgICB0ZW1wbyA9IHRlbXBvIHx8IDE7XG4gICAgY29uc29sZS5sb2coJ25vdGUnLCBub3RlKTtcbiAgICAvLyBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7bm90ZTogbm90ZSwgdGVtcG86IHRlbXBvfSkpO1xuICB9XG5cblxuICAvKlxuICAgIElOSVRJQUxJWkVcbiAgICovXG5cbiAgY3JlYXRlTm90ZXMobm90ZXMsIERFRkFVTFRfQkFTRV9OT1RFLCBTVEVQUywgTUlOT1JfU0NBTEUsIENBTlZBU19UT1ApO1xuICBpbml0aWFsaXplU2V0dGluZ3MoQ0FOVkFTX1RPUCk7XG5cbiAgLypcbiAgICBMb29wIG92ZXIgcGxheWVyc1xuICAgKi9cbiAgdmFyIGxvb3BDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gbG9vcFBsYXllcnMoKSB7XG4gICAgZm9yICh2YXIgaWQgaW4gcGxheWVycykge1xuICAgICAgaWYgKCEhcGxheWVyc1tpZF0pIHtcbiAgICAgICAgLy8gbG9vayBmb3IgcGxheWVycyB0byBzdGFydFxuICAgICAgICBpZiAocGxheWVyc1tpZF0udG9TdGFydCkge1xuICAgICAgICAgIC8vIHJlc2V0IHRpbWVvdXQgdXBvbiBuZXcgaW5wdXRcbiAgICAgICAgICBwbGF5ZXJzW2lkXS5wbGF5ZXIudGltZW91dCA9IDA7XG4gICAgICAgICAgcGxheWVyc1tpZF0udG9TdGFydCA9IGZhbHNlO1xuICAgICAgICAgIHBsYXllcnNbaWRdLnBsYXllci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgZm9yIGluYWN0aXZlIHBsYXllcnMgZXZlcnkgc2Vjb25kXG4gICAgICAgIGlmIChUSU1FT1VUICYmIGxvb3BDb3VudCA+PSA1KSB7XG4gICAgICAgICAgbG9vcENvdW50ID0gMDtcbiAgICAgICAgICAvLyBpbmNyZWFzZSB0aW1lb3V0IGV2ZXJ5IHNlY29uZFxuICAgICAgICAgIHBsYXllcnNbaWRdLnBsYXllci50aW1lb3V0ICs9IDE7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBsYXllciBpZiBubyBhY3Rpb25zIGZvciBtb3JlIHRoYW4gMzAgc2Vjb25kc1xuICAgICAgICAgIGlmIChwbGF5ZXJzW2lkXS5wbGF5ZXIudGltZW91dCA+PSAxMDAwKSB7XG4gICAgICAgICAgICBwbGF5ZXJzW2lkXS5wbGF5ZXIuc3RvcCgpO1xuICAgICAgICAgICAgcGxheWVyc1tpZF0ucGxheWVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgcGxheWVyc1tpZF0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsb29wQ291bnQrKztcbiAgfVxuXG4gIC8vIHNldCBpbnRlcnZhbCBhdCB0aGUgc2hvcnRlc3QgZGVsaW1pbmF0aW9uIG9mIG5vdGVzXG4gIGlmIChRVUFOVElaRSkge1xuICAgIHNldEludGVydmFsKGxvb3BQbGF5ZXJzLCBURU1QT1NbMF0pO1xuICB9XG5cbiAgLypcbiAgVVNFUiBJTlBVVFxuICAqL1xuICAkKCcubm90ZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBub3RlID0gJCh0aGlzKS5hdHRyKFwiaWRcIik7XG4gICAgY29uc29sZS5sb2coJ2NsaWNrJyk7XG4gICAgc2VuZE5vdGUobm90ZXNbbm90ZV0ubWlkaSk7XG4gIH0pO1xuXG5cbiAgJCgnLm5vdGUnKS5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBub3RlID0gJCh0aGlzKS5hdHRyKFwiaWRcIik7XG4gICAgdHJpZ2dlckF0dGFja1JlbGVhc2UobWlkaV90b19mcmVxKG5vdGVzW25vdGVdLm1pZGkpKTtcbiAgICBjb25zb2xlLmxvZygnaG92ZXInKTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcHAuanMiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3N0eWxlcy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4xLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOS0yMlQyMjozMFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMS4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHRcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0XHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRcdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0fVxuXG5cdC8vIENvbXBsZXggc2VsZWN0b3IsIGNvbXBhcmUgdGhlIHR3byBzZXRzLCByZW1vdmluZyBub24tRWxlbWVudHNcblx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRcdHJlc29sdmUuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSxcblx0XHR2YWwgPSAwO1xuXG5cdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRpZiAoIGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0aSA9IDQ7XG5cblx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHR9IGVsc2Uge1xuXHRcdGkgPSBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdGlmICggZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHR2YWwgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyBuYW1lIF07XG5cdH1cblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHJhZigpIHtcblx0aWYgKCB0aW1lcklkICkge1xuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApO1xuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmIG9yIGlmIGRvY3VtZW50IGlzIGhpZGRlblxuXHRpZiAoIGpRdWVyeS5meC5vZmYgfHwgZG9jdW1lbnQuaGlkZGVuICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKSA6XG5cdFx0XHR3aW5kb3cuc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aWYgKCB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aW1lcklkICk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0fVxuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLCByZWN0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGVsZW1lbnQgaXMgbm90IGhpZGRlbiAoZGlzcGxheTogbm9uZSlcblx0XHRpZiAoIHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQgKSB7XG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogcGFyZW50T2Zmc2V0LnRvcCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogcGFyZW50T2Zmc2V0LmxlZnQgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuLy8gY3JlYXRlIHRoZSBub3RlIG9iamVjdHNcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb3Rlcyhub3RlcywgYmFzZU5vdGUsIHN0ZXBzLCBzY2FsZSwgdG9wKSB7XG4gIGNvbnNvbGUubG9nKCd0b3AnLHRvcCk7XG4gIHZhciBtYXhXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICB2YXIgbm90ZVdpZHRoID0gbWF4V2lkdGggLyBzdGVwcztcbiAgICBub3Rlc1tpXSA9IHtcbiAgICAgIGlkOiBpLFxuICAgICAgbWlkaTogYmFzZU5vdGUgKyAoaSA8IDcgPyAwIDogKGkgPiAxMyA/IDI0IDogMTIpKSArIHNjYWxlWyhpICUgc2NhbGUubGVuZ3RoKV0sXG4gICAgICBsZWZ0OiBub3RlV2lkdGggKiBpLFxuICAgICAgd2lkdGg6IG5vdGVXaWR0aCxcbiAgICAgIGhlaWdodDogbm90ZVdpZHRoIC8gMixcbiAgICAgIHRvcDogbm90ZVdpZHRoIC8gNCxcbiAgICAgIGNlbnRlcjogbm90ZVdpZHRoICogaSArIG5vdGVXaWR0aCAvIDJcbiAgICB9XG4gIH1cbiAgcmVuZGVyTm90ZXMobm90ZXMsIHN0ZXBzLCB0b3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTm90ZXMobm90ZXMsIHN0ZXBzLCB0b3ApIHtcbiAgdmFyIG5vdGVIZWlnaHQ7XG4gICQoJyNjYW52YXMnKS5odG1sKFxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3Rlc0hUTUwgPSAnJztcbiAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSwgaXRlcikge1xuICAgICAgICB2YXIgY29sb3IgPSBwYXJzZUludCgoMTgwICogKGl0ZXIgLyBzdGVwcykgKyA2MCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgbm90ZUhlaWdodCA9IG5vdGUuaGVpZ2h0O1xuICAgICAgICBub3Rlc0hUTUwgKz0gKFxuICAgICAgICAgICc8ZGl2ICcgK1xuICAgICAgICAgICdjbGFzcz1cIm5vdGVcIiAnICtcbiAgICAgICAgICAnaWQ9XCInICsgaXRlciArICdcIiAnICtcbiAgICAgICAgICAnc3R5bGU9XCInICtcbiAgICAgICAgICAnbGVmdDonICsgbm90ZS5sZWZ0ICsgJ3B4OycgK1xuICAgICAgICAgICd0b3A6JyArIG5vdGUudG9wICsgJ3B4OycgK1xuICAgICAgICAgICd3aWR0aDonICsgbm90ZS53aWR0aCArICdweDsnICtcbiAgICAgICAgICAnaGVpZ2h0OicgKyBub3RlLmhlaWdodCArICdweDsnICtcbiAgICAgICAgICAnXCIgJyArXG4gICAgICAgICAgJz48L2Rpdj4nXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub3Rlc0hUTUw7XG4gICAgfSkoKVxuICApO1xuICAkKCcuc2NhbGUnKS5odG1sKFxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd0b3AnLHRvcCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGRpdiBjbGFzcz1cInNjYWxlLWJhY2tncm91bmRcIicgK1xuICAgICAgICAnc3R5bGU9XCInICtcbiAgICAgICAgJ3RvcDonICsgdG9wICsgJ3B4OycgK1xuICAgICAgICAnaGVpZ2h0OicgKyBub3RlSGVpZ2h0ICsgJ3B4OycgK1xuICAgICAgICAnXCIgJyArXG4gICAgICAgICc+PC9kaXY+J1xuICAgICAgKVxuICAgIH0pKClcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVNldHRpbmdzKHRvcCkge1xuICBjb25zb2xlLmxvZygndG9wJyx0b3ApO1xuICAkKCcubm90ZScpLmNzcygndG9wJywgdG9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFuaW1hdGVOb3RlKG5vdGUsIGR1cmF0aW9uKSB7XG4gIC8vIG5vdGUgdHJhbnNpdGlvblxuICB2YXIgYWN0aXZlTm90ZSA9ICQoJyMnICsgbm90ZSk7XG4gIGFjdGl2ZU5vdGUuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGFjdGl2ZU5vdGUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICB9LCBkdXJhdGlvbik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5pbWF0ZU5vdGVzLmpzIiwiaW1wb3J0IFRvbmUgZnJvbSAndG9uZSc7XG5cbnZhciB2b2wgPSBuZXcgVG9uZS5Wb2x1bWUoMTIpO1xudmFyIGZyZWV2ZXJiID0gbmV3IFRvbmUuRnJlZXZlcmIoMC43LCAxMjAwKS50b01hc3RlcigpO1xudmFyIHN5bnRoID0gbmV3IFRvbmUuUG9seVN5bnRoKDYsIFRvbmUuRk1TeW50aCwge1xuICAgIFwib3NjaWxsYXRvclwiOiB7XG4gICAgICAgIFwicGFydGlhbHNcIjogWzAsIDIsIDMsIDQsIDhdLFxuICAgIH0sXG4gICAgXCJlbnZlbG9wZVwiOiB7XG4gICAgICAgIFwiYXR0YWNrXCI6IDAuMjUsXG4gICAgICAgIFwiZGVjYXlcIjogMC40XG4gICAgfSxcbiAgICBcInZvbHVtZVwiOiB7XG4gICAgfVxufSkuY2hhaW4odm9sKS5jb25uZWN0KGZyZWV2ZXJiKS50b01hc3RlcigpO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckF0dGFja1JlbGVhc2Uobm90ZSwgdGVtcG8pIHtcbiAgbGV0IG5vdGVMZW5ndGggPSB0ZW1wbyB8fCBcIjhuXCI7XG4gIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKG5vdGUsIG5vdGVMZW5ndGgpO1xufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc291bmRHZW5lcmF0b3IuanMiLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSl7XG5cblx0Ly9VTURcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSgpO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiBcdH0gZWxzZSB7XG5cdFx0cm9vdC5Ub25lID0gZmFjdG9yeSgpO1xuXHR9XG5cbn0odGhpcywgZnVuY3Rpb24oKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdHZhciBUb25lO1xuXHQvL2NvbnN0cnVjdHMgdGhlIG1haW4gVG9uZSBvYmplY3Rcblx0ZnVuY3Rpb24gTWFpbihmdW5jKXtcblx0XHRUb25lID0gZnVuYygpO1xuXHR9XG5cdC8vaW52b2tlcyBlYWNoIG9mIHRoZSBtb2R1bGVzIHdpdGggdGhlIG1haW4gVG9uZSBvYmplY3QgYXMgdGhlIGFyZ3VtZW50XG5cdGZ1bmN0aW9uIE1vZHVsZShmdW5jKXtcblx0XHRmdW5jKFRvbmUpO1xuXHR9XHQvKipcblx0ICogIFRvbmUuanNcblx0ICogIEBhdXRob3IgWW90YW0gTWFublxuXHQgKiAgQGxpY2Vuc2UgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVCBNSVQgTGljZW5zZVxuXHQgKiAgQGNvcHlyaWdodCAyMDE0LTIwMTcgWW90YW0gTWFublxuXHQgKi9cblx0TWFpbihmdW5jdGlvbiAoKSB7XG5cdCAgICBcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0V0VCIEFVRElPIENPTlRFWFRcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgZnVuY3Rpb24gaXNVbmRlZih2YWwpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuXHQgICAgfVxuXHQgICAgdmFyIGF1ZGlvQ29udGV4dDtcblx0ICAgIC8vcG9seWZpbGwgZm9yIEF1ZGlvQ29udGV4dCBhbmQgT2ZmbGluZUF1ZGlvQ29udGV4dFxuXHQgICAgaWYgKGlzVW5kZWYod2luZG93LkF1ZGlvQ29udGV4dCkpIHtcblx0ICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcblx0ICAgIH1cblx0ICAgIGlmIChpc1VuZGVmKHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0KSkge1xuXHQgICAgICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG5cdCAgICB9XG5cdCAgICBpZiAoIWlzVW5kZWYoQXVkaW9Db250ZXh0KSkge1xuXHQgICAgICAgIGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgQXVkaW8gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcblx0ICAgIH1cblx0ICAgIC8vU0hJTVMvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgaWYgKCFpc0Z1bmN0aW9uKEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbikpIHtcblx0ICAgICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW4gPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW5Ob2RlO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0Z1bmN0aW9uKEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkpKSB7XG5cdCAgICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXlOb2RlO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0Z1bmN0aW9uKEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGVyaW9kaWNXYXZlKSkge1xuXHQgICAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGVyaW9kaWNXYXZlID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVXYXZlVGFibGU7XG5cdCAgICB9XG5cdCAgICBpZiAoIWlzRnVuY3Rpb24oQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5zdGFydCkpIHtcblx0ICAgICAgICBBdWRpb0J1ZmZlclNvdXJjZU5vZGUucHJvdG90eXBlLnN0YXJ0ID0gQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5ub3RlR3JhaW5Pbjtcblx0ICAgIH1cblx0ICAgIGlmICghaXNGdW5jdGlvbihBdWRpb0J1ZmZlclNvdXJjZU5vZGUucHJvdG90eXBlLnN0b3ApKSB7XG5cdCAgICAgICAgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5zdG9wID0gQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5ub3RlT2ZmO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0Z1bmN0aW9uKE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zdGFydCkpIHtcblx0ICAgICAgICBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc3RhcnQgPSBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUubm90ZU9uO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0Z1bmN0aW9uKE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zdG9wKSkge1xuXHQgICAgICAgIE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zdG9wID0gT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm5vdGVPZmY7XG5cdCAgICB9XG5cdCAgICBpZiAoIWlzRnVuY3Rpb24oT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnNldFBlcmlvZGljV2F2ZSkpIHtcblx0ICAgICAgICBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUuc2V0UGVyaW9kaWNXYXZlID0gT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnNldFdhdmVUYWJsZTtcblx0ICAgIH1cblx0ICAgIC8vZXh0ZW5kIHRoZSBjb25uZWN0IGZ1bmN0aW9uIHRvIGluY2x1ZGUgVG9uZXNcblx0ICAgIGlmIChpc1VuZGVmKEF1ZGlvTm9kZS5wcm90b3R5cGUuX25hdGl2ZUNvbm5lY3QpKSB7XG5cdCAgICAgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5fbmF0aXZlQ29ubmVjdCA9IEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdDtcblx0ICAgICAgICBBdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoQiwgb3V0TnVtLCBpbk51bSkge1xuXHQgICAgICAgICAgICBpZiAoQi5pbnB1dCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoQi5pbnB1dCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihpbk51bSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5OdW0gPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoQi5pbnB1dFtpbk51bV0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoQi5pbnB1dCwgb3V0TnVtLCBpbk51bSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChCIGluc3RhbmNlb2YgQXVkaW9Ob2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUNvbm5lY3QoQiwgb3V0TnVtLCBpbk51bSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29ubmVjdChCLCBvdXROdW0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGNvbm5lY3RpbmcgdG8gbm9kZTogJyArIEIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRPTkVcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBhbGwgb3RoZXIgY2xhc3Nlcy4gSXQgcHJvdmlkZXMgXG5cdFx0ICogICAgICAgICAgYSBsb3Qgb2YgbWV0aG9kcyBhbmQgZnVuY3Rpb25hbGl0eSB0byBhbGwgY2xhc3NlcyB0aGF0IGV4dGVuZFxuXHRcdCAqICAgICAgICAgIGl0LiBcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAYWxpYXMgVG9uZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0cz0xXSB0aGUgbnVtYmVyIG9mIGlucHV0IG5vZGVzXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0cz0xXSB0aGUgbnVtYmVyIG9mIG91dHB1dCBub2Rlc1xuXHRcdCAqL1xuXHQgICAgdmFyIFRvbmUgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGlucHV0IG5vZGUocylcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV8QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICBpZiAoaXNVbmRlZihpbnB1dHMpIHx8IGlucHV0cyA9PT0gMSkge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGlucHV0cyA+IDEpIHtcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBBcnJheShpbnB1dHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb3V0cHV0IG5vZGUocylcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV8QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICBpZiAoaXNVbmRlZihvdXRwdXRzKSB8fCBvdXRwdXRzID09PSAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG91dHB1dHMgPiAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IEFycmF5KGlucHV0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIHBhcmFtZXRlcnMgYXQgb25jZS4gRWl0aGVyIHBhc3MgaW4gYW5cblx0XHQgKiAgb2JqZWN0IG1hcHBpbmcgcGFyYW1ldGVycyB0byB2YWx1ZXMsIG9yIHRvIHNldCBhXG5cdFx0ICogIHNpbmdsZSBwYXJhbWV0ZXIsIGJ5IHBhc3NpbmcgaW4gYSBzdHJpbmcgYW5kIHZhbHVlLlxuXHRcdCAqICBUaGUgbGFzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCByYW1wIHRpbWUgd2hpY2ggXG5cdFx0ICogIHdpbGwgcmFtcCBhbnkgc2lnbmFsIHZhbHVlcyB0byB0aGVpciBkZXN0aW5hdGlvbiB2YWx1ZVxuXHRcdCAqICBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcGFyYW1zXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gcmFtcFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NldCB2YWx1ZXMgdXNpbmcgYW4gb2JqZWN0XG5cdFx0ICogZmlsdGVyLnNldCh7XG5cdFx0ICogXHRcImZyZXF1ZW5jeVwiIDogMzAwLFxuXHRcdCAqIFx0XCJ0eXBlXCIgOiBoaWdocGFzc1xuXHRcdCAqIH0pO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIGZpbHRlci5zZXQoXCJ0eXBlXCIsIFwiaGlnaHBhc3NcIik7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9yYW1wIHRvIHRoZSB2YWx1ZSAyMjAgb3ZlciAzIHNlY29uZHMuIFxuXHRcdCAqIG9zY2lsbGF0b3Iuc2V0KHtcblx0XHQgKiBcdFwiZnJlcXVlbmN5XCIgOiAyMjBcblx0XHQgKiB9LCAzKTtcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlLCByYW1wVGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KHBhcmFtcykpIHtcblx0ICAgICAgICAgICAgcmFtcFRpbWUgPSB2YWx1ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdHJpbmcocGFyYW1zKSkge1xuXHQgICAgICAgICAgICB2YXIgdG1wT2JqID0ge307XG5cdCAgICAgICAgICAgIHRtcE9ialtwYXJhbXNdID0gdmFsdWU7XG5cdCAgICAgICAgICAgIHBhcmFtcyA9IHRtcE9iajtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFyYW1Mb29wOlxuXHQgICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIHBhcmFtcykge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbXNbYXR0cl07XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmIChhdHRyLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXR0clNwbGl0ID0gYXR0ci5zcGxpdCgnLicpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0clNwbGl0Lmxlbmd0aCAtIDE7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbYXR0clNwbGl0W2ldXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJTcGxpdC5zcGxpY2UoMCwgaSArIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyUGFyYW0gPSBhdHRyU3BsaXQuam9pbignLicpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnNldChpbm5lclBhcmFtLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBwYXJhbUxvb3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJTcGxpdFthdHRyU3BsaXQubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJlbnRbYXR0cl07XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihwYXJhbSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLlNpZ25hbCAmJiBwYXJhbSBpbnN0YW5jZW9mIFRvbmUuU2lnbmFsIHx8IFRvbmUuUGFyYW0gJiYgcGFyYW0gaW5zdGFuY2VvZiBUb25lLlBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnZhbHVlICE9PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihyYW1wVGltZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5yYW1wVG8odmFsdWUsIHJhbXBUaW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnZhbHVlICE9PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBUb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0uc2V0KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gIT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyZW50W2F0dHJdID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBvYmplY3QncyBhdHRyaWJ1dGVzLiBHaXZlbiBubyBhcmd1bWVudHMgZ2V0XG5cdFx0ICogIHdpbGwgcmV0dXJuIGFsbCBhdmFpbGFibGUgb2JqZWN0IHByb3BlcnRpZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmdcblx0XHQgKiAgdmFsdWVzLiBQYXNzIGluIGEgc2luZ2xlIGF0dHJpYnV0ZSB0byByZXRyaWV2ZSBvciBhbiBhcnJheVxuXHRcdCAqICBvZiBhdHRyaWJ1dGVzLiBUaGUgYXR0cmlidXRlIHN0cmluZ3MgY2FuIGFsc28gaW5jbHVkZSBhIFwiLlwiXG5cdFx0ICogIHRvIGFjY2VzcyBkZWVwZXIgcHJvcGVydGllcy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBvc2MuZ2V0KCk7XG5cdFx0ICogLy9yZXR1cm5zIHtcInR5cGVcIiA6IFwic2luZVwiLCBcImZyZXF1ZW5jeVwiIDogNDQwLCAuLi5ldGN9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogb3NjLmdldChcInR5cGVcIik7XG5cdFx0ICogLy9yZXR1cm5zIHsgXCJ0eXBlXCIgOiBcInNpbmVcIn1cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vdXNlIGRvdCBub3RhdGlvbiB0byBhY2Nlc3MgZGVlcCBwcm9wZXJ0aWVzXG5cdFx0ICogc3ludGguZ2V0KFtcImVudmVsb3BlLmF0dGFja1wiLCBcImVudmVsb3BlLnJlbGVhc2VcIl0pO1xuXHRcdCAqIC8vcmV0dXJucyB7XCJlbnZlbG9wZVwiIDoge1wiYXR0YWNrXCIgOiAwLjIsIFwicmVsZWFzZVwiIDogMC40fX1cblx0XHQgKiAgQHBhcmFtIHtBcnJheT18c3RyaW5nfHVuZGVmaW5lZH0gcGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHRvIGdldCwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIFxuXHRcdCAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgYWxsIGF2YWlsYWJsZS5cblx0XHQgKiAgQHJldHVybnMge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblx0ICAgICAgICBpZiAoaXNVbmRlZihwYXJhbXMpKSB7XG5cdCAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMuX2NvbGxlY3REZWZhdWx0cyh0aGlzLmNvbnN0cnVjdG9yKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdHJpbmcocGFyYW1zKSkge1xuXHQgICAgICAgICAgICBwYXJhbXMgPSBbcGFyYW1zXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJldCA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBhdHRyID0gcGFyYW1zW2ldO1xuXHQgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHN1YlJldCA9IHJldDtcblx0ICAgICAgICAgICAgaWYgKGF0dHIuaW5kZXhPZignLicpICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGF0dHJTcGxpdCA9IGF0dHIuc3BsaXQoJy4nKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0clNwbGl0Lmxlbmd0aCAtIDE7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdWJBdHRyID0gYXR0clNwbGl0W2pdO1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YlJldFtzdWJBdHRyXSA9IHN1YlJldFtzdWJBdHRyXSB8fCB7fTtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJSZXQgPSBzdWJSZXRbc3ViQXR0cl07XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50W3N1YkF0dHJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJTcGxpdFthdHRyU3BsaXQubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyZW50W2F0dHJdO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pc09iamVjdChwYXJhbXNbYXR0cl0pKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS5nZXQoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLlNpZ25hbCAmJiBwYXJhbSBpbnN0YW5jZW9mIFRvbmUuU2lnbmFsKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS52YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLlBhcmFtICYmIHBhcmFtIGluc3RhbmNlb2YgVG9uZS5QYXJhbSkge1xuXHQgICAgICAgICAgICAgICAgc3ViUmV0W2F0dHJdID0gcGFyYW0udmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS52YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIFRvbmUpIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtLmdldCgpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKHBhcmFtKSAmJiAhaXNVbmRlZihwYXJhbSkpIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbGxlY3QgYWxsIG9mIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXMgaW4gb25lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0ciB0aGUgY29uc3RydWN0b3IgdG8gZmluZCB0aGUgZGVmYXVsdHMgZnJvbVxuXHRcdCAqICBAcmV0dXJuIHtBcnJheX0gYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIHdoaWNoIGJlbG9uZyB0byB0aGUgY2xhc3Ncblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLl9jb2xsZWN0RGVmYXVsdHMgPSBmdW5jdGlvbiAoY29uc3RyKSB7XG5cdCAgICAgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgICAgIGlmICghaXNVbmRlZihjb25zdHIuZGVmYXVsdHMpKSB7XG5cdCAgICAgICAgICAgIHJldCA9IE9iamVjdC5rZXlzKGNvbnN0ci5kZWZhdWx0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghaXNVbmRlZihjb25zdHIuX3N1cGVyKSkge1xuXHQgICAgICAgICAgICB2YXIgc3VwZXJEZWZzID0gdGhpcy5fY29sbGVjdERlZmF1bHRzKGNvbnN0ci5fc3VwZXIpO1xuXHQgICAgICAgICAgICAvL2ZpbHRlciBvdXQgcmVwZWF0c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cGVyRGVmcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHJldC5pbmRleE9mKHN1cGVyRGVmc1tpXSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goc3VwZXJEZWZzW2ldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcmV0dXJucyB7c3RyaW5nfSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyBhcyBhIHN0cmluZ1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgY2xhc3NOYW1lIGluIFRvbmUpIHtcblx0ICAgICAgICAgICAgdmFyIGlzTGV0dGVyID0gY2xhc3NOYW1lWzBdLm1hdGNoKC9eW0EtWl0kLyk7XG5cdCAgICAgICAgICAgIHZhciBzYW1lQ29uc3RydWN0b3IgPSBUb25lW2NsYXNzTmFtZV0gPT09IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKFRvbmVbY2xhc3NOYW1lXSkgJiYgaXNMZXR0ZXIgJiYgc2FtZUNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAnVG9uZSc7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0Q0xBU1MgVkFSU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQSBzdGF0aWMgcG9pbnRlciB0byB0aGUgYXVkaW8gY29udGV4dCBhY2Nlc3NpYmxlIGFzIFRvbmUuY29udGV4dC4gXG5cdFx0ICogIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdFx0ICovXG5cdCAgICBUb25lLmNvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGF1ZGlvIGNvbnRleHQuXG5cdFx0ICogIEB0eXBlIHtBdWRpb0NvbnRleHR9XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5jb250ZXh0ID0gVG9uZS5jb250ZXh0O1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IGJ1ZmZlciBzaXplXG5cdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5idWZmZXJTaXplID0gMjA0ODtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVsYXkgdGltZSBvZiBhIHNpbmdsZSBmcmFtZSAoMTI4IHNhbXBsZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjKS4gXG5cdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5ibG9ja1RpbWUgPSAxMjggLyBUb25lLmNvbnRleHQuc2FtcGxlUmF0ZTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdGltZSBvZiBhIHNpbmdsZSBzYW1wbGVcblx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnNhbXBsZVRpbWUgPSAxIC8gVG9uZS5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBpbnB1dHMgZmVlZGluZyBpbnRvIHRoZSBBdWRpb05vZGUuIFxuXHRcdCAqICBGb3Igc291cmNlIG5vZGVzLCB0aGlzIHdpbGwgYmUgMC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdFx0ICogIEBuYW1lIG51bWJlck9mSW5wdXRzXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUucHJvdG90eXBlLCAnbnVtYmVyT2ZJbnB1dHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlucHV0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KHRoaXMuaW5wdXQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBvdXRwdXRzIGNvbWluZyBvdXQgb2YgdGhlIEF1ZGlvTm9kZS4gXG5cdFx0ICogIEZvciBzb3VyY2Ugbm9kZXMsIHRoaXMgd2lsbCBiZSAwLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZSNcblx0XHQgKiAgQG5hbWUgbnVtYmVyT2ZJbnB1dHNcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5wcm90b3R5cGUsICdudW1iZXJPZk91dHB1dHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBcnJheSh0aGlzLm91dHB1dCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRDT05ORUNUSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgZGlzY29ubmVjdCBhbmQgZGlzcG9zZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZih0aGlzLmlucHV0KSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbnB1dCBpbnN0YW5jZW9mIEF1ZGlvTm9kZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKHRoaXMub3V0cHV0KSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBBdWRpb05vZGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLm91dHB1dCA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBhIHNpbGVudCBjb25uZWN0aW9uIHRvIHRoZSBEZXNpbmF0aW9uTm9kZVxuXHRcdCAqICB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueXRoaW5nIGNvbm5lY3RlZCB0byBpdFxuXHRcdCAqICB3aWxsIG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdCAqICBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIHZhciBfc2lsZW50Tm9kZSA9IG51bGw7XG5cdCAgICAvKipcblx0XHQgKiAgbWFrZXMgYSBjb25uZWN0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBub2RlIHdpbGwgbm90IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ICogIHVudGlsICdkaXNwb3NlJyBpcyBleHBsaWNpdGx5IGNhbGxlZFxuXHRcdCAqXG5cdFx0ICogIHVzZSBjYXJlZnVsbHkuIGNpcmN1bXZlbnRzIEpTIGFuZCBXZWJBdWRpbydzIG5vcm1hbCBHYXJiYWdlIENvbGxlY3Rpb24gYmVoYXZpb3Jcblx0XHQgKiAgQHJldHVybnMge1RvbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLm5vR0MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdChfc2lsZW50Tm9kZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5ub0dDID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29ubmVjdChfc2lsZW50Tm9kZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbm5lY3QgdGhlIG91dHB1dCBvZiBhIFRvbmVOb2RlIHRvIGFuIEF1ZGlvUGFyYW0sIEF1ZGlvTm9kZSwgb3IgVG9uZU5vZGVcblx0XHQgKiAgQHBhcmFtICB7VG9uZSB8IEF1ZGlvUGFyYW0gfCBBdWRpb05vZGV9IHVuaXQgXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggb3V0cHV0IHRvIGNvbm5lY3QgZnJvbVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggaW5wdXQgdG8gY29ubmVjdCB0b1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0LCBvdXRwdXROdW0sIGlucHV0TnVtKSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vdXRwdXQpKSB7XG5cdCAgICAgICAgICAgIG91dHB1dE51bSA9IHRoaXMuZGVmYXVsdEFyZyhvdXRwdXROdW0sIDApO1xuXHQgICAgICAgICAgICB0aGlzLm91dHB1dFtvdXRwdXROdW1dLmNvbm5lY3QodW5pdCwgMCwgaW5wdXROdW0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodW5pdCwgb3V0cHV0TnVtLCBpbnB1dE51bSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNjb25uZWN0IHRoZSBvdXRwdXRcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8QXVkaW9Ob2RlfSBvdXRwdXQgRWl0aGVyIHRoZSBvdXRwdXQgaW5kZXggdG8gZGlzY29ubmVjdFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB0aGUgb3V0cHV0IGlzIGFuIGFycmF5LCBvciB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSB0byBkaXNjb25uZWN0IGZyb20uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKG91dHB1dCkge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3V0cHV0KSkge1xuXHQgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmRlZmF1bHRBcmcob3V0cHV0LCAwKTtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXRbb3V0cHV0XS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1VuZGVmKG91dHB1dCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdChvdXRwdXQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbm5lY3QgdG9nZXRoZXIgYWxsIG9mIHRoZSBhcmd1bWVudHMgaW4gc2VyaWVzXG5cdFx0ICogIEBwYXJhbSB7Li4uQXVkaW9QYXJhbXxUb25lfEF1ZGlvTm9kZX0gbm9kZXNcblx0XHQgKiAgQHJldHVybnMge1RvbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmNvbm5lY3RTZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50VW5pdCA9IGFyZ3VtZW50c1swXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0b1VuaXQgPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50VW5pdC5jb25uZWN0KHRvVW5pdCk7XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50VW5pdCA9IHRvVW5pdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSB0byB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgaW4gc2VyaWVzLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAvL2Nvbm5lY3QgYSBub2RlIHRvIGFuIGVmZmVjdCwgcGFuVm9sIGFuZCB0aGVuIHRvIHRoZSBtYXN0ZXIgb3V0cHV0XG5cdFx0ICogIG5vZGUuY2hhaW4oZWZmZWN0LCBwYW5Wb2wsIFRvbmUuTWFzdGVyKTtcblx0XHQgKiAgQHBhcmFtIHsuLi5BdWRpb1BhcmFtfFRvbmV8QXVkaW9Ob2RlfSBub2Rlc1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50VW5pdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG9Vbml0ID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgY3VycmVudFVuaXQuY29ubmVjdCh0b1VuaXQpO1xuXHQgICAgICAgICAgICAgICAgY3VycmVudFVuaXQgPSB0b1VuaXQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbm5lY3QgdGhlIG91dHB1dCBvZiB0aGlzIG5vZGUgdG8gdGhlIHJlc3Qgb2YgdGhlIG5vZGVzIGluIHBhcmFsbGVsLlxuXHRcdCAqICBAcGFyYW0gey4uLkF1ZGlvUGFyYW18VG9uZXxBdWRpb05vZGV9IG5vZGVzXG5cdFx0ICogIEByZXR1cm5zIHtUb25lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5mYW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoYXJndW1lbnRzW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvL2dpdmUgbmF0aXZlIG5vZGVzIGNoYWluIGFuZCBmYW4gbWV0aG9kc1xuXHQgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5jaGFpbiA9IFRvbmUucHJvdG90eXBlLmNoYWluO1xuXHQgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5mYW4gPSBUb25lLnByb3RvdHlwZS5mYW47XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRVVElMSVRJRVMgLyBIRUxQRVJTIC8gTUFUSFNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIElmIHRoZSBgZ2l2ZW5gIHBhcmFtZXRlciBpcyB1bmRlZmluZWQsIHVzZSB0aGUgYGZhbGxiYWNrYC4gXG5cdFx0ICogIElmIGJvdGggYGdpdmVuYCBhbmQgYGZhbGxiYWNrYCBhcmUgb2JqZWN0IGxpdGVyYWxzLCBpdCB3aWxsXG5cdFx0ICogIHJldHVybiBhIGRlZXAgY29weSB3aGljaCBpbmNsdWRlcyBhbGwgb2YgdGhlIHBhcmFtZXRlcnMgZnJvbSBib3RoIFxuXHRcdCAqICBvYmplY3RzLiBJZiBhIHBhcmFtZXRlciBpcyB1bmRlZmluZWQgaW4gZ2l2ZW4sIGl0IHdpbGwgcmV0dXJuXG5cdFx0ICogIHRoZSBmYWxsYmFjayBwcm9wZXJ0eS4gXG5cdFx0ICogIDxicj48YnI+XG5cdFx0ICogIFdBUk5JTkc6IGlmIG9iamVjdCBpcyBzZWxmIHJlZmVyZW50aWFsLCBpdCB3aWxsIGdvIGludG8gYW4gYW4gXG5cdFx0ICogIGluZmluaXRlIHJlY3Vyc2l2ZSBsb29wLlxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7Kn0gZ2l2ZW4gICAgXG5cdFx0ICogIEBwYXJhbSAgeyp9IGZhbGxiYWNrIFxuXHRcdCAqICBAcmV0dXJuIHsqfSAgICAgICAgICBcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmRlZmF1bHRBcmcgPSBmdW5jdGlvbiAoZ2l2ZW4sIGZhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNPYmplY3QoZ2l2ZW4pICYmIHRoaXMuaXNPYmplY3QoZmFsbGJhY2spKSB7XG5cdCAgICAgICAgICAgIHZhciByZXQgPSB7fTtcblx0ICAgICAgICAgICAgLy9tYWtlIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBvYmplY3Rcblx0ICAgICAgICAgICAgZm9yICh2YXIgZ2l2ZW5Qcm9wIGluIGdpdmVuKSB7XG5cdCAgICAgICAgICAgICAgICByZXRbZ2l2ZW5Qcm9wXSA9IHRoaXMuZGVmYXVsdEFyZyhmYWxsYmFja1tnaXZlblByb3BdLCBnaXZlbltnaXZlblByb3BdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWxsYmFja1Byb3AgaW4gZmFsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgIHJldFtmYWxsYmFja1Byb3BdID0gdGhpcy5kZWZhdWx0QXJnKGdpdmVuW2ZhbGxiYWNrUHJvcF0sIGZhbGxiYWNrW2ZhbGxiYWNrUHJvcF0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGlzVW5kZWYoZ2l2ZW4pID8gZmFsbGJhY2sgOiBnaXZlbjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHJldHVybnMgdGhlIGFyZ3MgYXMgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBnaXZlbiBhcmd1bWVudHNcblx0XHQgKiAgbWFwcGVkIHRvIHRoZSBuYW1lcyBwcm92aWRlZC4gXG5cdFx0ICpcblx0XHQgKiAgaWYgdGhlIGFyZ3MgZ2l2ZW4gaXMgYW4gYXJyYXkgY29udGFpbmluZyBvbmx5IG9uZSBvYmplY3QsIGl0IGlzIGFzc3VtZWRcblx0XHQgKiAgdGhhdCB0aGF0J3MgYWxyZWFkeSB0aGUgb3B0aW9ucyBvYmplY3QgYW5kIHdpbGwganVzdCByZXR1cm4gaXQuIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9IHZhbHVlcyAgdGhlICdhcmd1bWVudHMnIG9iamVjdCBvZiB0aGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9IGtleXMgdGhlIG5hbWVzIG9mIHRoZSBhcmd1bWVudHMgYXMgdGhleVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGFwcGVhciBpbiB0aGUgb3B0aW9ucyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtPYmplY3Q9fSBkZWZhdWx0cyBvcHRpb25hbCBkZWZhdWx0cyB0byBtaXhpbiB0byB0aGUgcmV0dXJuZWQgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyBvYmplY3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHQgKiAgQHJldHVybiB7T2JqZWN0fSAgICAgICB0aGUgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgbmFtZXMgbWFwcGVkIHRvIHRoZSBhcmd1bWVudHNcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLm9wdGlvbnNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWVzLCBrZXlzLCBkZWZhdWx0cykge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgdGhpcy5pc09iamVjdCh2YWx1ZXNbMF0pKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZXNbMF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zW2tleXNbaV1dID0gdmFsdWVzW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKGRlZmF1bHRzKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0QXJnKG9wdGlvbnMsIGRlZmF1bHRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBUWVBFIENIRUNLSU5HXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICB0ZXN0IGlmIHRoZSBhcmcgaXMgdW5kZWZpbmVkXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgdW5kZWZpbmVkXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuaXNVbmRlZiA9IGlzVW5kZWY7XG5cdCAgICAvKipcblx0XHQgKiAgdGVzdCBpZiB0aGUgYXJnIGlzIGEgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIGZ1bmN0aW9uXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIuXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBudW1iZXJcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYW4gb2JqZWN0IGxpdGVyYWwgKGkuZS4gYHt9YCk7XG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYW4gb2JqZWN0IGxpdGVyYWwuXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5pc09iamVjdCA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIGFyZy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBhIGJvb2xlYW4uXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBib29sZWFuXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgYW4gQXJyYXlcblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZy5cblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIHN0cmluZ1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuaXNTdHJpbmcgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBbiBlbXB0eSBmdW5jdGlvbi5cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5ub09wID0gZnVuY3Rpb24gKCkge1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYWtlIHRoZSBwcm9wZXJ0eSBub3Qgd3JpdGFibGUuIEludGVybmFsIHVzZSBvbmx5LiBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7c3RyaW5nfSAgcHJvcGVydHkgIHRoZSBwcm9wZXJ0eSB0byBtYWtlIG5vdCB3cml0YWJsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuX3JlYWRPbmx5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHkpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRPbmx5KHByb3BlcnR5W2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwge1xuXHQgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1ha2UgYW4gYXR0cmlidXRlIHdyaXRlYWJsZS4gSW50ZXJhbCB1c2Ugb25seS4gXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBwYXJhbSAge3N0cmluZ30gIHByb3BlcnR5ICB0aGUgcHJvcGVydHkgdG8gbWFrZSB3cml0YWJsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuX3dyaXRhYmxlID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHkpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRhYmxlKHByb3BlcnR5W2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwgeyB3cml0YWJsZTogdHJ1ZSB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUG9zc2libGUgcGxheSBzdGF0ZXMuIFxuXHRcdCAqIEBlbnVtIHtzdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLlN0YXRlID0ge1xuXHQgICAgICAgIFN0YXJ0ZWQ6ICdzdGFydGVkJyxcblx0ICAgICAgICBTdG9wcGVkOiAnc3RvcHBlZCcsXG5cdCAgICAgICAgUGF1c2VkOiAncGF1c2VkJ1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gR0FJTiBDT05WRVJTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgRXF1YWwgcG93ZXIgZ2FpbiBzY2FsZS4gR29vZCBmb3IgY3Jvc3MtZmFkaW5nLlxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gcGVyY2VudCAoMC0xKVxuXHRcdCAqICBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgb3V0cHV0IGdhaW4gKDAtMSlcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmVxdWFsUG93ZXJTY2FsZSA9IGZ1bmN0aW9uIChwZXJjZW50KSB7XG5cdCAgICAgICAgdmFyIHBpRmFjdG9yID0gMC41ICogTWF0aC5QSTtcblx0ICAgICAgICByZXR1cm4gTWF0aC5zaW4ocGVyY2VudCAqIHBpRmFjdG9yKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBkZWNpYmVscyBpbnRvIGdhaW4uXG5cdFx0ICogIEBwYXJhbSAge0RlY2liZWxzfSBkYlxuXHRcdCAqICBAcmV0dXJuIHtOdW1iZXJ9ICAgXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5kYlRvR2FpbiA9IGZ1bmN0aW9uIChkYikge1xuXHQgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCBkYiAvIDYpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGdhaW4gdG8gZGVjaWJlbHMuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gZ2FpbiAoMC0xKVxuXHRcdCAqICBAcmV0dXJuIHtEZWNpYmVsc30gICBcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmdhaW5Ub0RiID0gZnVuY3Rpb24gKGdhaW4pIHtcblx0ICAgICAgICByZXR1cm4gMjAgKiAoTWF0aC5sb2coZ2FpbikgLyBNYXRoLkxOMTApO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGFuIGludGVydmFsIChpbiBzZW1pdG9uZXMpIHRvIGEgZnJlcXVlbmN5IHJhdGlvLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbH0gaW50ZXJ2YWwgdGhlIG51bWJlciBvZiBzZW1pdG9uZXMgYWJvdmUgdGhlIGJhc2Ugbm90ZVxuXHRcdCAqICBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgIHRoZSBmcmVxdWVuY3kgcmF0aW9cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB0b25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbygwKTsgLy8gMVxuXHRcdCAqIHRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKDEyKTsgLy8gMlxuXHRcdCAqIHRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKC0xMik7IC8vIDAuNVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIGludGVydmFsIC8gMTIpO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRJTUlOR1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIEF1ZGlvQ29udGV4dCBjbG9jay5cblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfSB0aGUgY3VycmVudFRpbWUgZnJvbSB0aGUgQXVkaW9Db250ZXh0XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIEF1ZGlvQ29udGV4dCBjbG9jay5cblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfSB0aGUgY3VycmVudFRpbWUgZnJvbSB0aGUgQXVkaW9Db250ZXh0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUubm93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBUb25lLmNvbnRleHQuY3VycmVudFRpbWU7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0SU5IRVJJVEFOQ0Vcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIGhhdmUgYSBjaGlsZCBpbmhlcml0IGFsbCBvZiBUb25lJ3MgKG9yIGEgcGFyZW50J3MpIHByb3RvdHlwZVxuXHRcdCAqICB0byBpbmhlcml0IHRoZSBwYXJlbnQncyBwcm9wZXJ0aWVzLCBtYWtlIHN1cmUgdG8gY2FsbCBcblx0XHQgKiAgUGFyZW50LmNhbGwodGhpcykgaW4gdGhlIGNoaWxkJ3MgY29uc3RydWN0b3Jcblx0XHQgKlxuXHRcdCAqICBiYXNlZCBvbiBjbG9zdXJlIGxpYnJhcnkncyBpbmhlcml0IGZ1bmN0aW9uXG5cdFx0ICpcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcGFyYW0gIHtmdW5jdGlvbn0gXHRjaGlsZCAgXG5cdFx0ICogIEBwYXJhbSAge2Z1bmN0aW9uPX0gcGFyZW50IChvcHRpb25hbCkgcGFyZW50IHRvIGluaGVyaXQgZnJvbVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBubyBwYXJlbnQgaXMgc3VwcGxpZWQsIHRoZSBjaGlsZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGluaGVyaXQgZnJvbSBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cdCAgICAgICAgaWYgKGlzVW5kZWYocGFyZW50KSkge1xuXHQgICAgICAgICAgICBwYXJlbnQgPSBUb25lO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBUZW1wQ29uc3RydWN0b3IoKSB7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRlbXBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuXHQgICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBUZW1wQ29uc3RydWN0b3IoKTtcblx0ICAgICAgICAvKiogQG92ZXJyaWRlICovXG5cdCAgICAgICAgY2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG5cdCAgICAgICAgY2hpbGQuX3N1cGVyID0gcGFyZW50O1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdENPTlRFWFRcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIGFycmF5IG9mIGNhbGxiYWNrcyB0byBiZSBpbnZva2VkIHdoZW4gYSBuZXcgY29udGV4dCBpcyBhZGRlZFxuXHRcdCAqICBAcHJpdmF0ZSBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIHZhciBuZXdDb250ZXh0Q2FsbGJhY2tzID0gW107XG5cdCAgICAvKipcblx0XHQgKiAgaW52b2tlIHRoaXMgY2FsbGJhY2sgd2hlbiBhIG5ldyBjb250ZXh0IGlzIGFkZGVkXG5cdFx0ICogIHdpbGwgYmUgaW52b2tlZCBpbml0aWFsbHkgd2l0aCB0aGUgZmlyc3QgY29udGV4dFxuXHRcdCAqICBAcHJpdmF0ZSBcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9uKEF1ZGlvQ29udGV4dCl9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgYXVkaW8gY29udGV4dFxuXHRcdCAqL1xuXHQgICAgVG9uZS5faW5pdEF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIC8vaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBleGlzdGluZyBBdWRpb0NvbnRleHRcblx0ICAgICAgICBjYWxsYmFjayhUb25lLmNvbnRleHQpO1xuXHQgICAgICAgIC8vYWRkIGl0IHRvIHRoZSBhcnJheVxuXHQgICAgICAgIG5ld0NvbnRleHRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRvbmUgYXV0b21hdGljYWxseSBjcmVhdGVzIGEgY29udGV4dCBvbiBpbml0LCBidXQgaWYgeW91IGFyZSB3b3JraW5nXG5cdFx0ICogIHdpdGggb3RoZXIgbGlicmFyaWVzIHdoaWNoIGFsc28gY3JlYXRlIGFuIEF1ZGlvQ29udGV4dCwgaXQgY2FuIGJlXG5cdFx0ICogIHVzZWZ1bCB0byBzZXQgeW91ciBvd24uIElmIHlvdSBhcmUgZ29pbmcgdG8gc2V0IHlvdXIgb3duIGNvbnRleHQsIFxuXHRcdCAqICBiZSBzdXJlIHRvIGRvIGl0IGF0IHRoZSBzdGFydCBvZiB5b3VyIGNvZGUsIGJlZm9yZSBjcmVhdGluZyBhbnkgb2JqZWN0cy5cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY3R4IFRoZSBuZXcgYXVkaW8gY29udGV4dCB0byBzZXRcblx0XHQgKi9cblx0ICAgIFRvbmUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjdHgpIHtcblx0ICAgICAgICAvL3NldCB0aGUgcHJvdG90eXBlc1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmNvbnRleHQgPSBjdHg7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gY3R4O1xuXHQgICAgICAgIC8vaW52b2tlIGFsbCB0aGUgY2FsbGJhY2tzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDb250ZXh0Q2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIG5ld0NvbnRleHRDYWxsYmFja3NbaV0oY3R4KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy9zZXR1cCB0aGUgY29udGV4dFxuXHQgICAgVG9uZS5faW5pdEF1ZGlvQ29udGV4dChmdW5jdGlvbiAoYXVkaW9Db250ZXh0KSB7XG5cdCAgICAgICAgLy9zZXQgdGhlIGJsb2NrVGltZVxuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmJsb2NrVGltZSA9IDEyOCAvIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLnNhbXBsZVRpbWUgPSAxIC8gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAgICAgX3NpbGVudE5vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIF9zaWxlbnROb2RlLmdhaW4udmFsdWUgPSAwO1xuXHQgICAgICAgIF9zaWxlbnROb2RlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcblx0ICAgIH0pO1xuXHQgICAgVG9uZS52ZXJzaW9uID0gJ3I5Jztcblx0ICAgIC8vIGFsbG93IG9wdGlvbmFsIHNpbGVuY2luZyBvZiB0aGlzIGxvZ1xuXHQgICAgaWYgKCF3aW5kb3cuVE9ORV9TSUxFTkNFX1ZFUlNJT05fTE9HR0lORykge1xuXHQgICAgICAgIGNvbnNvbGUubG9nKCclYyAqIFRvbmUuanMgJyArIFRvbmUudmVyc2lvbiArICcgKiAnLCAnYmFja2dyb3VuZDogIzAwMDsgY29sb3I6ICNmZmYnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBUb25lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEJhc2UgY2xhc3MgZm9yIGFsbCBTaWduYWxzLiBVc2VkIEludGVybmFsbHkuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuU2lnbmFsQmFzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFdoZW4gc2lnbmFscyBjb25uZWN0IHRvIG90aGVyIHNpZ25hbHMgb3IgQXVkaW9QYXJhbXMsIFxuXHRcdCAqICB0aGV5IHRha2Ugb3ZlciB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoYXQgc2lnbmFsIG9yIEF1ZGlvUGFyYW0uIFxuXHRcdCAqICBGb3IgYWxsIG90aGVyIG5vZGVzLCB0aGUgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYSBkZWZhdWx0IDxjb2RlPmNvbm5lY3Q8L2NvZGU+LiBcblx0XHQgKlxuXHRcdCAqICBAb3ZlcnJpZGVcblx0XHQgKiAgQHBhcmFtIHtBdWRpb1BhcmFtfEF1ZGlvTm9kZXxUb25lLlNpZ25hbHxUb25lfSBub2RlIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE51bWJlcj0wXSBUaGUgb3V0cHV0IG51bWJlciB0byBjb25uZWN0IGZyb20uXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW1iZXI9MF0gVGhlIGlucHV0IG51bWJlciB0byBjb25uZWN0IHRvLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TaWduYWxCYXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAobm9kZSwgb3V0cHV0TnVtYmVyLCBpbnB1dE51bWJlcikge1xuXHQgICAgICAgIC8vemVybyBpdCBvdXQgc28gdGhhdCB0aGUgc2lnbmFsIGNhbiBoYXZlIGZ1bGwgY29udHJvbFxuXHQgICAgICAgIGlmIChUb25lLlNpZ25hbCAmJiBUb25lLlNpZ25hbCA9PT0gbm9kZS5jb25zdHJ1Y3RvciB8fCBUb25lLlBhcmFtICYmIFRvbmUuUGFyYW0gPT09IG5vZGUuY29uc3RydWN0b3IgfHwgVG9uZS5UaW1lbGluZVNpZ25hbCAmJiBUb25lLlRpbWVsaW5lU2lnbmFsID09PSBub2RlLmNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIC8vY2FuY2VsIGNoYW5nZXNcblx0ICAgICAgICAgICAgbm9kZS5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHQgICAgICAgICAgICAvL3Jlc2V0IHRoZSB2YWx1ZVxuXHQgICAgICAgICAgICBub2RlLl9wYXJhbS52YWx1ZSA9IDA7XG5cdCAgICAgICAgICAgIC8vbWFyayB0aGUgdmFsdWUgYXMgb3ZlcnJpZGRlblxuXHQgICAgICAgICAgICBub2RlLm92ZXJyaWRkZW4gPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0pIHtcblx0ICAgICAgICAgICAgbm9kZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XG5cdCAgICAgICAgICAgIG5vZGUudmFsdWUgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcywgbm9kZSwgb3V0cHV0TnVtYmVyLCBpbnB1dE51bWJlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2lnbmFsQmFzZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFdyYXBzIHRoZSBuYXRpdmUgV2ViIEF1ZGlvIEFQSSBcblx0XHQgKiAgICAgICAgIFtXYXZlU2hhcGVyTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtd2F2ZXNoYXBlcm5vZGUtaW50ZXJmYWNlKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbnxBcnJheXxOdW1iZXJ9IG1hcHBpbmcgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZGVmaW5lIHRoZSB2YWx1ZXMuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG1hcHBpbmcgZnVuY3Rpb24gc2hvdWxkIHRha2UgdHdvIGFyZ3VtZW50czogXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlyc3QgaXMgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGFycmF5IHBvc2l0aW9uLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgdGhhdCBhcnJheSB3aWxsIGJlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQgYXMgdGhlIHdhdmUgc2hhcGluZyBmdW5jdGlvbi4gVGhlIGlucHV0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgaXMgYW4gQXVkaW9SYW5nZSBbLTEsIDFdIHZhbHVlIGFuZCB0aGUgb3V0cHV0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgY2FuIHRha2Ugb24gYW55IG51bWVyaWNhbCB2YWx1ZXMuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBbYnVmZmVyTGVuPTEwMjRdIFRoZSBsZW5ndGggb2YgdGhlIFdhdmVTaGFwZXJOb2RlIGJ1ZmZlci5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgdGltZXNUd28gPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uKHZhbCl7XG5cdFx0ICogXHRyZXR1cm4gdmFsICogMjtcblx0XHQgKiB9LCAyMDQ4KTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2Egd2F2ZXNoYXBlciBjYW4gYWxzbyBiZSBjb25zdHJ1Y3RlZCB3aXRoIGFuIGFycmF5IG9mIHZhbHVlc1xuXHRcdCAqIHZhciBpbnZlcnQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKFsxLCAtMV0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5XYXZlU2hhcGVyID0gZnVuY3Rpb24gKG1hcHBpbmcsIGJ1ZmZlckxlbikge1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB3YXZlc2hhcGVyXG5cdFx0XHQgKiAgQHR5cGUge1dhdmVTaGFwZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlV2F2ZVNoYXBlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB3YXZlc2hhcGVycyBjdXJ2ZVxuXHRcdFx0ICogIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2N1cnZlID0gbnVsbDtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwaW5nKSkge1xuXHQgICAgICAgICAgICB0aGlzLmN1cnZlID0gbWFwcGluZztcblx0ICAgICAgICB9IGVsc2UgaWYgKGlzRmluaXRlKG1hcHBpbmcpIHx8IHRoaXMuaXNVbmRlZihtYXBwaW5nKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kZWZhdWx0QXJnKG1hcHBpbmcsIDEwMjQpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNGdW5jdGlvbihtYXBwaW5nKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kZWZhdWx0QXJnKGJ1ZmZlckxlbiwgMTAyNCkpO1xuXHQgICAgICAgICAgICB0aGlzLnNldE1hcChtYXBwaW5nKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5XYXZlU2hhcGVyLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFVzZXMgYSBtYXBwaW5nIGZ1bmN0aW9uIHRvIHNldCB0aGUgdmFsdWUgb2YgdGhlIGN1cnZlLiBcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gbWFwcGluZyBUaGUgZnVuY3Rpb24gdXNlZCB0byBkZWZpbmUgdGhlIHZhbHVlcy4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG1hcHBpbmcgZnVuY3Rpb24gdGFrZSB0d28gYXJndW1lbnRzOiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlyc3QgaXMgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGdvZXMgZnJvbSAtMSB0byAxIG92ZXIgdGhlIG51bWJlciBvZiBlbGVtZW50c1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBjdXJ2ZSBhcnJheS4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgYXJyYXkgcG9zaXRpb24uIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5XYXZlU2hhcGVyfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9tYXAgdGhlIGlucHV0IHNpZ25hbCBmcm9tIFstMSwgMV0gdG8gWzAsIDEwXVxuXHRcdCAqIHNoYXBlci5zZXRNYXAoZnVuY3Rpb24odmFsLCBpbmRleCl7XG5cdFx0ICogXHRyZXR1cm4gKHZhbCArIDEpICogNTtcblx0XHQgKiB9KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5XYXZlU2hhcGVyLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiAobWFwcGluZykge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9jdXJ2ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGkgLyAobGVuIC0gMSkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgdGhpcy5fY3VydmVbaV0gPSBtYXBwaW5nKG5vcm1hbGl6ZWQsIGkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zaGFwZXIuY3VydmUgPSB0aGlzLl9jdXJ2ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYXJyYXkgdG8gc2V0IGFzIHRoZSB3YXZlc2hhcGVyIGN1cnZlLiBGb3IgbGluZWFyIGN1cnZlc1xuXHRcdCAqIGFycmF5IGxlbmd0aCBkb2VzIG5vdCBtYWtlIG11Y2ggZGlmZmVyZW5jZSwgYnV0IGZvciBjb21wbGV4IGN1cnZlc1xuXHRcdCAqIGxvbmdlciBhcnJheXMgd2lsbCBwcm92aWRlIHNtb290aGVyIGludGVycG9sYXRpb24uIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLldhdmVTaGFwZXIjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIGN1cnZlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5XYXZlU2hhcGVyLnByb3RvdHlwZSwgJ2N1cnZlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVyLmN1cnZlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWFwcGluZykge1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkobWFwcGluZyk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5jdXJ2ZSA9IHRoaXMuX2N1cnZlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogU3BlY2lmaWVzIHdoYXQgdHlwZSBvZiBvdmVyc2FtcGxpbmcgKGlmIGFueSkgc2hvdWxkIGJlIHVzZWQgd2hlbiBcblx0XHQgKiBhcHBseWluZyB0aGUgc2hhcGluZyBjdXJ2ZS4gQ2FuIGVpdGhlciBiZSBcIm5vbmVcIiwgXCIyeFwiIG9yIFwiNHhcIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuV2F2ZVNoYXBlciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIG92ZXJzYW1wbGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLCAnb3ZlcnNhbXBsZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob3ZlcnNhbXBsaW5nKSB7XG5cdCAgICAgICAgICAgIGlmIChbXG5cdCAgICAgICAgICAgICAgICAgICAgJ25vbmUnLFxuXHQgICAgICAgICAgICAgICAgICAgICcyeCcsXG5cdCAgICAgICAgICAgICAgICAgICAgJzR4J1xuXHQgICAgICAgICAgICAgICAgXS5pbmRleE9mKG92ZXJzYW1wbGluZykgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZSA9IG92ZXJzYW1wbGluZztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUb25lLldhdmVTaGFwZXI6IG92ZXJzYW1wbGluZyBtdXN0IGJlIGVpdGhlciBcXCdub25lXFwnLCBcXCcyeFxcJywgb3IgXFwnNHhcXCcnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5XYXZlU2hhcGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuV2F2ZVNoYXBlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlRpbWVCYXNlIGlzIGEgZmxleGlibGUgZW5jb2Rpbmcgb2YgdGltZVxuXHRcdCAqICAgICAgICAgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZCB0byBhbmQgZnJvbSBhIHN0cmluZy5cblx0XHQgKiAgICAgICAgIFBhcnNpbmcgY29kZSBtb2RpZmllZCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdGFwZGlnaXQvXG5cdFx0ICogICAgICAgICBDb3B5cmlnaHQgMjAxMSAyMDEyIEFyaXlhIEhpZGF5YXQsIE5ldyBCU0QgTGljZW5zZVxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZSBhcyBhIG51bWJlciBvciBzdHJpbmdcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBVbml0IHZhbHVlc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoNCwgXCJuXCIpXG5cdFx0ICogVG9uZS5UaW1lQmFzZSgyLCBcInRcIilcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMnRcIikuYWRkKFwiMW1cIilcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMnQgKyAxbVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIC8vYWxsb3dzIGl0IHRvIGJlIGNvbnN0cnVjdGVkIHdpdGggb3Igd2l0aG91dCAnbmV3J1xuXHQgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkge1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEFueSBleHByZXNzaW9ucyBwYXJzZWQgZnJvbSB0aGUgVGltZVxuXHRcdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9leHByID0gdGhpcy5fbm9PcDtcblx0ICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29weSh2YWwpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzVW5kZWYodW5pdHMpIHx8IHRoaXMuaXNOdW1iZXIodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgLy9kZWZhdWx0IHVuaXRzXG5cdCAgICAgICAgICAgICAgICB1bml0cyA9IHRoaXMuZGVmYXVsdEFyZyh1bml0cywgdGhpcy5fZGVmYXVsdFVuaXRzKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnNbdW5pdHNdLm1ldGhvZDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V4cHIgPSBtZXRob2QuYmluZCh0aGlzLCB2YWwpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdHJpbmcodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXQodmFsKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVW5kZWYodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgLy9kZWZhdWx0IGV4cHJlc3Npb25cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V4cHIgPSB0aGlzLl9kZWZhdWx0RXhwcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRpbWVCYXNlKHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpbWVCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXBhbGNlIHRoZSBjdXJyZW50IHRpbWUgdmFsdWUgd2l0aCB0aGUgdmFsdWVcblx0XHQgKiAgZ2l2ZW4gYnkgdGhlIGV4cHJlc3Npb24gc3RyaW5nLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBleHByU3RyaW5nXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuVGltZUJhc2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChleHByU3RyaW5nKSB7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IHRoaXMuX3BhcnNlRXhwclN0cmluZyhleHByU3RyaW5nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIGEgY2xvbmUgb2YgdGhlIFRpbWVCYXNlIG9iamVjdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9IFRoZSBuZXcgY2xvbmVkIFRvbmUuVGltZUJhc2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgaW5zdGFuY2UuY29weSh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvcGllcyB0aGUgdmFsdWUgb2YgdGltZSB0byB0aGlzIFRpbWVcblx0XHQgKiAgQHBhcmFtIHtUb25lLlRpbWVCYXNlfSB0aW1lXG5cdFx0ICogIEByZXR1cm4gIHtUaW1lQmFzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciB2YWwgPSB0aW1lLl9leHByKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHZhbCk7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0QUJTVFJBQ1QgU1lOVEFYIFRSRUUgUEFSU0VSXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBBbGwgdGhlIHByaW1hcnkgZXhwcmVzc2lvbnMuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucyA9IHtcblx0ICAgICAgICAnbic6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKW4vaSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlYXRzVG9Vbml0cyh0aGlzLl90aW1lU2lnbmF0dXJlKCkpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKDQgLyB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICd0Jzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCspdC9pLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKDggLyAocGFyc2VJbnQodmFsdWUpICogMykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnbSc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKW0vaSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VJbnQodmFsdWUpICogdGhpcy5fdGltZVNpZ25hdHVyZSgpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2knOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKylpL2ksXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja3NUb1VuaXRzKHBhcnNlSW50KHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdoeic6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/KWh6L2ksXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJlcXVlbmN5VG9Vbml0cyhwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICd0cic6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/KTooXFxkKyg/OlxcLlxcZCspPyk6PyhcXGQrKD86XFwuXFxkKyk/KT8vLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChtLCBxLCBzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuXHQgICAgICAgICAgICAgICAgaWYgKG0gJiYgbSAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX3RpbWVTaWduYXR1cmUoKSAqIHBhcnNlRmxvYXQobSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHEgJiYgcSAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHMgJiYgcyAhPT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocykgLyA0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3MnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspP3MpLyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWNvbmRzVG9Vbml0cyhwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdzYW1wbGVzJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCspc2FtcGxlcy8sXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpIC8gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdkZWZhdWx0Jzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT8pLyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnNbdGhpcy5fZGVmYXVsdFVuaXRzXS5tZXRob2QuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFsbCB0aGUgYmluYXJ5IGV4cHJlc3Npb25zIHRoYXQgVGltZUJhc2UgY2FuIGFjY2VwdC5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fYmluYXJ5RXhwcmVzc2lvbnMgPSB7XG5cdCAgICAgICAgJysnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXCsvLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAyLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpICsgcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJy0nOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXC0vLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAyLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpIC0gcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJyonOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXCovLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpICogcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJy8nOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXC8vLFxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCwgcmgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaCgpIC8gcmgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWxsIHRoZSB1bmFyeSBleHByZXNzaW9ucy5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyA9IHtcblx0ICAgICAgICAnbmVnJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eXFwtLyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobGgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtbGgoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3ludGFjdGljIGdsdWUgd2hpY2ggaG9sZHMgZXhwcmVzc2lvbnMgdG9nZXRoZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fc3ludGF4R2x1ZSA9IHtcblx0ICAgICAgICAnKCc6IHsgcmVnZXhwOiAvXlxcKC8gfSxcblx0ICAgICAgICAnKSc6IHsgcmVnZXhwOiAvXlxcKS8gfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0b2tlbml6ZSB0aGUgZXhwcmVzc2lvbiBiYXNlZCBvbiB0aGUgRXhwcmVzc2lvbnMgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICAgICAgcmV0dXJucyB0d28gbWV0aG9kcyBvbiB0aGUgdG9rZW5pemVkIGxpc3QsIG5leHQgYW5kIHBlZWtcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl90b2tlbml6ZSA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG5cdCAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuXHQgICAgICAgIHdoaWxlIChleHByLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIudHJpbSgpO1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBnZXROZXh0VG9rZW4oZXhwciwgdGhpcyk7XG5cdCAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIuc3Vic3RyKHRva2VuLnZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldE5leHRUb2tlbihleHByLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtcblx0ICAgICAgICAgICAgICAgICdfYmluYXJ5RXhwcmVzc2lvbnMnLFxuXHQgICAgICAgICAgICAgICAgJ191bmFyeUV4cHJlc3Npb25zJyxcblx0ICAgICAgICAgICAgICAgICdfcHJpbWFyeUV4cHJlc3Npb25zJyxcblx0ICAgICAgICAgICAgICAgICdfc3ludGF4R2x1ZSdcblx0ICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gY29udGV4dFtleHByZXNzaW9uc1tpXV07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvcE5hbWUgaW4gZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBncm91cFtvcE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZWcgPSBvcC5yZWdleHA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZXhwci5tYXRjaChyZWcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcC5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBvcC5wcmVjZWRlbmNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwOiBvcC5yZWdleHAsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hbMF1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLlRpbWVCYXNlOiBVbmV4cGVjdGVkIHRva2VuICcgKyBleHByKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1srK3Bvc2l0aW9uXTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcGVlazogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1twb3NpdGlvbiArIDFdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2l2ZW4gYSB0b2tlbiwgZmluZCB0aGUgdmFsdWUgd2l0aGluIHRoZSBncm91cE5hbWVcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IHRva2VuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWVcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHByZWNlZGVuY2Vcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9tYXRjaEdyb3VwID0gZnVuY3Rpb24gKHRva2VuLCBncm91cCwgcHJlYykge1xuXHQgICAgICAgIHZhciByZXQgPSBmYWxzZTtcblx0ICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZih0b2tlbikpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgb3BOYW1lIGluIGdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3AgPSBncm91cFtvcE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9wLnJlZ2V4cC50ZXN0KHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKHByZWMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5wcmVjZWRlbmNlID09PSBwcmVjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1hdGNoIGEgYmluYXJ5IGV4cHJlc3Npb24gZ2l2ZW4gdGhlIHRva2VuIGFuZCB0aGUgcHJlY2VkZW5jZVxuXHRcdCAqICBAcGFyYW0ge0xleGVyfSBsZXhlclxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcHJlY2VkZW5jZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlQmluYXJ5ID0gZnVuY3Rpb24gKGxleGVyLCBwcmVjZWRlbmNlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNVbmRlZihwcmVjZWRlbmNlKSkge1xuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV4cHI7XG5cdCAgICAgICAgaWYgKHByZWNlZGVuY2UgPCAwKSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9wYXJzZVVuYXJ5KGxleGVyKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5fcGFyc2VCaW5hcnkobGV4ZXIsIHByZWNlZGVuY2UgLSAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgIHdoaWxlICh0b2tlbiAmJiB0aGlzLl9tYXRjaEdyb3VwKHRva2VuLCB0aGlzLl9iaW5hcnlFeHByZXNzaW9ucywgcHJlY2VkZW5jZSkpIHtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0b2tlbi5tZXRob2QuYmluZCh0aGlzLCBleHByLCB0aGlzLl9wYXJzZUJpbmFyeShsZXhlciwgcHJlY2VkZW5jZSAtIDEpKTtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYXRjaCBhIHVuYXJ5IGV4cHJlc3Npb24uXG5cdFx0ICogIEBwYXJhbSB7TGV4ZXJ9IGxleGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcGFyc2VVbmFyeSA9IGZ1bmN0aW9uIChsZXhlcikge1xuXHQgICAgICAgIHZhciB0b2tlbiwgZXhwcjtcblx0ICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICB2YXIgb3AgPSB0aGlzLl9tYXRjaEdyb3VwKHRva2VuLCB0aGlzLl91bmFyeUV4cHJlc3Npb25zKTtcblx0ICAgICAgICBpZiAob3ApIHtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9wYXJzZVVuYXJ5KGxleGVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG9wLm1ldGhvZC5iaW5kKHRoaXMsIGV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VQcmltYXJ5KGxleGVyKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTWF0Y2ggYSBwcmltYXJ5IGV4cHJlc3Npb24gKGEgdmFsdWUpLlxuXHRcdCAqICBAcGFyYW0ge0xleGVyfSBsZXhlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uIChsZXhlcikge1xuXHQgICAgICAgIHZhciB0b2tlbiwgZXhwcjtcblx0ICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICBpZiAodGhpcy5pc1VuZGVmKHRva2VuKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuVGltZUJhc2U6IFVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb24nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuX21hdGNoR3JvdXAodG9rZW4sIHRoaXMuX3ByaW1hcnlFeHByZXNzaW9ucykpIHtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IHRva2VuLnZhbHVlLm1hdGNoKHRva2VuLnJlZ2V4cCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0b2tlbi5tZXRob2QuYmluZCh0aGlzLCBtYXRjaGluZ1sxXSwgbWF0Y2hpbmdbMl0sIG1hdGNoaW5nWzNdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnZhbHVlID09PSAnKCcpIHtcblx0ICAgICAgICAgICAgbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5fcGFyc2VCaW5hcnkobGV4ZXIpO1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgaWYgKCEodG9rZW4gJiYgdG9rZW4udmFsdWUgPT09ICcpJykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRXhwZWN0ZWQgKScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuVGltZUJhc2U6IENhbm5vdCBwcm9jZXNzIHRva2VuICcgKyB0b2tlbi52YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlY3Vyc2l2ZWx5IHBhcnNlIHRoZSBzdHJpbmcgZXhwcmVzc2lvbiBpbnRvIGEgc3ludGF4IHRyZWUuXG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgXG5cdFx0ICogIEByZXR1cm4gIHtGdW5jdGlvbn0gdGhlIGJvdW5kIG1ldGhvZCB0byBiZSBldmFsdWF0ZWQgbGF0ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZUV4cHJTdHJpbmcgPSBmdW5jdGlvbiAoZXhwclN0cmluZykge1xuXHQgICAgICAgIGlmICghdGhpcy5pc1N0cmluZyhleHByU3RyaW5nKSkge1xuXHQgICAgICAgICAgICBleHByU3RyaW5nID0gZXhwclN0cmluZy50b1N0cmluZygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGV4ZXIgPSB0aGlzLl90b2tlbml6ZShleHByU3RyaW5nKTtcblx0ICAgICAgICB2YXIgdHJlZSA9IHRoaXMuX3BhcnNlQmluYXJ5KGxleGVyKTtcblx0ICAgICAgICByZXR1cm4gdHJlZTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRERUZBVUxUU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGluaXRpYWwgZXhwcmVzc2lvbiB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIGluaXRpYWwgdmFsdWUgMFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX25vT3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IGV4cHJlc3Npb24gdmFsdWUgaWYgbm8gYXJndW1lbnRzIGFyZSBnaXZlblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2RlZmF1bHRFeHByID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ub09wO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB1bml0cyBpZiBub25lIGFyZSBnaXZlbi5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9kZWZhdWx0VW5pdHMgPSAncyc7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRVTklUIENPTlZFUlNJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGZyZXF1ZW5jeSBpbiB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2ZyZXF1ZW5jeVRvVW5pdHMgPSBmdW5jdGlvbiAoZnJlcSkge1xuXHQgICAgICAgIHJldHVybiAxIC8gZnJlcTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgYmVhdHMgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGJlYXRzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fYmVhdHNUb1VuaXRzID0gZnVuY3Rpb24gKGJlYXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIDYwIC8gVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlICogYmVhdHM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc2Vjb25kIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7U2Vjb25kc30gc2Vjb25kc1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3NlY29uZHNUb1VuaXRzID0gZnVuY3Rpb24gKHNlY29uZHMpIHtcblx0ICAgICAgICByZXR1cm4gc2Vjb25kcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSB0aWNrIGluIHRoZSBjdXJyZW50IHRpbWUgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtUaWNrc30gdGlja3Ncblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl90aWNrc1RvVW5pdHMgPSBmdW5jdGlvbiAodGlja3MpIHtcblx0ICAgICAgICByZXR1cm4gdGlja3MgKiAodGhpcy5fYmVhdHNUb1VuaXRzKDEpIC8gVG9uZS5UcmFuc3BvcnQuUFBRKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIHNpZ25hdHVyZS5cblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl90aW1lU2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEVYUFJFU1NJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBQdXNoIGFuIGV4cHJlc3Npb24gb250byB0aGUgZXhwcmVzc2lvbiBsaXN0XG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWxcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgdHlwZVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICB1bml0c1xuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcHVzaEV4cHIgPSBmdW5jdGlvbiAodmFsLCBuYW1lLCB1bml0cykge1xuXHQgICAgICAgIC8vY3JlYXRlIHRoZSBleHByZXNzaW9uXG5cdCAgICAgICAgaWYgKCEodmFsIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkpIHtcblx0ICAgICAgICAgICAgdmFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IodmFsLCB1bml0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2V4cHIgPSB0aGlzLl9iaW5hcnlFeHByZXNzaW9uc1tuYW1lXS5tZXRob2QuYmluZCh0aGlzLCB0aGlzLl9leHByLCB2YWwuX2V4cHIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgdG8gdGhlIGN1cnJlbnQgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWwgICAgVGhlIHZhbHVlIHRvIGFkZFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIE9wdGlvbmFsIHVuaXRzIHRvIHVzZSB3aXRoIHRoZSB2YWx1ZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJtXCIpLmFkZChcIjFtXCIpOyAvL1wiM21cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEV4cHIodmFsLCAnKycsIHVuaXRzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3VidHJhY3QgdGhlIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdmFsdWUgdG8gc3VidHJhY3Rcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBPcHRpb25hbCB1bml0cyB0byB1c2Ugd2l0aCB0aGUgdmFsdWUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVCYXNlfSAgdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoXCIybVwiKS5zdWIoXCIxbVwiKTsgLy9cIjFtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFeHByKHZhbCwgJy0nLCB1bml0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE11bHRpcGx5IHRoZSBjdXJyZW50IHZhbHVlIGJ5IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB2YWx1ZSB0byBtdWx0aXBseVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIE9wdGlvbmFsIHVuaXRzIHRvIHVzZSB3aXRoIHRoZSB2YWx1ZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJtXCIpLm11bHQoXCIyXCIpOyAvL1wiNG1cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFeHByKHZhbCwgJyonLCB1bml0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIERpdmlkZSB0aGUgY3VycmVudCB2YWx1ZSBieSB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdmFsdWUgdG8gZGl2aWRlIGJ5XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgT3B0aW9uYWwgdW5pdHMgdG8gdXNlIHdpdGggdGhlIHZhbHVlLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMm1cIikuZGl2KDIpOyAvL1wiMW1cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEV4cHIodmFsLCAnLycsIHVuaXRzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRXZhbHVhdGUgdGhlIHRpbWUgdmFsdWUuIFJldHVybnMgdGhlIHRpbWVcblx0XHQgKiAgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge1NlY29uZHN9IFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXhwcigpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlRpbWVCYXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2V4cHIgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVCYXNlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVGltZSBpcyBhIHByaW1pdGl2ZSB0eXBlIGZvciBlbmNvZGluZyBUaW1lIHZhbHVlcy4gXG5cdFx0ICogICAgICAgICBFdmVudHVhbGx5IGFsbCB0aW1lIHZhbHVlcyBhcmUgZXZhbHVhdGVkIHRvIHNlY29uZHNcblx0XHQgKiAgICAgICAgIHVzaW5nIHRoZSBgZXZhbGAgbWV0aG9kLiBUb25lLlRpbWUgY2FuIGJlIGNvbnN0cnVjdGVkXG5cdFx0ICogICAgICAgICB3aXRoIG9yIHdpdGhvdXQgdGhlIGBuZXdgIGtleXdvcmQuIFRvbmUuVGltZSBjYW4gYmUgcGFzc2VkXG5cdFx0ICogICAgICAgICBpbnRvIHRoZSBwYXJhbWV0ZXIgb2YgYW55IG1ldGhvZCB3aGljaCB0YWtlcyB0aW1lIGFzIGFuIGFyZ3VtZW50LiBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVCYXNlfVxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgdmFsICAgIFRoZSB0aW1lIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIFRoZSB1bml0cyBvZiB0aGUgdmFsdWUuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHQgPSBUb25lLlRpbWUoXCI0blwiKTsvL2VuY29kZXMgYSBxdWFydGVyIG5vdGVcblx0XHQgKiB0Lm11bHQoNCk7IC8vIG11bHRpcGx5IHRoYXQgdmFsdWUgYnkgNFxuXHRcdCAqIHQudG9Ob3RhdGlvbigpOyAvL3JldHVybnMgXCIxbVwiXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5UaW1lKSB7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgSWYgdGhlIGN1cnJlbnQgY2xvY2sgdGltZSBzaG91bGRcblx0XHRcdFx0ICogIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXRcblx0XHRcdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9wbHVzTm93ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIFRvbmUuVGltZUJhc2UuY2FsbCh0aGlzLCB2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuVGltZSh2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaW1lLCBUb25lLlRpbWVCYXNlKTtcblx0ICAgIC8vY2xvbmUgdGhlIGV4cHJlc3Npb25zIHNvIHRoYXQgXG5cdCAgICAvL3dlIGNhbiBhZGQgbW9yZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMgPSBPYmplY3QuY3JlYXRlKFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zKTtcblx0ICAgIC8qXG5cdFx0ICogIEFkZHMgYW4gYWRkaXRpb25hbCB1bmFyeSBleHByZXNzaW9uXG5cdFx0ICogIHdoaWNoIHF1YW50aXplcyB2YWx1ZXMgdG8gdGhlIG5leHQgc3ViZGl2aXNpb25cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMucXVhbnRpemUgPSB7XG5cdCAgICAgICAgcmVnZXhwOiAvXkAvLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHJoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydC5uZXh0U3ViZGl2aXNpb24ocmgoKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qXG5cdFx0ICogIEFkZHMgYW4gYWRkaXRpb25hbCB1bmFyeSBleHByZXNzaW9uXG5cdFx0ICogIHdoaWNoIGFkZHMgdGhlIGN1cnJlbnQgY2xvY2sgdGltZS5cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMubm93ID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL15cXCsvLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGxoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsdXNOb3cgPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm4gbGgoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFF1YW50aXplIHRoZSB0aW1lIGJ5IHRoZSBnaXZlbiBzdWJkaXZpc2lvbi4gT3B0aW9uYWxseSBhZGQgYVxuXHRcdCAqICBwZXJjZW50YWdlIHdoaWNoIHdpbGwgbW92ZSB0aGUgdGltZSB2YWx1ZSB0b3dhcmRzIHRoZSBpZGVhbFxuXHRcdCAqICBxdWFudGl6ZWQgdmFsdWUgYnkgdGhhdCBwZXJjZW50YWdlLiBcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfFRpbWV9ICB2YWwgICAgVGhlIHN1YmRpdmlzaW9uIHRvIHF1YW50aXplIHRvXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSAgW3BlcmNlbnQ9MV0gIE1vdmUgdGhlIHRpbWUgdmFsdWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG93YXJkcyB0aGUgcXVhbnRpemVkIHZhbHVlIGJ5XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgcGVyY2VudGFnZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZX0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWUoMjEpLnF1YW50aXplKDIpLmV2YWwoKSAvL3JldHVybnMgMjJcblx0XHQgKiBUb25lLlRpbWUoMC42KS5xdWFudGl6ZShcIjRuXCIsIDAuNSkuZXZhbCgpIC8vcmV0dXJucyAwLjU1XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnF1YW50aXplID0gZnVuY3Rpb24gKHN1YmRpdiwgcGVyY2VudCkge1xuXHQgICAgICAgIHBlcmNlbnQgPSB0aGlzLmRlZmF1bHRBcmcocGVyY2VudCwgMSk7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IGZ1bmN0aW9uIChleHByLCBzdWJkaXZpc2lvbiwgcGVyY2VudCkge1xuXHQgICAgICAgICAgICBleHByID0gZXhwcigpO1xuXHQgICAgICAgICAgICBzdWJkaXZpc2lvbiA9IHN1YmRpdmlzaW9uLnRvU2Vjb25kcygpO1xuXHQgICAgICAgICAgICB2YXIgbXVsdGlwbGUgPSBNYXRoLnJvdW5kKGV4cHIgLyBzdWJkaXZpc2lvbik7XG5cdCAgICAgICAgICAgIHZhciBpZGVhbCA9IG11bHRpcGxlICogc3ViZGl2aXNpb247XG5cdCAgICAgICAgICAgIHZhciBkaWZmID0gaWRlYWwgLSBleHByO1xuXHQgICAgICAgICAgICByZXR1cm4gZXhwciArIGRpZmYgKiBwZXJjZW50O1xuXHQgICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLl9leHByLCBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzdWJkaXYpLCBwZXJjZW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkcyB0aGUgY2xvY2sgdGltZSB0byB0aGUgdGltZSBleHByZXNzaW9uIGF0IHRoZSBcblx0XHQgKiAgbW9tZW50IG9mIGV2YWx1YXRpb24uIFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5hZGROb3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fcGx1c05vdyA9IHRydWU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBvdmVycmlkZVxuXHRcdCAqICBPdmVycmlkZSB0aGUgZGVmYXVsdCB2YWx1ZSByZXR1cm4gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbi5cblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgJ25vdydcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX2RlZmF1bHRFeHByID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3BsdXNOb3cgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ub09wO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb3BpZXMgdGhlIHZhbHVlIG9mIHRpbWUgdG8gdGhpcyBUaW1lXG5cdFx0ICogIEBwYXJhbSB7VG9uZS5UaW1lfSB0aW1lXG5cdFx0ICogIEByZXR1cm4gIHtUaW1lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgdGltZSk7XG5cdCAgICAgICAgdGhpcy5fcGx1c05vdyA9IHRpbWUuX3BsdXNOb3c7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy9DT05WRVJTSU9OUy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIFRpbWUgdG8gTm90YXRpb24uIFZhbHVlcyB3aWxsIGJlIHRocmVzaG9sZGVkIHRvIHRoZSBuZWFyZXN0IDEyOHRoIG5vdGUuIFxuXHRcdCAqICBAcmV0dXJuIHtOb3RhdGlvbn0gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9pZiB0aGUgVHJhbnNwb3J0IGlzIGF0IDEyMGJwbTpcblx0XHQgKiBUb25lLlRpbWUoMikudG9Ob3RhdGlvbigpOy8vcmV0dXJucyBcIjFtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9Ob3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdGltZSA9IHRoaXMudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgdmFyIHRlc3ROb3RhdGlvbnMgPSBbXG5cdCAgICAgICAgICAgICcxbScsXG5cdCAgICAgICAgICAgICcybicsXG5cdCAgICAgICAgICAgICc0bicsXG5cdCAgICAgICAgICAgICc4bicsXG5cdCAgICAgICAgICAgICcxNm4nLFxuXHQgICAgICAgICAgICAnMzJuJyxcblx0ICAgICAgICAgICAgJzY0bicsXG5cdCAgICAgICAgICAgICcxMjhuJ1xuXHQgICAgICAgIF07XG5cdCAgICAgICAgdmFyIHJldE5vdGF0aW9uID0gdGhpcy5fdG9Ob3RhdGlvbkhlbHBlcih0aW1lLCB0ZXN0Tm90YXRpb25zKTtcblx0ICAgICAgICAvL3RyeSB0aGUgc2FtZSB0aGluZyBidXQgd2l0aCB0cmlwZWxldHNcblx0ICAgICAgICB2YXIgdGVzdFRyaXBsZXROb3RhdGlvbnMgPSBbXG5cdCAgICAgICAgICAgICcxbScsXG5cdCAgICAgICAgICAgICcybicsXG5cdCAgICAgICAgICAgICcydCcsXG5cdCAgICAgICAgICAgICc0bicsXG5cdCAgICAgICAgICAgICc0dCcsXG5cdCAgICAgICAgICAgICc4bicsXG5cdCAgICAgICAgICAgICc4dCcsXG5cdCAgICAgICAgICAgICcxNm4nLFxuXHQgICAgICAgICAgICAnMTZ0Jyxcblx0ICAgICAgICAgICAgJzMybicsXG5cdCAgICAgICAgICAgICczMnQnLFxuXHQgICAgICAgICAgICAnNjRuJyxcblx0ICAgICAgICAgICAgJzY0dCcsXG5cdCAgICAgICAgICAgICcxMjhuJ1xuXHQgICAgICAgIF07XG5cdCAgICAgICAgdmFyIHJldFRyaXBsZXROb3RhdGlvbiA9IHRoaXMuX3RvTm90YXRpb25IZWxwZXIodGltZSwgdGVzdFRyaXBsZXROb3RhdGlvbnMpO1xuXHQgICAgICAgIC8vY2hvb3NlIHRoZSBzaW1wbGVyIGV4cHJlc3Npb24gb2YgdGhlIHR3b1xuXHQgICAgICAgIGlmIChyZXRUcmlwbGV0Tm90YXRpb24uc3BsaXQoJysnKS5sZW5ndGggPCByZXROb3RhdGlvbi5zcGxpdCgnKycpLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcmV0VHJpcGxldE5vdGF0aW9uO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiByZXROb3RhdGlvbjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEhlbHBlciBtZXRob2QgZm9yIFRvbmUudG9Ob3RhdGlvblxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gdW5pdHMgXG5cdFx0ICogIEBwYXJhbSB7QXJyYXl9IHRlc3ROb3RhdGlvbnNcblx0XHQgKiAgQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fdG9Ob3RhdGlvbkhlbHBlciA9IGZ1bmN0aW9uICh1bml0cywgdGVzdE5vdGF0aW9ucykge1xuXHQgICAgICAgIC8vdGhlIHRocmVzaG9sZCBpcyB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgYXJyYXlcblx0ICAgICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5fbm90YXRpb25Ub1VuaXRzKHRlc3ROb3RhdGlvbnNbdGVzdE5vdGF0aW9ucy5sZW5ndGggLSAxXSk7XG5cdCAgICAgICAgdmFyIHJldE5vdGF0aW9uID0gJyc7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXN0Tm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBub3RhdGlvblRpbWUgPSB0aGlzLl9ub3RhdGlvblRvVW5pdHModGVzdE5vdGF0aW9uc1tpXSk7XG5cdCAgICAgICAgICAgIC8vYWNjb3VudCBmb3IgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIChpLmUuIHJvdW5kIHVwIGlmIHRoZSB2YWx1ZSBpcyAwLjk5OTk5OSlcblx0ICAgICAgICAgICAgdmFyIG11bHRpcGxlID0gdW5pdHMgLyBub3RhdGlvblRpbWU7XG5cdCAgICAgICAgICAgIHZhciBmbG9hdGluZ1BvaW50RXJyb3IgPSAwLjAwMDAwMTtcblx0ICAgICAgICAgICAgaWYgKDEgLSBtdWx0aXBsZSAlIDEgPCBmbG9hdGluZ1BvaW50RXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG11bHRpcGxlICs9IGZsb2F0aW5nUG9pbnRFcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBtdWx0aXBsZSA9IE1hdGguZmxvb3IobXVsdGlwbGUpO1xuXHQgICAgICAgICAgICBpZiAobXVsdGlwbGUgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXROb3RhdGlvbiArPSB0ZXN0Tm90YXRpb25zW2ldO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXROb3RhdGlvbiArPSBtdWx0aXBsZS50b1N0cmluZygpICsgJyonICsgdGVzdE5vdGF0aW9uc1tpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHVuaXRzIC09IG11bHRpcGxlICogbm90YXRpb25UaW1lO1xuXHQgICAgICAgICAgICAgICAgaWYgKHVuaXRzIDwgdGhyZXNob2xkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldE5vdGF0aW9uICs9ICcgKyAnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXROb3RhdGlvbiA9PT0gJycpIHtcblx0ICAgICAgICAgICAgcmV0Tm90YXRpb24gPSAnMCc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXROb3RhdGlvbjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIG5vdGF0aW9uIHZhbHVlIHRvIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSAge05vdGF0aW9ufSAgbm90YXRpb24gXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9IFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fbm90YXRpb25Ub1VuaXRzID0gZnVuY3Rpb24gKG5vdGF0aW9uKSB7XG5cdCAgICAgICAgdmFyIHByaW1hcnlFeHBycyA9IHRoaXMuX3ByaW1hcnlFeHByZXNzaW9ucztcblx0ICAgICAgICB2YXIgbm90YXRpb25FeHBycyA9IFtcblx0ICAgICAgICAgICAgcHJpbWFyeUV4cHJzLm4sXG5cdCAgICAgICAgICAgIHByaW1hcnlFeHBycy50LFxuXHQgICAgICAgICAgICBwcmltYXJ5RXhwcnMubVxuXHQgICAgICAgIF07XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3RhdGlvbkV4cHJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBleHByID0gbm90YXRpb25FeHByc1tpXTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoID0gbm90YXRpb24ubWF0Y2goZXhwci5yZWdleHApO1xuXHQgICAgICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBleHByLm1ldGhvZC5jYWxsKHRoaXMsIG1hdGNoWzFdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGVuY29kZWQgYXMgQmFyczpCZWF0czpTaXh0ZWVudGhzLlxuXHRcdCAqICBAcmV0dXJuICB7QmFyc0JlYXRzU2l4dGVlbnRoc31cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9CYXJzQmVhdHNTaXh0ZWVudGhzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBxdWFydGVyVGltZSA9IHRoaXMuX2JlYXRzVG9Vbml0cygxKTtcblx0ICAgICAgICB2YXIgcXVhcnRlcnMgPSB0aGlzLnRvU2Vjb25kcygpIC8gcXVhcnRlclRpbWU7XG5cdCAgICAgICAgdmFyIG1lYXN1cmVzID0gTWF0aC5mbG9vcihxdWFydGVycyAvIHRoaXMuX3RpbWVTaWduYXR1cmUoKSk7XG5cdCAgICAgICAgdmFyIHNpeHRlZW50aHMgPSBxdWFydGVycyAlIDEgKiA0O1xuXHQgICAgICAgIHF1YXJ0ZXJzID0gTWF0aC5mbG9vcihxdWFydGVycykgJSB0aGlzLl90aW1lU2lnbmF0dXJlKCk7XG5cdCAgICAgICAgc2l4dGVlbnRocyA9IHNpeHRlZW50aHMudG9TdHJpbmcoKTtcblx0ICAgICAgICBpZiAoc2l4dGVlbnRocy5sZW5ndGggPiAzKSB7XG5cdCAgICAgICAgICAgIHNpeHRlZW50aHMgPSBwYXJzZUZsb2F0KHNpeHRlZW50aHMpLnRvRml4ZWQoMyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcm9ncmVzcyA9IFtcblx0ICAgICAgICAgICAgbWVhc3VyZXMsXG5cdCAgICAgICAgICAgIHF1YXJ0ZXJzLFxuXHQgICAgICAgICAgICBzaXh0ZWVudGhzXG5cdCAgICAgICAgXTtcblx0ICAgICAgICByZXR1cm4gcHJvZ3Jlc3Muam9pbignOicpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gdGlja3MuXG5cdFx0ICogIEByZXR1cm4gIHtUaWNrc31cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9UaWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcXVhcnRlclRpbWUgPSB0aGlzLl9iZWF0c1RvVW5pdHMoMSk7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJzID0gdGhpcy5ldmFsKCkgLyBxdWFydGVyVGltZTtcblx0ICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihxdWFydGVycyAqIFRvbmUuVHJhbnNwb3J0LlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiBzYW1wbGVzXG5cdFx0ICogIEByZXR1cm4gIHtTYW1wbGVzfSAgXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvU2FtcGxlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZHMoKSAqIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgYXMgYSBmcmVxdWVuY3kgdmFsdWVcblx0XHQgKiAgQHJldHVybiAge0ZyZXF1ZW5jeX0gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lKDIpLnRvRnJlcXVlbmN5KCk7IC8vMC41XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAxIC8gdGhpcy50b1NlY29uZHMoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9TZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmV2YWwoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge01pbGxpc2Vjb25kc30gXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvTWlsbGlzZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnRvU2Vjb25kcygpICogMTAwMDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5fZXhwcigpO1xuXHQgICAgICAgIHJldHVybiB2YWwgKyAodGhpcy5fcGx1c05vdyA/IHRoaXMubm93KCkgOiAwKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5UaW1lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRnJlcXVlbmN5IGlzIGEgcHJpbWl0aXZlIHR5cGUgZm9yIGVuY29kaW5nIEZyZXF1ZW5jeSB2YWx1ZXMuIFxuXHRcdCAqICAgICAgICAgRXZlbnR1YWxseSBhbGwgdGltZSB2YWx1ZXMgYXJlIGV2YWx1YXRlZCB0byBoZXJ0elxuXHRcdCAqICAgICAgICAgdXNpbmcgdGhlIGBldmFsYCBtZXRob2QuIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuVGltZUJhc2V9XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9ICB2YWwgICAgVGhlIHRpbWUgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVGhlIHVuaXRzIG9mIHRoZSB2YWx1ZS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkZyZXF1ZW5jeShcIkMzXCIpLmV2YWwoKSAvLyAyNjFcblx0XHQgKiBUb25lLkZyZXF1ZW5jeSgzOCwgXCJtaWRpXCIpLmV2YWwoKSAvL1xuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KFwiQzNcIikudHJhbnNwb3NlKDQpLmV2YWwoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5ID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRvbmUuRnJlcXVlbmN5KSB7XG5cdCAgICAgICAgICAgIFRvbmUuVGltZUJhc2UuY2FsbCh0aGlzLCB2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuRnJlcXVlbmN5KHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZyZXF1ZW5jeSwgVG9uZS5UaW1lQmFzZSk7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRBVUdNRU5UIEJBU0UgRVhQUkVTU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9jbG9uZSB0aGUgZXhwcmVzc2lvbnMgc28gdGhhdCBcblx0ICAgIC8vd2UgY2FuIGFkZCBtb3JlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMgPSBPYmplY3QuY3JlYXRlKFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMpO1xuXHQgICAgLypcblx0XHQgKiAgbWlkaSB0eXBlIHByaW1hcnkgZXhwcmVzc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMubWlkaSA9IHtcblx0ICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT9taWRpKS8sXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlkaVRvRnJlcXVlbmN5KHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLypcblx0XHQgKiAgbm90ZSB0eXBlIHByaW1hcnkgZXhwcmVzc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMubm90ZSA9IHtcblx0ICAgICAgICByZWdleHA6IC9eKFthLWddezF9KD86YnwjfHh8YmIpPykoLT9bMC05XSspL2ksXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAocGl0Y2gsIG9jdGF2ZSkge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSBub3RlVG9TY2FsZUluZGV4W3BpdGNoLnRvTG93ZXJDYXNlKCldO1xuXHQgICAgICAgICAgICB2YXIgbm90ZU51bWJlciA9IGluZGV4ICsgKHBhcnNlSW50KG9jdGF2ZSkgKyAxKSAqIDEyO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5taWRpVG9GcmVxdWVuY3kobm90ZU51bWJlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qXG5cdFx0ICogIEJlYXRzQmFyc1NpeHRlZW50aHMgdHlwZSBwcmltYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zLnRyID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspPyk6KFxcZCsoPzpcXC5cXGQrKT8pOj8oXFxkKyg/OlxcLlxcZCspPyk/Lyxcblx0ICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChtLCBxLCBzKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3RhbCA9IDE7XG5cdCAgICAgICAgICAgIGlmIChtICYmIG0gIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKj0gdGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX3RpbWVTaWduYXR1cmUoKSAqIHBhcnNlRmxvYXQobSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChxICYmIHEgIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKj0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChzICYmIHMgIT09ICcwJykge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKj0gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQocykgLyA0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdG90YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEVYUFJFU1NJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBUcmFuc3Bvc2VzIHRoZSBmcmVxdWVuY3kgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBzZW1pdG9uZXMuXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsfSAgaW50ZXJ2YWxcblx0XHQgKiAgQHJldHVybiAge1RvbmUuRnJlcXVlbmN5fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koXCJBNFwiKS50cmFuc3Bvc2UoMyk7IC8vXCJDNVwiXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IGZ1bmN0aW9uIChleHByLCBpbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gZXhwcigpO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsICogdGhpcy5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oaW50ZXJ2YWwpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLl9leHByLCBpbnRlcnZhbCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRha2VzIGFuIGFycmF5IG9mIHNlbWl0b25lIGludGVydmFscyBhbmQgcmV0dXJuc1xuXHRcdCAqICBhbiBhcnJheSBvZiBmcmVxdWVuY2llcyB0cmFuc3Bvc2VkIGJ5IHRob3NlIGludGVydmFscy5cblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICBpbnRlcnZhbHNcblx0XHQgKiAgQHJldHVybiAge1RvbmUuRnJlcXVlbmN5fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koXCJBNFwiKS5oYXJtb25pemUoWzAsIDMsIDddKTsgLy9bXCJBNFwiLCBcIkM1XCIsIFwiRTVcIl1cblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5oYXJtb25pemUgPSBmdW5jdGlvbiAoaW50ZXJ2YWxzKSB7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IGZ1bmN0aW9uIChleHByLCBpbnRlcnZhbHMpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IGV4cHIoKTtcblx0ICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVydmFscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcmV0W2ldID0gdmFsICogdGhpcy5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oaW50ZXJ2YWxzW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLl9leHByLCBpbnRlcnZhbHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFVOSVQgQ09OVkVSU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZyZXF1ZW5jeSBhcyBhIE1JREkgbm90ZVxuXHRcdCAqICBAcmV0dXJuICB7TUlESX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkZyZXF1ZW5jeShcIkM0XCIpLnRvTWlkaSgpOyAvLzYwXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9NaWRpID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZyZXF1ZW5jeVRvTWlkaSh0aGlzLmV2YWwoKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZyZXF1ZW5jeSBpbiBTY2llbnRpZmljIFBpdGNoIE5vdGF0aW9uXG5cdFx0ICogIEByZXR1cm4gIHtOb3RlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KDY5LCBcIm1pZGlcIikudG9Ob3RlKCk7IC8vXCJBNFwiXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9Ob3RlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBmcmVxID0gdGhpcy5ldmFsKCk7XG5cdCAgICAgICAgdmFyIGxvZyA9IE1hdGgubG9nKGZyZXEgLyBUb25lLkZyZXF1ZW5jeS5BNCkgLyBNYXRoLkxOMjtcblx0ICAgICAgICB2YXIgbm90ZU51bWJlciA9IE1hdGgucm91bmQoMTIgKiBsb2cpICsgNTc7XG5cdCAgICAgICAgdmFyIG9jdGF2ZSA9IE1hdGguZmxvb3Iobm90ZU51bWJlciAvIDEyKTtcblx0ICAgICAgICBpZiAob2N0YXZlIDwgMCkge1xuXHQgICAgICAgICAgICBub3RlTnVtYmVyICs9IC0xMiAqIG9jdGF2ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5vdGVOYW1lID0gc2NhbGVJbmRleFRvTm90ZVtub3RlTnVtYmVyICUgMTJdO1xuXHQgICAgICAgIHJldHVybiBub3RlTmFtZSArIG9jdGF2ZS50b1N0cmluZygpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGR1cmF0aW9uIG9mIG9uZSBjeWNsZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7U2Vjb25kc31cblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b1NlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyB0aGlzLmV2YWwoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB2YWx1ZSBpbiBIZXJ0elxuXHRcdCAqICBAcmV0dXJuICB7RnJlcXVlbmN5fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmV2YWwoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBkdXJhdGlvbiBvZiBvbmUgY3ljbGUgaW4gdGlja3Ncblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJUaW1lID0gdGhpcy5fYmVhdHNUb1VuaXRzKDEpO1xuXHQgICAgICAgIHZhciBxdWFydGVycyA9IHRoaXMuZXZhbCgpIC8gcXVhcnRlclRpbWU7XG5cdCAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocXVhcnRlcnMgKiBUb25lLlRyYW5zcG9ydC5QUFEpO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFVOSVQgQ09OVkVSU0lPTlMgSEVMUEVSU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBmcmVxdWVuY3kgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXFcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fZnJlcXVlbmN5VG9Vbml0cyA9IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgcmV0dXJuIGZyZXE7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgdGljayBpbiB0aGUgY3VycmVudCB0aW1lIHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7VGlja3N9IHRpY2tzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3RpY2tzVG9Vbml0cyA9IGZ1bmN0aW9uICh0aWNrcykge1xuXHQgICAgICAgIHJldHVybiAxIC8gKHRpY2tzICogNjAgLyAoVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlICogVG9uZS5UcmFuc3BvcnQuUFBRKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGJlYXRzIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBiZWF0c1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9iZWF0c1RvVW5pdHMgPSBmdW5jdGlvbiAoYmVhdHMpIHtcblx0ICAgICAgICByZXR1cm4gMSAvIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9iZWF0c1RvVW5pdHMuY2FsbCh0aGlzLCBiZWF0cyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc2Vjb25kIGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7U2Vjb25kc30gc2Vjb25kc1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl9zZWNvbmRzVG9Vbml0cyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyBzZWNvbmRzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB1bml0cyBpZiBub25lIGFyZSBnaXZlbi5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fZGVmYXVsdFVuaXRzID0gJ2h6Jztcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEZSRVFVRU5DWSBDT05WRVJTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgTm90ZSB0byBzY2FsZSBpbmRleFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIHZhciBub3RlVG9TY2FsZUluZGV4ID0ge1xuXHQgICAgICAgICdjYmInOiAtMixcblx0ICAgICAgICAnY2InOiAtMSxcblx0ICAgICAgICAnYyc6IDAsXG5cdCAgICAgICAgJ2MjJzogMSxcblx0ICAgICAgICAnY3gnOiAyLFxuXHQgICAgICAgICdkYmInOiAwLFxuXHQgICAgICAgICdkYic6IDEsXG5cdCAgICAgICAgJ2QnOiAyLFxuXHQgICAgICAgICdkIyc6IDMsXG5cdCAgICAgICAgJ2R4JzogNCxcblx0ICAgICAgICAnZWJiJzogMixcblx0ICAgICAgICAnZWInOiAzLFxuXHQgICAgICAgICdlJzogNCxcblx0ICAgICAgICAnZSMnOiA1LFxuXHQgICAgICAgICdleCc6IDYsXG5cdCAgICAgICAgJ2ZiYic6IDMsXG5cdCAgICAgICAgJ2ZiJzogNCxcblx0ICAgICAgICAnZic6IDUsXG5cdCAgICAgICAgJ2YjJzogNixcblx0ICAgICAgICAnZngnOiA3LFxuXHQgICAgICAgICdnYmInOiA1LFxuXHQgICAgICAgICdnYic6IDYsXG5cdCAgICAgICAgJ2cnOiA3LFxuXHQgICAgICAgICdnIyc6IDgsXG5cdCAgICAgICAgJ2d4JzogOSxcblx0ICAgICAgICAnYWJiJzogNyxcblx0ICAgICAgICAnYWInOiA4LFxuXHQgICAgICAgICdhJzogOSxcblx0ICAgICAgICAnYSMnOiAxMCxcblx0ICAgICAgICAnYXgnOiAxMSxcblx0ICAgICAgICAnYmJiJzogOSxcblx0ICAgICAgICAnYmInOiAxMCxcblx0ICAgICAgICAnYic6IDExLFxuXHQgICAgICAgICdiIyc6IDEyLFxuXHQgICAgICAgICdieCc6IDEzXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHNjYWxlIGluZGV4IHRvIG5vdGUgKHNoYXJwcylcblx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBzY2FsZUluZGV4VG9Ob3RlID0gW1xuXHQgICAgICAgICdDJyxcblx0ICAgICAgICAnQyMnLFxuXHQgICAgICAgICdEJyxcblx0ICAgICAgICAnRCMnLFxuXHQgICAgICAgICdFJyxcblx0ICAgICAgICAnRicsXG5cdCAgICAgICAgJ0YjJyxcblx0ICAgICAgICAnRycsXG5cdCAgICAgICAgJ0cjJyxcblx0ICAgICAgICAnQScsXG5cdCAgICAgICAgJ0EjJyxcblx0ICAgICAgICAnQidcblx0ICAgIF07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFtjb25jZXJ0IHBpdGNoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25jZXJ0X3BpdGNoKVxuXHRcdCAqICBBNCdzIHZhbHVlcyBpbiBIZXJ0ei4gXG5cdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LkE0ID0gNDQwO1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSBNSURJIG5vdGUgdG8gZnJlcXVlbmN5IHZhbHVlLiBcblx0XHQgKiAgQHBhcmFtICB7TUlESX0gbWlkaSBUaGUgbWlkaSBudW1iZXIgdG8gY29udmVydC5cblx0XHQgKiAgQHJldHVybiB7RnJlcXVlbmN5fSB0aGUgY29ycmVzcG9uZGluZyBmcmVxdWVuY3kgdmFsdWVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB0b25lLm1pZGlUb0ZyZXF1ZW5jeSg2OSk7IC8vIHJldHVybnMgNDQwXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUubWlkaVRvRnJlcXVlbmN5ID0gZnVuY3Rpb24gKG1pZGkpIHtcblx0ICAgICAgICByZXR1cm4gVG9uZS5GcmVxdWVuY3kuQTQgKiBNYXRoLnBvdygyLCAobWlkaSAtIDY5KSAvIDEyKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIGZyZXF1ZW5jeSB2YWx1ZSB0byBhIE1JREkgbm90ZS5cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgdmFsdWUgdG8gZnJlcXVlbmN5IHZhbHVlIHRvIGNvbnZlcnQuXG5cdFx0ICogIEByZXR1cm5zICB7TUlESX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB0b25lLm1pZGlUb0ZyZXF1ZW5jeSg0NDApOyAvLyByZXR1cm5zIDY5XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuZnJlcXVlbmN5VG9NaWRpID0gZnVuY3Rpb24gKGZyZXF1ZW5jeSkge1xuXHQgICAgICAgIHJldHVybiA2OSArIDEyICogTWF0aC5sb2coZnJlcXVlbmN5IC8gVG9uZS5GcmVxdWVuY3kuQTQpIC8gTWF0aC5MTjI7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRnJlcXVlbmN5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVHJhbnNwb3J0VGltZSBpcyBhIHRoZSB0aW1lIGFsb25nIHRoZSBUcmFuc3BvcnQnc1xuXHRcdCAqICAgICAgICAgdGltZWxpbmUuIEl0IGlzIHNpbWlsYXIgdG8gVG9uZS5UaW1lLCBidXQgaW5zdGVhZCBvZiBldmFsdWF0aW5nXG5cdFx0ICogICAgICAgICBhZ2FpbnN0IHRoZSBBdWRpb0NvbnRleHQncyBjbG9jaywgaXQgaXMgZXZhbHVhdGVkIGFnYWluc3Rcblx0XHQgKiAgICAgICAgIHRoZSBUcmFuc3BvcnQncyBwb3NpdGlvbi4gU2VlIFtUcmFuc3BvcnRUaW1lIHdpa2ldKGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RyYW5zcG9ydFRpbWUpLlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZSBhcyBhIG51bWJlciBvciBzdHJpbmdcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBVbml0IHZhbHVlc1xuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5UaW1lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRvbmUuVHJhbnNwb3J0VGltZSkge1xuXHQgICAgICAgICAgICBUb25lLlRpbWUuY2FsbCh0aGlzLCB2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuVHJhbnNwb3J0VGltZSh2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UcmFuc3BvcnRUaW1lLCBUb25lLlRpbWUpO1xuXHQgICAgLy9jbG9uZSB0aGUgZXhwcmVzc2lvbnMgc28gdGhhdCBcblx0ICAgIC8vd2UgY2FuIGFkZCBtb3JlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyA9IE9iamVjdC5jcmVhdGUoVG9uZS5UaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyk7XG5cdCAgICAvKipcblx0XHQgKiAgQWRkcyBhbiBhZGRpdGlvbmFsIHVuYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgd2hpY2ggcXVhbnRpemVzIHZhbHVlcyB0byB0aGUgbmV4dCBzdWJkaXZpc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucy5xdWFudGl6ZSA9IHtcblx0ICAgICAgICByZWdleHA6IC9eQC8sXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAocmgpIHtcblx0ICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9uID0gdGhpcy5fc2Vjb25kc1RvVGlja3MocmgoKSk7XG5cdCAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGguY2VpbChUb25lLlRyYW5zcG9ydC50aWNrcyAvIHN1YmRpdmlzaW9uKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tzVG9Vbml0cyhtdWx0aXBsZSAqIHN1YmRpdmlzaW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgc2Vjb25kcyBpbnRvIHRpY2tzXG5cdFx0ICogIEBwYXJhbSB7U2Vjb25kc30gc2Vjb25kc1xuXHRcdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLl9zZWNvbmRzVG9UaWNrcyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJUaW1lID0gdGhpcy5fYmVhdHNUb1VuaXRzKDEpO1xuXHQgICAgICAgIHZhciBxdWFydGVycyA9IHNlY29uZHMgLyBxdWFydGVyVGltZTtcblx0ICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChxdWFydGVycyAqIFRvbmUuVHJhbnNwb3J0LlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEV2YWx1YXRlIHRoZSB0aW1lIGV4cHJlc3Npb24uIFJldHVybnMgdmFsdWVzIGluIHRpY2tzXG5cdFx0ICogIEByZXR1cm4ge1RpY2tzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB2YWwgPSB0aGlzLl9zZWNvbmRzVG9UaWNrcyh0aGlzLl9leHByKCkpO1xuXHQgICAgICAgIHJldHVybiB2YWwgKyAodGhpcy5fcGx1c05vdyA/IFRvbmUuVHJhbnNwb3J0LnRpY2tzIDogMCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiB0aWNrcy5cblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b1RpY2tzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmV2YWwoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtTZWNvbmRzfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b1NlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHRoaXMuX2V4cHIoKTtcblx0ICAgICAgICByZXR1cm4gdmFsICsgKHRoaXMuX3BsdXNOb3cgPyBUb25lLlRyYW5zcG9ydC5zZWNvbmRzIDogMCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBhcyBhIGZyZXF1ZW5jeSB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7RnJlcXVlbmN5fSBcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUudG9GcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyB0aGlzLnRvU2Vjb25kcygpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRZUEVTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqIFVuaXRzIHdoaWNoIGEgdmFsdWUgY2FuIHRha2Ugb24uXG5cdFx0ICogQGVudW0ge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuVHlwZSA9IHtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgRGVmYXVsdCB1bml0c1xuXHRcdFx0ICogIEB0eXBlZGVmIHtEZWZhdWx0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgRGVmYXVsdDogJ251bWJlcicsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGltZSBjYW4gYmUgZGVzY3JpYmVkIGluIGEgbnVtYmVyIG9mIHdheXMuIFJlYWQgbW9yZSBbVGltZV0oaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvVGltZSkuXG5cdFx0XHQgKlxuXHRcdFx0ICogIDx1bD5cblx0XHRcdCAqICA8bGk+TnVtYmVycywgd2hpY2ggd2lsbCBiZSB0YWtlbiBsaXRlcmFsbHkgYXMgdGhlIHRpbWUgKGluIHNlY29uZHMpLjwvbGk+XG5cdFx0XHQgKiAgPGxpPk5vdGF0aW9uLCAoXCI0blwiLCBcIjh0XCIpIGRlc2NyaWJlcyB0aW1lIGluIEJQTSBhbmQgdGltZSBzaWduYXR1cmUgcmVsYXRpdmUgdmFsdWVzLjwvbGk+XG5cdFx0XHQgKiAgPGxpPlRyYW5zcG9ydFRpbWUsIChcIjQ6MzoyXCIpIHdpbGwgYWxzbyBwcm92aWRlIHRlbXBvIGFuZCB0aW1lIHNpZ25hdHVyZSByZWxhdGl2ZSB0aW1lcyBcblx0XHRcdCAqICBpbiB0aGUgZm9ybSBCQVJTOlFVQVJURVJTOlNJWFRFRU5USFMuPC9saT5cblx0XHRcdCAqICA8bGk+RnJlcXVlbmN5LCAoXCI4aHpcIikgaXMgY29udmVydGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIGN5Y2xlIGluIHNlY29uZHMuPC9saT5cblx0XHRcdCAqICA8bGk+Tm93LVJlbGF0aXZlLCAoXCIrMVwiKSBwcmVmaXggYW55IG9mIHRoZSBhYm92ZSB3aXRoIFwiK1wiIGFuZCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIFxuXHRcdFx0ICogIFwidGhlIGN1cnJlbnQgdGltZSBwbHVzIHdoYXRldmVyIGV4cHJlc3Npb24gZm9sbG93c1wiLjwvbGk+XG5cdFx0XHQgKiAgPGxpPkV4cHJlc3Npb25zLCAoXCIzOjAgKyAyIC0gKDFtIC8gNylcIikgYW55IG9mIHRoZSBhYm92ZSBjYW4gYWxzbyBiZSBjb21iaW5lZCBcblx0XHRcdCAqICBpbnRvIGEgbWF0aGVtYXRpY2FsIGV4cHJlc3Npb24gd2hpY2ggd2lsbCBiZSBldmFsdWF0ZWQgdG8gY29tcHV0ZSB0aGUgZGVzaXJlZCB0aW1lLjwvbGk+XG5cdFx0XHQgKiAgPGxpPk5vIEFyZ3VtZW50LCBmb3IgbWV0aG9kcyB3aGljaCBhY2NlcHQgdGltZSwgbm8gYXJndW1lbnQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBcblx0XHRcdCAqICBcIm5vd1wiIChpLmUuIHRoZSBjdXJyZW50VGltZSkuPC9saT5cblx0XHRcdCAqICA8L3VsPlxuXHRcdFx0ICogIFxuXHRcdFx0ICogIEB0eXBlZGVmIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgVGltZTogJ3RpbWUnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEZyZXF1ZW5jeSBjYW4gYmUgZGVzY3JpYmVkIHNpbWlsYXIgdG8gdGltZSwgZXhjZXB0IHVsdGltYXRlbHkgdGhlXG5cdFx0XHQgKiAgdmFsdWVzIGFyZSBjb252ZXJ0ZWQgdG8gZnJlcXVlbmN5IGluc3RlYWQgb2Ygc2Vjb25kcy4gQSBudW1iZXJcblx0XHRcdCAqICBpcyB0YWtlbiBsaXRlcmFsbHkgYXMgdGhlIHZhbHVlIGluIGhlcnR6LiBBZGRpdGlvbmFsbHkgYW55IG9mIHRoZSBcblx0XHRcdCAqICBUaW1lIGVuY29kaW5ncyBjYW4gYmUgdXNlZC4gTm90ZSBuYW1lcyBpbiB0aGUgZm9ybVxuXHRcdFx0ICogIG9mIE5PVEUgT0NUQVZFIChpLmUuIEM0KSBhcmUgYWxzbyBhY2NlcHRlZCBhbmQgY29udmVydGVkIHRvIHRoZWlyXG5cdFx0XHQgKiAgZnJlcXVlbmN5IHZhbHVlLiBcblx0XHRcdCAqICBAdHlwZWRlZiB7RnJlcXVlbmN5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgRnJlcXVlbmN5OiAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUcmFuc3BvcnRUaW1lIGRlc2NyaWJlcyBhIHBvc2l0aW9uIGFsb25nIHRoZSBUcmFuc3BvcnQncyB0aW1lbGluZS4gSXQgaXNcblx0XHRcdCAqICBzaW1pbGFyIHRvIFRpbWUgaW4gdGhhdCBpdCB1c2VzIGFsbCB0aGUgc2FtZSBlbmNvZGluZ3MsIGJ1dCBUcmFuc3BvcnRUaW1lIHNwZWNpZmljYWxseVxuXHRcdFx0ICogIHBlcnRhaW5zIHRvIHRoZSBUcmFuc3BvcnQncyB0aW1lbGluZSwgd2hpY2ggaXMgc3RhcnRhYmxlLCBzdG9wcGFibGUsIGxvb3BhYmxlLCBhbmQgc2Vla2FibGUuIFxuXHRcdFx0ICogIFtSZWFkIG1vcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RyYW5zcG9ydFRpbWUpXG5cdFx0XHQgKiAgQHR5cGVkZWYge1RyYW5zcG9ydFRpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICBUcmFuc3BvcnRUaW1lOiAndHJhbnNwb3J0VGltZScsXG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIFRpY2tzIGFyZSB0aGUgYmFzaWMgc3VidW5pdCBvZiB0aGUgVHJhbnNwb3J0LiBUaGV5IGFyZVxuXHRcdFx0ICogIHRoZSBzbWFsbGVzdCB1bml0IG9mIHRpbWUgdGhhdCB0aGUgVHJhbnNwb3J0IHN1cHBvcnRzLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtUaWNrc31cblx0XHRcdCAqL1xuXHQgICAgICAgIFRpY2tzOiAndGlja3MnLFxuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBOb3JtYWwgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIHJhbmdlIFswLCAxXS5cblx0XHRcdCAqICBAdHlwZWRlZiB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKi9cblx0ICAgICAgICBOb3JtYWxSYW5nZTogJ25vcm1hbFJhbmdlJyxcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQXVkaW9SYW5nZSB2YWx1ZXMgYXJlIGJldHdlZW4gWy0xLCAxXS5cblx0XHRcdCAqICBAdHlwZWRlZiB7QXVkaW9SYW5nZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIEF1ZGlvUmFuZ2U6ICdhdWRpb1JhbmdlJyxcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgRGVjaWJlbHMgYXJlIGEgbG9nYXJpdGhtaWMgdW5pdCBvZiBtZWFzdXJlbWVudCB3aGljaCBpcyB1c2VmdWwgZm9yIHZvbHVtZVxuXHRcdFx0ICogIGJlY2F1c2Ugb2YgdGhlIGxvZ2FyaXRobWljIHdheSB0aGF0IHdlIHBlcmNlaXZlIGxvdWRuZXNzLiAwIGRlY2liZWxzIFxuXHRcdFx0ICogIG1lYW5zIG5vIGNoYW5nZSBpbiB2b2x1bWUuIC0xMGRiIGlzIGFwcHJveGltYXRlbHkgaGFsZiBhcyBsb3VkIGFuZCAxMGRiIFxuXHRcdFx0ICogIGlzIHR3aWNlIGlzIGxvdWQuIFxuXHRcdFx0ICogIEB0eXBlZGVmIHtEZWNpYmVsc31cblx0XHRcdCAqL1xuXHQgICAgICAgIERlY2liZWxzOiAnZGInLFxuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBIYWxmLXN0ZXAgbm90ZSBpbmNyZW1lbnRzLCBpLmUuIDEyIGlzIGFuIG9jdGF2ZSBhYm92ZSB0aGUgcm9vdC4gYW5kIDEgaXMgYSBoYWxmLXN0ZXAgdXAuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0ludGVydmFsfVxuXHRcdFx0ICovXG5cdCAgICAgICAgSW50ZXJ2YWw6ICdpbnRlcnZhbCcsXG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEJlYXRzIHBlciBtaW51dGUuIFxuXHRcdFx0ICogIEB0eXBlZGVmIHtCUE19XG5cdFx0XHQgKi9cblx0ICAgICAgICBCUE06ICdicG0nLFxuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMC5cblx0XHRcdCAqICBAdHlwZWRlZiB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICBQb3NpdGl2ZTogJ3Bvc2l0aXZlJyxcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQSBjZW50IGlzIGEgaHVuZHJlZHRoIG9mIGEgc2VtaXRvbmUuIFxuXHRcdFx0ICogIEB0eXBlZGVmIHtDZW50c31cblx0XHRcdCAqL1xuXHQgICAgICAgIENlbnRzOiAnY2VudHMnLFxuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBBbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MC4gXG5cdFx0XHQgKiAgQHR5cGVkZWYge0RlZ3JlZXN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBEZWdyZWVzOiAnZGVncmVlcycsXG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEEgbnVtYmVyIHJlcHJlc2VudGluZyBhIG1pZGkgbm90ZS5cblx0XHRcdCAqICBAdHlwZWRlZiB7TUlESX1cblx0XHRcdCAqL1xuXHQgICAgICAgIE1JREk6ICdtaWRpJyxcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQSBjb2xvbi1zZXBhcmF0ZWQgcmVwcmVzZW50YXRpb24gb2YgdGltZSBpbiB0aGUgZm9ybSBvZlxuXHRcdFx0ICogIEJhcnM6QmVhdHM6U2l4dGVlbnRocy4gXG5cdFx0XHQgKiAgQHR5cGVkZWYge0JhcnNCZWF0c1NpeHRlZW50aHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBCYXJzQmVhdHNTaXh0ZWVudGhzOiAnYmFyc0JlYXRzU2l4dGVlbnRocycsXG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIFNhbXBsaW5nIGlzIHRoZSByZWR1Y3Rpb24gb2YgYSBjb250aW51b3VzIHNpZ25hbCB0byBhIGRpc2NyZXRlIHNpZ25hbC5cblx0XHRcdCAqICBBdWRpbyBpcyB0eXBpY2FsbHkgc2FtcGxlZCA0NDEwMCB0aW1lcyBwZXIgc2Vjb25kLiBcblx0XHRcdCAqICBAdHlwZWRlZiB7U2FtcGxlc31cblx0XHRcdCAqL1xuXHQgICAgICAgIFNhbXBsZXM6ICdzYW1wbGVzJyxcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgSGVydHogYXJlIGEgZnJlcXVlbmN5IHJlcHJlc2VudGF0aW9uIGRlZmluZWQgYXMgb25lIGN5Y2xlIHBlciBzZWNvbmQuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0hlcnR6fVxuXHRcdFx0ICovXG5cdCAgICAgICAgSGVydHo6ICdoZXJ0eicsXG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEEgZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IGEgbGV0dGVyIG5hbWUsIFxuXHRcdFx0ICogIGFjY2lkZW50YWwgYW5kIG9jdGF2ZS4gVGhpcyBzeXN0ZW0gaXMga25vd24gYXNcblx0XHRcdCAqICBbU2NpZW50aWZpYyBQaXRjaCBOb3RhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NpZW50aWZpY19waXRjaF9ub3RhdGlvbikuXG5cdFx0XHQgKiAgQHR5cGVkZWYge05vdGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICBOb3RlOiAnbm90ZScsXG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIE9uZSBtaWxsaXNlY29uZCBpcyBhIHRob3VzYW5kdGggb2YgYSBzZWNvbmQuIFxuXHRcdFx0ICogIEB0eXBlZGVmIHtNaWxsaXNlY29uZHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBNaWxsaXNlY29uZHM6ICdtaWxsaXNlY29uZHMnLFxuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBTZWNvbmRzIGFyZSB0aGUgdGltZSB1bml0IG9mIHRoZSBBdWRpb0NvbnRleHQuIEluIHRoZSBlbmQsIFxuXHRcdFx0ICogIGFsbCB2YWx1ZXMgbmVlZCB0byBiZSBldmFsdWF0ZWQgdG8gc2Vjb25kcy4gXG5cdFx0XHQgKiAgQHR5cGVkZWYge1NlY29uZHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBTZWNvbmRzOiAnc2Vjb25kcycsXG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGEgbWVhc3VyZS4gXG5cdFx0XHQgKiAgPHVsPlxuXHRcdFx0ICogIFx0PGxpPlwiNG5cIiA9IHF1YXJ0ZXIgbm90ZTwvbGk+XG5cdFx0XHQgKiAgIFx0PGxpPlwiMm1cIiA9IHR3byBtZWFzdXJlczwvbGk+XG5cdFx0XHQgKiAgICBcdDxsaT5cIjh0XCIgPSBlaWdodGgtbm90ZSB0cmlwbGV0PC9saT5cblx0XHRcdCAqICA8L3VsPlxuXHRcdFx0ICogIEB0eXBlZGVmIHtOb3RhdGlvbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIE5vdGF0aW9uOiAnbm90YXRpb24nXG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBBVUdNRU5UIFRPTkUncyBQUk9UT1RZUEVcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgVGltZSBpbnRvIHNlY29uZHMuXG5cdFx0ICogIFxuXHRcdCAqICBVbmxpa2UgdGhlIG1ldGhvZCB3aGljaCBpdCBvdmVycmlkZXMsIHRoaXMgdGFrZXMgaW50byBhY2NvdW50IFxuXHRcdCAqICB0cmFuc3BvcnR0aW1lIGFuZCBtdXNpY2FsIG5vdGF0aW9uLlxuXHRcdCAqXG5cdFx0ICogIFRpbWUgOiAxLjQwXG5cdFx0ICogIE5vdGF0aW9uOiA0bnwxbXwydFxuXHRcdCAqICBOb3cgUmVsYXRpdmU6ICszblxuXHRcdCAqICBNYXRoOiAzbisxNm4gb3IgZXZlbiBjb21wbGljYXRlZCBleHByZXNzaW9ucyAoKDNuKjIpLzYgKyAxKVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgXG5cdFx0ICogIEByZXR1cm4ge1NlY29uZHN9IFxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUudG9TZWNvbmRzID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc051bWJlcih0aW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGltZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNVbmRlZih0aW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5ub3coKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdHJpbmcodGltZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRpbWUodGltZSkudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aW1lIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGltZS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSBmcmVxdWVuY3kgcmVwcmVzZW50YXRpb24gaW50byBhIG51bWJlci5cblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBmcmVxIFxuXHRcdCAqICBAcmV0dXJuIHtIZXJ0en0gICAgICB0aGUgZnJlcXVlbmN5IGluIGhlcnR6XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS50b0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOdW1iZXIoZnJlcSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZyZXE7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3RyaW5nKGZyZXEpIHx8IHRoaXMuaXNVbmRlZihmcmVxKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuRnJlcXVlbmN5KGZyZXEpLmV2YWwoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGZyZXEgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmcmVxLnRvRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGEgdGltZSByZXByZXNlbnRhdGlvbiBpbnRvIHRpY2tzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lXG5cdFx0ICogIEByZXR1cm4ge1RpY2tzfSAgdGhlIHRpbWUgaW4gdGlja3Ncblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmlzTnVtYmVyKHRpbWUpIHx8IHRoaXMuaXNTdHJpbmcodGltZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRyYW5zcG9ydFRpbWUodGltZSkudG9UaWNrcygpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1VuZGVmKHRpbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydC50aWNrcztcblx0ICAgICAgICB9IGVsc2UgaWYgKHRpbWUgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aW1lLnRvVGlja3MoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhcmFtIHdyYXBzIHRoZSBuYXRpdmUgV2ViIEF1ZGlvJ3MgQXVkaW9QYXJhbSB0byBwcm92aWRlXG5cdFx0ICogICAgICAgICBhZGRpdGlvbmFsIHVuaXQgY29udmVyc2lvbiBmdW5jdGlvbmFsaXR5LiBJdCBhbHNvXG5cdFx0ICogICAgICAgICBzZXJ2ZXMgYXMgYSBiYXNlLWNsYXNzIGZvciBjbGFzc2VzIHdoaWNoIGhhdmUgYSBzaW5nbGUsXG5cdFx0ICogICAgICAgICBhdXRvbWF0YWJsZSBwYXJhbWV0ZXIuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtICB7QXVkaW9QYXJhbX0gIHBhcmFtICBUaGUgcGFyYW1ldGVyIHRvIHdyYXAuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuVHlwZX0gdW5pdHMgVGhlIHVuaXRzIG9mIHRoZSBhdWRpbyBwYXJhbS5cblx0XHQgKiAgQHBhcmFtICB7Qm9vbGVhbn0gY29udmVydCBJZiB0aGUgcGFyYW0gc2hvdWxkIGJlIGNvbnZlcnRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdwYXJhbScsXG5cdCAgICAgICAgICAgICd1bml0cycsXG5cdCAgICAgICAgICAgICdjb252ZXJ0J1xuXHQgICAgICAgIF0sIFRvbmUuUGFyYW0uZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBuYXRpdmUgcGFyYW1ldGVyIHRvIGNvbnRyb2xcblx0XHRcdCAqICBAdHlwZSAge0F1ZGlvUGFyYW19XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dCA9IG9wdGlvbnMucGFyYW07XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHVuaXRzIG9mIHRoZSBwYXJhbWV0ZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UeXBlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy51bml0cyA9IG9wdGlvbnMudW5pdHM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgb3Igbm90XG5cdFx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNvbnZlcnQgPSBvcHRpb25zLmNvbnZlcnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVHJ1ZSBpZiB0aGUgc2lnbmFsIHZhbHVlIGlzIGJlaW5nIG92ZXJyaWRkZW4gYnkgXG5cdFx0XHQgKiAgYSBjb25uZWN0ZWQgc2lnbmFsLlxuXHRcdFx0ICogIEByZWFkT25seVxuXHRcdFx0ICogIEB0eXBlICB7Ym9vbGVhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdmVycmlkZGVuID0gZmFsc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlcmUgaXMgYW4gTEZPLCB0aGlzIGlzIHdoZXJlIGl0IGlzIGhlbGQuXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICBpZiAodGhpcy5pc09iamVjdChvcHRpb25zLmxmbykpIHtcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMubGZvO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNVbmRlZihvcHRpb25zLnZhbHVlKSkge1xuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYXJhbSk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRGVmYXVsdCxcblx0ICAgICAgICAnY29udmVydCc6IHRydWUsXG5cdCAgICAgICAgJ3BhcmFtJzogdW5kZWZpbmVkXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGFyYW0jXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1VuaXRzKHRoaXMuX3BhcmFtLnZhbHVlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgLy90aHJvdyBhbiBlcnJvciBpZiB0aGUgTEZPIG5lZWRzIHRvIGJlIGluY2x1ZGVkXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmKFRvbmUuTEZPKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jbHVkZSBcXCdUb25lLkxGT1xcJyB0byB1c2UgYW4gTEZPIGFzIGEgUGFyYW0gdmFsdWUuJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgb2xkIG9uZVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xmbykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm8gPSBuZXcgVG9uZS5MRk8odmFsdWUpLnN0YXJ0KCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm8uY29ubmVjdCh0aGlzLmlucHV0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRWYWwgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKDApO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW0udmFsdWUgPSBjb252ZXJ0ZWRWYWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSB0eXBlIHNwZWNpZmllZCBieSBUb25lLlBhcmFtLnVuaXRzXG5cdFx0ICogIGludG8gdGhlIGRlc3RpbmF0aW9uIHZhbHVlIChzdWNoIGFzIEdhaW4gb3IgRnJlcXVlbmN5KS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7Kn0gdmFsIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG5cdFx0ICogIEByZXR1cm4ge251bWJlcn0gICAgIHRoZSBudW1iZXIgd2hpY2ggdGhlIHZhbHVlIHNob3VsZCBiZSBzZXQgdG9cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLl9mcm9tVW5pdHMgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udmVydCB8fCB0aGlzLmlzVW5kZWYodGhpcy5jb252ZXJ0KSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudW5pdHMpIHtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuVGltZTpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU2Vjb25kcyh2YWwpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5GcmVxdWVuY3k6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0ZyZXF1ZW5jeSh2YWwpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5EZWNpYmVsczpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRiVG9HYWluKHZhbCk7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLk5vcm1hbFJhbmdlOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgMCksIDEpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5BdWRpb1JhbmdlOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgLTEpLCAxKTtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuUG9zaXRpdmU6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodmFsLCAwKTtcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBDb252ZXJ0IHRoZSBwYXJhbWV0ZXJzIHZhbHVlIGludG8gdGhlIHVuaXRzIHNwZWNpZmllZCBieSBUb25lLlBhcmFtLnVuaXRzLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtICB7bnVtYmVyfSB2YWwgdGhlIHZhbHVlIHRvIGNvbnZlcnRcblx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5fdG9Vbml0cyA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICBpZiAodGhpcy5jb252ZXJ0IHx8IHRoaXMuaXNVbmRlZih0aGlzLmNvbnZlcnQpKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy51bml0cykge1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5EZWNpYmVsczpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdhaW5Ub0RiKHZhbCk7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZVxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuX21pbk91dHB1dCA9IDAuMDAwMDE7XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGEgcGFyYW1ldGVyIHZhbHVlIGNoYW5nZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtIHsqfVx0dmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgc2lnbmFsLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9ICB0aW1lIFRoZSB0aW1lIHdoZW4gdGhlIGNoYW5nZSBzaG91bGQgb2NjdXIuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgdGhlIGZyZXF1ZW5jeSB0byBcIkc0XCIgaW4gZXhhY3RseSAxIHNlY29uZCBmcm9tIG5vdy4gXG5cdFx0ICogZnJlcS5zZXRWYWx1ZUF0VGltZShcIkc0XCIsIFwiKzFcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdGltZSkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgaWYgKHRpbWUgPD0gdGhpcy5ub3coKSArIHRoaXMuYmxvY2tUaW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcmFtLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUodmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ3JlYXRlcyBhIHNjaGVkdWxlIHBvaW50IHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgYXQgdGhlIGN1cnJlbnQgdGltZS5cblx0XHQgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGFuIGF1dG9tYXRpb24gYW5jaG9yIHBvaW50IGluIG9yZGVyIHRvIFxuXHRcdCAqICBzY2hlZHVsZSBjaGFuZ2VzIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuIFxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gbm93IChPcHRpb25hbGx5KSBwYXNzIHRoZSBub3cgdmFsdWUgaW4uIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuc2V0UmFtcFBvaW50ID0gZnVuY3Rpb24gKG5vdykge1xuXHQgICAgICAgIG5vdyA9IHRoaXMuZGVmYXVsdEFyZyhub3csIHRoaXMubm93KCkpO1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsID0gdGhpcy5fcGFyYW0udmFsdWU7XG5cdCAgICAgICAgLy8gZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0IGNhbm5vdCBldmVyIHJhbXAgZnJvbSBvciB0byAwXG5cdCAgICAgICAgLy8gTW9yZSBpbmZvOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI1NjAwI2MyXG5cdCAgICAgICAgaWYgKGN1cnJlbnRWYWwgPT09IDApIHtcblx0ICAgICAgICAgICAgY3VycmVudFZhbCA9IHRoaXMuX21pbk91dHB1dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUoY3VycmVudFZhbCwgbm93KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGEgbGluZWFyIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZSBcblx0XHQgKiAgcHJldmlvdXMgc2NoZWR1bGVkIHBhcmFtZXRlciB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlICAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWUgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5kVGltZSkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgdGhpcy50b1NlY29uZHMoZW5kVGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb20gXG5cdFx0ICogIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZSBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIGVuZFRpbWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhbiBleHBvbmVudGlhbCBjb250aW51b3VzIGNoYW5nZSBpbiBwYXJhbWV0ZXIgdmFsdWUgZnJvbSBcblx0XHQgKiAgdGhlIGN1cnJlbnQgdGltZSBhbmQgY3VycmVudCB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUgb3ZlciB0aGUgXG5cdFx0ICogIGR1cmF0aW9uIG9mIHRoZSByYW1wVGltZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gcmFtcFRpbWUgdGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0aGUgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgdG8gcmFtcCBmcm9tIGl0J3MgY3VycmVudCB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9XHRbc3RhcnRUaW1lPW5vd10gXHRXaGVuIHRoZSByYW1wIHNob3VsZCBzdGFydC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9leHBvbmVudGlhbGx5IHJhbXAgdG8gdGhlIHZhbHVlIDIgb3ZlciA0IHNlY29uZHMuIFxuXHRcdCAqIHNpZ25hbC5leHBvbmVudGlhbFJhbXBUb1ZhbHVlKDIsIDQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSArIHRoaXMudG9TZWNvbmRzKHJhbXBUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhbiBsaW5lYXIgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb20gXG5cdFx0ICogIHRoZSBjdXJyZW50IHRpbWUgYW5kIGN1cnJlbnQgdmFsdWUgdG8gdGhlIGdpdmVuIHZhbHVlIG92ZXIgdGhlIFxuXHRcdCAqICBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlICAgVGhlIHZhbHVlIHRvIHJhbXAgdG8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHJhbXBUaW1lIHRoZSB0aW1lIHRoYXQgaXQgdGFrZXMgdGhlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbGluZWFybHkgcmFtcCB0byB0aGUgdmFsdWUgNCBvdmVyIDMgc2Vjb25kcy4gXG5cdFx0ICogc2lnbmFsLmxpbmVhclJhbXBUb1ZhbHVlKDQsIDMpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIHJhbXBUaW1lLCBzdGFydFRpbWUpIHtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lICsgdGhpcy50b1NlY29uZHMocmFtcFRpbWUpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgZXhwb25lbnRpYWxseSBhcHByb2FjaGluZyB0aGUgdGFyZ2V0IHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lIHdpdGhcblx0XHQgKiAgYSByYXRlIGhhdmluZyB0aGUgZ2l2ZW4gdGltZSBjb25zdGFudC5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHZhbHVlICAgICAgICBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWUgICAgXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB0aW1lQ29uc3RhbnQgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydFRpbWUsIHRpbWVDb25zdGFudCkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICAvLyBUaGUgdmFsdWUgd2lsbCBuZXZlciBiZSBhYmxlIHRvIGFwcHJvYWNoIHdpdGhvdXQgdGltZUNvbnN0YW50ID4gMC5cblx0ICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jZGZuLXNldFRhcmdldEF0VGltZSwgd2hlcmUgdGhlIGVxdWF0aW9uXG5cdCAgICAgICAgLy8gaXMgZGVzY3JpYmVkLiAwIHJlc3VsdHMgaW4gYSBkaXZpc2lvbiBieSAwLlxuXHQgICAgICAgIHZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LCB2YWx1ZSk7XG5cdCAgICAgICAgdGltZUNvbnN0YW50ID0gTWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKSwgdGltZUNvbnN0YW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0cyBhbiBhcnJheSBvZiBhcmJpdHJhcnkgcGFyYW1ldGVyIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqICBcdFxuXHRcdCAqICBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgICAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGR1cmF0aW9uICBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLnNldFZhbHVlQ3VydmVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFsdWVzW2ldID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlc1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFZhbHVlQ3VydmVBdFRpbWUodmFsdWVzLCB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpLCB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbikpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWxzIGFsbCBzY2hlZHVsZWQgcGFyYW1ldGVyIGNoYW5nZXMgd2l0aCB0aW1lcyBncmVhdGVyIHRoYW4gb3IgXG5cdFx0ICogIGVxdWFsIHRvIHN0YXJ0VGltZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzID0gZnVuY3Rpb24gKHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmFtcHMgdG8gdGhlIGdpdmVuIHZhbHVlIG92ZXIgdGhlIGR1cmF0aW9uIG9mIHRoZSByYW1wVGltZS4gXG5cdFx0ICogIEF1dG9tYXRpY2FsbHkgc2VsZWN0cyB0aGUgYmVzdCByYW1wIHR5cGUgKGV4cG9uZW50aWFsIG9yIGxpbmVhcilcblx0XHQgKiAgZGVwZW5kaW5nIG9uIHRoZSBgdW5pdHNgIG9mIHRoZSBzaWduYWxcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gcmFtcFRpbWUgXHRUaGUgdGltZSB0aGF0IGl0IHRha2VzIHRoZSBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vcmFtcCB0byB0aGUgdmFsdWUgZWl0aGVyIGxpbmVhcmx5IG9yIGV4cG9uZW50aWFsbHkgXG5cdFx0ICogLy9kZXBlbmRpbmcgb24gdGhlIFwidW5pdHNcIiB2YWx1ZSBvZiB0aGUgc2lnbmFsXG5cdFx0ICogc2lnbmFsLnJhbXBUbygwLCAxMCk7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zY2hlZHVsZSBpdCB0byByYW1wIHN0YXJ0aW5nIGF0IGEgc3BlY2lmaWMgdGltZVxuXHRcdCAqIHNpZ25hbC5yYW1wVG8oMCwgMTAsIDUpXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5yYW1wVG8gPSBmdW5jdGlvbiAodmFsdWUsIHJhbXBUaW1lLCBzdGFydFRpbWUpIHtcblx0ICAgICAgICByYW1wVGltZSA9IHRoaXMuZGVmYXVsdEFyZyhyYW1wVGltZSwgMCk7XG5cdCAgICAgICAgaWYgKHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5GcmVxdWVuY3kgfHwgdGhpcy51bml0cyA9PT0gVG9uZS5UeXBlLkJQTSkge1xuXHQgICAgICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWUodmFsdWUsIHJhbXBUaW1lLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWUodmFsdWUsIHJhbXBUaW1lLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIExGTyBjcmVhdGVkIGJ5IHRoZSBzaWduYWwgaW5zdGFuY2UuIElmIG5vbmVcblx0XHQgKiAgd2FzIGNyZWF0ZWQsIHRoaXMgaXMgbnVsbC5cblx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFyYW0jXG5cdFx0ICogIEBuYW1lIGxmb1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCAnbGZvJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMuX2xmbykge1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QYXJhbTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgdGhpbiB3cmFwcGVyIGFyb3VuZCB0aGUgTmF0aXZlIFdlYiBBdWRpbyBHYWluTm9kZS5cblx0XHQgKiAgICAgICAgIFRoZSBHYWluTm9kZSBpcyBhIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIG9mIHRoZSBXZWIgQXVkaW9cblx0XHQgKiAgICAgICAgIEFQSSBhbmQgaXMgdXNlZnVsIGZvciByb3V0aW5nIGF1ZGlvIGFuZCBhZGp1c3RpbmcgZ2FpbnMuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyPX0gIGdhaW4gIFRoZSBpbml0aWFsIGdhaW4gb2YgdGhlIEdhaW5Ob2RlXG5cdFx0ICogIEBwYXJhbSB7VG9uZS5UeXBlPX0gdW5pdHMgVGhlIHVuaXRzIG9mIHRoZSBnYWluIHBhcmFtZXRlci4gXG5cdFx0ICovXG5cdCAgICBUb25lLkdhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdnYWluJyxcblx0ICAgICAgICAgICAgJ3VuaXRzJ1xuXHQgICAgICAgIF0sIFRvbmUuR2Fpbi5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIEdhaW5Ob2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIHBhcmFtZXRlciBvZiB0aGUgZ2FpbiBub2RlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBhcmFtfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fZ2Fpbk5vZGUuZ2Fpbixcblx0ICAgICAgICAgICAgJ3VuaXRzJzogb3B0aW9ucy51bml0cyxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5nYWluLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IG9wdGlvbnMuY29udmVydFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdnYWluJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HYWluKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdnYWluJzogMSxcblx0ICAgICAgICAnY29udmVydCc6IHRydWVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkdhaW59ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdhaW4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9nYWluTm9kZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2dhaW4nKTtcblx0ICAgICAgICB0aGlzLmdhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLy9TVEFUSUMvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQ3JlYXRlIGlucHV0IGFuZCBvdXRwdXRzIGZvciB0aGlzIG9iamVjdC5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgaW5wdXQgICBUaGUgbnVtYmVyIG9mIGlucHV0c1xuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXI9fSAgb3V0cHV0cyAgVGhlIG51bWJlciBvZiBvdXRwdXRzXG5cdFx0ICogIEByZXR1cm4gIHtUb25lfSAgdGhpc1xuXHRcdCAqICBAaW50ZXJuYWxcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmNyZWF0ZUluc091dHMgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzKSB7XG5cdCAgICAgICAgaWYgKGlucHV0cyA9PT0gMSkge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRzID4gMSkge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0ID0gbmV3IEFycmF5KGlucHV0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvdXRwdXRzID09PSAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0cyA+IDEpIHtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgQXJyYXkoaW5wdXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICByZXR1cm4gVG9uZS5HYWluO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc2lnbmFsIGlzIGFuIGF1ZGlvLXJhdGUgdmFsdWUuIFRvbmUuU2lnbmFsIGlzIGEgY29yZSBjb21wb25lbnQgb2YgdGhlIGxpYnJhcnkuXG5cdFx0ICogICAgICAgICAgVW5saWtlIGEgbnVtYmVyLCBTaWduYWxzIGNhbiBiZSBzY2hlZHVsZWQgd2l0aCBzYW1wbGUtbGV2ZWwgYWNjdXJhY3kuIFRvbmUuU2lnbmFsXG5cdFx0ICogICAgICAgICAgaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdG8gbmF0aXZlIFdlYiBBdWRpbyBcblx0XHQgKiAgICAgICAgICBbQXVkaW9QYXJhbV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtYXVkaW9wYXJhbS1pbnRlcmZhY2UpXG5cdFx0ICogICAgICAgICAgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIGNvbnZlbmllbmNlcy4gUmVhZCBtb3JlIGFib3V0IHdvcmtpbmcgd2l0aCBzaWduYWxzIFxuXHRcdCAqICAgICAgICAgIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9TaWduYWxzKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuUGFyYW19XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfEF1ZGlvUGFyYW19IFt2YWx1ZV0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2lnbmFsLiBJZiBhbiBBdWRpb1BhcmFtXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFzc2VkIGluLCB0aGF0IHBhcmFtZXRlciB3aWxsIGJlIHdyYXBwZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29udHJvbGxlZCBieSB0aGUgU2lnbmFsLiBcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1OdW1iZXJdIHVuaXQgVGhlIHVuaXRzIHRoZSBzaWduYWwgaXMgaW4uIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMTApO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd2YWx1ZScsXG5cdCAgICAgICAgICAgICd1bml0cydcblx0ICAgICAgICBdLCBUb25lLlNpZ25hbC5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgbm9kZSB3aGVyZSB0aGUgY29uc3RhbnQgc2lnbmFsIHZhbHVlIGlzIHNjYWxlZC5cblx0XHRcdCAqIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMuX2dhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIG9wdGlvbnMucGFyYW0gPSB0aGlzLl9nYWluLmdhaW47XG5cdCAgICAgICAgVG9uZS5QYXJhbS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIHNldC5cblx0XHRcdCAqIEB0eXBlIHtUb25lLlBhcmFtfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLl9wYXJhbSA9IHRoaXMuX2dhaW4uZ2Fpbjtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIGNvbnN0IG91dHB1dCB0byB0aGUgbm9kZSBvdXRwdXRcblx0ICAgICAgICBUb25lLlNpZ25hbC5fY29uc3RhbnQuY2hhaW4odGhpcy5fZ2Fpbik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TaWduYWwsIFRvbmUuUGFyYW0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuU2lnbmFsLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd2YWx1ZSc6IDAsXG5cdCAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkRlZmF1bHQsXG5cdCAgICAgICAgJ2NvbnZlcnQnOiB0cnVlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFdoZW4gc2lnbmFscyBjb25uZWN0IHRvIG90aGVyIHNpZ25hbHMgb3IgQXVkaW9QYXJhbXMsIFxuXHRcdCAqICB0aGV5IHRha2Ugb3ZlciB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoYXQgc2lnbmFsIG9yIEF1ZGlvUGFyYW0uIFxuXHRcdCAqICBGb3IgYWxsIG90aGVyIG5vZGVzLCB0aGUgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYSBkZWZhdWx0IDxjb2RlPmNvbm5lY3Q8L2NvZGU+LiBcblx0XHQgKlxuXHRcdCAqICBAb3ZlcnJpZGVcblx0XHQgKiAgQHBhcmFtIHtBdWRpb1BhcmFtfEF1ZGlvTm9kZXxUb25lLlNpZ25hbHxUb25lfSBub2RlIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE51bWJlcj0wXSBUaGUgb3V0cHV0IG51bWJlciB0byBjb25uZWN0IGZyb20uXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXROdW1iZXI9MF0gVGhlIGlucHV0IG51bWJlciB0byBjb25uZWN0IHRvLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TaWduYWxCYXNlfSB0aGlzXG5cdFx0ICogIEBtZXRob2Rcblx0XHQgKi9cblx0ICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0ID0gVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5jb25uZWN0O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgYW5kIGRpc2Nvbm5lY3Rcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2dhaW4uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2dhaW4gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNUQVRJQ1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgR2VuZXJhdGVzIGEgY29uc3RhbnQgb3V0cHV0IG9mIDEuXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0ICovXG5cdCAgICBUb25lLlNpZ25hbC5fY29uc3RhbnQgPSBudWxsO1xuXHQgICAgLyoqXG5cdFx0ICogIGluaXRpYWxpemVyIGZ1bmN0aW9uXG5cdFx0ICovXG5cdCAgICBUb25lLl9pbml0QXVkaW9Db250ZXh0KGZ1bmN0aW9uIChhdWRpb0NvbnRleHQpIHtcblx0ICAgICAgICB2YXIgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxMjgsIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcblx0ICAgICAgICB2YXIgYXJyID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGFycltpXSA9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuU2lnbmFsLl9jb25zdGFudCA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0ICAgICAgICBUb25lLlNpZ25hbC5fY29uc3RhbnQuY2hhbm5lbENvdW50ID0gMTtcblx0ICAgICAgICBUb25lLlNpZ25hbC5fY29uc3RhbnQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgVG9uZS5TaWduYWwuX2NvbnN0YW50LmJ1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICBUb25lLlNpZ25hbC5fY29uc3RhbnQubG9vcCA9IHRydWU7XG5cdCAgICAgICAgVG9uZS5TaWduYWwuX2NvbnN0YW50LnN0YXJ0KDApO1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLl9jb25zdGFudC5ub0dDKCk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLlNpZ25hbDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgVGltZWxpbmUgY2xhc3MgZm9yIHNjaGVkdWxpbmcgYW5kIG1haW50YWluaW5nIHN0YXRlXG5cdFx0ICogICAgICAgICBhbG9uZyBhIHRpbWVsaW5lLiBBbGwgZXZlbnRzIG11c3QgaGF2ZSBhIFwidGltZVwiIHByb3BlcnR5LiBcblx0XHQgKiAgICAgICAgIEludGVybmFsbHksIGV2ZW50cyBhcmUgc3RvcmVkIGluIHRpbWUgb3JkZXIgZm9yIGZhc3QgXG5cdFx0ICogICAgICAgICByZXRyaWV2YWwuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge1Bvc2l0aXZlfSBbbWVtb3J5PUluZmluaXR5XSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIGV2ZW50cyB0aGF0IGFyZSByZXRhaW5lZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbJ21lbW9yeSddLCBUb25lLlRpbWVsaW5lLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYXJyYXkgb2Ygc2NoZWR1bGVkIHRpbWVsaW5lIGV2ZW50c1xuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQW4gYXJyYXkgb2YgaXRlbXMgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuIFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdG9SZW1vdmUgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBGbGFnIGlmIHRoZSB0aWVsaW5lIGlzIG1pZCBpdGVyYXRpb25cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gZmFsc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1lbW9yeSBvZiB0aGUgdGltZWxpbmUsIGkuZS5cblx0XHRcdCAqICBob3cgbWFueSBldmVudHMgaW4gdGhlIHBhc3QgaXQgd2lsbCByZXRhaW5cblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1lbW9yeSA9IG9wdGlvbnMubWVtb3J5O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVGltZWxpbmUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUuZGVmYXVsdHMgPSB7ICdtZW1vcnknOiBJbmZpbml0eSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UaW1lbGluZSNcblx0XHQgKiAgQG5hbWUgbGVuZ3RoXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVGltZWxpbmUucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmUubGVuZ3RoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEluc2VydCBhbiBldmVudCBvYmplY3Qgb250byB0aGUgdGltZWxpbmUuIEV2ZW50cyBtdXN0IGhhdmUgYSBcInRpbWVcIiBhdHRyaWJ1dGUuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0IHRvIGluc2VydCBpbnRvIHRoZSBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIC8vdGhlIGV2ZW50IG5lZWRzIHRvIGhhdmUgYSB0aW1lIGF0dHJpYnV0ZVxuXHQgICAgICAgIGlmICh0aGlzLmlzVW5kZWYoZXZlbnQudGltZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLlRpbWVsaW5lOiBldmVudHMgbXVzdCBoYXZlIGEgdGltZSBhdHRyaWJ1dGUnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2goZXZlbnQudGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnNwbGljZShpbmRleCArIDEsIDAsIGV2ZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lbGluZS5wdXNoKGV2ZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pZiB0aGUgbGVuZ3RoIGlzIG1vcmUgdGhhbiB0aGUgbWVtb3J5LCByZW1vdmUgdGhlIHByZXZpb3VzIG9uZXNcblx0ICAgICAgICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLm1lbW9yeSkge1xuXHQgICAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMubGVuZ3RoIC0gdGhpcy5tZW1vcnk7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnNwbGljZSgwLCBkaWZmKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSBhbiBldmVudCBmcm9tIHRoZSB0aW1lbGluZS5cblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3QgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICBpZiAodGhpcy5faXRlcmF0aW5nKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3RvUmVtb3ZlLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3RpbWVsaW5lLmluZGV4T2YoZXZlbnQpO1xuXHQgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIG5lYXJlc3QgZXZlbnQgd2hvc2UgdGltZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZXZlbnQgb2JqZWN0IHNldCBhZnRlciB0aGF0IHRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0ICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZVtpbmRleF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGZpcnN0IGV2ZW50IGluIHRoZSB0aW1lbGluZSB3aXRob3V0IHJlbW92aW5nIGl0XG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCBldmVudCBvYmplY3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lWzBdO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIGZpcnN0IGV2ZW50IGluIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0XG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCBldmVudCBvYmplY3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZS5zaGlmdCgpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIGV2ZW50IHdoaWNoIGlzIHNjaGVkdWxlZCBhZnRlciB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBldmVudCBvYmplY3QgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmdldEFmdGVyID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX3RpbWVsaW5lLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbaW5kZXggKyAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgZXZlbnQgYmVmb3JlIHRoZSBldmVudCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBldmVudCBvYmplY3QgYmVmb3JlIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5nZXRCZWZvcmUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciBsZW4gPSB0aGlzLl90aW1lbGluZS5sZW5ndGg7XG5cdCAgICAgICAgLy9pZiBpdCdzIGFmdGVyIHRoZSBsYXN0IGl0ZW0sIHJldHVybiB0aGUgbGFzdCBpdGVtXG5cdCAgICAgICAgaWYgKGxlbiA+IDAgJiYgdGhpcy5fdGltZWxpbmVbbGVuIC0gMV0udGltZSA8IHRpbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2xlbiAtIDFdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgaWYgKGluZGV4IC0gMSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZVtpbmRleCAtIDFdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGV2ZW50cyBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChhZnRlcikge1xuXHQgICAgICAgIGlmICh0aGlzLl90aW1lbGluZS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaChhZnRlcik7XG5cdCAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZWxpbmVbaW5kZXhdLnRpbWUgPT09IGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGZpcnN0IGl0ZW0gd2l0aCB0aGF0IHRpbWVcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aW1lbGluZVtpXS50aW1lID09PSBhZnRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZSgwLCBpbmRleCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gdGhpcy5fdGltZWxpbmUuc2xpY2UoMCwgaW5kZXggKyAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gW107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3RpbWVsaW5lLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAvL3RoZSBmaXJzdCBpdGVtJ3MgdGltZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fdGltZWxpbmVbMF0udGltZSA+PSBhZnRlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGV2ZW50cyBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIGNhbmNlbCBiZWZvcmUuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5jYW5jZWxCZWZvcmUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl90aW1lbGluZS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZShpbmRleCArIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEb2VzIGEgYmluYXJ5IHNlcmFjaCBvbiB0aGUgdGltZWxpbmUgYXJyYXkgYW5kIHJldHVybnMgdGhlIFxuXHRcdCAqICBuZWFyZXN0IGV2ZW50IGluZGV4IHdob3NlIHRpbWUgaXMgYWZ0ZXIgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIElmIGEgdGltZSBpcyBzZWFyY2hlZCBiZWZvcmUgdGhlIGZpcnN0IGluZGV4IGluIHRoZSB0aW1lbGluZSwgLTEgaXMgcmV0dXJuZWQuXG5cdFx0ICogIElmIHRoZSB0aW1lIGlzIGFmdGVyIHRoZSBlbmQsIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpdGVtIGlzIHJldHVybmVkLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBcblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gdGhlIGluZGV4IGluIHRoZSB0aW1lbGluZSBhcnJheSBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLl9zZWFyY2ggPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciBiZWdpbm5pbmcgPSAwO1xuXHQgICAgICAgIHZhciBsZW4gPSB0aGlzLl90aW1lbGluZS5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGVuZCA9IGxlbjtcblx0ICAgICAgICBpZiAobGVuID4gMCAmJiB0aGlzLl90aW1lbGluZVtsZW4gLSAxXS50aW1lIDw9IHRpbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlIChiZWdpbm5pbmcgPCBlbmQpIHtcblx0ICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludCBmb3Igcm91Z2hseSBlcXVhbCBwYXJ0aXRpb25cblx0ICAgICAgICAgICAgdmFyIG1pZFBvaW50ID0gTWF0aC5mbG9vcihiZWdpbm5pbmcgKyAoZW5kIC0gYmVnaW5uaW5nKSAvIDIpO1xuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl90aW1lbGluZVttaWRQb2ludF07XG5cdCAgICAgICAgICAgIHZhciBuZXh0RXZlbnQgPSB0aGlzLl90aW1lbGluZVttaWRQb2ludCArIDFdO1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQudGltZSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgLy9jaG9vc2UgdGhlIGxhc3Qgb25lIHRoYXQgaGFzIHRoZSBzYW1lIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtaWRQb2ludDsgaSA8IHRoaXMuX3RpbWVsaW5lLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RFdmVudCA9IHRoaXMuX3RpbWVsaW5lW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0RXZlbnQudGltZSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtaWRQb2ludCA9IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1pZFBvaW50O1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnRpbWUgPCB0aW1lICYmIG5leHRFdmVudC50aW1lID4gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1pZFBvaW50O1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnRpbWUgPiB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAvL3NlYXJjaCBsb3dlclxuXHQgICAgICAgICAgICAgICAgZW5kID0gbWlkUG9pbnQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGltZSA8IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vc2VhcmNoIHVwcGVyXG5cdCAgICAgICAgICAgICAgICBiZWdpbm5pbmcgPSBtaWRQb2ludCArIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBpdGVyYXRvci4gQXBwbGllcyBleHRyYSBzYWZldHkgY2hlY2tzIGZvciBcblx0XHQgKiAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgYXJyYXkuIFxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXI9fSAgICBsb3dlckJvdW5kICAgICBcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyPX0gICAgdXBwZXJCb3VuZCAgICBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG5cdCAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gdHJ1ZTtcblx0ICAgICAgICBsb3dlckJvdW5kID0gdGhpcy5kZWZhdWx0QXJnKGxvd2VyQm91bmQsIDApO1xuXHQgICAgICAgIHVwcGVyQm91bmQgPSB0aGlzLmRlZmF1bHRBcmcodXBwZXJCb3VuZCwgdGhpcy5fdGltZWxpbmUubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IGxvd2VyQm91bmQ7IGkgPD0gdXBwZXJCb3VuZDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuX3RpbWVsaW5lW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKHRoaXMuX3RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl90b1JlbW92ZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdGltZWxpbmUuaW5kZXhPZih0aGlzLl90b1JlbW92ZVtqXSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90b1JlbW92ZSA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5XG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLl9pdGVyYXRlKGNhbGxiYWNrKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGF0IG9yIGJlZm9yZSB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hCZWZvcmUgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgaXRlbXMgaW4gcmV2ZXJzZSBzbyB0aGF0IHJlbW92aW5nIGFuIGl0ZW0gZG9lc24ndCBicmVhayB0aGluZ3Ncblx0ICAgICAgICB2YXIgdXBwZXJCb3VuZCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0ICAgICAgICBpZiAodXBwZXJCb3VuZCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdGhpcy5faXRlcmF0ZShjYWxsYmFjaywgMCwgdXBwZXJCb3VuZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQWZ0ZXIgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgaXRlbXMgaW4gcmV2ZXJzZSBzbyB0aGF0IHJlbW92aW5nIGFuIGl0ZW0gZG9lc24ndCBicmVhayB0aGluZ3Ncblx0ICAgICAgICB2YXIgbG93ZXJCb3VuZCA9IHRoaXMuX3NlYXJjaCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9pdGVyYXRlKGNhbGxiYWNrLCBsb3dlckJvdW5kICsgMSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBhdCBvciBhZnRlciB0aGUgZ2l2ZW4gdGltZS4gU2ltaWxhciB0byBcblx0XHQgKiAgZm9yRWFjaEFmdGVyLCBidXQgaW5jbHVkZXMgdGhlIGl0ZW0ocykgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoRnJvbSA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiByZXZlcnNlIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGJyZWFrIHRoaW5nc1xuXHQgICAgICAgIHZhciBsb3dlckJvdW5kID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgIC8vd29yayBiYWNrd2FyZHMgdW50aWwgdGhlIGV2ZW50IHRpbWUgaXMgbGVzcyB0aGFuIHRpbWVcblx0ICAgICAgICB3aGlsZSAobG93ZXJCb3VuZCA+PSAwICYmIHRoaXMuX3RpbWVsaW5lW2xvd2VyQm91bmRdLnRpbWUgPj0gdGltZSkge1xuXHQgICAgICAgICAgICBsb3dlckJvdW5kLS07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2ssIGxvd2VyQm91bmQgKyAxKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgLy9pdGVyYXRlIG92ZXIgdGhlIGl0ZW1zIGluIHJldmVyc2Ugc28gdGhhdCByZW1vdmluZyBhbiBpdGVtIGRvZXNuJ3QgYnJlYWsgdGhpbmdzXG5cdCAgICAgICAgdmFyIHVwcGVyQm91bmQgPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgaWYgKHVwcGVyQm91bmQgIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGUoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGltZSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgMCwgdXBwZXJCb3VuZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZWxpbmV9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl90aW1lbGluZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdG9SZW1vdmUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSBzaWduYWwgd2hpY2ggYWRkcyB0aGUgbWV0aG9kIGdldFZhbHVlQXRUaW1lLiBcblx0XHQgKiAgICAgICAgIENvZGUgYW5kIGluc3BpcmF0aW9uIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzYW50ZWxsL3dlYi1hdWRpby1hdXRvbWF0aW9uLXRpbWVsaW5lXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlBhcmFtfVxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IHZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBzaWduYWxcblx0XHQgKiAgQHBhcmFtIHtTdHJpbmc9fSB1bml0cyBUaGUgY29udmVyc2lvbiB1bml0cyBvZiB0aGUgc2lnbmFsLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgJ3VuaXRzJ1xuXHQgICAgICAgIF0sIFRvbmUuU2lnbmFsLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2NoZWR1bGVkIGV2ZW50c1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLlRpbWVsaW5lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgVG9uZS5UaW1lbGluZSgxMCk7XG5cdCAgICAgICAgLy9jb25zdHJ1Y3RvcnNcblx0ICAgICAgICBUb25lLlNpZ25hbC5hcHBseSh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICBvcHRpb25zLnBhcmFtID0gdGhpcy5fcGFyYW07XG5cdCAgICAgICAgVG9uZS5QYXJhbS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbml0aWFsIHNjaGVkdWxlZCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2luaXRpYWwgPSB0aGlzLl9mcm9tVW5pdHModGhpcy5fcGFyYW0udmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVGltZWxpbmVTaWduYWwsIFRvbmUuUGFyYW0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBldmVudCB0eXBlcyBvZiBhIHNjaGVkdWxhYmxlIHNpZ25hbC5cblx0XHQgKiAgQGVudW0ge1N0cmluZ31cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZSA9IHtcblx0ICAgICAgICBMaW5lYXI6ICdsaW5lYXInLFxuXHQgICAgICAgIEV4cG9uZW50aWFsOiAnZXhwb25lbnRpYWwnLFxuXHQgICAgICAgIFRhcmdldDogJ3RhcmdldCcsXG5cdCAgICAgICAgQ3VydmU6ICdjdXJ2ZScsXG5cdCAgICAgICAgU2V0OiAnc2V0J1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzaWduYWwuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlRpbWVsaW5lU2lnbmFsI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobm93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvVW5pdHModmFsKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRWYWwgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9pbml0aWFsID0gY29udmVydGVkVmFsO1xuXHQgICAgICAgICAgICB0aGlzLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS52YWx1ZSA9IGNvbnZlcnRlZFZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNDSEVEVUxJTkdcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhIHBhcmFtZXRlciB2YWx1ZSBjaGFuZ2UgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSB7Kn1cdHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHNpZ25hbC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSAgdGltZSBUaGUgdGltZSB3aGVuIHRoZSBjaGFuZ2Ugc2hvdWxkIG9jY3VyLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IHRoZSBmcmVxdWVuY3kgdG8gXCJHNFwiIGluIGV4YWN0bHkgMSBzZWNvbmQgZnJvbSBub3cuIFxuXHRcdCAqIGZyZXEuc2V0VmFsdWVBdFRpbWUoXCJHNFwiLCBcIisxXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5hZGQoe1xuXHQgICAgICAgICAgICAndHlwZSc6IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5TZXQsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuXHQgICAgICAgICAgICAndGltZSc6IHN0YXJ0VGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vaW52b2tlIHRoZSBvcmlnaW5hbCBldmVudFxuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFZhbHVlQXRUaW1lKHZhbHVlLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYSBsaW5lYXIgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb20gdGhlIFxuXHRcdCAqICBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZSBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBlbmRUaW1lKSB7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIGVuZFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyLFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBlbmRUaW1lXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb20gXG5cdFx0ICogIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZSBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIGVuZFRpbWUpIHtcblx0ICAgICAgICAvL2dldCB0aGUgcHJldmlvdXMgZXZlbnQgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBzdGFydGluZyBmcm9tIDBcblx0ICAgICAgICBlbmRUaW1lID0gdGhpcy50b1NlY29uZHMoZW5kVGltZSk7XG5cdCAgICAgICAgdmFyIGJlZm9yZUV2ZW50ID0gdGhpcy5fc2VhcmNoQmVmb3JlKGVuZFRpbWUpO1xuXHQgICAgICAgIGlmIChiZWZvcmVFdmVudCAmJiBiZWZvcmVFdmVudC52YWx1ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICAvL3Jlc2NoZWR1bGUgdGhhdCBldmVudFxuXHQgICAgICAgICAgICB0aGlzLnNldFZhbHVlQXRUaW1lKHRoaXMuX21pbk91dHB1dCwgYmVmb3JlRXZlbnQudGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICB2YXIgc2V0VmFsdWUgPSBNYXRoLm1heCh2YWx1ZSwgdGhpcy5fbWluT3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuRXhwb25lbnRpYWwsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IHNldFZhbHVlLFxuXHQgICAgICAgICAgICAndGltZSc6IGVuZFRpbWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2lmIHRoZSByYW1wZWQgdG8gdmFsdWUgaXMgMCwgbWFrZSBpdCBnbyB0byB0aGUgbWluIG91dHB1dCwgYW5kIHRoZW4gc2V0IHRvIDAuXG5cdCAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5fbWluT3V0cHV0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fbWluT3V0cHV0LCBlbmRUaW1lIC0gdGhpcy5zYW1wbGVUaW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUF0VGltZSgwLCBlbmRUaW1lKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBlbmRUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZSB3aXRoXG5cdFx0ICogIGEgcmF0ZSBoYXZpbmcgdGhlIGdpdmVuIHRpbWUgY29uc3RhbnQuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAgICAgICAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lICAgIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdGltZUNvbnN0YW50IFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpcyBcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFRhcmdldEF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHZhbHVlKTtcblx0ICAgICAgICB0aW1lQ29uc3RhbnQgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuVGFyZ2V0LFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBzdGFydFRpbWUsXG5cdCAgICAgICAgICAgICdjb25zdGFudCc6IHRpbWVDb25zdGFudFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYW4gYXJyYXkgb2YgYXJiaXRyYXJ5IHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZSBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmFsdWVzICAgICAgICBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWUgICAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb25cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3NjYWxpbmc9MV0gSWYgdGhlIHZhbHVlcyBpbiB0aGUgY3VydmUgc2hvdWxkIGJlIHNjYWxlZCBieSBzb21lIHZhbHVlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVDdXJ2ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHN0YXJ0VGltZSwgZHVyYXRpb24sIHNjYWxpbmcpIHtcblx0ICAgICAgICBzY2FsaW5nID0gdGhpcy5kZWZhdWx0QXJnKHNjYWxpbmcsIDEpO1xuXHQgICAgICAgIC8vY29weSB0aGUgYXJyYXlcblx0ICAgICAgICB2YXIgZmxvYXRzID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmxvYXRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGZsb2F0c1tpXSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZXNbaV0pICogc2NhbGluZztcblx0ICAgICAgICB9XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuQ3VydmUsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IGZsb2F0cyxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBzdGFydFRpbWUsXG5cdCAgICAgICAgICAgICdkdXJhdGlvbic6IGR1cmF0aW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGZpcnN0IHZhbHVlXG5cdCAgICAgICAgdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUoZmxvYXRzWzBdLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIC8vc2NoZWR1bGUgYSBsaWVuYXIgcmFtcCBmb3IgZWFjaCBvZiB0aGUgc2VnbWVudHNcblx0ICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGZsb2F0cy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICB2YXIgc2VnbWVudFRpbWUgPSBzdGFydFRpbWUgKyBqIC8gKGZsb2F0cy5sZW5ndGggLSAxKSAqIGR1cmF0aW9uO1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShmbG9hdHNbal0sIHNlZ21lbnRUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbHMgYWxsIHNjaGVkdWxlZCBwYXJhbWV0ZXIgY2hhbmdlcyB3aXRoIHRpbWVzIGdyZWF0ZXIgdGhhbiBvciBcblx0XHQgKiAgZXF1YWwgdG8gc3RhcnRUaW1lLlxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICBhZnRlciA9IHRoaXMudG9TZWNvbmRzKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuY2FuY2VsKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoYWZ0ZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBjb21wdXRlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gVGhpcyBwcm92aWRlc1xuXHRcdCAqICBhIHBvaW50IGZyb20gd2hpY2ggYSBsaW5lYXIgb3IgZXhwb25lbnRpYWwgY3VydmVcblx0XHQgKiAgY2FuIGJlIHNjaGVkdWxlZCBhZnRlci4gV2lsbCBjYW5jZWwgZXZlbnRzIGFmdGVyIFxuXHRcdCAqICB0aGUgZ2l2ZW4gdGltZSBhbmQgc2hvcnRlbiB0aGUgY3VycmVudGx5IHNjaGVkdWxlZFxuXHRcdCAqICBsaW5lYXIgb3IgZXhwb25lbnRpYWwgcmFtcCBzbyB0aGF0IGl0IGVuZHMgYXQgYHRpbWVgIC5cblx0XHQgKiAgVGhpcyBpcyB0byBhdm9pZCBkaXNjb250aW51aXRpZXMgYW5kIGNsaWNrcyBpbiBlbnZlbG9wZXMuIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWUgV2hlbiB0byBzZXQgdGhlIHJhbXAgcG9pbnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFJhbXBQb2ludCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIC8vZ2V0IHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgIHZhciB2YWwgPSB0aGlzLl90b1VuaXRzKHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSkpO1xuXHQgICAgICAgIC8vaWYgdGhlcmUgaXMgYW4gZXZlbnQgYXQgdGhlIGdpdmVuIHRpbWVcblx0ICAgICAgICAvL2FuZCB0aGF0IGV2ZW4gaXMgbm90IGEgXCJzZXRcIlxuXHQgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLl9zZWFyY2hCZWZvcmUodGltZSk7XG5cdCAgICAgICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudGltZSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAvL3JlbW92ZSBldmVyeXRoaW5nIGFmdGVyXG5cdCAgICAgICAgICAgIHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUgKyB0aGlzLnNhbXBsZVRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlICYmIGJlZm9yZS50eXBlID09PSBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuQ3VydmUgJiYgYmVmb3JlLnRpbWUgKyBiZWZvcmUuZHVyYXRpb24gPiB0aW1lKSB7XG5cdCAgICAgICAgICAgIC8vaWYgdGhlIGN1cnZlIGlzIHN0aWxsIHBsYXlpbmdcblx0ICAgICAgICAgICAgLy9jYW5jZWwgdGhlIGN1cnZlXG5cdCAgICAgICAgICAgIHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9yZXNjaGVkdWxlIHRoZSBuZXh0IGV2ZW50IHRvIGVuZCBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLl9zZWFyY2hBZnRlcih0aW1lKTtcblx0ICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAvL2NhbmNlbCB0aGUgbmV4dCBldmVudChzKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkxpbmVhcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkV4cG9uZW50aWFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUF0VGltZSh2YWwsIHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRG8gYSBsaW5lYXIgcmFtcCB0byB0aGUgZ2l2ZW4gdmFsdWUgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGZpbmlzaCB0aW1lcy5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byByYW1wIHRvLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0IFRoZSBiZWdpbm5pbmcgYW5jaG9yIHBvaW50IHRvIGRvIHRoZSBsaW5lYXIgcmFtcFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGZpbmlzaCBUaGUgZW5kaW5nIGFuY2hvciBwb2ludCBieSB3aGljaCB0aGUgdmFsdWUgb2Zcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNpZ25hbCB3aWxsIGVxdWFsIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQmV0d2VlbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGZpbmlzaCkge1xuXHQgICAgICAgIHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0KTtcblx0ICAgICAgICB0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBmaW5pc2gpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEbyBhIGV4cG9uZW50aWFsIHJhbXAgdG8gdGhlIGdpdmVuIHZhbHVlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBmaW5pc2ggdGltZXMuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydCBUaGUgYmVnaW5uaW5nIGFuY2hvciBwb2ludCB0byBkbyB0aGUgZXhwb25lbnRpYWwgcmFtcFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGZpbmlzaCBUaGUgZW5kaW5nIGFuY2hvciBwb2ludCBieSB3aGljaCB0aGUgdmFsdWUgb2Zcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNpZ25hbCB3aWxsIGVxdWFsIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVCZXR3ZWVuID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZmluaXNoKSB7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQoc3RhcnQpO1xuXHQgICAgICAgIHRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZmluaXNoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRHRVRUSU5HIFNDSEVEVUxFRCBWQUxVRVNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIGJlZm9yZSBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeVxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgVGhlIGV2ZW50IGF0IG9yIGJlZm9yZSB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9zZWFyY2hCZWZvcmUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZ2V0KHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZXZlbnQgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICBUaGUgbmV4dCBldmVudCBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX3NlYXJjaEFmdGVyID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmdldEFmdGVyKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gVGhpcyB3aWxsXG5cdFx0ICogIHJldHVybiB0aGUgdW5jb252ZXJ0ZWQgKHJhdykgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIGluIHNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICBUaGUgc2NoZWR1bGVkIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZ2V0VmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLl9zZWFyY2hBZnRlcih0aW1lKTtcblx0ICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5fc2VhcmNoQmVmb3JlKHRpbWUpO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgLy9pZiBpdCB3YXMgc2V0IGJ5XG5cdCAgICAgICAgaWYgKGJlZm9yZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgfSBlbHNlIGlmIChiZWZvcmUudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLlRhcmdldCkge1xuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9ldmVudHMuZ2V0QmVmb3JlKGJlZm9yZS50aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VWYWw7XG5cdCAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcHJldmlvdVZhbCA9IHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwcmV2aW91VmFsID0gcHJldmlvdXMudmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9leHBvbmVudGlhbEFwcHJvYWNoKGJlZm9yZS50aW1lLCBwcmV2aW91VmFsLCBiZWZvcmUudmFsdWUsIGJlZm9yZS5jb25zdGFudCwgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChiZWZvcmUudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkN1cnZlKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fY3VydmVJbnRlcnBvbGF0ZShiZWZvcmUudGltZSwgYmVmb3JlLnZhbHVlLCBiZWZvcmUuZHVyYXRpb24sIHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBiZWZvcmUudmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChhZnRlci50eXBlID09PSBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fbGluZWFySW50ZXJwb2xhdGUoYmVmb3JlLnRpbWUsIGJlZm9yZS52YWx1ZSwgYWZ0ZXIudGltZSwgYWZ0ZXIudmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkV4cG9uZW50aWFsKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZXhwb25lbnRpYWxJbnRlcnBvbGF0ZShiZWZvcmUudGltZSwgYmVmb3JlLnZhbHVlLCBhZnRlci50aW1lLCBhZnRlci52YWx1ZSwgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBiZWZvcmUudmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgV2hlbiBzaWduYWxzIGNvbm5lY3QgdG8gb3RoZXIgc2lnbmFscyBvciBBdWRpb1BhcmFtcywgXG5cdFx0ICogIHRoZXkgdGFrZSBvdmVyIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhhdCBzaWduYWwgb3IgQXVkaW9QYXJhbS4gXG5cdFx0ICogIEZvciBhbGwgb3RoZXIgbm9kZXMsIHRoZSBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBhIGRlZmF1bHQgPGNvZGU+Y29ubmVjdDwvY29kZT4uIFxuXHRcdCAqXG5cdFx0ICogIEBvdmVycmlkZVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvUGFyYW18QXVkaW9Ob2RlfFRvbmUuU2lnbmFsfFRvbmV9IG5vZGUgXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bWJlcj0wXSBUaGUgaW5wdXQgbnVtYmVyIHRvIGNvbm5lY3QgdG8uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICogIEBtZXRob2Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNvbm5lY3QgPSBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRBVVRPTUFUSU9OIENVUlZFIENBTENVTEFUSU9OU1xuXHQgICAgLy9cdE1JVCBMaWNlbnNlLCBjb3B5cmlnaHQgKGMpIDIwMTQgSm9yZGFuIFNhbnRlbGxcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIENhbGN1bGF0ZXMgdGhlIHRoZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgcHJvZHVjZWQgYnkgc2V0VGFyZ2V0QXRUaW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fZXhwb25lbnRpYWxBcHByb2FjaCA9IGZ1bmN0aW9uICh0MCwgdjAsIHYxLCB0aW1lQ29uc3RhbnQsIHQpIHtcblx0ICAgICAgICByZXR1cm4gdjEgKyAodjAgLSB2MSkgKiBNYXRoLmV4cCgtKHQgLSB0MCkgLyB0aW1lQ29uc3RhbnQpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IGxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fbGluZWFySW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodDAsIHYwLCB0MSwgdjEsIHQpIHtcblx0ICAgICAgICByZXR1cm4gdjAgKyAodjEgLSB2MCkgKiAoKHQgLSB0MCkgLyAodDEgLSB0MCkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IGV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9leHBvbmVudGlhbEludGVycG9sYXRlID0gZnVuY3Rpb24gKHQwLCB2MCwgdDEsIHYxLCB0KSB7XG5cdCAgICAgICAgdjAgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHYwKTtcblx0ICAgICAgICByZXR1cm4gdjAgKiBNYXRoLnBvdyh2MSAvIHYwLCAodCAtIHQwKSAvICh0MSAtIHQwKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbGN1bGF0ZXMgdGhlIHRoZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgcHJvZHVjZWQgYnkgc2V0VmFsdWVDdXJ2ZUF0VGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX2N1cnZlSW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoc3RhcnQsIGN1cnZlLCBkdXJhdGlvbiwgdGltZSkge1xuXHQgICAgICAgIHZhciBsZW4gPSBjdXJ2ZS5sZW5ndGg7XG5cdCAgICAgICAgLy8gSWYgdGltZSBpcyBhZnRlciBkdXJhdGlvbiwgcmV0dXJuIHRoZSBsYXN0IGN1cnZlIHZhbHVlXG5cdCAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnQgKyBkdXJhdGlvbikge1xuXHQgICAgICAgICAgICByZXR1cm4gY3VydmVbbGVuIC0gMV07XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aW1lIDw9IHN0YXJ0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjdXJ2ZVswXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAodGltZSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXHQgICAgICAgICAgICB2YXIgbG93ZXJJbmRleCA9IE1hdGguZmxvb3IoKGxlbiAtIDEpICogcHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICB2YXIgdXBwZXJJbmRleCA9IE1hdGguY2VpbCgobGVuIC0gMSkgKiBwcm9ncmVzcyk7XG5cdCAgICAgICAgICAgIHZhciBsb3dlclZhbCA9IGN1cnZlW2xvd2VySW5kZXhdO1xuXHQgICAgICAgICAgICB2YXIgdXBwZXJWYWwgPSBjdXJ2ZVt1cHBlckluZGV4XTtcblx0ICAgICAgICAgICAgaWYgKHVwcGVySW5kZXggPT09IGxvd2VySW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsb3dlclZhbDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lYXJJbnRlcnBvbGF0ZShsb3dlckluZGV4LCBsb3dlclZhbCwgdXBwZXJJbmRleCwgdXBwZXJWYWwsIHByb2dyZXNzICogKGxlbiAtIDEpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lU2lnbmFsO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgUG93IGFwcGxpZXMgYW4gZXhwb25lbnQgdG8gdGhlIGluY29taW5nIHNpZ25hbC4gVGhlIGluY29taW5nIHNpZ25hbFxuXHRcdCAqICAgICAgICAgbXVzdCBiZSBBdWRpb1JhbmdlLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge1Bvc2l0aXZlfSBleHAgVGhlIGV4cG9uZW50IHRvIGFwcGx5IHRvIHRoZSBpbmNvbWluZyBzaWduYWwsIG11c3QgYmUgYXQgbGVhc3QgMi4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBvdyA9IG5ldyBUb25lLlBvdygyKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDAuNSkuY29ubmVjdChwb3cpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIHBvdyBpcyAwLjI1LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuUG93ID0gZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogdGhlIGV4cG9uZW50XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHR5cGUge251bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V4cCA9IHRoaXMuZGVmYXVsdEFyZyhleHAsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwU2NhbGVyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcih0aGlzLl9leHBGdW5jKHRoaXMuX2V4cCksIDgxOTIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUG93LCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHZhbHVlIG9mIHRoZSBleHBvbmVudC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Qb3cjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUG93LnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZXhwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V4cCA9IGV4cDtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwU2NhbGVyLnNldE1hcCh0aGlzLl9leHBGdW5jKHRoaXMuX2V4cCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBmdW5jdGlvbiB3aGljaCBtYXBzIHRoZSB3YXZlc2hhcGVyXG5cdFx0ICogIEBwYXJhbSAgIHtudW1iZXJ9IGV4cFxuXHRcdCAqICBAcmV0dXJuIHtmdW5jdGlvbn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUG93LnByb3RvdHlwZS5fZXhwRnVuYyA9IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coTWF0aC5hYnModmFsKSwgZXhwKTtcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG93fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBvdy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZXhwU2NhbGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9leHBTY2FsZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBvdztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkVudmVsb3BlIGlzIGFuIFtBRFNSXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW50aGVzaXplciNBRFNSX2VudmVsb3BlKVxuXHRcdCAqICAgICAgICAgIGVudmVsb3BlIGdlbmVyYXRvci4gVG9uZS5FbnZlbG9wZSBvdXRwdXRzIGEgc2lnbmFsIHdoaWNoIFxuXHRcdCAqICAgICAgICAgIGNhbiBiZSBjb25uZWN0ZWQgdG8gYW4gQXVkaW9QYXJhbSBvciBUb25lLlNpZ25hbC4gXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2UvZWEvQURTUl9wYXJhbWV0ZXIuc3ZnXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFthdHRhY2tdIFRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlIHRvIGdvIGZyb20gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgMCB0byBpdCdzIG1heGltdW0gdmFsdWUuIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtkZWNheV1cdFRoZSBwZXJpb2Qgb2YgdGltZSBhZnRlciB0aGUgYXR0YWNrIHRoYXQgaXQgdGFrZXMgZm9yIHRoZSBlbnZlbG9wZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICBcdHRvIGZhbGwgdG8gdGhlIHN1c3RhaW4gdmFsdWUuIFxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbc3VzdGFpbl1cdFRoZSBwZXJjZW50IG9mIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIGVudmVsb3BlIHJlc3RzIGF0IHVudGlsXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0dGhlIHJlbGVhc2UgaXMgdHJpZ2dlcmVkLiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbcmVsZWFzZV1cdFRoZSBhbW91bnQgb2YgdGltZSBhZnRlciB0aGUgcmVsZWFzZSBpcyB0cmlnZ2VyZWQgaXQgdGFrZXMgdG8gcmVhY2ggMC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hbiBhbXBsaXR1ZGUgZW52ZWxvcGVcblx0XHQgKiB2YXIgZ2Fpbk5vZGUgPSBUb25lLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdCAqIHZhciBlbnYgPSBuZXcgVG9uZS5FbnZlbG9wZSh7XG5cdFx0ICogXHRcImF0dGFja1wiIDogMC4xLFxuXHRcdCAqIFx0XCJkZWNheVwiIDogMC4yLFxuXHRcdCAqIFx0XCJzdXN0YWluXCIgOiAxLFxuXHRcdCAqIFx0XCJyZWxlYXNlXCIgOiAwLjgsXG5cdFx0ICogfSk7XG5cdFx0ICogZW52LmNvbm5lY3QoZ2Fpbk5vZGUuZ2Fpbik7XG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vZ2V0IGFsbCBvZiB0aGUgZGVmYXVsdHNcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdkZWNheScsXG5cdCAgICAgICAgICAgICdzdXN0YWluJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5FbnZlbG9wZS5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIFdoZW4gdHJpZ2dlckF0dGFjayBpcyBjYWxsZWQsIHRoZSBhdHRhY2sgdGltZSBpcyB0aGUgYW1vdW50IG9mXG5cdFx0XHQgKiAgdGltZSBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlIHRvIHJlYWNoIGl0J3MgbWF4aW11bSB2YWx1ZS4gXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFjayA9IG9wdGlvbnMuYXR0YWNrO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFmdGVyIHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUsIHRoZSB2YWx1ZSB3aWxsIGZhbGxcblx0XHRcdCAqICBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgZGVjYXkgdGltZSB0byBpdCdzIHN1c3RhaW4gdmFsdWUuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWNheSA9IG9wdGlvbnMuZGVjYXk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBcdFRoZSBzdXN0YWluIHZhbHVlIGlzIHRoZSB2YWx1ZSBcblx0XHRcdCAqIFx0d2hpY2ggdGhlIGVudmVsb3BlIHJlc3RzIGF0IGFmdGVyIHRyaWdnZXJBdHRhY2sgaXNcblx0XHRcdCAqIFx0Y2FsbGVkLCBidXQgYmVmb3JlIHRyaWdnZXJSZWxlYXNlIGlzIGludm9rZWQuIFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuc3VzdGFpbiA9IG9wdGlvbnMuc3VzdGFpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBZnRlciB0cmlnZ2VyUmVsZWFzZSBpcyBjYWxsZWQsIHRoZSBlbnZlbG9wZSdzXG5cdFx0XHQgKiAgdmFsdWUgd2lsbCBmYWxsIHRvIGl0J3MgbWltaW51bSB2YWx1ZSBvdmVyIHRoZVxuXHRcdFx0ICogIGR1cmF0aW9uIG9mIHRoZSByZWxlYXNlIHRpbWUuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yZWxlYXNlID0gb3B0aW9ucy5yZWxlYXNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBuZXh0IHRpbWUgdGhlIGVudmVsb3BlIGlzIGF0IHN0YW5kYnlcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hdHRhY2tDdXJ2ZSA9ICdsaW5lYXInO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBuZXh0IHRpbWUgdGhlIGVudmVsb3BlIGlzIGF0IHN0YW5kYnlcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yZWxlYXNlQ3VydmUgPSAnZXhwb25lbnRpYWwnO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZVNpZ25hbH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2lnID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5UaW1lbGluZVNpZ25hbCgpO1xuXHQgICAgICAgIHRoaXMuX3NpZy5zZXRWYWx1ZUF0VGltZSgwLCAwKTtcblx0ICAgICAgICAvL3NldCB0aGUgYXR0YWNrQ3VydmUgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5hdHRhY2tDdXJ2ZSA9IG9wdGlvbnMuYXR0YWNrQ3VydmU7XG5cdCAgICAgICAgdGhpcy5yZWxlYXNlQ3VydmUgPSBvcHRpb25zLnJlbGVhc2VDdXJ2ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkVudmVsb3BlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICdkZWNheSc6IDAuMSxcblx0ICAgICAgICAnc3VzdGFpbic6IDAuNSxcblx0ICAgICAgICAncmVsZWFzZSc6IDEsXG5cdCAgICAgICAgJ2F0dGFja0N1cnZlJzogJ2xpbmVhcicsXG5cdCAgICAgICAgJ3JlbGVhc2VDdXJ2ZSc6ICdleHBvbmVudGlhbCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZWFkIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBlbnZlbG9wZS4gVXNlZnVsIGZvciBcblx0XHQgKiBzeW5jcm9uaXppbmcgdmlzdWFsIG91dHB1dCB0byB0aGUgZW52ZWxvcGUuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkVudmVsb3BlI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkVudmVsb3BlLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBzaGFwZSBvZiB0aGUgYXR0YWNrLiBcblx0XHQgKiBDYW4gYmUgYW55IG9mIHRoZXNlIHN0cmluZ3M6XG5cdFx0ICogPHVsPlxuXHRcdCAqICAgPGxpPmxpbmVhcjwvbGk+XG5cdFx0ICogICA8bGk+ZXhwb25lbnRpYWw8L2xpPlxuXHRcdCAqICAgPGxpPnNpbmU8L2xpPlxuXHRcdCAqICAgPGxpPmNvc2luZTwvbGk+XG5cdFx0ICogICA8bGk+Ym91bmNlPC9saT5cblx0XHQgKiAgIDxsaT5yaXBwbGU8L2xpPlxuXHRcdCAqICAgPGxpPnN0ZXA8L2xpPlxuXHRcdCAqIDwvdWw+XG5cdFx0ICogQ2FuIGFsc28gYmUgYW4gYXJyYXkgd2hpY2ggZGVzY3JpYmVzIHRoZSBjdXJ2ZS4gVmFsdWVzXG5cdFx0ICogaW4gdGhlIGFycmF5IGFyZSBldmVubHkgc3ViZGl2aWRlZCBhbmQgbGluZWFybHlcblx0XHQgKiBpbnRlcnBvbGF0ZWQgb3ZlciB0aGUgZHVyYXRpb24gb2YgdGhlIGF0dGFjay4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge1N0cmluZ3xBcnJheX1cblx0XHQgKiBAbmFtZSBhdHRhY2tDdXJ2ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogZW52LmF0dGFja0N1cnZlID0gXCJsaW5lYXJcIjtcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vY2FuIGFsc28gYmUgYW4gYXJyYXlcblx0XHQgKiBlbnYuYXR0YWNrQ3VydmUgPSBbMCwgMC4yLCAwLjMsIDAuNCwgMV1cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkVudmVsb3BlLnByb3RvdHlwZSwgJ2F0dGFja0N1cnZlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pc1N0cmluZyh0aGlzLl9hdHRhY2tDdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2tDdXJ2ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQXJyYXkodGhpcy5fYXR0YWNrQ3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICAvL2xvb2sgdXAgdGhlIG5hbWUgaW4gdGhlIGN1cnZlcyBhcnJheVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBUb25lLkVudmVsb3BlLlR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoVG9uZS5FbnZlbG9wZS5UeXBlW3R5cGVdLkluID09PSB0aGlzLl9hdHRhY2tDdXJ2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgYXJyYXlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2tDdXJ2ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoY3VydmUpIHtcblx0ICAgICAgICAgICAgLy9jaGVjayBpZiBpdCdzIGEgdmFsaWQgdHlwZVxuXHQgICAgICAgICAgICBpZiAoVG9uZS5FbnZlbG9wZS5UeXBlLmhhc093blByb3BlcnR5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGVmID0gVG9uZS5FbnZlbG9wZS5UeXBlW2N1cnZlXTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KGN1cnZlRGVmKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFja0N1cnZlID0gY3VydmVEZWYuSW47XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFja0N1cnZlID0gY3VydmVEZWY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0FycmF5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNrQ3VydmUgPSBjdXJ2ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5FbnZlbG9wZTogaW52YWxpZCBjdXJ2ZTogJyArIGN1cnZlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHNoYXBlIG9mIHRoZSByZWxlYXNlLiBTZWUgdGhlIGF0dGFjayBjdXJ2ZSB0eXBlcy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge1N0cmluZ3xBcnJheX1cblx0XHQgKiBAbmFtZSByZWxlYXNlQ3VydmVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGVudi5yZWxlYXNlQ3VydmUgPSBcImxpbmVhclwiO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLCAncmVsZWFzZUN1cnZlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pc1N0cmluZyh0aGlzLl9yZWxlYXNlQ3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVsZWFzZUN1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNBcnJheSh0aGlzLl9yZWxlYXNlQ3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICAvL2xvb2sgdXAgdGhlIG5hbWUgaW4gdGhlIGN1cnZlcyBhcnJheVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBUb25lLkVudmVsb3BlLlR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoVG9uZS5FbnZlbG9wZS5UeXBlW3R5cGVdLk91dCA9PT0gdGhpcy5fcmVsZWFzZUN1cnZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSBhcnJheVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2VDdXJ2ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoY3VydmUpIHtcblx0ICAgICAgICAgICAgLy9jaGVjayBpZiBpdCdzIGEgdmFsaWQgdHlwZVxuXHQgICAgICAgICAgICBpZiAoVG9uZS5FbnZlbG9wZS5UeXBlLmhhc093blByb3BlcnR5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN1cnZlRGVmID0gVG9uZS5FbnZlbG9wZS5UeXBlW2N1cnZlXTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KGN1cnZlRGVmKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9IGN1cnZlRGVmLk91dDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVsZWFzZUN1cnZlID0gY3VydmVEZWY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0FycmF5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVsZWFzZUN1cnZlID0gY3VydmU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuRW52ZWxvcGU6IGludmFsaWQgY3VydmU6ICcgKyBjdXJ2ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2svZGVjYXkgcG9ydGlvbiBvZiB0aGUgQURTUiBlbnZlbG9wZS4gXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgYXR0YWNrIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIFRoZSB2ZWxvY2l0eSBvZiB0aGUgZW52ZWxvcGUgc2NhbGVzIHRoZSB2YWxlcy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgYmV0d2VlbiAwLTFcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRW52ZWxvcGV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgLy90cmlnZ2VyIHRoZSBhdHRhY2sgMC41IHNlY29uZHMgZnJvbSBub3cgd2l0aCBhIHZlbG9jaXR5IG9mIDAuMlxuXHRcdCAqICBlbnYudHJpZ2dlckF0dGFjayhcIiswLjVcIiwgMC4yKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIG9yaWdpbmFsQXR0YWNrID0gdGhpcy50b1NlY29uZHModGhpcy5hdHRhY2spO1xuXHQgICAgICAgIHZhciBhdHRhY2sgPSBvcmlnaW5hbEF0dGFjaztcblx0ICAgICAgICB2YXIgZGVjYXkgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLmRlY2F5KTtcblx0ICAgICAgICB2ZWxvY2l0eSA9IHRoaXMuZGVmYXVsdEFyZyh2ZWxvY2l0eSwgMSk7XG5cdCAgICAgICAgLy9jaGVjayBpZiBpdCdzIG5vdCBhIGNvbXBsZXRlIGF0dGFja1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHQgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPiAwKSB7XG5cdCAgICAgICAgICAgIC8vc3VidHJhY3QgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgYXR0YWNrIHRpbWVcblx0ICAgICAgICAgICAgdmFyIGF0dGFja1JhdGUgPSAxIC8gYXR0YWNrO1xuXHQgICAgICAgICAgICB2YXIgcmVtYWluaW5nRGlzdGFuY2UgPSAxIC0gY3VycmVudFZhbHVlO1xuXHQgICAgICAgICAgICAvL3RoZSBhdHRhY2sgaXMgbm93IHRoZSByZW1haW5pbmcgdGltZVxuXHQgICAgICAgICAgICBhdHRhY2sgPSByZW1haW5pbmdEaXN0YW5jZSAvIGF0dGFja1JhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vYXR0YWNrXG5cdCAgICAgICAgaWYgKHRoaXMuX2F0dGFja0N1cnZlID09PSAnbGluZWFyJykge1xuXHQgICAgICAgICAgICB0aGlzLl9zaWcubGluZWFyUmFtcFRvVmFsdWUodmVsb2NpdHksIGF0dGFjaywgdGltZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdHRhY2tDdXJ2ZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuXHQgICAgICAgICAgICB0aGlzLl9zaWcuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZSh2ZWxvY2l0eSwgYXR0YWNrLCB0aW1lKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGF0dGFjayA+IDApIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2lnLnNldFJhbXBQb2ludCh0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5fYXR0YWNrQ3VydmU7XG5cdCAgICAgICAgICAgIC8vdGFrZSBvbmx5IGEgcG9ydGlvbiBvZiB0aGUgY3VydmVcblx0ICAgICAgICAgICAgaWYgKGF0dGFjayA8IG9yaWdpbmFsQXR0YWNrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGVyY2VudENvbXBsZXRlID0gMSAtIGF0dGFjayAvIG9yaWdpbmFsQXR0YWNrO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNsaWNlSW5kZXggPSBNYXRoLmZsb29yKHBlcmNlbnRDb21wbGV0ZSAqIHRoaXMuX2F0dGFja0N1cnZlLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBjdXJ2ZSA9IHRoaXMuX2F0dGFja0N1cnZlLnNsaWNlKHNsaWNlSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgLy90aGUgZmlyc3QgaW5kZXggaXMgdGhlIGN1cnJlbnQgdmFsdWVcblx0ICAgICAgICAgICAgICAgIGN1cnZlWzBdID0gY3VycmVudFZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3NpZy5zZXRWYWx1ZUN1cnZlQXRUaW1lKGN1cnZlLCB0aW1lLCBhdHRhY2ssIHZlbG9jaXR5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9kZWNheVxuXHQgICAgICAgIHRoaXMuX3NpZy5leHBvbmVudGlhbFJhbXBUb1ZhbHVlKHZlbG9jaXR5ICogdGhpcy5zdXN0YWluLCBkZWNheSwgYXR0YWNrICsgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXJzIHRoZSByZWxlYXNlIG9mIHRoZSBlbnZlbG9wZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlIHNob3VsZCBzdGFydC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVudmVsb3BlfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIC8vdHJpZ2dlciByZWxlYXNlIGltbWVkaWF0ZWx5XG5cdFx0ICogIGVudi50cmlnZ2VyUmVsZWFzZSgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0ICAgICAgICBpZiAoY3VycmVudFZhbHVlID4gMCkge1xuXHQgICAgICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMudG9TZWNvbmRzKHRoaXMucmVsZWFzZSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9yZWxlYXNlQ3VydmUgPT09ICdsaW5lYXInKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaWcubGluZWFyUmFtcFRvVmFsdWUoMCwgcmVsZWFzZSwgdGltZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcmVsZWFzZUN1cnZlID09PSAnZXhwb25lbnRpYWwnKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaWcuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZSgwLCByZWxlYXNlLCB0aW1lKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuX3JlbGVhc2VDdXJ2ZTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQXJyYXkoY3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lnLnNldFJhbXBQb2ludCh0aW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWcuc2V0VmFsdWVDdXJ2ZUF0VGltZShjdXJ2ZSwgdGltZSwgcmVsZWFzZSwgY3VycmVudFZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFRoaXMgd2lsbFxuXHRcdCAqICByZXR1cm4gdGhlIHVuY29udmVydGVkIChyYXcpIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fc2lnLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0cmlnZ2VyQXR0YWNrUmVsZWFzZSBpcyBzaG9ydGhhbmQgZm9yIHRyaWdnZXJBdHRhY2ssIHRoZW4gd2FpdGluZ1xuXHRcdCAqICBzb21lIGR1cmF0aW9uLCB0aGVuIHRyaWdnZXJSZWxlYXNlLiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHN1c3RhaW4uXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBhdHRhY2sgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgb2YgdGhlIGVudmVsb3BlLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRW52ZWxvcGV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgdGhlIGF0dGFjayBhbmQgdGhlbiB0aGUgcmVsZWFzZSBhZnRlciAwLjYgc2Vjb25kcy5cblx0XHQgKiBlbnYudHJpZ2dlckF0dGFja1JlbGVhc2UoMC42KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKGR1cmF0aW9uLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2UodGltZSArIHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbHMgYWxsIHNjaGVkdWxlZCBlbnZlbG9wZSBjaGFuZ2VzIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBhZnRlclxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgdGhpcy5fc2lnLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhZnRlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEJvcnJvd3MgdGhlIGNvbm5lY3QgbWV0aG9kIGZyb20gVG9uZS5TaWduYWwuIFxuXHRcdCAqICBAZnVuY3Rpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLmNvbm5lY3QgPSBUb25lLlNpZ25hbC5wcm90b3R5cGUuY29ubmVjdDtcblx0ICAgIC8qKlxuXHQgXHQgKiAgR2VuZXJhdGUgc29tZSBjb21wbGV4IGVudmVsb3BlIGN1cnZlcy4gXG5cdCBcdCAqL1xuXHQgICAgKGZ1bmN0aW9uIF9jcmVhdGVDdXJ2ZXMoKSB7XG5cdCAgICAgICAgdmFyIGN1cnZlTGVuID0gMTI4O1xuXHQgICAgICAgIHZhciBpLCBrO1xuXHQgICAgICAgIC8vY29zaW5lIGN1cnZlXG5cdCAgICAgICAgdmFyIGNvc2luZUN1cnZlID0gW107XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgY29zaW5lQ3VydmVbaV0gPSBNYXRoLnNpbihpIC8gKGN1cnZlTGVuIC0gMSkgKiAoTWF0aC5QSSAvIDIpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9yaXBwbGUgY3VydmVcblx0ICAgICAgICB2YXIgcmlwcGxlQ3VydmUgPSBbXTtcblx0ICAgICAgICB2YXIgcmlwcGxlQ3VydmVGcmVxID0gNi40O1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdXJ2ZUxlbiAtIDE7IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgc2luZVdhdmUgPSBNYXRoLnNpbihrICogKE1hdGguUEkgKiAyKSAqIHJpcHBsZUN1cnZlRnJlcSAtIE1hdGguUEkgLyAyKSArIDE7XG5cdCAgICAgICAgICAgIHJpcHBsZUN1cnZlW2ldID0gc2luZVdhdmUgLyAxMCArIGsgKiAwLjgzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByaXBwbGVDdXJ2ZVtjdXJ2ZUxlbiAtIDFdID0gMTtcblx0ICAgICAgICAvL3N0YWlycyBjdXJ2ZVxuXHQgICAgICAgIHZhciBzdGFpcnNDdXJ2ZSA9IFtdO1xuXHQgICAgICAgIHZhciBzdGVwcyA9IDU7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgc3RhaXJzQ3VydmVbaV0gPSBNYXRoLmNlaWwoaSAvIChjdXJ2ZUxlbiAtIDEpICogc3RlcHMpIC8gc3RlcHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vaW4tb3V0IGVhc2luZyBjdXJ2ZVxuXHQgICAgICAgIHZhciBzaW5lQ3VydmUgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VydmVMZW47IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICBzaW5lQ3VydmVbaV0gPSAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vYSBib3VuY2UgY3VydmVcblx0ICAgICAgICB2YXIgYm91bmNlQ3VydmUgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VydmVMZW47IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgZnJlcSA9IE1hdGgucG93KGssIDMpICogNCArIDAuMjtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IE1hdGguY29zKGZyZXEgKiBNYXRoLlBJICogMiAqIGspO1xuXHQgICAgICAgICAgICBib3VuY2VDdXJ2ZVtpXSA9IE1hdGguYWJzKHZhbCAqICgxIC0gaykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJbnZlcnQgYSB2YWx1ZSBjdXJ2ZSB0byBtYWtlIGl0IHdvcmsgZm9yIHRoZSByZWxlYXNlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIGZ1bmN0aW9uIGludmVydEN1cnZlKGN1cnZlKSB7XG5cdCAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoY3VydmUubGVuZ3RoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjdXJ2ZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgb3V0W2pdID0gMSAtIGN1cnZlW2pdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHJldmVyc2UgdGhlIGN1cnZlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIGZ1bmN0aW9uIHJldmVyc2VDdXJ2ZShjdXJ2ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY3VydmUuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBhdHRhY2sgYW5kIHJlbGVhc2UgY3VydmUgYXJyYXlzXG5cdFx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUuVHlwZSA9IHtcblx0ICAgICAgICAgICAgJ2xpbmVhcic6ICdsaW5lYXInLFxuXHQgICAgICAgICAgICAnZXhwb25lbnRpYWwnOiAnZXhwb25lbnRpYWwnLFxuXHQgICAgICAgICAgICAnYm91bmNlJzoge1xuXHQgICAgICAgICAgICAgICAgSW46IGludmVydEN1cnZlKGJvdW5jZUN1cnZlKSxcblx0ICAgICAgICAgICAgICAgIE91dDogYm91bmNlQ3VydmVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2Nvc2luZSc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBjb3NpbmVDdXJ2ZSxcblx0ICAgICAgICAgICAgICAgIE91dDogcmV2ZXJzZUN1cnZlKGNvc2luZUN1cnZlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc3RlcCc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBzdGFpcnNDdXJ2ZSxcblx0ICAgICAgICAgICAgICAgIE91dDogaW52ZXJ0Q3VydmUoc3RhaXJzQ3VydmUpXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdyaXBwbGUnOiB7XG5cdCAgICAgICAgICAgICAgICBJbjogcmlwcGxlQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGludmVydEN1cnZlKHJpcHBsZUN1cnZlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc2luZSc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBzaW5lQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGludmVydEN1cnZlKHNpbmVDdXJ2ZSlcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXHQgICAgLyoqXG5cdFx0ICogIERpc2Nvbm5lY3QgYW5kIGRpc3Bvc2UuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zaWcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NpZyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYXR0YWNrQ3VydmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRW52ZWxvcGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSBpcyBhIFRvbmUuRW52ZWxvcGUgY29ubmVjdGVkIHRvIGEgZ2FpbiBub2RlLiBcblx0XHQgKiAgICAgICAgICBVbmxpa2UgVG9uZS5FbnZlbG9wZSwgd2hpY2ggb3V0cHV0cyB0aGUgZW52ZWxvcGUncyB2YWx1ZSwgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSBhY2NlcHRzXG5cdFx0ICogICAgICAgICAgYW4gYXVkaW8gc2lnbmFsIGFzIHRoZSBpbnB1dCBhbmQgd2lsbCBhcHBseSB0aGUgZW52ZWxvcGUgdG8gdGhlIGFtcGxpdHVkZVxuXHRcdCAqICAgICAgICAgIG9mIHRoZSBzaWduYWwuIFJlYWQgbW9yZSBhYm91dCBBRFNSIEVudmVsb3BlcyBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW50aGVzaXplciNBRFNSX2VudmVsb3BlKS5cblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbnZlbG9wZX1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2F0dGFja10gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHRha2VzIGZvciB0aGUgZW52ZWxvcGUgdG8gZ28gZnJvbSBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIHRvIGl0J3MgbWF4aW11bSB2YWx1ZS4gXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0VGhlIHBlcmlvZCBvZiB0aW1lIGFmdGVyIHRoZSBhdHRhY2sgdGhhdCBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIFx0dG8gZmFsbCB0byB0aGUgc3VzdGFpbiB2YWx1ZS4gXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFtzdXN0YWluXVx0VGhlIHBlcmNlbnQgb2YgdGhlIG1heGltdW0gdmFsdWUgdGhhdCB0aGUgZW52ZWxvcGUgcmVzdHMgYXQgdW50aWxcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR0aGUgcmVsZWFzZSBpcyB0cmlnZ2VyZWQuIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0VGhlIGFtb3VudCBvZiB0aW1lIGFmdGVyIHRoZSByZWxlYXNlIGlzIHRyaWdnZXJlZCBpdCB0YWtlcyB0byByZWFjaCAwLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgYW1wRW52ID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUoe1xuXHRcdCAqIFx0XCJhdHRhY2tcIjogMC4xLFxuXHRcdCAqIFx0XCJkZWNheVwiOiAwLjIsXG5cdFx0ICogXHRcInN1c3RhaW5cIjogMS4wLFxuXHRcdCAqIFx0XCJyZWxlYXNlXCI6IDAuOFxuXHRcdCAqIH0pLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9jcmVhdGUgYW4gb3NjaWxsYXRvciBhbmQgY29ubmVjdCBpdFxuXHRcdCAqIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdChhbXBFbnYpLnN0YXJ0KCk7XG5cdFx0ICogLy90cmlnZ2VyIHRoZSBlbnZlbG9wZXMgYXR0YWNrIGFuZCByZWxlYXNlIFwiOHRcIiBhcGFydFxuXHRcdCAqIGFtcEVudi50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIjh0XCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVudmVsb3BlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGlucHV0IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICB0aGlzLl9zaWcuY29ubmVjdCh0aGlzLm91dHB1dC5nYWluKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkFtcGxpdHVkZUVudmVsb3BlLCBUb25lLkVudmVsb3BlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5BbXBsaXR1ZGVFbnZlbG9wZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XG5cdCAgICAgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFtcGxpdHVkZUVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgV2ViIEF1ZGlvJ3MgXG5cdFx0ICogICAgICAgICAgW0FuYWx5c2VyTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyNpZGwtZGVmLUFuYWx5c2VyTm9kZSkuXG5cdFx0ICogICAgICAgICAgRXh0cmFjdHMgRkZUIG9yIFdhdmVmb3JtIGRhdGEgZnJvbSB0aGUgaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmc9fSB0eXBlIFRoZSByZXR1cm4gdHlwZSBvZiB0aGUgYW5hbHlzaXMsIGVpdGhlciBcImZmdFwiLCBvciBcIndhdmVmb3JtXCIuIFxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IHNpemUgVGhlIHNpemUgb2YgdGhlIEZGVC4gVmFsdWUgbXVzdCBiZSBhIHBvd2VyIG9mIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3R5cGUnLFxuXHQgICAgICAgICAgICAnc2l6ZSdcblx0ICAgICAgICBdLCBUb25lLkFuYWx5c2VyLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW5hbHlzZXIgbm9kZS5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBbmFseXNlck5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbmFseXNlciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbmFseXNpcyB0eXBlXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmV0dXJuIHR5cGUgb2YgdGhlIGFuYWx5c2lzXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcmV0dXJuVHlwZSA9IG9wdGlvbnMucmV0dXJuVHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYnVmZmVyIHRoYXQgdGhlIEZGVCBkYXRhIGlzIHdyaXR0ZW4gdG9cblx0XHRcdCAqICBAdHlwZSB7VHlwZWRBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICAvL3NldCB0aGUgdmFsdWVzIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gb3B0aW9ucy5yZXR1cm5UeXBlO1xuXHQgICAgICAgIHRoaXMubWluRGVjaWJlbHMgPSBvcHRpb25zLm1pbkRlY2liZWxzO1xuXHQgICAgICAgIHRoaXMubWF4RGVjaWJlbHMgPSBvcHRpb25zLm1heERlY2liZWxzO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQW5hbHlzZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlcy5cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdzaXplJzogMTAyNCxcblx0ICAgICAgICAncmV0dXJuVHlwZSc6ICdieXRlJyxcblx0ICAgICAgICAndHlwZSc6ICdmZnQnLFxuXHQgICAgICAgICdzbW9vdGhpbmcnOiAwLjgsXG5cdCAgICAgICAgJ21heERlY2liZWxzJzogLTMwLFxuXHQgICAgICAgICdtaW5EZWNpYmVscyc6IC0xMDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUG9zc2libGUgcmV0dXJuIHR5cGVzIG9mIFRvbmUuQW5hbHlzZXIuYW5hbHlzZSgpXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLlR5cGUgPSB7XG5cdCAgICAgICAgV2F2ZWZvcm06ICd3YXZlZm9ybScsXG5cdCAgICAgICAgRkZUOiAnZmZ0J1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBQb3NzaWJsZSByZXR1cm4gdHlwZXMgb2YgVG9uZS5BbmFseXNlci5hbmFseXNlKCkuIFxuXHRcdCAqICBieXRlIHZhbHVlcyBhcmUgYmV0d2VlbiBbMCwyNTVdLiBmbG9hdCB2YWx1ZXMgYXJlIGJldHdlZW4gXG5cdFx0ICogIFstMSwgMV0gd2hlbiB0aGUgdHlwZSBpcyBzZXQgdG8gXCJ3YXZlZm9ybVwiIGFuZCBiZXR3ZWVuIFxuXHRcdCAqICBbbWluRGVjaWJlbHMsbWF4RGVjaWJlbHNdIHdoZW4gdGhlIHR5cGUgaXMgXCJmZnRcIi5cblx0XHQgKiAgQGVudW0ge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuQW5hbHlzZXIuUmV0dXJuVHlwZSA9IHtcblx0ICAgICAgICBCeXRlOiAnYnl0ZScsXG5cdCAgICAgICAgRmxvYXQ6ICdmbG9hdCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUnVuIHRoZSBhbmFseXNpcyBnaXZlbiB0aGUgY3VycmVudCBzZXR0aW5ncyBhbmQgcmV0dXJuIHRoZSBcblx0XHQgKiAgcmVzdWx0IGFzIGEgVHlwZWRBcnJheS4gXG5cdFx0ICogIEByZXR1cm5zIHtUeXBlZEFycmF5fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlci5wcm90b3R5cGUuYW5hbHlzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5BbmFseXNlci5UeXBlLkZGVCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fcmV0dXJuVHlwZSA9PT0gVG9uZS5BbmFseXNlci5SZXR1cm5UeXBlLkJ5dGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKHRoaXMuX2J1ZmZlcik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEodGhpcy5fYnVmZmVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5BbmFseXNlci5UeXBlLldhdmVmb3JtKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9yZXR1cm5UeXBlID09PSBUb25lLkFuYWx5c2VyLlJldHVyblR5cGUuQnl0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKHRoaXMuX2J1ZmZlcik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Z1bmN0aW9uKEFuYWx5c2VyTm9kZS5wcm90b3R5cGUuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5nZXRGbG9hdFRpbWVEb21haW5EYXRhKHRoaXMuX2J1ZmZlcik7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB1aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1ZmZlci5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YSh1aW50OCk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9yZWZlcmVuY2VkIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2hheW9uYW8vZ2V0LWZsb2F0LXRpbWUtZG9tYWluLWRhdGEgXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUE9MWUZJTExcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnQ4Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlcltpXSA9ICh1aW50OFtpXSAtIDEyOCkgKiAwLjAwNzgxMjU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzaXplIG9mIGFuYWx5c2lzLiBUaGlzIG11c3QgYmUgYSBwb3dlciBvZiB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5BbmFseXNlciNcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgc2l6ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLCAnc2l6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5mZnRTaXplID0gc2l6ZSAqIDI7XG5cdCAgICAgICAgICAgIHRoaXMudHlwZSA9IHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHJldHVybiB0eXBlIG9mIFRvbmUuQW5hbHlzZXIuYW5hbHlzZSgpLCBlaXRoZXIgXCJieXRlXCIgb3IgXCJmbG9hdFwiLiBcblx0XHQgKiAgV2hlbiB0aGUgdHlwZSBpcyBzZXQgdG8gXCJieXRlXCIgdGhlIHJhbmdlIG9mIHZhbHVlcyByZXR1cm5lZCBpbiB0aGUgYXJyYXlcblx0XHQgKiAgYXJlIGJldHdlZW4gMC0yNTUuIFwiZmxvYXRcIiB2YWx1ZXMgYXJlIGJldHdlZW4gXG5cdFx0ICogIFstMSwgMV0gd2hlbiB0aGUgdHlwZSBpcyBzZXQgdG8gXCJ3YXZlZm9ybVwiIGFuZCBiZXR3ZWVuIFxuXHRcdCAqICBbbWluRGVjaWJlbHMsbWF4RGVjaWJlbHNdIHdoZW4gdGhlIHR5cGUgaXMgXCJmZnRcIi5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQW5hbHlzZXIjXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFuYWx5c2VyLnByb3RvdHlwZSwgJ3JldHVyblR5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5UeXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICBpZiAodHlwZSA9PT0gVG9uZS5BbmFseXNlci5SZXR1cm5UeXBlLkJ5dGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2FuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkFuYWx5c2VyLlJldHVyblR5cGUuRmxvYXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVG9uZS5BbmFsYXlzZXI6IGludmFsaWQgcmV0dXJuIHR5cGU6ICcgKyB0eXBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9yZXR1cm5UeXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYW5hbHlzaXMgZnVuY3Rpb24gcmV0dXJuZWQgYnkgVG9uZS5BbmFseXNlci5hbmFseXNlKCksIGVpdGhlciBcImZmdFwiIG9yIFwid2F2ZWZvcm1cIi4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkFuYWx5c2VyI1xuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BbmFseXNlci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGUgIT09IFRvbmUuQW5hbHlzZXIuVHlwZS5XYXZlZm9ybSAmJiB0eXBlICE9PSBUb25lLkFuYWx5c2VyLlR5cGUuRkZUKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb25lLkFuYWx5c2VyOiBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICAwIHJlcHJlc2VudHMgbm8gdGltZSBhdmVyYWdpbmcgd2l0aCB0aGUgbGFzdCBhbmFseXNpcyBmcmFtZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQW5hbHlzZXIjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgc21vb3RoaW5nXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BbmFseXNlci5wcm90b3R5cGUsICdzbW9vdGhpbmcnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzbWFsbGVzdCBkZWNpYmVsIHZhbHVlIHdoaWNoIGlzIGFuYWx5c2VkIGJ5IHRoZSBGRlQuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5BbmFseXNlciNcblx0XHQgKiAgQHR5cGUge0RlY2liZWxzfVxuXHRcdCAqICBAbmFtZSBtaW5EZWNpYmVsc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLCAnbWluRGVjaWJlbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5taW5EZWNpYmVscztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5taW5EZWNpYmVscyA9IHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbGFyZ2VzdCBkZWNpYmVsIHZhbHVlIHdoaWNoIGlzIGFuYWx5c2VkIGJ5IHRoZSBGRlQuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5BbmFseXNlciNcblx0XHQgKiAgQHR5cGUge0RlY2liZWxzfVxuXHRcdCAqICBAbmFtZSBtYXhEZWNpYmVsc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLCAnbWF4RGVjaWJlbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5tYXhEZWNpYmVscztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5tYXhEZWNpYmVscyA9IHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQW5hbHlzZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQW5hbHlzZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkNvbXByZXNzb3IgaXMgYSB0aGluIHdyYXBwZXIgYXJvdW5kIHRoZSBXZWIgQXVkaW8gXG5cdFx0ICogICAgICAgICBbRHluYW1pY3NDb21wcmVzc29yTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtZHluYW1pY3Njb21wcmVzc29ybm9kZS1pbnRlcmZhY2UpLlxuXHRcdCAqICAgICAgICAgQ29tcHJlc3Npb24gcmVkdWNlcyB0aGUgdm9sdW1lIG9mIGxvdWQgc291bmRzIG9yIGFtcGxpZmllcyBxdWlldCBzb3VuZHMgXG5cdFx0ICogICAgICAgICBieSBuYXJyb3dpbmcgb3IgXCJjb21wcmVzc2luZ1wiIGFuIGF1ZGlvIHNpZ25hbCdzIGR5bmFtaWMgcmFuZ2UuIFxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0R5bmFtaWNfcmFuZ2VfY29tcHJlc3Npb24pLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc3xPYmplY3R9IFt0aHJlc2hvbGRdIFRoZSB2YWx1ZSBhYm92ZSB3aGljaCB0aGUgY29tcHJlc3Npb24gc3RhcnRzIHRvIGJlIGFwcGxpZWQuXG5cdFx0ICogIEBwYXJhbSB7UG9zaXRpdmV9IFtyYXRpb10gVGhlIGdhaW4gcmVkdWN0aW9uIHJhdGlvLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjb21wID0gbmV3IFRvbmUuQ29tcHJlc3NvcigtMzAsIDMpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Db21wcmVzc29yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndGhyZXNob2xkJyxcblx0ICAgICAgICAgICAgJ3JhdGlvJ1xuXHQgICAgICAgIF0sIFRvbmUuQ29tcHJlc3Nvci5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGNvbXByZXNzb3Igbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtEeW5hbWljc0NvbXByZXNzb3JOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0aHJlc2hvbGQgdmF1ZVxuXHRcdFx0ICogIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnRocmVzaG9sZCA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fY29tcHJlc3Nvci50aHJlc2hvbGQsXG5cdCAgICAgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5EZWNpYmVscyxcblx0ICAgICAgICAgICAgJ2NvbnZlcnQnOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhdHRhY2sgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hdHRhY2sgPSBuZXcgVG9uZS5QYXJhbSh0aGlzLl9jb21wcmVzc29yLmF0dGFjaywgVG9uZS5UeXBlLlRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByZWxlYXNlIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVsZWFzZSA9IG5ldyBUb25lLlBhcmFtKHRoaXMuX2NvbXByZXNzb3IucmVsZWFzZSwgVG9uZS5UeXBlLlRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBrbmVlIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmtuZWUgPSBuZXcgVG9uZS5QYXJhbSh7XG5cdCAgICAgICAgICAgICdwYXJhbSc6IHRoaXMuX2NvbXByZXNzb3Iua25lZSxcblx0ICAgICAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkRlY2liZWxzLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJhdGlvIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJhdGlvID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9jb21wcmVzc29yLnJhdGlvLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAna25lZScsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJyxcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdyYXRpbycsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5zZXQob3B0aW9ucyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Db21wcmVzc29yKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Db21wcmVzc29yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdyYXRpbyc6IDEyLFxuXHQgICAgICAgICd0aHJlc2hvbGQnOiAtMjQsXG5cdCAgICAgICAgJ3JlbGVhc2UnOiAwLjI1LFxuXHQgICAgICAgICdhdHRhY2snOiAwLjAwMyxcblx0ICAgICAgICAna25lZSc6IDMwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNvbXByZXNzb3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29tcHJlc3Nvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAna25lZScsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJyxcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdyYXRpbycsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fY29tcHJlc3Nvci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fY29tcHJlc3NvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5hdHRhY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuYXR0YWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJlbGVhc2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucmVsZWFzZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudGhyZXNob2xkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJhdGlvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJhdGlvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmtuZWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMua25lZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ29tcHJlc3Nvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEFkZCBhIHNpZ25hbCBhbmQgYSBudW1iZXIgb3IgdHdvIHNpZ25hbHMuIFdoZW4gbm8gdmFsdWUgaXNcblx0XHQgKiAgICAgICAgIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciwgVG9uZS5BZGQgd2lsbCBzdW0gPGNvZGU+aW5wdXRbMF08L2NvZGU+XG5cdFx0ICogICAgICAgICBhbmQgPGNvZGU+aW5wdXRbMV08L2NvZGU+LiBJZiBhIHZhbHVlIGlzIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciwgXG5cdFx0ICogICAgICAgICB0aGUgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5wdXQuXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlIElmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLCBUb25lLkFkZCB3aWxsIHN1bSB0aGUgZmlyc3Rcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2Vjb25kIGlucHV0cy4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNpZ25hbCA9IG5ldyBUb25lLlNpZ25hbCgyKTtcblx0XHQgKiB2YXIgYWRkID0gbmV3IFRvbmUuQWRkKDIpO1xuXHRcdCAqIHNpZ25hbC5jb25uZWN0KGFkZCk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIGFkZCBlcXVhbHMgNFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaWYgY29uc3RydWN0ZWQgd2l0aCBubyBhcmd1bWVudHNcblx0XHQgKiAvL2l0IHdpbGwgYWRkIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGlucHV0c1xuXHRcdCAqIHZhciBhZGQgPSBuZXcgVG9uZS5BZGQoKTtcblx0XHQgKiB2YXIgc2lnMCA9IG5ldyBUb25lLlNpZ25hbCgzKS5jb25uZWN0KGFkZCwgMCwgMCk7XG5cdFx0ICogdmFyIHNpZzEgPSBuZXcgVG9uZS5TaWduYWwoNCkuY29ubmVjdChhZGQsIDAsIDEpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBhZGQgZXF1YWxzIDcuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5BZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHN1bW1pbmcgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3VtID0gdGhpcy5pbnB1dFswXSA9IHRoaXMuaW5wdXRbMV0gPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dFsxXSA9IG5ldyBUb25lLlNpZ25hbCh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uY29ubmVjdCh0aGlzLl9zdW0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQWRkLCBUb25lLlNpZ25hbCk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFkZH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BZGQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3N1bS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3VtID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFkZDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBNdWx0aXBseSB0d28gaW5jb21pbmcgc2lnbmFscy4gT3IsIGlmIGEgbnVtYmVyIGlzIGdpdmVuIGluIHRoZSBjb25zdHJ1Y3RvciwgXG5cdFx0ICogICAgICAgICAgbXVsdGlwbGllcyB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5IHRoYXQgdmFsdWUuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWx9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWUgQ29uc3RhbnQgdmFsdWUgdG8gbXVsdGlwbGUuIElmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgcmV0dXJuIHRoZSBwcm9kdWN0IG9mIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGlucHV0c1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBtdWx0ID0gbmV3IFRvbmUuTXVsdGlwbHkoKTtcblx0XHQgKiB2YXIgc2lnQSA9IG5ldyBUb25lLlNpZ25hbCgzKTtcblx0XHQgKiB2YXIgc2lnQiA9IG5ldyBUb25lLlNpZ25hbCg0KTtcblx0XHQgKiBzaWdBLmNvbm5lY3QobXVsdCwgMCwgMCk7XG5cdFx0ICogc2lnQi5jb25uZWN0KG11bHQsIDAsIDEpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIG11bHQgaXMgMTIuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG11bHQgPSBuZXcgVG9uZS5NdWx0aXBseSgxMCk7XG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCgyKS5jb25uZWN0KG11bHQpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBtdWx0IGlzIDIwLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlwbHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGlucHV0IG5vZGUgaXMgdGhlIHNhbWUgYXMgdGhlIG91dHB1dCBub2RlXG5cdFx0XHQgKiAgaXQgaXMgYWxzbyB0aGUgR2Fpbk5vZGUgd2hpY2ggaGFuZGxlcyB0aGUgc2NhbGluZyBvZiBpbmNvbWluZyBzaWduYWxcblx0XHRcdCAqICBcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHQgPSB0aGlzLmlucHV0WzBdID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHNjYWxpbmcgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvUGFyYW19XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dFsxXSA9IHRoaXMub3V0cHV0LmdhaW47XG5cdCAgICAgICAgdGhpcy5fcGFyYW0udmFsdWUgPSB0aGlzLmRlZmF1bHRBcmcodmFsdWUsIDApO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTXVsdGlwbHksIFRvbmUuU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NdWx0aXBseX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aXBseS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbXVsdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpcGx5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTmVnYXRlIHRoZSBpbmNvbWluZyBzaWduYWwuIGkuZS4gYW4gaW5wdXQgc2lnbmFsIG9mIDEwIHdpbGwgb3V0cHV0IC0xMFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBuZWcgPSBuZXcgVG9uZS5OZWdhdGUoKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKC0yKS5jb25uZWN0KG5lZyk7XG5cdFx0ICogLy9vdXRwdXQgb2YgbmVnIGlzIHBvc2l0aXZlIDIuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5OZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbmVnYXRpb24gaXMgZG9uZSBieSBtdWx0aXBseWluZyBieSAtMVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tdWx0aXBseSA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk11bHRpcGx5KC0xKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk5lZ2F0ZSwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5OZWdhdGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTmVnYXRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBseS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk5lZ2F0ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFN1YnRyYWN0IHRoZSBzaWduYWwgY29ubmVjdGVkIHRvIDxjb2RlPmlucHV0WzFdPC9jb2RlPiBmcm9tIHRoZSBzaWduYWwgY29ubmVjdGVkIFxuXHRcdCAqICAgICAgICAgdG8gPGNvZGU+aW5wdXRbMF08L2NvZGU+LiBJZiBhbiBhcmd1bWVudCBpcyBwcm92aWRlZCBpbiB0aGUgY29uc3RydWN0b3IsIHRoZSBcblx0XHQgKiAgICAgICAgIHNpZ25hbHMgPGNvZGU+LnZhbHVlPC9jb2RlPiB3aWxsIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWUgVGhlIHZhbHVlIHRvIHN1YnRyYWN0IGZyb20gdGhlIGluY29taW5nIHNpZ25hbC4gSWYgdGhlIHZhbHVlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgaXMgb21pdHRlZCwgaXQgd2lsbCBzdWJ0cmFjdCB0aGUgc2Vjb25kIHNpZ25hbCBmcm9tIHRoZSBmaXJzdC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ViID0gbmV3IFRvbmUuU3VidHJhY3QoMSk7XG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCg0KS5jb25uZWN0KHN1Yik7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIHN1YiBpcyAzLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ViID0gbmV3IFRvbmUuU3VidHJhY3QoKTtcblx0XHQgKiB2YXIgc2lnQSA9IG5ldyBUb25lLlNpZ25hbCgxMCk7XG5cdFx0ICogdmFyIHNpZ0IgPSBuZXcgVG9uZS5TaWduYWwoMi41KTtcblx0XHQgKiBzaWdBLmNvbm5lY3Qoc3ViLCAwLCAwKTtcblx0XHQgKiBzaWdCLmNvbm5lY3Qoc3ViLCAwLCAxKTtcblx0XHQgKiAvL291dHB1dCBvZiBzdWIgaXMgNy41XG5cdFx0ICovXG5cdCAgICBUb25lLlN1YnRyYWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBzdW1taW5nIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N1bSA9IHRoaXMuaW5wdXRbMF0gPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBuZWdhdGUgdGhlIGlucHV0IG9mIHRoZSBzZWNvbmQgaW5wdXQgYmVmb3JlIGNvbm5lY3RpbmcgaXRcblx0XHRcdCAqICB0byB0aGUgc3VtbWluZyBub2RlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk5lZ2F0ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbmVnID0gbmV3IFRvbmUuTmVnYXRlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIHNldFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuU2lnbmFsKHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jaGFpbih0aGlzLl9uZWcsIHRoaXMuX3N1bSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdWJ0cmFjdCwgVG9uZS5TaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TaWduYWxCYXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlN1YnRyYWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9uZWcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX25lZyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3VtLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9zdW0gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3VidHJhY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgR3JlYXRlclRoYW5aZXJvIG91dHB1dHMgMSB3aGVuIHRoZSBpbnB1dCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gemVyb1xuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGd0MCA9IG5ldyBUb25lLkdyZWF0ZXJUaGFuWmVybygpO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoMC4wMSkuY29ubmVjdChndDApO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBndDAgaXMgMS4gXG5cdFx0ICogc2lnLnZhbHVlID0gMDtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2YgZ3QwIGlzIDAuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmVhdGVyVGhhblplcm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuV2F2ZVNoYXBlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdGhyZXNoID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbCA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSwgMTI3KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZSB0aGUgZmlyc3QgdGhyZXNob2xkZWQgc2lnbmFsIGJ5IGEgbGFyZ2UgdmFsdWUuXG5cdFx0XHQgKiAgdGhpcyB3aWxsIGhlbHAgd2l0aCB2YWx1ZXMgd2hpY2ggYXJlIHZlcnkgY2xvc2UgdG8gMFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5NdWx0aXBseSgxMDAwMCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmNvbm5lY3QodGhpcy5fdGhyZXNoKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkdyZWF0ZXJUaGFuWmVybywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIG1ldGhvZFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HcmVhdGVyVGhhblplcm99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JlYXRlclRoYW5aZXJvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3RocmVzaC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGhyZXNoID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HcmVhdGVyVGhhblplcm87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgT3V0cHV0IDEgaWYgdGhlIHNpZ25hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlLCBvdGhlcndpc2Ugb3V0cHV0cyAwLlxuXHRcdCAqICAgICAgICAgIGNhbiBjb21wYXJlIHR3byBzaWduYWxzIG9yIGEgc2lnbmFsIGFuZCBhIG51bWJlci4gXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZhbHVlPTBdIHRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIHRoZSBpbmNvbWluZyBzaWduYWxcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZ3QgPSBuZXcgVG9uZS5HcmVhdGVyVGhhbigyKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDQpLmNvbm5lY3QoZ3QpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIGd0IGlzIGVxdWFsIDEuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmVhdGVyVGhhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzdWJ0cmFjdCB0aGUgYW1vdW50IGZyb20gdGhlIGluY29taW5nIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IHRoaXMuaW5wdXRbMF0gPSBuZXcgVG9uZS5TdWJ0cmFjdCh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5pbnB1dFsxXSA9IHRoaXMuX3BhcmFtLmlucHV0WzFdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbXBhcmUgdGhhdCBhbW91bnQgdG8gemVyb1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdyZWF0ZXJUaGFuWmVyb31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ3R6ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HcmVhdGVyVGhhblplcm8oKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rcblx0ICAgICAgICB0aGlzLl9wYXJhbS5jb25uZWN0KHRoaXMuX2d0eik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HcmVhdGVyVGhhbiwgVG9uZS5TaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgbWV0aG9kXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkdyZWF0ZXJUaGFufSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdyZWF0ZXJUaGFuLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2d0ei5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ3R6ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HcmVhdGVyVGhhbjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYW4gaW5jb21pbmcgc2lnbmFsLiBcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoLTEpO1xuXHRcdCAqIHZhciBhYnMgPSBuZXcgVG9uZS5BYnMoKTtcblx0XHQgKiBzaWduYWwuY29ubmVjdChhYnMpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBhYnMgaXMgMS4gXG5cdFx0ICovXG5cdCAgICBUb25lLkFicyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MZXNzVGhhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWJzID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LCAxMjcpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQWJzLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgbWV0aG9kXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFic30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BYnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2Ficy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYWJzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BYnM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBTaWduYWwtcmF0ZSBtb2R1bG8gb3BlcmF0b3IuIE9ubHkgd29ya3MgaW4gQXVkaW9SYW5nZSBbLTEsIDFdIGFuZCBmb3IgbW9kdWx1c1xuXHRcdCAqICAgICAgICAgdmFsdWVzIGluIHRoZSBOb3JtYWxSYW5nZS4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IG1vZHVsdXMgVGhlIG1vZHVsdXMgdG8gYXBwbHkuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG1vZCA9IG5ldyBUb25lLk1vZHVsbygwLjIpXG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCgwLjUpLmNvbm5lY3QobW9kKTtcblx0XHQgKiAvL21vZCBvdXRwdXRzIDAuMVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb2R1bG8gPSBmdW5jdGlvbiAobW9kdWx1cykge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHdhdmVzaGFwZXIgZ2V0cyB0aGUgaW50ZWdlciBtdWx0aXBsZSBvZiBcblx0XHRcdCAqICB0aGUgaW5wdXQgc2lnbmFsIGFuZCB0aGUgbW9kdWx1cy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKE1hdGgucG93KDIsIDE2KSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGludGVnZXIgbXVsdGlwbGUgaXMgbXVsdGlwbGllZCBieSB0aGUgbW9kdWx1c1xuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkgPSBuZXcgVG9uZS5NdWx0aXBseSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGFuZCBzdWJ0cmFjdGVkIGZyb20gdGhlIGlucHV0IHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5TdWJ0cmFjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3VidHJhY3QgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlN1YnRyYWN0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1vZHVsdXMgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kU2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKG1vZHVsdXMpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmZhbih0aGlzLl9zaGFwZXIsIHRoaXMuX3N1YnRyYWN0KTtcblx0ICAgICAgICB0aGlzLl9tb2RTaWduYWwuY29ubmVjdCh0aGlzLl9tdWx0aXBseSwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmNvbm5lY3QodGhpcy5fbXVsdGlwbHksIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5LmNvbm5lY3QodGhpcy5fc3VidHJhY3QsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX3NldFdhdmVTaGFwZXIobW9kdWx1cyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Nb2R1bG8sIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSAgbW9kICB0aGUgbW9kdWx1cyB0byBhcHBseVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb2R1bG8ucHJvdG90eXBlLl9zZXRXYXZlU2hhcGVyID0gZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5zZXRNYXAoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB2YXIgbXVsdGlwbGUgPSBNYXRoLmZsb29yKCh2YWwgKyAwLjAwMDEpIC8gbW9kKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtb2R1bHVzIHZhbHVlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk1vZHVsbyNcblx0XHQgKiBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1vZHVsby5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vZFNpZ25hbC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RTaWduYWwudmFsdWUgPSBtb2Q7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFdhdmVTaGFwZXIobW9kKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vZHVsb30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb2R1bG8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBseS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kU2lnbmFsLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2RTaWduYWwgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1vZHVsbztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEF1ZGlvVG9HYWluIGNvbnZlcnRzIGFuIGlucHV0IGluIEF1ZGlvUmFuZ2UgWy0xLDFdIHRvIE5vcm1hbFJhbmdlIFswLDFdLiBcblx0XHQgKiAgICAgICAgIFNlZSBUb25lLkdhaW5Ub0F1ZGlvLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgYTJnID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ub0dhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1dhdmVTaGFwZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ub3JtID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHggKyAxKSAvIDI7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BdWRpb1RvR2FpbiwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb1RvR2Fpbn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb1RvR2Fpbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbm9ybS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXVkaW9Ub0dhaW47XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBFdmFsdWF0ZSBhbiBleHByZXNzaW9uIGF0IGF1ZGlvIHJhdGUuIDxicj48YnI+XG5cdFx0ICogICAgICAgICBQYXJzaW5nIGNvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3RhcGRpZ2l0L1xuXHRcdCAqICAgICAgICAgQ29weXJpZ2h0IDIwMTEgMjAxMiBBcml5YSBIaWRheWF0LCBOZXcgQlNEIExpY2Vuc2Vcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IGV4cHIgdGhlIGV4cHJlc3Npb24gdG8gZ2VuZXJhdGVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2FkZHMgdGhlIHNpZ25hbHMgZnJvbSBpbnB1dFswXSBhbmQgaW5wdXRbMV0uXG5cdFx0ICogdmFyIGV4cHIgPSBuZXcgVG9uZS5FeHByKFwiJDAgKyAkMVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuX3JlcGxhY2VtZW50cyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblx0ICAgICAgICB2YXIgaW5wdXRDb3VudCA9IHRoaXMuX3BhcnNlSW5wdXRzKGV4cHIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGhvbGQgb250byBhbGwgb2YgdGhlIG5vZGVzIGZvciBkaXNwb3NhbFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgaW5wdXRzLiBUaGUgbGVuZ3RoIGlzIGRldGVybWluZWQgYnkgdGhlIGV4cHJlc3Npb24uIFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgQXJyYXkoaW5wdXRDb3VudCk7XG5cdCAgICAgICAgLy9jcmVhdGUgYSBnYWluIGZvciBlYWNoIGlucHV0XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dFtpXSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vcGFyc2UgdGhlIHN5bnRheCB0cmVlXG5cdCAgICAgICAgdmFyIHRyZWUgPSB0aGlzLl9wYXJzZVRyZWUoZXhwcik7XG5cdCAgICAgICAgLy9ldmFsdWF0ZSB0aGUgcmVzdWx0c1xuXHQgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZXZhbCh0cmVlKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VOb2RlcygpO1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuRXhwcjogQ291bGQgZXZhbHVhdGUgZXhwcmVzc2lvbjogJyArIGV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IG5vZGUgaXMgdGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvblxuXHRcdFx0ICogIEB0eXBlIHtUb25lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FeHByLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLy9zb21lIGhlbHBlcnMgdG8gY3V0IGRvd24gdGhlIGFtb3VudCBvZiBjb2RlXG5cdCAgICBmdW5jdGlvbiBhcHBseUJpbmFyeShDb25zdHJ1Y3RvciwgYXJncywgc2VsZikge1xuXHQgICAgICAgIHZhciBvcCA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCwgMCwgMCk7XG5cdCAgICAgICAgc2VsZi5fZXZhbChhcmdzWzFdKS5jb25uZWN0KG9wLCAwLCAxKTtcblx0ICAgICAgICByZXR1cm4gb3A7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhcHBseVVuYXJ5KENvbnN0cnVjdG9yLCBhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgdmFyIG9wID0gbmV3IENvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgc2VsZi5fZXZhbChhcmdzWzBdKS5jb25uZWN0KG9wLCAwLCAwKTtcblx0ICAgICAgICByZXR1cm4gb3A7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXROdW1iZXIoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyZyA/IHBhcnNlRmxvYXQoYXJnKSA6IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGxpdGVyYWxOdW1iZXIoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyZyAmJiBhcmcuYXJncyA/IHBhcnNlRmxvYXQoYXJnLmFyZ3MpIDogdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgICAgLypcblx0XHQgKiAgdGhlIEV4cHJlc3Npb25zIHRoYXQgVG9uZS5FeHByIGNhbiBwYXJzZS5cblx0XHQgKlxuXHRcdCAqICBlYWNoIGV4cHJlc3Npb24gYmVsb25ncyB0byBhIGdyb3VwIGFuZCBjb250YWlucyBhIHJlZ2V4cCBcblx0XHQgKiAgZm9yIHNlbGVjdGluZyB0aGUgb3BlcmF0b3IgYXMgd2VsbCBhcyB0aGF0IG9wZXJhdG9ycyBtZXRob2Rcblx0XHQgKiAgXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIuX0V4cHJlc3Npb25zID0ge1xuXHQgICAgICAgIC8vdmFsdWVzXG5cdCAgICAgICAgJ3ZhbHVlJzoge1xuXHQgICAgICAgICAgICAnc2lnbmFsJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcZCtcXC5cXGQrfF5cXGQrLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoZ2V0TnVtYmVyKGFyZykpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdpbnB1dCc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXCRcXGQvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoYXJnLCBzZWxmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5wdXRbZ2V0TnVtYmVyKGFyZy5zdWJzdHIoMSkpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy9zeW50YWN0aWMgZ2x1ZVxuXHQgICAgICAgICdnbHVlJzoge1xuXHQgICAgICAgICAgICAnKCc6IHsgcmVnZXhwOiAvXlxcKC8gfSxcblx0ICAgICAgICAgICAgJyknOiB7IHJlZ2V4cDogL15cXCkvIH0sXG5cdCAgICAgICAgICAgICcsJzogeyByZWdleHA6IC9eLC8gfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy9mdW5jdGlvbnNcblx0ICAgICAgICAnZnVuYyc6IHtcblx0ICAgICAgICAgICAgJ2Ficyc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15hYnMvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseVVuYXJ5LmJpbmQodGhpcywgVG9uZS5BYnMpXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdtb2QnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9ebW9kLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWx1cyA9IGxpdGVyYWxOdW1iZXIoYXJnc1sxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gbmV3IFRvbmUuTW9kdWxvKG1vZHVsdXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAncG93Jzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXnBvdy8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cCA9IGxpdGVyYWxOdW1iZXIoYXJnc1sxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gbmV3IFRvbmUuUG93KGV4cCk7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi5fZXZhbChhcmdzWzBdKS5jb25uZWN0KG9wKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdhMmcnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eYTJnLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvL2JpbmFyeSBleHByZXNzaW9uc1xuXHQgICAgICAgICdiaW5hcnknOiB7XG5cdCAgICAgICAgICAgICcrJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcKy8sXG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseUJpbmFyeS5iaW5kKHRoaXMsIFRvbmUuQWRkKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnLSc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXC0vLFxuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL2JvdGggdW5hcnkgYW5kIGJpbmFyeSBvcFxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlVbmFyeShUb25lLk5lZ2F0ZSwgYXJncywgc2VsZik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5QmluYXJ5KFRvbmUuU3VidHJhY3QsIGFyZ3MsIHNlbGYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJyonOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwqLyxcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDAsXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGFwcGx5QmluYXJ5LmJpbmQodGhpcywgVG9uZS5NdWx0aXBseSlcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy91bmFyeSBleHByZXNzaW9uc1xuXHQgICAgICAgICd1bmFyeSc6IHtcblx0ICAgICAgICAgICAgJy0nOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwtLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogYXBwbHlVbmFyeS5iaW5kKHRoaXMsIFRvbmUuTmVnYXRlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnISc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXCEvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseVVuYXJ5LmJpbmQodGhpcywgVG9uZS5OT1QpXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgdGhlIGV4cHJlc3Npb24gc3RyaW5nXG5cdFx0ICogIEByZXR1cm4gIHtudW1iZXJ9ICAgICAgdGhlIGlucHV0IGNvdW50XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl9wYXJzZUlucHV0cyA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIGlucHV0QXJyYXkgPSBleHByLm1hdGNoKC9cXCRcXGQvZyk7XG5cdCAgICAgICAgdmFyIGlucHV0TWF4ID0gMDtcblx0ICAgICAgICBpZiAoaW5wdXRBcnJheSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnB1dE51bSA9IHBhcnNlSW50KGlucHV0QXJyYXlbaV0uc3Vic3RyKDEpKSArIDE7XG5cdCAgICAgICAgICAgICAgICBpbnB1dE1heCA9IE1hdGgubWF4KGlucHV0TWF4LCBpbnB1dE51bSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGlucHV0TWF4O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcGFyYW0gICB7QXJyYXl9IGFyZ3MgXHRhbiBhcnJheSBvZiBhcmd1bWVudHNcblx0XHQgKiAgQHJldHVybiAge3N0cmluZ30gdGhlIHJlc3VsdHMgb2YgdGhlIHJlcGxhY2VtZW50cyBiZWluZyByZXBsYWNlZFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fcmVwbGFjZW1lbnRzID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgICB2YXIgZXhwciA9IGFyZ3Muc2hpZnQoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIucmVwbGFjZSgvXFwlL2ksIGFyZ3NbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdG9rZW5pemUgdGhlIGV4cHJlc3Npb24gYmFzZWQgb24gdGhlIEV4cHJlc3Npb25zIG9iamVjdFxuXHRcdCAqICBAcGFyYW0gICB7c3RyaW5nfSBleHByIFxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgICAgIHJldHVybnMgdHdvIG1ldGhvZHMgb24gdGhlIHRva2VuaXplZCBsaXN0LCBuZXh0IGFuZCBwZWVrXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl90b2tlbml6ZSA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG5cdCAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuXHQgICAgICAgIHdoaWxlIChleHByLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIudHJpbSgpO1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBnZXROZXh0VG9rZW4oZXhwcik7XG5cdCAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIuc3Vic3RyKHRva2VuLnZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldE5leHRUb2tlbihleHByKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gVG9uZS5FeHByLl9FeHByZXNzaW9ucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gVG9uZS5FeHByLl9FeHByZXNzaW9uc1t0eXBlXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9wTmFtZSBpbiBncm91cCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGdyb3VwW29wTmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlZyA9IG9wLnJlZ2V4cDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBleHByLm1hdGNoKHJlZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoWzBdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcC5tZXRob2Rcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IFVuZXhwZWN0ZWQgdG9rZW4gJyArIGV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zWysrcG9zaXRpb25dO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwZWVrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zW3Bvc2l0aW9uICsgMV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICByZWN1cnNpdmVseSBwYXJzZSB0aGUgc3RyaW5nIGV4cHJlc3Npb24gaW50byBhIHN5bnRheCB0cmVlXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gICB7c3RyaW5nfSBleHByIFxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fcGFyc2VUcmVlID0gZnVuY3Rpb24gKGV4cHIpIHtcblx0ICAgICAgICB2YXIgbGV4ZXIgPSB0aGlzLl90b2tlbml6ZShleHByKTtcblx0ICAgICAgICB2YXIgaXNVbmRlZiA9IHRoaXMuaXNVbmRlZi5iaW5kKHRoaXMpO1xuXHQgICAgICAgIGZ1bmN0aW9uIG1hdGNoU3ludGF4KHRva2VuLCBzeW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICFpc1VuZGVmKHRva2VuKSAmJiB0b2tlbi50eXBlID09PSAnZ2x1ZScgJiYgdG9rZW4udmFsdWUgPT09IHN5bjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWF0Y2hHcm91cCh0b2tlbiwgZ3JvdXBOYW1lLCBwcmVjKSB7XG5cdCAgICAgICAgICAgIHZhciByZXQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIGdyb3VwID0gVG9uZS5FeHByLl9FeHByZXNzaW9uc1tncm91cE5hbWVdO1xuXHQgICAgICAgICAgICBpZiAoIWlzVW5kZWYodG9rZW4pKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvcE5hbWUgaW4gZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBncm91cFtvcE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcC5yZWdleHAudGVzdCh0b2tlbi52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmKHByZWMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AucHJlY2VkZW5jZSA9PT0gcHJlYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKHByZWNlZGVuY2UpIHtcblx0ICAgICAgICAgICAgaWYgKGlzVW5kZWYocHJlY2VkZW5jZSkpIHtcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2UgPSA1O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBleHByO1xuXHQgICAgICAgICAgICBpZiAocHJlY2VkZW5jZSA8IDApIHtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5KCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKHByZWNlZGVuY2UgLSAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgIHdoaWxlIChtYXRjaEdyb3VwKHRva2VuLCAnYmluYXJ5JywgcHJlY2VkZW5jZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogdG9rZW4udmFsdWUsXG5cdCAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0b2tlbi5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUV4cHJlc3Npb24ocHJlY2VkZW5jZSAtIDEpXG5cdCAgICAgICAgICAgICAgICAgICAgXVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBwYXJzZVVuYXJ5KCkge1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4sIGV4cHI7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICBpZiAobWF0Y2hHcm91cCh0b2tlbiwgJ3VuYXJ5JykpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnkoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRva2VuLnZhbHVlLFxuXHQgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdG9rZW4ubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtleHByXVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VQcmltYXJ5KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeSgpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICAgICAgaWYgKGlzVW5kZWYodG9rZW4pKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogVW5leHBlY3RlZCB0ZXJtaW5hdGlvbiBvZiBleHByZXNzaW9uJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdmdW5jJykge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkNhbGwodG9rZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAndmFsdWUnKSB7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0b2tlbi5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgYXJnczogdG9rZW4udmFsdWVcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKG1hdGNoU3ludGF4KHRva2VuLCAnKCcpKSB7XG5cdCAgICAgICAgICAgICAgICBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcpJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0V4cGVjdGVkICknKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBQYXJzZSBlcnJvciwgY2Fubm90IHByb2Nlc3MgdG9rZW4gJyArIHRva2VuLnZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkNhbGwoZnVuYykge1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4sIGFyZ3MgPSBbXTtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcoJykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBFeHBlY3RlZCAoIGluIGEgZnVuY3Rpb24gY2FsbCBcIicgKyBmdW5jLnZhbHVlICsgJ1wiJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcpJykpIHtcblx0ICAgICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50TGlzdCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBpZiAoIW1hdGNoU3ludGF4KHRva2VuLCAnKScpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogRXhwZWN0ZWQgKSBpbiBhIGZ1bmN0aW9uIGNhbGwgXCInICsgZnVuYy52YWx1ZSArICdcIicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgYXJnczogYXJncyxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudExpc3QoKSB7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiwgZXhwciwgYXJncyA9IFtdO1xuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZXhwcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIHRocm93IGV4Y2VwdGlvbj9cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtYXRjaFN5bnRheCh0b2tlbiwgJywnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHJlY3Vyc2l2ZWx5IGV2YWx1YXRlIHRoZSBleHByZXNzaW9uIHRyZWVcblx0XHQgKiAgQHBhcmFtICAge09iamVjdH0gdHJlZSBcblx0XHQgKiAgQHJldHVybiAge0F1ZGlvTm9kZX0gICAgICB0aGUgcmVzdWx0aW5nIGF1ZGlvIG5vZGUgZnJvbSB0aGUgZXhwcmVzc2lvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fZXZhbCA9IGZ1bmN0aW9uICh0cmVlKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWYodHJlZSkpIHtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0cmVlLm1ldGhvZCh0cmVlLmFyZ3MsIHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuXHQgICAgICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgYWxsIHRoZSBub2Rlc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fZGlzcG9zZU5vZGVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaXNGdW5jdGlvbihub2RlLmRpc3Bvc2UpKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRnVuY3Rpb24obm9kZS5kaXNjb25uZWN0KSkge1xuXHQgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbm9kZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX25vZGVzW2ldID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9kaXNwb3NlTm9kZXMoKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FeHByO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQ29udmVydCBhbiBpbmNvbWluZyBzaWduYWwgYmV0d2VlbiAwLCAxIHRvIGFuIGVxdWFsIHBvd2VyIGdhaW4gc2NhbGUuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGVxUG93R2FpbiA9IG5ldyBUb25lLkVxdWFsUG93ZXJHYWluKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkVxdWFsUG93ZXJHYWluID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2VxUG93ZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZhbCkgPCAwLjAwMSkge1xuXHQgICAgICAgICAgICAgICAgLy9zaG91bGQgb3V0cHV0IDAgd2hlbiBpbnB1dCBpcyAwXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFsUG93ZXJTY2FsZSh2YWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpLCA0MDk2KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkVxdWFsUG93ZXJHYWluLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVxdWFsUG93ZXJHYWlufSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVxdWFsUG93ZXJHYWluLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9lcVBvd2VyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9lcVBvd2VyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FcXVhbFBvd2VyR2Fpbjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiBAY2xhc3MgIFRvbmUuQ3Jvc3NmYWRlIHByb3ZpZGVzIGVxdWFsIHBvd2VyIGZhZGluZyBiZXR3ZWVuIHR3byBpbnB1dHMuIFxuXHRcdCAqICAgICAgICAgTW9yZSBvbiBjcm9zc2ZhZGluZyB0ZWNobmlxdWUgW2hlcmVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZhZGVfKGF1ZGlvX2VuZ2luZWVyaW5nKSNDcm9zc2ZhZGluZykuXG5cdFx0ICpcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiBAcGFyYW0ge05vcm1hbFJhbmdlfSBbaW5pdGlhbEZhZGU9MC41XVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIGNyb3NzRmFkZSA9IG5ldyBUb25lLkNyb3NzRmFkZSgwLjUpO1xuXHRcdCAqIC8vY29ubmVjdCBlZmZlY3QgQSB0byBjcm9zc2ZhZGUgZnJvbVxuXHRcdCAqIC8vZWZmZWN0IG91dHB1dCAwIHRvIGNyb3NzZmFkZSBpbnB1dCAwXG5cdFx0ICogZWZmZWN0QS5jb25uZWN0KGNyb3NzRmFkZSwgMCwgMCk7XG5cdFx0ICogLy9jb25uZWN0IGVmZmVjdCBCIHRvIGNyb3NzZmFkZSBmcm9tXG5cdFx0ICogLy9lZmZlY3Qgb3V0cHV0IDAgdG8gY3Jvc3NmYWRlIGlucHV0IDFcblx0XHQgKiBlZmZlY3RCLmNvbm5lY3QoY3Jvc3NGYWRlLCAwLCAxKTtcblx0XHQgKiBjcm9zc0ZhZGUuZmFkZS52YWx1ZSA9IDA7XG5cdFx0ICogLy8gXiBvbmx5IGVmZmVjdEEgaXMgb3V0cHV0XG5cdFx0ICogY3Jvc3NGYWRlLmZhZGUudmFsdWUgPSAxO1xuXHRcdCAqIC8vIF4gb25seSBlZmZlY3RCIGlzIG91dHB1dFxuXHRcdCAqIGNyb3NzRmFkZS5mYWRlLnZhbHVlID0gMC41O1xuXHRcdCAqIC8vIF4gdGhlIHR3byBzaWduYWxzIGFyZSBtaXhlZCBlcXVhbGx5LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3Jvc3NGYWRlID0gZnVuY3Rpb24gKGluaXRpYWxGYWRlKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFswXTwvY29kZT4uIFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmEgPSB0aGlzLmlucHV0WzBdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFsxXTwvY29kZT4uIFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmIgPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogXHRUaGUgbWl4IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuIEEgZmFkZSB2YWx1ZSBvZiAwXG5cdFx0XHQgKiBcdHdpbGwgb3V0cHV0IDEwMCUgPGNvZGU+aW5wdXRbMF08L2NvZGU+IGFuZCBcblx0XHRcdCAqIFx0YSB2YWx1ZSBvZiAxIHdpbGwgb3V0cHV0IDEwMCUgPGNvZGU+aW5wdXRbMV08L2NvZGU+LiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlID0gbmV3IFRvbmUuU2lnbmFsKHRoaXMuZGVmYXVsdEFyZyhpbml0aWFsRmFkZSwgMC41KSwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBlcXVhbCBwb3dlciBnYWluIGNyb3NzIGZhZGVcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkVxdWFsUG93ZXJHYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckEgPSBuZXcgVG9uZS5FcXVhbFBvd2VyR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGVxdWFsIHBvd2VyIGdhaW4gY3Jvc3MgZmFkZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXF1YWxQb3dlckdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQiA9IG5ldyBUb25lLkVxdWFsUG93ZXJHYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaW52ZXJ0IHRoZSBpbmNvbWluZyBzaWduYWxcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW52ZXJ0ID0gbmV3IFRvbmUuRXhwcignMSAtICQwJyk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuYS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLmIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5mYWRlLmNoYWluKHRoaXMuX2VxdWFsUG93ZXJCLCB0aGlzLmIuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5mYWRlLmNoYWluKHRoaXMuX2ludmVydCwgdGhpcy5fZXF1YWxQb3dlckEsIHRoaXMuYS5nYWluKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZmFkZScpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ3Jvc3NGYWRlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Dcm9zc0ZhZGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3Jvc3NGYWRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZmFkZScpO1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJBLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJCID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZhZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZmFkZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5faW52ZXJ0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9pbnZlcnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuYS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5hID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuYiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ3Jvc3NGYWRlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRmlsdGVyIGlzIGEgZmlsdGVyIHdoaWNoIGFsbG93cyBmb3IgYWxsIG9mIHRoZSBzYW1lIG5hdGl2ZSBtZXRob2RzXG5cdFx0ICogICAgICAgICAgYXMgdGhlIFtCaXF1YWRGaWx0ZXJOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1iaXF1YWRmaWx0ZXJub2RlLWludGVyZmFjZSkuIFxuXHRcdCAqICAgICAgICAgIFRvbmUuRmlsdGVyIGhhcyB0aGUgYWRkZWQgYWJpbGl0eSB0byBzZXQgdGhlIGZpbHRlciByb2xsb2ZmIGF0IC0xMiBcblx0XHQgKiAgICAgICAgICAoZGVmYXVsdCksIC0yNCBhbmQgLTQ4LiBcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIGN1dG9mZiBmcmVxdWVuY3kgb2YgdGhlIGZpbHRlci5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmc9fSB0eXBlIFRoZSB0eXBlIG9mIGZpbHRlci5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSByb2xsb2ZmIFRoZSBkcm9wIGluIGRlY2liZWxzIHBlciBvY3RhdmUgYWZ0ZXIgdGhlIGN1dG9mZiBmcmVxdWVuY3kuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgMyBjaG9pY2VzOiAtMTIsIC0yNCwgYW5kIC00OFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgZmlsdGVyID0gbmV3IFRvbmUuRmlsdGVyKDIwMCwgXCJoaWdocGFzc1wiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ3JvbGxvZmYnXG5cdCAgICAgICAgXSwgVG9uZS5GaWx0ZXIuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmaWx0ZXIocylcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY3V0b2ZmIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVyLiBcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbCgwLCBUb25lLlR5cGUuQ2VudHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIG9mIHRoZSBmaWx0ZXIsIG9ubHkgdXNlZCBpbiBjZXJ0YWluIGZpbHRlciB0eXBlc1xuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5nYWluID0gbmV3IFRvbmUuU2lnbmFsKHtcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5nYWluLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIFEgb3IgUXVhbGl0eSBvZiB0aGUgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuUSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLlEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0eXBlIG9mIHRoZSBmaWx0ZXJcblx0XHRcdCAqICBAdHlwZSB7c3RyaW5nfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByb2xsb2ZmIHZhbHVlIG9mIHRoZSBmaWx0ZXJcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yb2xsb2ZmID0gb3B0aW9ucy5yb2xsb2ZmO1xuXHQgICAgICAgIC8vc2V0IHRoZSByb2xsb2ZmO1xuXHQgICAgICAgIHRoaXMucm9sbG9mZiA9IG9wdGlvbnMucm9sbG9mZjtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2dhaW4nLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZpbHRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRmlsdGVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd0eXBlJzogJ2xvd3Bhc3MnLFxuXHQgICAgICAgICdmcmVxdWVuY3knOiAzNTAsXG5cdCAgICAgICAgJ3JvbGxvZmYnOiAtMTIsXG5cdCAgICAgICAgJ1EnOiAxLFxuXHQgICAgICAgICdnYWluJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBmaWx0ZXIuIFR5cGVzOiBcImxvd3Bhc3NcIiwgXCJoaWdocGFzc1wiLCBcblx0XHQgKiBcImJhbmRwYXNzXCIsIFwibG93c2hlbGZcIiwgXCJoaWdoc2hlbGZcIiwgXCJub3RjaFwiLCBcImFsbHBhc3NcIiwgb3IgXCJwZWFraW5nXCIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZpbHRlciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZpbHRlci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdmFyIHR5cGVzID0gW1xuXHQgICAgICAgICAgICAgICAgJ2xvd3Bhc3MnLFxuXHQgICAgICAgICAgICAgICAgJ2hpZ2hwYXNzJyxcblx0ICAgICAgICAgICAgICAgICdiYW5kcGFzcycsXG5cdCAgICAgICAgICAgICAgICAnbG93c2hlbGYnLFxuXHQgICAgICAgICAgICAgICAgJ2hpZ2hzaGVsZicsXG5cdCAgICAgICAgICAgICAgICAnbm90Y2gnLFxuXHQgICAgICAgICAgICAgICAgJ2FsbHBhc3MnLFxuXHQgICAgICAgICAgICAgICAgJ3BlYWtpbmcnXG5cdCAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgIGlmICh0eXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVG9uZS5GaWx0ZXI6IGludmFsaWQgdHlwZSAnICsgdHlwZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tpXS50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHJvbGxvZmYgb2YgdGhlIGZpbHRlciB3aGljaCBpcyB0aGUgZHJvcCBpbiBkYlxuXHRcdCAqIHBlciBvY3RhdmUuIEltcGxlbWVudGVkIGludGVybmFsbHkgYnkgY2FzY2FkaW5nIGZpbHRlcnMuXG5cdFx0ICogT25seSBhY2NlcHRzIHRoZSB2YWx1ZXMgLTEyLCAtMjQsIC00OCBhbmQgLTk2LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZpbHRlciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHJvbGxvZmZcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZpbHRlci5wcm90b3R5cGUsICdyb2xsb2ZmJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9sbG9mZjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJvbGxvZmYpIHtcblx0ICAgICAgICAgICAgcm9sbG9mZiA9IHBhcnNlSW50KHJvbGxvZmYsIDEwKTtcblx0ICAgICAgICAgICAgdmFyIHBvc3NpYmlsaXRpZXMgPSBbXG5cdCAgICAgICAgICAgICAgICAtMTIsXG5cdCAgICAgICAgICAgICAgICAtMjQsXG5cdCAgICAgICAgICAgICAgICAtNDgsXG5cdCAgICAgICAgICAgICAgICAtOTZcblx0ICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgdmFyIGNhc2NhZGluZ0NvdW50ID0gcG9zc2liaWxpdGllcy5pbmRleE9mKHJvbGxvZmYpO1xuXHQgICAgICAgICAgICAvL2NoZWNrIHRoZSByb2xsb2ZmIGlzIHZhbGlkXG5cdCAgICAgICAgICAgIGlmIChjYXNjYWRpbmdDb3VudCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUb25lLkZpbHRlcjogcm9sbG9mZiBjYW4gb25seSBiZSAtMTIsIC0yNCwgLTQ4IG9yIC05NicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhc2NhZGluZ0NvdW50ICs9IDE7XG5cdCAgICAgICAgICAgIHRoaXMuX3JvbGxvZmYgPSByb2xsb2ZmO1xuXHQgICAgICAgICAgICAvL2ZpcnN0IGRpc2Nvbm5lY3QgdGhlIGZpbHRlcnMgYW5kIHRocm93IHRoZW0gYXdheVxuXHQgICAgICAgICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2ldLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbaV0gPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnMgPSBuZXcgQXJyYXkoY2FzY2FkaW5nQ291bnQpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjb3VudCA9IDA7IGNvdW50IDwgY2FzY2FkaW5nQ291bnQ7IGNvdW50KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIudHlwZSA9IHRoaXMuX3R5cGU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KGZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kZXR1bmUuY29ubmVjdChmaWx0ZXIuZGV0dW5lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuUS5jb25uZWN0KGZpbHRlci5RKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KGZpbHRlci5nYWluKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbY291bnRdID0gZmlsdGVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vY29ubmVjdCB0aGVtIHVwXG5cdCAgICAgICAgICAgIHZhciBjb25uZWN0aW9uQ2hhaW4gPSBbdGhpcy5pbnB1dF0uY29uY2F0KHRoaXMuX2ZpbHRlcnMpLmNvbmNhdChbdGhpcy5vdXRwdXRdKTtcblx0ICAgICAgICAgICAgdGhpcy5jb25uZWN0U2VyaWVzLmFwcGx5KHRoaXMsIGNvbm5lY3Rpb25DaGFpbik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GaWx0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZmlsdGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2ldLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZ2FpbicsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLlEuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5nYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmdhaW4gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZpbHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFNwbGl0IHRoZSBpbmNvbWluZyBzaWduYWwgaW50byB0aHJlZSBiYW5kcyAobG93LCBtaWQsIGhpZ2gpXG5cdFx0ICogICAgICAgICB3aXRoIHR3byBjcm9zc292ZXIgZnJlcXVlbmN5IGNvbnRyb2xzLiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2xvd0ZyZXF1ZW5jeV0gdGhlIGxvdy9taWQgY3Jvc3NvdmVyIGZyZXF1ZW5jeVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2hpZ2hGcmVxdWVuY3ldIHRoZSBtaWQvaGlnaCBjcm9zc292ZXIgZnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZFNwbGl0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knXG5cdCAgICAgICAgXSwgVG9uZS5NdWx0aWJhbmRTcGxpdC5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGlucHV0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb3V0cHV0c1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgQXJyYXkoMyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxvdyBiYW5kLiBBbGlhcyBmb3IgPGNvZGU+b3V0cHV0WzBdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93ID0gdGhpcy5vdXRwdXRbMF0gPSBuZXcgVG9uZS5GaWx0ZXIoMCwgJ2xvd3Bhc3MnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbG93ZXIgZmlsdGVyIG9mIHRoZSBtaWQgYmFuZFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG93TWlkRmlsdGVyID0gbmV3IFRvbmUuRmlsdGVyKDAsICdoaWdocGFzcycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQgYmFuZCBvdXRwdXQuIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMV08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWQgPSB0aGlzLm91dHB1dFsxXSA9IG5ldyBUb25lLkZpbHRlcigwLCAnbG93cGFzcycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBoaWdoIGJhbmQgb3V0cHV0LiBBbGlhcyBmb3IgPGNvZGU+b3V0cHV0WzJdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IHRoaXMub3V0cHV0WzJdID0gbmV3IFRvbmUuRmlsdGVyKDAsICdoaWdocGFzcycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsb3cvbWlkIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmxvd0ZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZC9oaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5oaWdoRnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcXVhbGl0eSBvZiBhbGwgdGhlIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuUSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLlEpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZmFuKHRoaXMubG93LCB0aGlzLmhpZ2gpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY2hhaW4odGhpcy5fbG93TWlkRmlsdGVyLCB0aGlzLm1pZCk7XG5cdCAgICAgICAgLy90aGUgZnJlcXVlbmN5IGNvbnRyb2wgc2lnbmFsXG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kuY29ubmVjdCh0aGlzLmxvdy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fbG93TWlkRmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5LmNvbm5lY3QodGhpcy5taWQuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kuY29ubmVjdCh0aGlzLmhpZ2guZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3RoZSBRIHZhbHVlXG5cdCAgICAgICAgdGhpcy5RLmNvbm5lY3QodGhpcy5sb3cuUSk7XG5cdCAgICAgICAgdGhpcy5RLmNvbm5lY3QodGhpcy5fbG93TWlkRmlsdGVyLlEpO1xuXHQgICAgICAgIHRoaXMuUS5jb25uZWN0KHRoaXMubWlkLlEpO1xuXHQgICAgICAgIHRoaXMuUS5jb25uZWN0KHRoaXMuaGlnaC5RKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NdWx0aWJhbmRTcGxpdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRTcGxpdC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbG93RnJlcXVlbmN5JzogNDAwLFxuXHQgICAgICAgICdoaWdoRnJlcXVlbmN5JzogMjUwMCxcblx0ICAgICAgICAnUSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk11bHRpYmFuZFNwbGl0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZFNwbGl0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5sb3cuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubG93ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sb3dNaWRGaWx0ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xvd01pZEZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5taWQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2guZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5RLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpYmFuZFNwbGl0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5FUTMgaXMgYSB0aHJlZSBiYW5kIEVRIHdpdGggY29udHJvbCBvdmVyIGxvdywgbWlkLCBhbmQgaGlnaCBnYWluIGFzXG5cdFx0ICogICAgICAgICB3ZWxsIGFzIHRoZSBsb3cgYW5kIGhpZ2ggY3Jvc3NvdmVyIGZyZXF1ZW5jaWVzLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN8T2JqZWN0fSBbbG93TGV2ZWxdIFRoZSBnYWluIGFwcGxpZWQgdG8gdGhlIGxvd3MuXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN9IFttaWRMZXZlbF0gVGhlIGdhaW4gYXBwbGllZCB0byB0aGUgbWlkLlxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfSBbaGlnaExldmVsXSBUaGUgZ2FpbiBhcHBsaWVkIHRvIHRoZSBoaWdoLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBlcSA9IG5ldyBUb25lLkVRMygtMTAsIDMsIC0yMCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkVRMyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnaGlnaCdcblx0ICAgICAgICBdLCBUb25lLkVRMy5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG91dHB1dCBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbXVsdGliYW5kIHNwbGl0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGliYW5kU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk11bHRpYmFuZFNwbGl0KHtcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IG9wdGlvbnMubG93RnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IG9wdGlvbnMuaGlnaEZyZXF1ZW5jeVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIGZvciB0aGUgbG93ZXIgc2lnbmFsc1xuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb3dHYWluID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLmxvdywgVG9uZS5UeXBlLkRlY2liZWxzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZ2FpbiBmb3IgdGhlIG1pZCBzaWduYWxzXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZEdhaW4gPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMubWlkLCBUb25lLlR5cGUuRGVjaWJlbHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gaW4gZGVjaWJlbHMgb2YgdGhlIGhpZ2ggcGFydFxuXHRcdFx0ICogQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9oaWdoR2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5oaWdoLCBUb25lLlR5cGUuRGVjaWJlbHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gaW4gZGVjaWJlbHMgb2YgdGhlIGxvdyBwYXJ0XG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvdyA9IHRoaXMuX2xvd0dhaW4uZ2Fpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBnYWluIGluIGRlY2liZWxzIG9mIHRoZSBtaWQgcGFydFxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWQgPSB0aGlzLl9taWRHYWluLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZ2FpbiBpbiBkZWNpYmVscyBvZiB0aGUgaGlnaCBwYXJ0XG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2ggPSB0aGlzLl9oaWdoR2Fpbi5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBRIHZhbHVlIGZvciBhbGwgb2YgdGhlIGZpbHRlcnMuIFxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLlEgPSB0aGlzLl9tdWx0aWJhbmRTcGxpdC5RO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsb3cvbWlkIGNyb3Nzb3ZlciBmcmVxdWVuY3kuIFxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSB0aGlzLl9tdWx0aWJhbmRTcGxpdC5sb3dGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZC9oaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY3kuIFxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5ID0gdGhpcy5fbXVsdGliYW5kU3BsaXQuaGlnaEZyZXF1ZW5jeTtcblx0ICAgICAgICAvL3RoZSBmcmVxdWVuY3kgYmFuZHNcblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdC5sb3cuY2hhaW4odGhpcy5fbG93R2FpbiwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0Lm1pZC5jaGFpbih0aGlzLl9taWRHYWluLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGliYW5kU3BsaXQuaGlnaC5jaGFpbih0aGlzLl9oaWdoR2FpbiwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkVRMyk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICovXG5cdCAgICBUb25lLkVRMy5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbG93JzogMCxcblx0ICAgICAgICAnbWlkJzogMCxcblx0ICAgICAgICAnaGlnaCc6IDAsXG5cdCAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IDQwMCxcblx0ICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IDI1MDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRVEzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVRMy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdoaWdoJyxcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbG93R2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbG93R2FpbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWlkR2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkR2FpbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5faGlnaEdhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2hpZ2hHYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmxvdyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5taWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5RID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FUTM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgUGVyZm9ybXMgYSBsaW5lYXIgc2NhbGluZyBvbiBhbiBpbnB1dCBzaWduYWwuXG5cdFx0ICogICAgICAgICAgU2NhbGVzIGEgTm9ybWFsUmFuZ2UgaW5wdXQgdG8gYmV0d2VlblxuXHRcdCAqICAgICAgICAgIG91dHB1dE1pbiBhbmQgb3V0cHV0TWF4LlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE1pbj0wXSBUaGUgb3V0cHV0IHZhbHVlIHdoZW4gdGhlIGlucHV0IGlzIDAuIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE1heD0xXVx0VGhlIG91dHB1dCB2YWx1ZSB3aGVuIHRoZSBpbnB1dCBpcyAxLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2NhbGUgPSBuZXcgVG9uZS5TY2FsZSg1MCwgMTAwKTtcblx0XHQgKiB2YXIgc2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKDAuNSkuY29ubmVjdChzY2FsZSk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIHNjYWxlIGVxdWFscyA3NVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZSA9IGZ1bmN0aW9uIChvdXRwdXRNaW4sIG91dHB1dE1heCkge1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vdXRwdXRNaW4gPSB0aGlzLmRlZmF1bHRBcmcob3V0cHV0TWluLCAwKTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3V0cHV0TWF4ID0gdGhpcy5kZWZhdWx0QXJnKG91dHB1dE1heCwgMSk7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk11bHRpcGx5KDEpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFkZH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWRkID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5BZGQoMCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUuY29ubmVjdCh0aGlzLl9hZGQpO1xuXHQgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TY2FsZSwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZS4gVGhpcyBudW1iZXIgaXMgb3V0cHV0IHdoZW4gXG5cdFx0ICogdGhlIHZhbHVlIGlucHV0IHZhbHVlIGlzIDAuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNjYWxlI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZS5wcm90b3R5cGUsICdtaW4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRwdXRNaW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3V0cHV0TWluID0gbWluO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSYW5nZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1heGltdW0gb3V0cHV0IHZhbHVlLiBUaGlzIG51bWJlciBpcyBvdXRwdXQgd2hlbiBcblx0XHQgKiB0aGUgdmFsdWUgaW5wdXQgdmFsdWUgaXMgMS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlLnByb3RvdHlwZSwgJ21heCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX291dHB1dE1heDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1heCkge1xuXHQgICAgICAgICAgICB0aGlzLl9vdXRwdXRNYXggPSBtYXg7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgc2V0IHRoZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGUucHJvdG90eXBlLl9zZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9hZGQudmFsdWUgPSB0aGlzLl9vdXRwdXRNaW47XG5cdCAgICAgICAgdGhpcy5fc2NhbGUudmFsdWUgPSB0aGlzLl9vdXRwdXRNYXggLSB0aGlzLl9vdXRwdXRNaW47XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TY2FsZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYWRkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hZGQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2NhbGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFBlcmZvcm1zIGFuIGV4cG9uZW50aWFsIHNjYWxpbmcgb24gYW4gaW5wdXQgc2lnbmFsLlxuXHRcdCAqICAgICAgICAgIFNjYWxlcyBhIE5vcm1hbFJhbmdlIHZhbHVlIFswLDFdIGV4cG9uZW50aWFsbHlcblx0XHQgKiAgICAgICAgICB0byB0aGUgb3V0cHV0IHJhbmdlIG9mIG91dHB1dE1pbiB0byBvdXRwdXRNYXguXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TWluPTBdIFRoZSBvdXRwdXQgdmFsdWUgd2hlbiB0aGUgaW5wdXQgaXMgMC4gXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TWF4PTFdXHRUaGUgb3V0cHV0IHZhbHVlIHdoZW4gdGhlIGlucHV0IGlzIDEuIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2V4cG9uZW50PTJdIFRoZSBleHBvbmVudCB3aGljaCBzY2FsZXMgdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2NhbGVFeHAgPSBuZXcgVG9uZS5TY2FsZUV4cCgwLCAxMDAsIDIpO1xuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMC41KS5jb25uZWN0KHNjYWxlRXhwKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVFeHAgPSBmdW5jdGlvbiAob3V0cHV0TWluLCBvdXRwdXRNYXgsIGV4cG9uZW50KSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc2NhbGUgdGhlIGlucHV0IHRvIHRoZSBvdXRwdXQgcmFuZ2Vcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TY2FsZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlNjYWxlKG91dHB1dE1pbiwgb3V0cHV0TWF4KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBvd31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlBvdyh0aGlzLmRlZmF1bHRBcmcoZXhwb25lbnQsIDIpKTtcblx0ICAgICAgICB0aGlzLl9leHAuY29ubmVjdCh0aGlzLl9zY2FsZSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TY2FsZUV4cCwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqIEluc3RlYWQgb2YgaW50ZXJwb2xhdGluZyBsaW5lYXJseSBiZXR3ZWVuIHRoZSA8Y29kZT5taW48L2NvZGU+IGFuZCBcblx0XHQgKiA8Y29kZT5tYXg8L2NvZGU+IHZhbHVlcywgc2V0dGluZyB0aGUgZXhwb25lbnQgd2lsbCBpbnRlcnBvbGF0ZSBiZXR3ZWVuXG5cdFx0ICogdGhlIHR3byB2YWx1ZXMgd2l0aCBhbiBleHBvbmVudGlhbCBjdXJ2ZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVFeHAjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBleHBvbmVudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVFeHAucHJvdG90eXBlLCAnZXhwb25lbnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHAudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwLnZhbHVlID0gZXhwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbmltdW0gb3V0cHV0IHZhbHVlLiBUaGlzIG51bWJlciBpcyBvdXRwdXQgd2hlbiBcblx0XHQgKiB0aGUgdmFsdWUgaW5wdXQgdmFsdWUgaXMgMC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVFeHAjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtaW5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlRXhwLnByb3RvdHlwZSwgJ21pbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5taW4gPSBtaW47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSBvdXRwdXQgdmFsdWUuIFRoaXMgbnVtYmVyIGlzIG91dHB1dCB3aGVuIFxuXHRcdCAqIHRoZSB2YWx1ZSBpbnB1dCB2YWx1ZSBpcyAxLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZUV4cCNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1heFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVFeHAucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWF4O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWF4KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1heCA9IG1heDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2NhbGVFeHB9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVFeHAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZXhwLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9leHAgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNjYWxlRXhwO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgV3JhcHBlciBhcm91bmQgV2ViIEF1ZGlvJ3MgbmF0aXZlIFtEZWxheU5vZGVdKGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jdGhlLWRlbGF5bm9kZS1pbnRlcmZhY2UpLiBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7VGltZT19IGRlbGF5VGltZSBUaGUgZGVsYXkgYXBwbGllZCB0byB0aGUgaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSBtYXhEZWxheSBUaGUgbWF4aW11bSBkZWxheSB0aW1lLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAnbWF4RGVsYXknXG5cdCAgICAgICAgXSwgVG9uZS5EZWxheS5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG5hdGl2ZSBkZWxheSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0RlbGF5Tm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZURlbGF5KHRoaXMudG9TZWNvbmRzKG9wdGlvbnMubWF4RGVsYXkpKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHRpbWUgdGhlIGluY29taW5nIHNpZ25hbCBpc1xuXHRcdFx0ICogIGRlbGF5ZWQuIFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBhcmFtfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9kZWxheU5vZGUuZGVsYXlUaW1lLFxuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuVGltZSxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5kZWxheVRpbWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZGVsYXlUaW1lJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5EZWxheSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRGVsYXkuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21heERlbGF5JzogMSxcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRGVsYXl9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRlbGF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2RlbGF5VGltZScpO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5EZWxheTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIENvbWIgZmlsdGVycyBhcmUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIGZvciBwaHlzaWNhbCBtb2RlbGluZy4gUmVhZCBtb3JlXG5cdFx0ICogICAgICAgICBhYm91dCBjb21iIGZpbHRlcnMgb24gW0NDUk1BJ3Mgd2Vic2l0ZV0oaHR0cHM6Ly9jY3JtYS5zdGFuZm9yZC5lZHUvfmpvcy9wYXNwL0ZlZWRiYWNrX0NvbWJfRmlsdGVycy5odG1sKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFtkZWxheVRpbWVdIFRoZSBkZWxheSB0aW1lIG9mIHRoZSBmaWx0ZXIuIFxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlPX0gcmVzb25hbmNlIFRoZSBhbW91bnQgb2YgZmVlZGJhY2sgdGhlIGZpbHRlciBoYXMuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAncmVzb25hbmNlJ1xuXHQgICAgICAgIF0sIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXkgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtEZWxheU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5ID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuRGVsYXkob3B0aW9ucy5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZGVsYXkgb2YgdGhlIGNvbWIgZmlsdGVyLiBcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IHRoaXMuX2RlbGF5LmRlbGF5VGltZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZmVlZGJhY2sgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2sgPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMucmVzb25hbmNlLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZmVlZGJhY2sgb2YgdGhlIGRlbGF5ZWQgc2lnbmFsLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yZXNvbmFuY2UgPSB0aGlzLl9mZWVkYmFjay5nYWluO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmNoYWluKHRoaXMuX2ZlZWRiYWNrLCB0aGlzLl9kZWxheSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZlZWRiYWNrQ29tYkZpbHRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAuMSxcblx0ICAgICAgICAncmVzb25hbmNlJzogMC41XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZlZWRiYWNrQ29tYkZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRm9sbG93ZXIgaXMgYSAgY3J1ZGUgZW52ZWxvcGUgZm9sbG93ZXIgd2hpY2ggd2lsbCBmb2xsb3cgXG5cdFx0ICogICAgICAgICAgdGhlIGFtcGxpdHVkZSBvZiBhbiBpbmNvbWluZyBzaWduYWwuIFxuXHRcdCAqICAgICAgICAgIFRha2UgY2FyZSB3aXRoIHNtYWxsICg8IDAuMDIpIGF0dGFjayBvciBkZWNheSB2YWx1ZXMgXG5cdFx0ICogICAgICAgICAgYXMgZm9sbG93ZXIgaGFzIHNvbWUgcmlwcGxlIHdoaWNoIGlzIGV4YWdnZXJhdGVkXG5cdFx0ICogICAgICAgICAgYXQgdGhlc2UgdmFsdWVzLiBSZWFkIG1vcmUgYWJvdXQgZW52ZWxvcGUgZm9sbG93ZXJzIChhbHNvIGtub3duIFxuXHRcdCAqICAgICAgICAgIGFzIGVudmVsb3BlIGRldGVjdG9ycykgb24gW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW52ZWxvcGVfZGV0ZWN0b3IpLlxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbYXR0YWNrXSBUaGUgcmF0ZSBhdCB3aGljaCB0aGUgZm9sbG93ZXIgcmlzZXMuXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJlbGVhc2UgVGhlIHJhdGUgYXQgd2hpY2ggdGhlIGZvbG93ZXIgZmFsbHMuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBmb2xsb3dlciA9IG5ldyBUb25lLkZvbGxvd2VyKDAuMiwgMC40KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDEpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5Gb2xsb3dlci5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQWJzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hYnMgPSBuZXcgVG9uZS5BYnMoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbG93cGFzcyBmaWx0ZXIgd2hpY2ggc21vb3RocyB0aGUgaW5wdXRcblx0XHRcdCAqICBAdHlwZSB7QmlxdWFkRmlsdGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci50eXBlID0gJ2xvd3Bhc3MnO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci5mcmVxdWVuY3kudmFsdWUgPSAwO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci5RLnZhbHVlID0gLTEwMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7V2F2ZVNoYXBlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcyA9IG5ldyBUb25lLldhdmVTaGFwZXIoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TdWJ0cmFjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3ViID0gbmV3IFRvbmUuU3VidHJhY3QoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXkgPSBuZXcgVG9uZS5EZWxheSh0aGlzLmJsb2NrVGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhpcyBrZWVwcyBpdCBmYXIgZnJvbSAwLCBldmVuIGZvciB2ZXJ5IHNtYWxsIGRpZmZlcmVuY2VzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHQgPSBuZXcgVG9uZS5NdWx0aXBseSgxMDAwMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYXR0YWNrID0gb3B0aW9ucy5hdHRhY2s7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcmVsZWFzZSA9IG9wdGlvbnMucmVsZWFzZTtcblx0ICAgICAgICAvL3RoZSBzbW9vdGhlZCBzaWduYWwgdG8gZ2V0IHRoZSB2YWx1ZXNcblx0ICAgICAgICB0aGlzLmlucHV0LmNoYWluKHRoaXMuX2FicywgdGhpcy5fZmlsdGVyLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy90aGUgZGlmZmVyZW5jZSBwYXRoXG5cdCAgICAgICAgdGhpcy5fYWJzLmNvbm5lY3QodGhpcy5fc3ViLCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXIuY2hhaW4odGhpcy5fZGVsYXksIHRoaXMuX3N1Yik7XG5cdCAgICAgICAgLy90aHJlc2hvbGQgdGhlIGRpZmZlcmVuY2UgYW5kIHVzZSB0aGUgdGhyZXNoIHRvIHNldCB0aGUgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5fc3ViLmNoYWluKHRoaXMuX211bHQsIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcywgdGhpcy5fZmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSB2YWx1ZXMgaW4gdGhlIHRhYmxlXG5cdCAgICAgICAgdGhpcy5fc2V0QXR0YWNrUmVsZWFzZSh0aGlzLl9hdHRhY2ssIHRoaXMuX3JlbGVhc2UpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRm9sbG93ZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2F0dGFjayc6IDAuMDUsXG5cdCAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc2V0cyB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIHRpbWVzIGluIHRoZSB3YXZlIHNoYXBlclxuXHRcdCAqICBAcGFyYW0gICB7VGltZX0gYXR0YWNrICBcblx0XHQgKiAgQHBhcmFtICAge1RpbWV9IHJlbGVhc2UgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZvbGxvd2VyLnByb3RvdHlwZS5fc2V0QXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChhdHRhY2ssIHJlbGVhc2UpIHtcblx0ICAgICAgICB2YXIgbWluVGltZSA9IHRoaXMuYmxvY2tUaW1lO1xuXHQgICAgICAgIGF0dGFjayA9IFRvbmUuVGltZShhdHRhY2spLnRvRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgcmVsZWFzZSA9IFRvbmUuVGltZShyZWxlYXNlKS50b0ZyZXF1ZW5jeSgpO1xuXHQgICAgICAgIGF0dGFjayA9IE1hdGgubWF4KGF0dGFjaywgbWluVGltZSk7XG5cdCAgICAgICAgcmVsZWFzZSA9IE1hdGgubWF4KHJlbGVhc2UsIG1pblRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcy5zZXRNYXAoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhdHRhY2s7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVsZWFzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhdHRhY2sgdGltZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Gb2xsb3dlciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBhdHRhY2tcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZvbGxvd2VyLnByb3RvdHlwZSwgJ2F0dGFjaycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGF0dGFjaykge1xuXHQgICAgICAgICAgICB0aGlzLl9hdHRhY2sgPSBhdHRhY2s7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEF0dGFja1JlbGVhc2UodGhpcy5fYXR0YWNrLCB0aGlzLl9yZWxlYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByZWxlYXNlIHRpbWUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRm9sbG93ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgcmVsZWFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRm9sbG93ZXIucHJvdG90eXBlLCAncmVsZWFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZWxlYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlbGVhc2UgPSByZWxlYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBdHRhY2tSZWxlYXNlKHRoaXMuX2F0dGFjaywgdGhpcy5fcmVsZWFzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQm9ycm93cyB0aGUgY29ubmVjdCBtZXRob2QgZnJvbSBTaWduYWwgc28gdGhhdCB0aGUgb3V0cHV0IGNhbiBiZSB1c2VkXG5cdFx0ICogIGFzIGEgVG9uZS5TaWduYWwgY29udHJvbCBzaWduYWwuXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqL1xuXHQgICAgVG9uZS5Gb2xsb3dlci5wcm90b3R5cGUuY29ubmVjdCA9IFRvbmUuU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2Vcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRm9sbG93ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3lWYWx1ZXMuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdWIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX3N1YiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYWJzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hYnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX211bHQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX211bHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2N1cnZlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Gb2xsb3dlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuU2NhbGVkRW52ZWxvcCBpcyBhbiBlbnZlbG9wZSB3aGljaCBjYW4gYmUgc2NhbGVkIFxuXHRcdCAqICAgICAgICAgdG8gYW55IHJhbmdlLiBJdCdzIHVzZWZ1bCBmb3IgYXBwbHlpbmcgYW4gZW52ZWxvcGUgXG5cdFx0ICogICAgICAgICB0byBhIGZyZXF1ZW5jeSBvciBhbnkgb3RoZXIgbm9uLU5vcm1hbFJhbmdlIHNpZ25hbCBcblx0XHQgKiAgICAgICAgIHBhcmFtZXRlci4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRW52ZWxvcGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbYXR0YWNrXVx0dGhlIGF0dGFjayB0aW1lIGluIHNlY29uZHNcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbZGVjYXldXHR0aGUgZGVjYXkgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbc3VzdGFpbl0gXHRhIHBlcmNlbnRhZ2UgKDAtMSkgb2YgdGhlIGZ1bGwgYW1wbGl0dWRlXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3JlbGVhc2VdXHR0aGUgcmVsZWFzZSB0aW1lIGluIHNlY29uZHNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIHNjYWxlZEVudiA9IG5ldyBUb25lLlNjYWxlZEVudmVsb3BlKHtcblx0XHQgKiAgXHRcImF0dGFja1wiIDogMC4yLFxuXHRcdCAqICBcdFwibWluXCIgOiAyMDAsXG5cdFx0ICogIFx0XCJtYXhcIiA6IDIwMDBcblx0XHQgKiAgfSk7XG5cdFx0ICogIHNjYWxlZEVudi5jb25uZWN0KG9zY2lsbGF0b3IuZnJlcXVlbmN5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVkRW52ZWxvcGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy9nZXQgYWxsIG9mIHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ2RlY2F5Jyxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkVudmVsb3BlLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkVudmVsb3BlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLlNjYWxlZEVudmVsb3BlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgc2NhbGUgdGhlIGluY29taW5nIHNpZ25hbCBieSBhbiBleHBvbmVudFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBvd31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Qb3cob3B0aW9ucy5leHBvbmVudCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc2NhbGUgdGhlIHNpZ25hbCB0byB0aGUgZGVzaXJlZCByYW5nZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuU2NhbGUob3B0aW9ucy5taW4sIG9wdGlvbnMubWF4KTtcblx0ICAgICAgICB0aGlzLl9zaWcuY2hhaW4odGhpcy5fZXhwLCB0aGlzLl9zY2FsZSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TY2FsZWRFbnZlbG9wZSwgVG9uZS5FbnZlbG9wZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlZEVudmVsb3BlLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICdleHBvbmVudCc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBtaW4gb3V0cHV0IHZhbHVlLiBUaGlzIGlzIHRoZSB2YWx1ZSB3aGljaCBpdFxuXHRcdCAqIHN0YXJ0cyBhdC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVkRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtaW5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlZEVudmVsb3BlLnByb3RvdHlwZSwgJ21pbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5taW4gPSBtaW47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBtYXggb3V0cHV0IHZhbHVlLiBJbiBvdGhlciB3b3JkcywgdGhlIHZhbHVlXG5cdFx0ICogYXQgdGhlIHBlYWsgb2YgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVkRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlZEVudmVsb3BlLnByb3RvdHlwZSwgJ21heCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1heDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1heCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5tYXggPSBtYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBleHBvbmVudCB2YWx1ZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVkRW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBleHBvbmVudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLCAnZXhwb25lbnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHAudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwLnZhbHVlID0gZXhwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNjYWxlZEVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlZEVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2V4cC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXhwID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TY2FsZWRFbnZlbG9wZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUgaXMgYSBUb25lLlNjYWxlZEVudmVsb3BlLCBidXQgaW5zdGVhZCBvZiBgbWluYCBhbmQgYG1heGBcblx0XHQgKiAgICAgICAgIGl0J3MgZ290IGEgYGJhc2VGcmVxdWVuY3lgIGFuZCBgb2N0YXZlc2AgcGFyYW1ldGVyLiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbnZlbG9wZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFthdHRhY2tdXHR0aGUgYXR0YWNrIHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtkZWNheV1cdHRoZSBkZWNheSB0aW1lIGluIHNlY29uZHNcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtzdXN0YWluXSBcdGEgcGVyY2VudGFnZSAoMC0xKSBvZiB0aGUgZnVsbCBhbXBsaXR1ZGVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbcmVsZWFzZV1cdHRoZSByZWxlYXNlIHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgZW52ID0gbmV3IFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUoe1xuXHRcdCAqICBcdFwiYXR0YWNrXCIgOiAwLjIsXG5cdFx0ICogIFx0XCJiYXNlRnJlcXVlbmN5XCIgOiBcIkMyXCIsXG5cdFx0ICogIFx0XCJvY3RhdmVzXCIgOiA0XG5cdFx0ICogIH0pO1xuXHRcdCAqICBzY2FsZWRFbnYuY29ubmVjdChvc2NpbGxhdG9yLmZyZXF1ZW5jeSk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeUVudmVsb3BlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ2RlY2F5Jyxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkVudmVsb3BlLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLlNjYWxlZEVudmVsb3BlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkZyZXF1ZW5jeUVudmVsb3BlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBTdG9yZXMgdGhlIG9jdGF2ZSB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvL3NldHVwXG5cdCAgICAgICAgdGhpcy5iYXNlRnJlcXVlbmN5ID0gb3B0aW9ucy5iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZyZXF1ZW5jeUVudmVsb3BlLCBUb25lLkVudmVsb3BlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAyMDAsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiA0LFxuXHQgICAgICAgICdleHBvbmVudCc6IDJcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBtaW5pbnVtIG91dHB1dCB2YWx1ZS4gVGhpcyBpcyB0aGUgdmFsdWUgd2hpY2ggaXRcblx0XHQgKiBzdGFydHMgYXQuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZyZXF1ZW5jeUVudmVsb3BlI1xuXHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0ICogQG5hbWUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLCAnYmFzZUZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5taW4gPSB0aGlzLnRvRnJlcXVlbmN5KG1pbik7XG5cdCAgICAgICAgICAgIC8vYWxzbyB1cGRhdGUgdGhlIG9jdGF2ZXNcblx0ICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyBhYm92ZSB0aGUgYmFzZUZyZXF1ZW5jeSB0aGF0IHRoZVxuXHRcdCAqIGVudmVsb3BlIHdpbGwgc2NhbGUgdG8uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBuYW1lIG9jdGF2ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZyZXF1ZW5jeUVudmVsb3BlLnByb3RvdHlwZSwgJ29jdGF2ZXMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vY3RhdmVzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob2N0YXZlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vY3RhdmVzID0gb2N0YXZlcztcblx0ICAgICAgICAgICAgdGhpcy5fc2NhbGUubWF4ID0gdGhpcy5iYXNlRnJlcXVlbmN5ICogTWF0aC5wb3coMiwgb2N0YXZlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZW52ZWxvcGUncyBleHBvbmVudCB2YWx1ZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBleHBvbmVudFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLCAnZXhwb25lbnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHAudmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwLnZhbHVlID0gZXhwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZyZXF1ZW5jeUVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeUVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GcmVxdWVuY3lFbnZlbG9wZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkdhdGUgb25seSBwYXNzZXMgYSBzaWduYWwgdGhyb3VnaCB3aGVuIHRoZSBpbmNvbWluZyBcblx0XHQgKiAgICAgICAgICBzaWduYWwgZXhjZWVkcyBhIHNwZWNpZmllZCB0aHJlc2hvbGQuIFRvIGRvIHRoaXMsIEdhdGUgdXNlcyBcblx0XHQgKiAgICAgICAgICBhIFRvbmUuRm9sbG93ZXIgdG8gZm9sbG93IHRoZSBhbXBsaXR1ZGUgb2YgdGhlIGluY29taW5nIHNpZ25hbC4gXG5cdFx0ICogICAgICAgICAgQSBjb21tb24gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBjbGFzcyBpcyBhIFtOb2lzZSBHYXRlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ob2lzZV9nYXRlKS5cblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc3xPYmplY3R9IFt0aHJlc2hvbGRdIFRoZSB0aHJlc2hvbGQgYWJvdmUgd2hpY2ggdGhlIGdhdGUgd2lsbCBvcGVuLiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gYXR0YWNrIFRoZSBmb2xsb3dlcidzIGF0dGFjayB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJlbGVhc2UgVGhlIGZvbGxvd2VyJ3MgcmVsZWFzZSB0aW1lXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGdhdGUgPSBuZXcgVG9uZS5HYXRlKC0zMCwgMC4yLCAwLjMpLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIG1pYyA9IG5ldyBUb25lLlVzZXJNZWRpYSgpLmNvbm5lY3QoZ2F0ZSk7XG5cdFx0ICogLy90aGUgZ2F0ZSB3aWxsIG9ubHkgcGFzcyB0aHJvdWdoIHRoZSBpbmNvbWluZyBcblx0XHQgKiAvL3NpZ25hbCB3aGVuIGl0J3MgbG91ZGVyIHRoYW4gLTMwZGJcblx0XHQgKi9cblx0ICAgIFRvbmUuR2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnLFxuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5HYXRlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Gb2xsb3dlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZm9sbG93ZXIgPSBuZXcgVG9uZS5Gb2xsb3dlcihvcHRpb25zLmF0dGFjaywgb3B0aW9ucy5yZWxlYXNlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HcmVhdGVyVGhhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ3QgPSBuZXcgVG9uZS5HcmVhdGVyVGhhbih0aGlzLmRiVG9HYWluKG9wdGlvbnMudGhyZXNob2xkKSk7XG5cdCAgICAgICAgLy90aGUgY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8vdGhlIGNvbnRyb2wgc2lnbmFsXG5cdCAgICAgICAgdGhpcy5pbnB1dC5jaGFpbih0aGlzLl9ndCwgdGhpcy5fZm9sbG93ZXIsIHRoaXMub3V0cHV0LmdhaW4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuR2F0ZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuR2F0ZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYXR0YWNrJzogMC4xLFxuXHQgICAgICAgICdyZWxlYXNlJzogMC4xLFxuXHQgICAgICAgICd0aHJlc2hvbGQnOiAtNDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdGhyZXNob2xkIG9mIHRoZSBnYXRlIGluIGRlY2liZWxzXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR2F0ZSNcblx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogQG5hbWUgdGhyZXNob2xkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ3RocmVzaG9sZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2FpblRvRGIodGhpcy5fZ3QudmFsdWUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhyZXNoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2d0LnZhbHVlID0gdGhpcy5kYlRvR2Fpbih0aHJlc2gpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGF0dGFjayBzcGVlZCBvZiB0aGUgZ2F0ZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdhdGUjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgYXR0YWNrXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ2F0dGFjaycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbGxvd2VyLmF0dGFjaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGF0dGFja1RpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZm9sbG93ZXIuYXR0YWNrID0gYXR0YWNrVGltZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByZWxlYXNlIHNwZWVkIG9mIHRoZSBnYXRlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR2F0ZSNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSByZWxlYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ3JlbGVhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb2xsb3dlci5yZWxlYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmVsZWFzZVRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZm9sbG93ZXIucmVsZWFzZSA9IHJlbGVhc2VUaW1lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuR2F0ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYXRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9mb2xsb3dlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ3QuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZvbGxvd2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9ndCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR2F0ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBBIFRpbWVsaW5lIFN0YXRlLiBQcm92aWRlcyB0aGUgbWV0aG9kczogPGNvZGU+c2V0U3RhdGVBdFRpbWUoXCJzdGF0ZVwiLCB0aW1lKTwvY29kZT5cblx0XHQgKiAgICAgICAgICBhbmQgPGNvZGU+Z2V0VmFsdWVBdFRpbWUodGltZSk8L2NvZGU+LlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVsaW5lfVxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gaW5pdGlhbCBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgVGltZWxpbmVTdGF0ZS4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDxjb2RlPnVuZGVmaW5lZDwvY29kZT5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTdGF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsKSB7XG5cdCAgICAgICAgVG9uZS5UaW1lbGluZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbml0aWFsIHN0YXRlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5pdGlhbCA9IGluaXRpYWw7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaW1lbGluZVN0YXRlLCBUb25lLlRpbWVsaW5lKTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBzY2hlZHVsZWQgc3RhdGUgc2NoZWR1bGVkIGJlZm9yZSBvciBhdFxuXHRcdCAqICB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm4gIHtTdHJpbmd9ICBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgaW5wdXQgaW4gc2V0U3RhdGVBdFRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU3RhdGUucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmdldCh0aW1lKTtcblx0ICAgICAgICBpZiAoZXZlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnN0YXRlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgc2NoZWR1bGVkIHN0YXRlIHNjaGVkdWxlZCBiZWZvcmUgb3IgYXRcblx0XHQgKiAgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHN0YXRlIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBzZXQuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVN0YXRlLnByb3RvdHlwZS5zZXRTdGF0ZUF0VGltZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGltZSkge1xuXHQgICAgICAgIHRoaXMuYWRkKHtcblx0ICAgICAgICAgICAgJ3N0YXRlJzogc3RhdGUsXG5cdCAgICAgICAgICAgICd0aW1lJzogdGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lU3RhdGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkVtaXR0ZXIgZ2l2ZXMgY2xhc3NlcyB3aGljaCBleHRlbmQgaXRcblx0XHQgKiAgICAgICAgIHRoZSBhYmlsaXR5IHRvIGxpc3RlbiBmb3IgYW5kIGVtaXQgZXZlbnRzLiBcblx0XHQgKiAgICAgICAgIEluc3BpcmF0aW9uIGFuZCByZWZlcmVuY2UgZnJvbSBKZXJvbWUgRXRpZW5uZSdzIFtNaWNyb0V2ZW50XShodHRwczovL2dpdGh1Yi5jb20vamVyb21lZXRpZW5uZS9taWNyb2V2ZW50LmpzKS5cblx0XHQgKiAgICAgICAgIE1JVCAoYykgMjAxMSBKZXJvbWUgRXRpZW5uZS5cblx0XHQgKiAgICAgICAgIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuRW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBDb250YWlucyBhbGwgb2YgdGhlIGV2ZW50cy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FbWl0dGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBCaW5kIGEgY2FsbGJhY2sgdG8gYSBzcGVjaWZpYyBldmVudC5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgICBldmVudCAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgaXMgZW1pdHRlZFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vc3BsaXQgdGhlIGV2ZW50XG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IGV2ZW50LnNwbGl0KC9cXFcrLyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgZXZlbnQgICAgIFRoZSBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB3aGljaCB3YXMgYm91bmQgdG8gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBldmVudCB3aXRoIFRvbmUuRW1pdHRlci5vbi5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY2FsbGJhY2sgaXMgZ2l2ZW4sIGFsbCBjYWxsYmFja3Ncblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIGFyZSByZW1vdmVkLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcblx0ICAgICAgICB2YXIgZXZlbnRzID0gZXZlbnQuc3BsaXQoL1xcVysvKTtcblx0ICAgICAgICBmb3IgKHZhciBldiA9IDA7IGV2IDwgZXZlbnRzLmxlbmd0aDsgZXYrKykge1xuXHQgICAgICAgICAgICBldmVudCA9IGV2ZW50c1tldl07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5wcm90b3R5cGUuaXNVbmRlZihjYWxsYmFjaykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gW107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBldmVudExpc3QgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudExpc3RbaV0gPT09IGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3Quc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnZva2UgYWxsIG9mIHRoZSBjYWxsYmFja3MgYm91bmQgdG8gdGhlIGV2ZW50XG5cdFx0ICogIHdpdGggYW55IGFyZ3VtZW50cyBwYXNzZWQgaW4uIFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBldmVudCAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0geyouLi59IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbnMgbGlzdGVuaW5nLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2V2ZW50cykge1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlbnRMaXN0ID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldmVudExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudExpc3RbaV0uYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBFbWl0dGVyIGZ1bmN0aW9ucyAob24vb2ZmL2VtaXQpIHRvIHRoZSBvYmplY3Rcblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fEZ1bmN0aW9ufSAgb2JqZWN0ICBUaGUgb2JqZWN0IG9yIGNsYXNzIHRvIGV4dGVuZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuRW1pdHRlci5taXhpbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0ICAgICAgICB2YXIgZnVuY3Rpb25zID0gW1xuXHQgICAgICAgICAgICAnb24nLFxuXHQgICAgICAgICAgICAnb2ZmJyxcblx0ICAgICAgICAgICAgJ2VtaXQnXG5cdCAgICAgICAgXTtcblx0ICAgICAgICBvYmplY3QuX2V2ZW50cyA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb25zW2ldO1xuXHQgICAgICAgICAgICB2YXIgZW1pdHRlckZ1bmMgPSBUb25lLkVtaXR0ZXIucHJvdG90eXBlW2Z1bmNdO1xuXHQgICAgICAgICAgICBvYmplY3RbZnVuY10gPSBlbWl0dGVyRnVuYztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkVtaXR0ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRW1pdHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBBIHNhbXBsZSBhY2N1cmF0ZSBjbG9jayB3aGljaCBwcm92aWRlcyBhIGNhbGxiYWNrIGF0IHRoZSBnaXZlbiByYXRlLiBcblx0XHQgKiAgICAgICAgICBXaGlsZSB0aGUgY2FsbGJhY2sgaXMgbm90IHNhbXBsZS1hY2N1cmF0ZSAoaXQgaXMgc3RpbGwgc3VzY2VwdGlibGUgdG9cblx0XHQgKiAgICAgICAgICBsb29zZSBKUyB0aW1pbmcpLCB0aGUgdGltZSBwYXNzZWQgaW4gYXMgdGhlIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFja1xuXHRcdCAqICAgICAgICAgIGlzIHByZWNpc2UuIEZvciBtb3N0IGFwcGxpY2F0aW9ucywgaXQgaXMgYmV0dGVyIHRvIHVzZSBUb25lLlRyYW5zcG9ydFxuXHRcdCAqICAgICAgICAgIGluc3RlYWQgb2YgdGhlIENsb2NrIGJ5IGl0c2VsZiBzaW5jZSB5b3UgY2FuIHN5bmNocm9uaXplIG11bHRpcGxlIGNhbGxiYWNrcy5cblx0XHQgKlxuXHRcdCAqIFx0QGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVtaXR0ZXJ9XG5cdFx0ICogXHRAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aXRoIHRoZSB0aW1lIG9mIHRoZSBhdWRpbyBldmVudFxuXHRcdCAqIFx0QHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgcmF0ZSBvZiB0aGUgY2FsbGJhY2tcblx0XHQgKiBcdEBleGFtcGxlXG5cdFx0ICogLy90aGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIGFwcHJveGltYXRlbHkgb25jZSBhIHNlY29uZFxuXHRcdCAqIC8vYW5kIHdpbGwgcHJpbnQgdGhlIHRpbWUgZXhhY3RseSBvbmNlIGEgc2Vjb25kIGFwYXJ0LlxuXHRcdCAqIHZhciBjbG9jayA9IG5ldyBUb25lLkNsb2NrKGZ1bmN0aW9uKHRpbWUpe1xuXHRcdCAqIFx0Y29uc29sZS5sb2codGltZSk7XG5cdFx0ICogfSwgMSk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnY2FsbGJhY2snLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0sIFRvbmUuQ2xvY2suZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2UgYXQgdGhlIHNjaGVkdWxlZCB0aWNrLlxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbmV4dCB0aW1lIHRoZSBjYWxsYmFjayBpcyBzY2hlZHVsZWQuXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbmV4dFRpY2sgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBsYXN0IHN0YXRlIG9mIHRoZSBjbG9jay5cblx0XHRcdCAqICBAdHlwZSAge1N0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sYXN0U3RhdGUgPSBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJhdGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCBiZSBpbnZva2VkLiBcblx0XHRcdCAqICBAdHlwZSAge0JQTX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlRpbWVsaW5lU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZnJlcXVlbmN5Jyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgY2FsbGJhY2sgd2FzIGludm9rZWQuIFN0YXJ0cyBjb3VudGluZyBhdCAwXG5cdFx0XHQgKiAgYW5kIGluY3JlbWVudHMgYWZ0ZXIgdGhlIGNhbGxiYWNrIHdhcyBpbnZva2VkLiBcblx0XHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnRpY2tzID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc3RhdGUgdGltZWxpbmVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZVN0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbG9vcCBmdW5jdGlvbiBib3VuZCB0byBpdHMgY29udGV4dC4gXG5cdFx0XHQgKiAgVGhpcyBpcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIHRoZSBldmVudCBpbiB0aGUgZW5kLlxuXHRcdFx0ICogIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYm91bmRMb29wID0gdGhpcy5fbG9vcC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIC8vYmluZCBhIGNhbGxiYWNrIHRvIHRoZSB3b3JrZXIgdGhyZWFkXG5cdCAgICAgICAgVG9uZS5DbG9jay5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9ib3VuZExvb3ApO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ2xvY2ssIFRvbmUuRW1pdHRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ2xvY2suZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdmcmVxdWVuY3knOiAxLFxuXHQgICAgICAgICdsb29rQWhlYWQnOiAnYXV0bydcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiLCBcInN0b3BwZWRcIiBvciBcInBhdXNlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNsb2NrI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2xvY2sucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgY2xvY2sgYXQgdGhlIGdpdmVuIHRpbWUuIE9wdGlvbmFsbHkgcGFzcyBpbiBhbiBvZmZzZXRcblx0XHQgKiAgb2Ygd2hlcmUgdG8gc3RhcnQgdGhlIHRpY2sgY291bnRlciBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICBUaGUgdGltZSB0aGUgY2xvY2sgc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEBwYXJhbSAge1RpY2tzPX0gIG9mZnNldCAgV2hlcmUgdGhlIHRpY2sgY291bnRlciBzdGFydHMgY291bnRpbmcgZnJvbS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQ2xvY2t9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpbWUpICE9PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuYWRkKHtcblx0ICAgICAgICAgICAgICAgICdzdGF0ZSc6IFRvbmUuU3RhdGUuU3RhcnRlZCxcblx0ICAgICAgICAgICAgICAgICd0aW1lJzogdGltZSxcblx0ICAgICAgICAgICAgICAgICdvZmZzZXQnOiBvZmZzZXRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBjbG9jay4gU3RvcHBpbmcgdGhlIGNsb2NrIHJlc2V0cyB0aGUgdGljayBjb3VudGVyIHRvIDAuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSBjbG9jayBzaG91bGQgc3RvcC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ2xvY2t9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBjbG9jay5zdG9wKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RvcHBlZCwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBhdXNlIHRoZSBjbG9jay4gUGF1c2luZyBkb2VzIG5vdCByZXNldCB0aGUgdGljayBjb3VudGVyLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgY2xvY2sgc2hvdWxkIHN0b3AuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuUGF1c2VkLCB0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzY2hlZHVsaW5nIGxvb3AuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSBjdXJyZW50IHBhZ2UgdGltZSBzdGFydGluZyBmcm9tIDBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgcGFnZSB3YXMgbG9hZGVkLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUuX2xvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGZyZXF1ZW5jeSB2YWx1ZSB0byBjb21wdXRlIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCBsb29wXG5cdCAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgLy9pZiBpdCdzIHN0YXJ0ZWRcblx0ICAgICAgICB2YXIgbG9va0FoZWFkID0gVG9uZS5DbG9jay5sb29rQWhlYWQ7XG5cdCAgICAgICAgdmFyIHVwZGF0ZUludGVydmFsID0gVG9uZS5DbG9jay51cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICB2YXIgbGFnQ29tcGVuc2F0aW9uID0gVG9uZS5DbG9jay5sYWcgKiAyO1xuXHQgICAgICAgIHZhciBsb29wSW50ZXJ2YWwgPSBub3cgKyBsb29rQWhlYWQgKyB1cGRhdGVJbnRlcnZhbCArIGxhZ0NvbXBlbnNhdGlvbjtcblx0ICAgICAgICB3aGlsZSAobG9vcEludGVydmFsID4gdGhpcy5fbmV4dFRpY2sgJiYgdGhpcy5fc3RhdGUpIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRoaXMuX25leHRUaWNrKTtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAhPT0gdGhpcy5fbGFzdFN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U3RhdGUgPSBjdXJyZW50U3RhdGU7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXQodGhpcy5fbmV4dFRpY2spO1xuXHQgICAgICAgICAgICAgICAgLy8gZW1pdCBhbiBldmVudFxuXHQgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0IHRoZSB0aW1lXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dFRpY2sgPSBldmVudC50aW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKGV2ZW50Lm9mZnNldCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrcyA9IGV2ZW50Lm9mZnNldDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIGV2ZW50LnRpbWUsIHRoaXMudGlja3MpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U3RhdGUgPT09IFRvbmUuU3RhdGUuU3RvcHBlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGlja3MgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIGV2ZW50LnRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U3RhdGUgPT09IFRvbmUuU3RhdGUuUGF1c2VkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXVzZScsIGV2ZW50LnRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB0aWNrVGltZSA9IHRoaXMuX25leHRUaWNrO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5mcmVxdWVuY3kpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX25leHRUaWNrICs9IDEgLyB0aGlzLmZyZXF1ZW5jeS5nZXRWYWx1ZUF0VGltZSh0aGlzLl9uZXh0VGljayk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRpY2tUaW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRpY2tzKys7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHNjaGVkdWxlZCBzdGF0ZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJuICB7U3RyaW5nfSAgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIGlucHV0IGluIHNldFN0YXRlQXRUaW1lLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIGNsb2NrLnN0YXJ0KFwiKzAuMVwiKTtcblx0XHQgKiBjbG9jay5nZXRTdGF0ZUF0VGltZShcIiswLjFcIik7IC8vcmV0dXJucyBcInN0YXJ0ZWRcIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUuZ2V0U3RhdGVBdFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIFRvbmUuQ2xvY2suX3dvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fYm91bmRMb29wKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZnJlcXVlbmN5Jyk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9ib3VuZExvb3AgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX25leHRUaWNrID0gSW5maW5pdHk7XG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFdPUktFUlxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1VSTCBTaGltXG5cdCAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIGV2ZW50cyBhcmUgXG5cdFx0ICogIHNjaGVkdWxlZCBpbiBhZHZhbmNlLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ2xvY2suX2xvb2tBaGVhZCA9IDAuMTtcblx0ICAgIC8qKlxuXHRcdCAqICBIb3cgb2Z0ZW4gdGhlIHdvcmtlciB0aWNrc1xuXHRcdCAqICBAdHlwZSAge1NlY29uZHN9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLl91cGRhdGVJbnRlcnZhbCA9IFRvbmUuQ2xvY2suX2xvb2tBaGVhZCAvIDM7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHNjcmlwdCB3aGljaCBydW5zIGluIGEgd2ViIHdvcmtlclxuXHRcdCAqICBAdHlwZSB7QmxvYn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIHZhciBibG9iID0gbmV3IEJsb2IoWy8vdGhlIGluaXRpYWwgdGltZW91dCB0aW1lXG5cdCAgICAgICAgJ3ZhciB0aW1lb3V0VGltZSA9ICcgKyBUb25lLkNsb2NrLl91cGRhdGVJbnRlcnZhbCAqIDEwMDAgKyAnOycgKyAvL29ubWVzc2FnZSBjYWxsYmFja1xuXHQgICAgICAgICdzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZyl7JyArICdcXHR0aW1lb3V0VGltZSA9IHBhcnNlSW50KG1zZy5kYXRhKTsnICsgJ307JyArIC8vdGhlIHRpY2sgZnVuY3Rpb24gd2hpY2ggcG9zdHMgYSBtZXNzYWdlXG5cdCAgICAgICAgLy9hbmQgc2NoZWR1bGVzIGEgbmV3IHRpY2tcblx0ICAgICAgICAnZnVuY3Rpb24gdGljaygpeycgKyAnXFx0c2V0VGltZW91dCh0aWNrLCB0aW1lb3V0VGltZSk7JyArICdcXHRzZWxmLnBvc3RNZXNzYWdlKFxcJ3RpY2tcXCcpOycgKyAnfScgKyAvL2NhbGwgdGljayBpbml0aWFsbHlcblx0ICAgICAgICAndGljaygpOyddKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDcmVhdGUgYSBibG9iIHVybCBmcm9tIHRoZSBCbG9iXG5cdFx0ICogIEB0eXBlICB7VVJMfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgdmFyIGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBXb3JrZXIgd2hpY2ggZ2VuZXJhdGVzIGEgcmVndWxhciBjYWxsYmFja1xuXHRcdCAqICBAdHlwZSB7V29ya2VyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLl93b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVcmwpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdCAqICBUaGUgdGltZSBvZiB0aGUgbGFzdCB1cGRhdGVcblx0XHQgKi9cblx0ICAgIHZhciBsYXN0VXBkYXRlID0gLTE7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgY29tcHV0ZWQgdXBkYXRlIHJhdGUgb2YgdGhlIGNsb2NrLlxuXHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIHZhciBjb21wdXRlZFVwZGF0ZUludGVydmFsID0gMDtcblx0ICAgIC8vbGlzdGVuIGZvciBtZXNzYWdlIGV2ZW50cyBhbmQgdXBkYXRlIHRoZSBnbG9iYWwgY2xvY2sgbG9va2FoZWFkXG5cdCAgICBUb25lLkNsb2NrLl93b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm93ID0gVG9uZS5ub3coKTtcblx0ICAgICAgICBpZiAobGFzdFVwZGF0ZSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdmFyIGRpZmYgPSBub3cgLSBsYXN0VXBkYXRlO1xuXHQgICAgICAgICAgICBjb21wdXRlZFVwZGF0ZUludGVydmFsID0gTWF0aC5tYXgoZGlmZiwgY29tcHV0ZWRVcGRhdGVJbnRlcnZhbCAqIDAuOTcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsYXN0VXBkYXRlID0gbm93O1xuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhpcyBpcyB0aGUgdGltZSB0aGF0IHRoZSBjbG9jayBpcyBmYWxsaW5nIGJlaGluZFxuXHRcdCAqICB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBpbnRlcnZhbC4gVGhlIENsb2NrIGF1dG9tYXRpY2FsbHlcblx0XHQgKiAgYWRqdXN0cyBmb3IgdGhlIGxhZyBhbmQgc2NoZWR1bGVzIGZ1cnRoZXIgaW4gYWR2YW5jZS5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ2xvY2tcblx0XHQgKiAgQG5hbWUgbGFnXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DbG9jaywgJ2xhZycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGRpZmYgPSBjb21wdXRlZFVwZGF0ZUludGVydmFsIC0gVG9uZS5DbG9jay5fdXBkYXRlSW50ZXJ2YWw7XG5cdCAgICAgICAgICAgIGRpZmYgPSBNYXRoLm1heChkaWZmLCAwKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGFtb3VudCBvZiB0aW1lIGluIGFkdmFuY2UgdGhhdCBldmVudHMgYXJlIHNjaGVkdWxlZC5cblx0XHQgKiAgVGhlIGxvb2tBaGVhZCB3aWxsIGFkanVzdCBzbGlnaHRseSBpbiByZXNwb25zZSB0byB0aGUgXG5cdFx0ICogIG1lYXN1cmVkIHVwZGF0ZSB0aW1lIHRvIHRyeSB0byBhdm9pZCBjbGlja3MuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNsb2NrXG5cdFx0ICogIEBuYW1lIGxvb2tBaGVhZFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DbG9jaywgJ2xvb2tBaGVhZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuQ2xvY2suX2xvb2tBaGVhZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxBKSB7XG5cdCAgICAgICAgICAgIFRvbmUuQ2xvY2suX2xvb2tBaGVhZCA9IGxBO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEhvdyBvZnRlbiB0aGUgV2ViIFdvcmtlciBjYWxsYmFjayBpcyBpbnZva2VkLlxuXHRcdCAqICBUaGlzIG51bWJlciBjb3JyZXNwb25kcyB0byBob3cgcmVzcG9uc2l2ZSB0aGUgc2NoZWR1bGluZ1xuXHRcdCAqICBjYW4gYmUuIENsb2NrLnVwZGF0ZUludGVydmFsICsgQ2xvY2subG9va0FoZWFkIGdpdmVzIHlvdSB0aGVcblx0XHQgKiAgdG90YWwgbGF0ZW5jeSBiZXR3ZWVuIHNjaGVkdWxpbmcgYW4gZXZlbnQgYW5kIGhlYXJpbmcgaXQuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNsb2NrXG5cdFx0ICogIEBuYW1lIHVwZGF0ZUludGVydmFsXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNsb2NrLCAndXBkYXRlSW50ZXJ2YWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLkNsb2NrLl91cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIFRvbmUuQ2xvY2suX3VwZGF0ZUludGVydmFsID0gTWF0aC5tYXgoaW50ZXJ2YWwsIDAuMDEpO1xuXHQgICAgICAgICAgICBUb25lLkNsb2NrLl93b3JrZXIucG9zdE1lc3NhZ2UoaW50ZXJ2YWwgKiAxMDAwKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbGF0ZW5jeSBoaW50XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd8TnVtYmVyfVxuXHRcdCAqL1xuXHQgICAgdmFyIGxhdGVuY3lIaW50ID0gJ2ludGVyYWN0aXZlJztcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdHlwZSBvZiBwbGF5YmFjaywgd2hpY2ggYWZmZWN0cyB0cmFkZW9mZnMgYmV0d2VlbiBhdWRpbyBcblx0XHQgKiAgb3V0cHV0IGxhdGVuY3kgYW5kIHJlc3BvbnNpdmVuZXNzLiBcblx0XHQgKiAgXG5cdFx0ICogIEluIGFkZGl0aW9uIHRvIHNldHRpbmcgdGhlIHZhbHVlIGluIHNlY29uZHMsIHRoZSBsYXRlbmN5SGludCBhbHNvXG5cdFx0ICogIGFjY2VwdHMgdGhlIHN0cmluZ3MgXCJpbnRlcmFjdGl2ZVwiIChwcmlvcml0aXplcyBsb3cgbGF0ZW5jeSksIFxuXHRcdCAqICBcInBsYXliYWNrXCIgKHByaW9yaXRpemVzIHN1c3RhaW5lZCBwbGF5YmFjayksIFwiYmFsYW5jZWRcIiAoYmFsYW5jZXNcblx0XHQgKiAgbGF0ZW5jeSBhbmQgcGVyZm9ybWFuY2UpLCBhbmQgXCJmYXN0ZXN0XCIgKGxvd2VzdCBsYXRlbmN5LCBtaWdodCBnbGl0Y2ggbW9yZSBvZnRlbikuIFxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfFNlY29uZHN9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNsb2NrI1xuXHRcdCAqICBAbmFtZSBsYXRlbmN5SGludFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgdGhlIGxvb2tBaGVhZCB0byAwLjMgc2Vjb25kc1xuXHRcdCAqIFRvbmUuQ2xvY2subGF0ZW5jeUhpbnQgPSAwLjM7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DbG9jaywgJ2xhdGVuY3lIaW50Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGF0ZW5jeUhpbnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChoaW50KSB7XG5cdCAgICAgICAgICAgIHZhciBsb29rQWhlYWQgPSBoaW50O1xuXHQgICAgICAgICAgICBsYXRlbmN5SGludCA9IGhpbnQ7XG5cdCAgICAgICAgICAgIGlmIChUb25lLnByb3RvdHlwZS5pc1N0cmluZyhoaW50KSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChoaW50KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdpbnRlcmFjdGl2ZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4xO1xuXHQgICAgICAgICAgICAgICAgICAgIFRvbmUuY29udGV4dC5sYXRlbmN5SGludCA9IGhpbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdwbGF5YmFjayc6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC44O1xuXHQgICAgICAgICAgICAgICAgICAgIFRvbmUuY29udGV4dC5sYXRlbmN5SGludCA9IGhpbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdiYWxhbmNlZCc6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4yNTtcblx0ICAgICAgICAgICAgICAgICAgICBUb25lLmNvbnRleHQubGF0ZW5jeUhpbnQgPSBoaW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnZmFzdGVzdCc6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4wMTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBUb25lLkNsb2NrLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcblx0ICAgICAgICAgICAgVG9uZS5DbG9jay51cGRhdGVJbnRlcnZhbCA9IGxvb2tBaGVhZCAvIDM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBUb25lLl9pbml0QXVkaW9Db250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBsYXN0VXBkYXRlID0gLTE7XG5cdCAgICAgICAgY29tcHV0ZWRVcGRhdGVJbnRlcnZhbCA9IDA7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLkNsb2NrO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgU2ltaWxhciB0byBUb25lLlRpbWVsaW5lLCBidXQgYWxsIGV2ZW50cyByZXByZXNlbnRcblx0XHQgKiAgICAgICAgIGludGVydmFscyB3aXRoIGJvdGggXCJ0aW1lXCIgYW5kIFwiZHVyYXRpb25cIiB0aW1lcy4gVGhlIFxuXHRcdCAqICAgICAgICAgZXZlbnRzIGFyZSBwbGFjZWQgaW4gYSB0cmVlIHN0cnVjdHVyZSBvcHRpbWl6ZWRcblx0XHQgKiAgICAgICAgIGZvciBxdWVyeWluZyBhbiBpbnRlcnNlY3Rpb24gcG9pbnQgd2l0aCB0aGUgdGltZWxpbmVcblx0XHQgKiAgICAgICAgIGV2ZW50cy4gSW50ZXJuYWxseSB1c2VzIGFuIFtJbnRlcnZhbCBUcmVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnZhbF90cmVlKVxuXHRcdCAqICAgICAgICAgdG8gcmVwcmVzZW50IHRoZSBkYXRhLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcm9vdCBub2RlIG9mIHRoZSBpbnRldmFsIHRyZWVcblx0XHRcdCAqICBAdHlwZSAge0ludGVydmFsTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgS2VlcCB0cmFjayBvZiB0aGUgbGVuZ3RoIG9mIHRoZSB0aW1lbGluZS5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkludGVydmFsVGltZWxpbmUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lLiBBbGwgZXZlbnRzIG11c3QgXG5cdFx0ICogIGhhdmUgYSB0aW1lIGFuZCBkdXJhdGlvbiB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IHRvIGFkZCB0byB0aGUgdGltZWxpbmVcblx0XHQgKiAgQHJldHVybiAge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNVbmRlZihldmVudC50aW1lKSB8fCB0aGlzLmlzVW5kZWYoZXZlbnQuZHVyYXRpb24pKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5JbnRlcnZhbFRpbWVsaW5lOiBldmVudHMgbXVzdCBoYXZlIHRpbWUgYW5kIGR1cmF0aW9uIHBhcmFtZXRlcnMnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5vZGUgPSBuZXcgSW50ZXJ2YWxOb2RlKGV2ZW50LnRpbWUsIGV2ZW50LnRpbWUgKyBldmVudC5kdXJhdGlvbiwgZXZlbnQpO1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBub2RlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QuaW5zZXJ0KG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sZW5ndGgrKztcblx0ICAgICAgICAvLyBSZXN0cnVjdHVyZSB0cmVlIHRvIGJlIGJhbGFuY2VkXG5cdCAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQoKTtcblx0ICAgICAgICAgICAgbm9kZS51cGRhdGVNYXgoKTtcblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKG5vZGUpO1xuXHQgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgdG8gcmVtb3ZlIGZyb20gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkludGVydmFsVGltZWxpbmV9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKGV2ZW50LnRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gcmVzdWx0c1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmV2ZW50ID09PSBldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU5vZGUobm9kZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5JbnRlcnZhbFRpbWVsaW5lI1xuXHRcdCAqICBAbmFtZSBsZW5ndGhcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgZXZlbnRzIHdob3NlIHRpbWUgdGltZSBpcyBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICB0aGlzLmZvckVhY2hBZnRlcihhZnRlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV2ZW50KTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIHJvb3Qgbm9kZSBhcyB0aGUgZ2l2ZW4gbm9kZVxuXHRcdCAqICBAcGFyYW0ge0ludGVydmFsTm9kZX0gbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgdGhpcy5fcm9vdCA9IG5vZGU7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcm9vdC5wYXJlbnQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVwbGFjZSB0aGUgcmVmZXJlbmNlcyB0byB0aGUgbm9kZSBpbiB0aGUgbm9kZSdzIHBhcmVudFxuXHRcdCAqICB3aXRoIHRoZSByZXBsYWNlbWVudCBub2RlLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbE5vZGV9ICBub2RlICAgICAgICBcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgcmVwbGFjZW1lbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yZXBsYWNlTm9kZUluUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUsIHJlcGxhY2VtZW50KSB7XG5cdCAgICAgICAgaWYgKG5vZGUucGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChub2RlLmlzTGVmdENoaWxkKCkpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKG5vZGUucGFyZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCByZXBsYWNlIGl0IHdpdGggXG5cdFx0ICogIGEgc3VjY2Vzc29yIHdoaWNoIGZvbGxvd3MgdGhlIHNjaGVtYS5cblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fcmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCAmJiBub2RlLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbm9kZS5sZWZ0KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIG5vZGUucmlnaHQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBiYWxhbmNlID0gbm9kZS5nZXRCYWxhbmNlKCk7XG5cdCAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCwgdGVtcDtcblx0ICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRlbXAgPSByZXBsYWNlbWVudDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLmxlZnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50LmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlcGxhY2VtZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbm9kZS5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gbm9kZS5yaWdodDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0LmxlZnQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IG5vZGUubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gbm9kZS5yaWdodC5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlcGxhY2VtZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbm9kZS5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gbm9kZS5yaWdodDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVmdENoaWxkKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zZXRSb290KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIHJlcGxhY2VtZW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKHRlbXApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBub2RlLmRpc3Bvc2UoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUm90YXRlIHRoZSB0cmVlIHRvIHRoZSBsZWZ0XG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JvdGF0ZUxlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcblx0ICAgICAgICB2YXIgaXNMZWZ0Q2hpbGQgPSBub2RlLmlzTGVmdENoaWxkKCk7XG5cdCAgICAgICAgLy8gTWFrZSBub2RlLnJpZ2h0IHRoZSBuZXcgcm9vdCBvZiB0aGlzIHN1YiB0cmVlIChpbnN0ZWFkIG9mIG5vZGUpXG5cdCAgICAgICAgdmFyIHBpdm90Tm9kZSA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgbm9kZS5yaWdodCA9IHBpdm90Tm9kZS5sZWZ0O1xuXHQgICAgICAgIHBpdm90Tm9kZS5sZWZ0ID0gbm9kZTtcblx0ICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0xlZnRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHBpdm90Tm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSb3RhdGUgdGhlIHRyZWUgdG8gdGhlIHJpZ2h0XG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgdmFyIGlzTGVmdENoaWxkID0gbm9kZS5pc0xlZnRDaGlsZCgpO1xuXHQgICAgICAgIC8vIE1ha2Ugbm9kZS5sZWZ0IHRoZSBuZXcgcm9vdCBvZiB0aGlzIHN1YiB0cmVlIChpbnN0ZWFkIG9mIG5vZGUpXG5cdCAgICAgICAgdmFyIHBpdm90Tm9kZSA9IG5vZGUubGVmdDtcblx0ICAgICAgICBub2RlLmxlZnQgPSBwaXZvdE5vZGUucmlnaHQ7XG5cdCAgICAgICAgcGl2b3ROb2RlLnJpZ2h0ID0gbm9kZTtcblx0ICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0xlZnRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHBpdm90Tm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBCYWxhbmNlIHRoZSBCU1Rcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fcmViYWxhbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICB2YXIgYmFsYW5jZSA9IG5vZGUuZ2V0QmFsYW5jZSgpO1xuXHQgICAgICAgIGlmIChiYWxhbmNlID4gMSkge1xuXHQgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LmdldEJhbGFuY2UoKSA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZUxlZnQobm9kZS5sZWZ0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZVJpZ2h0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChiYWxhbmNlIDwgLTEpIHtcblx0ICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQuZ2V0QmFsYW5jZSgpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcm90YXRlUmlnaHQobm9kZS5yaWdodCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yb3RhdGVMZWZ0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgYW4gZXZlbnQgd2hvc2UgdGltZSBhbmQgZHVyYXRpb24gc3BhbiB0aGUgZ2l2ZSB0aW1lLiBXaWxsXG5cdFx0ICogIHJldHVybiB0aGUgbWF0Y2ggd2hvc2UgXCJ0aW1lXCIgdmFsdWUgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICBUaGUgZXZlbnQgd2hpY2ggc3BhbnMgdGhlIGRlc2lyZWQgdGltZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKHRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWF4ID0gcmVzdWx0c1swXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldLmxvdyA+IG1heC5sb3cpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcmVzdWx0c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWF4LmV2ZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGFsbE5vZGVzID0gW107XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yb290LnRyYXZlcnNlKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXMucHVzaChub2RlKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldiA9IGFsbE5vZGVzW2ldLmV2ZW50O1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXYpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgaW4gd2hpY2ggdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgb3ZlcmxhcHMgd2l0aCB0aGUgdGltZSBhbmQgZHVyYXRpb24gdGltZSBvZiB0aGUgZXZlbnQuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIG92ZXJsYXBwaW5nXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICAgICAgdGhpcy5fcm9vdC5zZWFyY2godGltZSwgcmVzdWx0cyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXYgPSByZXN1bHRzW2ldLmV2ZW50O1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXYpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgaW4gd2hpY2ggdGhlIHRpbWUgaXMgZ3JlYXRlclxuXHRcdCAqICB0aGFuIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBiZWZvcmVcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5JbnRlcnZhbFRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hBZnRlciA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoQWZ0ZXIodGltZSwgcmVzdWx0cyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXYgPSByZXN1bHRzW2ldLmV2ZW50O1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXYpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5JbnRlcnZhbFRpbWVsaW5lfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhbGxOb2RlcyA9IFtdO1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QudHJhdmVyc2UoZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGFsbE5vZGVzW2ldLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYWxsTm9kZXMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdElOVEVSVkFMIE5PREUgSEVMUEVSXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgYmluYXJ5IHNlYXJjaCB0cmVlLCB3aXRoIHRoZSBhZGRpdGlvblxuXHRcdCAqICBvZiBhIFwiaGlnaFwiIHZhbHVlIHdoaWNoIGtlZXBzIHRyYWNrIG9mIHRoZSBoaWdoZXN0IHZhbHVlIG9mXG5cdFx0ICogIGl0cyBjaGlsZHJlbi4gXG5cdFx0ICogIFJlZmVyZW5jZXM6IFxuXHRcdCAqICBodHRwczovL2Jyb29rbm92YWsud29yZHByZXNzLmNvbS8yMDEzLzEyLzA3L2F1Z21lbnRlZC1pbnRlcnZhbC10cmVlLWluLWMvXG5cdFx0ICogIGh0dHA6Ly93d3cubWlmLnZ1Lmx0L352YWxkYXMvQUxHT1JJVE1BSS9MSVRFUkFUVVJBL0Nvcm1lbi9Db3JtZW4ucGRmXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBsb3dcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIHZhciBJbnRlcnZhbE5vZGUgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBldmVudCkge1xuXHQgICAgICAgIC8vdGhlIGV2ZW50IGNvbnRhaW5lclxuXHQgICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcblx0ICAgICAgICAvL3RoZSBsb3cgdmFsdWVcblx0ICAgICAgICB0aGlzLmxvdyA9IGxvdztcblx0ICAgICAgICAvL3RoZSBoaWdoIHZhbHVlXG5cdCAgICAgICAgdGhpcy5oaWdoID0gaGlnaDtcblx0ICAgICAgICAvL3RoZSBoaWdoIHZhbHVlIGZvciB0aGlzIGFuZCBhbGwgY2hpbGQgbm9kZXNcblx0ICAgICAgICB0aGlzLm1heCA9IHRoaXMuaGlnaDtcblx0ICAgICAgICAvL3RoZSBub2RlcyB0byB0aGUgbGVmdFxuXHQgICAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuXHQgICAgICAgIC8vdGhlIG5vZGVzIHRvIHRoZSByaWdodFxuXHQgICAgICAgIHRoaXMuX3JpZ2h0ID0gbnVsbDtcblx0ICAgICAgICAvL3RoZSBwYXJlbnQgbm9kZVxuXHQgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblx0ICAgICAgICAvL3RoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXNcblx0ICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG5cdCAgICB9O1xuXHQgICAgLyoqIFxuXHRcdCAqICBJbnNlcnQgYSBub2RlIGludG8gdGhlIGNvcnJlY3Qgc3BvdCBpbiB0aGUgdHJlZVxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbE5vZGV9ICBub2RlXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgaWYgKG5vZGUubG93IDw9IHRoaXMubG93KSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IG5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlZnQuaW5zZXJ0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSBub2RlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5pbnNlcnQobm9kZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNlYXJjaCB0aGUgdHJlZSBmb3Igbm9kZXMgd2hpY2ggb3ZlcmxhcCBcblx0XHQgKiAgd2l0aCB0aGUgZ2l2ZW4gcG9pbnRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgcG9pbnQgIFRoZSBwb2ludCB0byBxdWVyeVxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gIHJlc3VsdHMgIFRoZSBhcnJheSB0byBwdXQgdGhlIHJlc3VsdHNcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKHBvaW50LCByZXN1bHRzKSB7XG5cdCAgICAgICAgLy8gSWYgcCBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCBwb2ludCBvZiBhbnkgaW50ZXJ2YWxcblx0ICAgICAgICAvLyBpbiB0aGlzIG5vZGUgYW5kIGFsbCBjaGlsZHJlbiwgdGhlcmUgd29uJ3QgYmUgYW55IG1hdGNoZXMuXG5cdCAgICAgICAgaWYgKHBvaW50ID4gdGhpcy5tYXgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBTZWFyY2ggbGVmdCBjaGlsZHJlblxuXHQgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5sZWZ0LnNlYXJjaChwb2ludCwgcmVzdWx0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENoZWNrIHRoaXMgbm9kZVxuXHQgICAgICAgIGlmICh0aGlzLmxvdyA8PSBwb2ludCAmJiB0aGlzLmhpZ2ggPiBwb2ludCkge1xuXHQgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIElmIHAgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHRpbWUgb2YgdGhpcyBpbnRlcnZhbCxcblx0ICAgICAgICAvLyB0aGVuIGl0IGNhbid0IGJlIGluIGFueSBjaGlsZCB0byB0aGUgcmlnaHQuXG5cdCAgICAgICAgaWYgKHRoaXMubG93ID4gcG9pbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBTZWFyY2ggcmlnaHQgY2hpbGRyZW5cblx0ICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnJpZ2h0LnNlYXJjaChwb2ludCwgcmVzdWx0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZWFyY2ggdGhlIHRyZWUgZm9yIG5vZGVzIHdoaWNoIGFyZSBsZXNzIFxuXHRcdCAqICB0aGFuIHRoZSBnaXZlbiBwb2ludFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBwb2ludCAgVGhlIHBvaW50IHRvIHF1ZXJ5XG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgcmVzdWx0cyAgVGhlIGFycmF5IHRvIHB1dCB0aGUgcmVzdWx0c1xuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5zZWFyY2hBZnRlciA9IGZ1bmN0aW9uIChwb2ludCwgcmVzdWx0cykge1xuXHQgICAgICAgIC8vIENoZWNrIHRoaXMgbm9kZVxuXHQgICAgICAgIGlmICh0aGlzLmxvdyA+PSBwb2ludCkge1xuXHQgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcyk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubGVmdC5zZWFyY2hBZnRlcihwb2ludCwgcmVzdWx0cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gc2VhcmNoIHRoZSByaWdodCBzaWRlXG5cdCAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5yaWdodC5zZWFyY2hBZnRlcihwb2ludCwgcmVzdWx0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoaXMgZWxlbWVudCBhbmQgYm90aCBpdCdzIGJyYW5jaGVzXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2tcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICBjYWxsYmFjayh0aGlzKTtcblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMubGVmdC50cmF2ZXJzZShjYWxsYmFjayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMucmlnaHQudHJhdmVyc2UoY2FsbGJhY2spO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVXBkYXRlIHRoZSBoZWlnaHQgb2YgdGhlIG5vZGVcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUudXBkYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwgJiYgdGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMubGVmdC5oZWlnaHQsIHRoaXMucmlnaHQuaGVpZ2h0KSArIDE7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodC5oZWlnaHQgKyAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5sZWZ0LmhlaWdodCArIDE7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVXBkYXRlIHRoZSBoZWlnaHQgb2YgdGhlIG5vZGVcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUudXBkYXRlTWF4ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMubWF4ID0gdGhpcy5oaWdoO1xuXHQgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgdGhpcy5sZWZ0Lm1heCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMucmlnaHQubWF4KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBiYWxhbmNlIGlzIGhvdyB0aGUgbGVhZnMgYXJlIGRpc3RyaWJ1dGVkIG9uIHRoZSBub2RlXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICBOZWdhdGl2ZSBudW1iZXJzIGFyZSBiYWxhbmNlZCB0byB0aGUgcmlnaHRcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUuZ2V0QmFsYW5jZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYmFsYW5jZSA9IDA7XG5cdCAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCAmJiB0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGJhbGFuY2UgPSB0aGlzLmxlZnQuaGVpZ2h0IC0gdGhpcy5yaWdodC5oZWlnaHQ7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgYmFsYW5jZSA9IHRoaXMubGVmdC5oZWlnaHQgKyAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBiYWxhbmNlID0gLSh0aGlzLnJpZ2h0LmhlaWdodCArIDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYmFsYW5jZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBub2RlIGlzIHRoZSBsZWZ0IGNoaWxkXG5cdFx0ICogIG9mIGl0cyBwYXJlbnRcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUuaXNMZWZ0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICE9PSBudWxsICYmIHRoaXMucGFyZW50LmxlZnQgPT09IHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGdldC9zZXQgdGhlIGxlZnQgbm9kZVxuXHRcdCAqICBAdHlwZSB7SW50ZXJ2YWxOb2RlfVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVydmFsTm9kZS5wcm90b3R5cGUsICdsZWZ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGVmdCA9IG5vZGU7XG5cdCAgICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVNYXgoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBnZXQvc2V0IHRoZSByaWdodCBub2RlXG5cdFx0ICogIEB0eXBlIHtJbnRlcnZhbE5vZGV9XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJ2YWxOb2RlLnByb3RvdHlwZSwgJ3JpZ2h0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gbm9kZTtcblx0ICAgICAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gdGhpcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xuXHQgICAgICAgICAgICB0aGlzLnVwZGF0ZU1heCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIG51bGwgb3V0IHJlZmVyZW5jZXMuXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRFTkQgSU5URVJWQUwgTk9ERSBIRUxQRVJcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgcmV0dXJuIFRvbmUuSW50ZXJ2YWxUaW1lbGluZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUcmFuc3BvcnQgZm9yIHRpbWluZyBtdXNpY2FsIGV2ZW50cy5cblx0XHQgKiAgICAgICAgICBTdXBwb3J0cyB0ZW1wbyBjdXJ2ZXMgYW5kIHRpbWUgY2hhbmdlcy4gVW5saWtlIGJyb3dzZXItYmFzZWQgdGltaW5nIChzZXRJbnRlcnZhbCwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuXHRcdCAqICAgICAgICAgIFRvbmUuVHJhbnNwb3J0IHRpbWluZyBldmVudHMgcGFzcyBpbiB0aGUgZXhhY3QgdGltZSBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50XG5cdFx0ICogICAgICAgICAgaW4gdGhlIGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbi4gUGFzcyB0aGF0IHRpbWUgdmFsdWUgdG8gdGhlIG9iamVjdFxuXHRcdCAqICAgICAgICAgIHlvdSdyZSBzY2hlZHVsaW5nLiA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgIEEgc2luZ2xlIHRyYW5zcG9ydCBpcyBjcmVhdGVkIGZvciB5b3Ugd2hlbiB0aGUgbGlicmFyeSBpcyBpbml0aWFsaXplZC4gXG5cdFx0ICogICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgICBUaGUgdHJhbnNwb3J0IGVtaXRzIHRoZSBldmVudHM6IFwic3RhcnRcIiwgXCJzdG9wXCIsIFwicGF1c2VcIiwgYW5kIFwibG9vcFwiIHdoaWNoIGFyZVxuXHRcdCAqICAgICAgICAgIGNhbGxlZCB3aXRoIHRoZSB0aW1lIG9mIHRoYXQgZXZlbnQgYXMgdGhlIGFyZ3VtZW50LiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbWl0dGVyfVxuXHRcdCAqICBAc2luZ2xldG9uXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9yZXBlYXRlZCBldmVudCBldmVyeSA4dGggbm90ZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlUmVwZWF0KGZ1bmN0aW9uKHRpbWUpe1xuXHRcdCAqIFx0Ly9kbyBzb21ldGhpbmcgd2l0aCB0aGUgdGltZVxuXHRcdCAqIH0sIFwiOG5cIik7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zY2hlZHVsZSBhbiBldmVudCBvbiB0aGUgMTZ0aCBtZWFzdXJlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHQvL2RvIHNvbWV0aGluZyB3aXRoIHRoZSB0aW1lXG5cdFx0ICogfSwgXCIxNjowOjBcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVtaXR0ZXIuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8vXHRMT09QSU5HXG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqIFx0SWYgdGhlIHRyYW5zcG9ydCBsb29wcyBvciBub3QuXG5cdFx0XHQgKiAgQHR5cGUge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiBcdFRoZSBsb29wIHN0YXJ0IHBvc2l0aW9uIGluIHRpY2tzXG5cdFx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSAwO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqIFx0VGhlIGxvb3AgZW5kIHBvc2l0aW9uIGluIHRpY2tzXG5cdFx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wRW5kID0gMDtcblx0ICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8vXHRDTE9DSy9URU1QT1xuXHQgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBQdWxzZXMgcGVyIHF1YXJ0ZXIgaXMgdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgcXVhcnRlciBub3RlLlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wcHEgPSBUcmFuc3BvcnRDb25zdHJ1Y3Rvci5kZWZhdWx0cy5QUFE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgd2F0Y2hlcyB0aGUgbWFpbiBvc2NpbGxhdG9yIGZvciB0aW1pbmcgdGlja3Ncblx0XHRcdCAqICBpbml0aWFsbHkgc3RhcnRzIGF0IDEyMGJwbVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ2xvY2t9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jbG9jayA9IG5ldyBUb25lLkNsb2NrKHtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJzogdGhpcy5fcHJvY2Vzc1RpY2suYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IDBcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9iaW5kQ2xvY2tFdmVudHMoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgQmVhdHMgUGVyIE1pbnV0ZSBvZiB0aGUgVHJhbnNwb3J0LiBcblx0XHRcdCAqICBAdHlwZSB7QlBNfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gODA7XG5cdFx0XHQgKiAvL3JhbXAgdGhlIGJwbSB0byAxMjAgb3ZlciAxMCBzZWNvbmRzXG5cdFx0XHQgKiBUb25lLlRyYW5zcG9ydC5icG0ucmFtcFRvKDEyMCwgMTApO1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5icG0gPSB0aGlzLl9jbG9jay5mcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy5icG0uX3RvVW5pdHMgPSB0aGlzLl90b1VuaXRzLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdGhpcy5icG0uX2Zyb21Vbml0cyA9IHRoaXMuX2Zyb21Vbml0cy5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuYnBtLnVuaXRzID0gVG9uZS5UeXBlLkJQTTtcblx0ICAgICAgICB0aGlzLmJwbS52YWx1ZSA9IFRyYW5zcG9ydENvbnN0cnVjdG9yLmRlZmF1bHRzLmJwbTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnYnBtJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRpbWUgc2lnbmF0dXJlLCBvciBtb3JlIGFjY3VyYXRlbHkgdGhlIG51bWVyYXRvclxuXHRcdFx0ICogIG9mIHRoZSB0aW1lIHNpZ25hdHVyZSBvdmVyIGEgZGVub21pbmF0b3Igb2YgNC4gXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdGltZVNpZ25hdHVyZSA9IFRyYW5zcG9ydENvbnN0cnVjdG9yLmRlZmF1bHRzLnRpbWVTaWduYXR1cmU7XG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAvL1x0VElNRUxJTkUgRVZFTlRTXG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFsbCB0aGUgZXZlbnRzIGluIGFuIG9iamVjdCB0byBrZWVwIHRyYWNrIGJ5IElEXG5cdFx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzID0ge307XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGV2ZW50IElEIGNvdW50ZXJcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ldmVudElEID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFx0VGhlIHNjaGVkdWxlZCBldmVudHMuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbmV3IFRvbmUuVGltZWxpbmUoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBSZXBlYXRlZCBldmVudHNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzID0gbmV3IFRvbmUuSW50ZXJ2YWxUaW1lbGluZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEV2ZW50cyB0aGF0IG9jY3VyIG9uY2Vcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMgPSBuZXcgVG9uZS5UaW1lbGluZSgpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBBbGwgb2YgdGhlIHN5bmNlZCBTaWduYWxzXG5cdFx0XHQgKiAgQHByaXZhdGUgXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3luY2VkU2lnbmFscyA9IFtdO1xuXHQgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgLy9cdFNXSU5HXG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzdWJkaXZpc2lvbiBvZiB0aGUgc3dpbmdcblx0XHRcdCAqICBAdHlwZSAge1RpY2tzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zd2luZ1RpY2tzID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMuUFBRIC8gMjtcblx0ICAgICAgICAvLzhuXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHN3aW5nIGFtb3VudFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3dpbmdBbW91bnQgPSAwO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJhbnNwb3J0LCBUb25lLkVtaXR0ZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0c1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2JwbSc6IDEyMCxcblx0ICAgICAgICAnc3dpbmcnOiAwLFxuXHQgICAgICAgICdzd2luZ1N1YmRpdmlzaW9uJzogJzhuJyxcblx0ICAgICAgICAndGltZVNpZ25hdHVyZSc6IDQsXG5cdCAgICAgICAgJ2xvb3BTdGFydCc6IDAsXG5cdCAgICAgICAgJ2xvb3BFbmQnOiAnNG0nLFxuXHQgICAgICAgICdQUFEnOiAxOTJcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0VElDS1Ncblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBjYWxsZWQgb24gZXZlcnkgdGlja1xuXHRcdCAqICBAcGFyYW0gICB7bnVtYmVyfSB0aWNrVGltZSBjbG9jayByZWxhdGl2ZSB0aWNrIHRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5fcHJvY2Vzc1RpY2sgPSBmdW5jdGlvbiAodGlja1RpbWUpIHtcblx0ICAgICAgICB2YXIgdGlja3MgPSB0aGlzLl9jbG9jay50aWNrcztcblx0ICAgICAgICAvL2hhbmRsZSBzd2luZ1xuXHQgICAgICAgIGlmICh0aGlzLl9zd2luZ0Ftb3VudCA+IDAgJiYgdGlja3MgJSB0aGlzLl9wcHEgIT09IDAgJiYgLy9ub3Qgb24gYSBkb3duYmVhdFxuXHQgICAgICAgICAgICB0aWNrcyAlICh0aGlzLl9zd2luZ1RpY2tzICogMikgIT09IDApIHtcblx0ICAgICAgICAgICAgLy9hZGQgc29tZSBzd2luZ1xuXHQgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB0aWNrcyAlICh0aGlzLl9zd2luZ1RpY2tzICogMikgLyAodGhpcy5fc3dpbmdUaWNrcyAqIDIpO1xuXHQgICAgICAgICAgICB2YXIgYW1vdW50ID0gTWF0aC5zaW4ocHJvZ3Jlc3MgKiBNYXRoLlBJKSAqIHRoaXMuX3N3aW5nQW1vdW50O1xuXHQgICAgICAgICAgICB0aWNrVGltZSArPSBUb25lLlRpbWUodGhpcy5fc3dpbmdUaWNrcyAqIDIgLyAzLCAnaScpLmV2YWwoKSAqIGFtb3VudDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9kbyB0aGUgbG9vcCB0ZXN0XG5cdCAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuXHQgICAgICAgICAgICBpZiAodGlja3MgPT09IHRoaXMuX2xvb3BFbmQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9vcEVuZCcsIHRpY2tUaW1lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2Nsb2NrLnRpY2tzID0gdGhpcy5fbG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgdGlja3MgPSB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xvb3BTdGFydCcsIHRpY2tUaW1lLCB0aGlzLnNlY29uZHMpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsb29wJywgdGlja1RpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vcHJvY2VzcyB0aGUgc2luZ2xlIG9jY3VycmVuY2UgZXZlbnRzXG5cdCAgICAgICAgdGhpcy5fb25jZUV2ZW50cy5mb3JFYWNoQmVmb3JlKHRpY2tzLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgZXZlbnQuY2FsbGJhY2sodGlja1RpbWUpO1xuXHQgICAgICAgICAgICAvL3JlbW92ZSB0aGUgZXZlbnRcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudC5pZC50b1N0cmluZygpXTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIC8vYW5kIGNsZWFyIHRoZSBzaW5nbGUgb2NjdXJyZW5jZSB0aW1lbGluZVxuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMuY2FuY2VsQmVmb3JlKHRpY2tzKTtcblx0ICAgICAgICAvL2ZpcmUgdGhlIG5leHQgdGljayBldmVudHMgaWYgdGhlaXIgdGltZSBoYXMgY29tZVxuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lLmZvckVhY2hBdFRpbWUodGlja3MsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5jYWxsYmFjayh0aWNrVGltZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9wcm9jZXNzIHRoZSByZXBlYXRlZCBldmVudHNcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cy5mb3JFYWNoQXRUaW1lKHRpY2tzLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKCh0aWNrcyAtIGV2ZW50LnRpbWUpICUgZXZlbnQuaW50ZXJ2YWwgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LmNhbGxiYWNrKHRpY2tUaW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTQ0hFRFVMQUJMRSBFVkVOVFNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhbiBldmVudCBhbG9uZyB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGF0IHRoZSB0aW1lLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9ICB0aW1lIFRoZSB0aW1lIHRvIGludm9rZSB0aGUgY2FsbGJhY2sgYXQuXG5cdFx0ICogIEByZXR1cm4ge051bWJlcn0gVGhlIGlkIG9mIHRoZSBldmVudCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgY2FuY2VsaW5nIHRoZSBldmVudC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy90cmlnZ2VyIHRoZSBjYWxsYmFjayB3aGVuIHRoZSBUcmFuc3BvcnQgcmVhY2hlcyB0aGUgZGVzaXJlZCB0aW1lXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHRlbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUpO1xuXHRcdCAqIH0sIFwiMTI4aVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGltZSkge1xuXHQgICAgICAgIHZhciBldmVudCA9IHtcblx0ICAgICAgICAgICAgJ3RpbWUnOiB0aGlzLnRvVGlja3ModGltZSksXG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLl9ldmVudElEKys7XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2lkLnRvU3RyaW5nKCldID0ge1xuXHQgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcblx0ICAgICAgICAgICAgJ3RpbWVsaW5lJzogdGhpcy5fdGltZWxpbmVcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lLmFkZChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGlkO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhIHJlcGVhdGVkIGV2ZW50IGFsb25nIHRoZSB0aW1lbGluZS4gVGhlIGV2ZW50IHdpbGwgZmlyZVxuXHRcdCAqICBhdCB0aGUgYGludGVydmFsYCBzdGFydGluZyBhdCB0aGUgYHN0YXJ0VGltZWAgYW5kIGZvciB0aGUgc3BlY2lmaWVkXG5cdFx0ICogIGBkdXJhdGlvbmAuIFxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIHRvIGludm9rZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gICAgaW50ZXJ2YWwgICBUaGUgZHVyYXRpb24gYmV0d2VlbiBzdWNjZXNzaXZlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9uPX0gICAgc3RhcnRUaW1lICBXaGVuIGFsb25nIHRoZSB0aW1lbGluZSB0aGUgZXZlbnRzIHNob3VsZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IGJlaW5nIGludm9rZWQuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2R1cmF0aW9uPUluZmluaXR5XSBIb3cgbG9uZyB0aGUgZXZlbnQgc2hvdWxkIHJlcGVhdC4gXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICAgIFRoZSBJRCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50LiBVc2UgdGhpcyB0byBjYW5jZWxcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBldmVudC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIGNhbGxiYWNrIGludm9rZWQgZXZlcnkgZWlnaHRoIG5vdGUgYWZ0ZXIgdGhlIGZpcnN0IG1lYXN1cmVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdChjYWxsYmFjaywgXCI4blwiLCBcIjFtXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlUmVwZWF0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpbnRlcnZhbCwgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHQgICAgICAgIGlmIChpbnRlcnZhbCA8PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5UcmFuc3BvcnQ6IHJlcGVhdCBldmVudHMgbXVzdCBoYXZlIGFuIGludGVydmFsIGxhcmdlciB0aGFuIDAnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV2ZW50ID0ge1xuXHQgICAgICAgICAgICAndGltZSc6IHRoaXMudG9UaWNrcyhzdGFydFRpbWUpLFxuXHQgICAgICAgICAgICAnZHVyYXRpb24nOiB0aGlzLnRvVGlja3ModGhpcy5kZWZhdWx0QXJnKGR1cmF0aW9uLCBJbmZpbml0eSkpLFxuXHQgICAgICAgICAgICAnaW50ZXJ2YWwnOiB0aGlzLnRvVGlja3MoaW50ZXJ2YWwpLFxuXHQgICAgICAgICAgICAnY2FsbGJhY2snOiBjYWxsYmFja1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZlbnRJRCsrO1xuXHQgICAgICAgIHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tpZC50b1N0cmluZygpXSA9IHtcblx0ICAgICAgICAgICAgJ2V2ZW50JzogZXZlbnQsXG5cdCAgICAgICAgICAgICd0aW1lbGluZSc6IHRoaXMuX3JlcGVhdGVkRXZlbnRzXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cy5hZGQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiBpZDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGUgYW4gZXZlbnQgdGhhdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgaW52b2tlZC4gXG5cdFx0ICogIE5vdGUgdGhhdCBpZiB0aGUgZ2l2ZW4gdGltZSBpcyBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgdHJhbnNwb3J0IHRpbWUsIFxuXHRcdCAqICB0aGUgZXZlbnQgd2lsbCBiZSBpbnZva2VkIGltbWVkaWF0ZWx5LiBcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IHRpbWUgVGhlIHRpbWUgdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkLlxuXHRcdCAqICBAcmV0dXJucyB7TnVtYmVyfSBUaGUgSUQgb2YgdGhlIHNjaGVkdWxlZCBldmVudC4gXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc2NoZWR1bGVPbmNlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZlbnRJRCsrO1xuXHQgICAgICAgIHZhciBldmVudCA9IHtcblx0ICAgICAgICAgICAgJ3RpbWUnOiB0aGlzLnRvVGlja3ModGltZSksXG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrLFxuXHQgICAgICAgICAgICAnaWQnOiBpZFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzW2lkLnRvU3RyaW5nKCldID0ge1xuXHQgICAgICAgICAgICAnZXZlbnQnOiBldmVudCxcblx0ICAgICAgICAgICAgJ3RpbWVsaW5lJzogdGhpcy5fb25jZUV2ZW50c1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5fb25jZUV2ZW50cy5hZGQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiBpZDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYXIgdGhlIHBhc3NlZCBpbiBldmVudCBpZCBmcm9tIHRoZSB0aW1lbGluZVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gZXZlbnRJZCBUaGUgaWQgb2YgdGhlIGV2ZW50LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChldmVudElkKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NjaGVkdWxlZEV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudElkKSkge1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudElkLnRvU3RyaW5nKCldO1xuXHQgICAgICAgICAgICBpdGVtLnRpbWVsaW5lLnJlbW92ZShpdGVtLmV2ZW50KTtcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudElkLnRvU3RyaW5nKCldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVtb3ZlIHNjaGVkdWxlZCBldmVudHMgZnJvbSB0aGUgdGltZWxpbmUgYWZ0ZXJcblx0XHQgKiAgdGhlIGdpdmVuIHRpbWUuIFJlcGVhdGVkIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWRcblx0XHQgKiAgaWYgdGhlaXIgc3RhcnRUaW1lIGlzIGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gW2FmdGVyPTBdIENsZWFyIGFsbCBldmVudHMgYWZ0ZXJcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB0aW1lLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgYWZ0ZXIgPSB0aGlzLmRlZmF1bHRBcmcoYWZ0ZXIsIDApO1xuXHQgICAgICAgIGFmdGVyID0gdGhpcy50b1RpY2tzKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl90aW1lbGluZS5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMuY2FuY2VsKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cy5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTVEFSVC9TVE9QL1BBVVNFXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQmluZCBzdGFydC9zdG9wL3BhdXNlIGV2ZW50cyBmcm9tIHRoZSBjbG9jayBhbmQgZW1pdCB0aGVtLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl9iaW5kQ2xvY2tFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sub24oJ3N0YXJ0JywgZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgICAgICBvZmZzZXQgPSBUb25lLlRpbWUodGhpcy5fY2xvY2sudGlja3MsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB0aW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sub24oJ3N0b3AnLCBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCB0aW1lKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLm9uKCdwYXVzZScsIGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgncGF1c2UnLCB0aW1lKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIsIFwic3RvcHBlZFwiLCBvciBcInBhdXNlZFwiXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvY2suZ2V0U3RhdGVBdFRpbWUodGhpcy5ub3coKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIHRyYW5zcG9ydCBhbmQgYWxsIHNvdXJjZXMgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgdHJhbnNwb3J0IHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7VHJhbnNwb3J0VGltZT19IG9mZnNldCBUaGUgdGltZWxpbmUgb2Zmc2V0IHRvIHN0YXJ0IHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc3RhcnQgdGhlIHRyYW5zcG9ydCBpbiBvbmUgc2Vjb25kIHN0YXJ0aW5nIGF0IGJlZ2lubmluZyBvZiB0aGUgNXRoIG1lYXN1cmUuIFxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KFwiKzFcIiwgXCI0OjA6MFwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQpIHtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBjbG9ja1xuXHQgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKG9mZnNldCkpIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1RpY2tzKG9mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0YXJ0KHRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIHRyYW5zcG9ydCBhbmQgYWxsIHNvdXJjZXMgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgdHJhbnNwb3J0IHNob3VsZCBzdG9wLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RvcCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBhdXNlIHRoZSB0cmFuc3BvcnQgYW5kIGFsbCBzb3VyY2VzIHN5bmNlZCB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9jbG9jay5wYXVzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0U0VUVEVSUy9HRVRURVJTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHRpbWUgc2lnbmF0dXJlIGFzIGp1c3QgdGhlIG51bWVyYXRvciBvdmVyIDQuIFxuXHRcdCAqICBGb3IgZXhhbXBsZSA0LzQgd291bGQgYmUganVzdCA0IGFuZCA2Lzggd291bGQgYmUgMy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7TnVtYmVyfEFycmF5fVxuXHRcdCAqICBAbmFtZSB0aW1lU2lnbmF0dXJlXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jb21tb24gdGltZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnRpbWVTaWduYXR1cmUgPSA0O1xuXHRcdCAqIC8vIDcvOFxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnRpbWVTaWduYXR1cmUgPSBbNywgOF07XG5cdFx0ICogLy90aGlzIHdpbGwgYmUgcmVkdWNlZCB0byBhIHNpbmdsZSBudW1iZXJcblx0XHQgKiBUb25lLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlOyAvL3JldHVybnMgMy41XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAndGltZVNpZ25hdHVyZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVTaWduYXR1cmU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aW1lU2lnKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlzQXJyYXkodGltZVNpZykpIHtcblx0ICAgICAgICAgICAgICAgIHRpbWVTaWcgPSB0aW1lU2lnWzBdIC8gdGltZVNpZ1sxXSAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdGltZVNpZ25hdHVyZSA9IHRpbWVTaWc7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBXaGVuIHRoZSBUb25lLlRyYW5zcG9ydC5sb29wID0gdHJ1ZSwgdGhpcyBpcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIGxvb3AuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZSh0aGlzLl9sb29wU3RhcnQsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzdGFydFBvc2l0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhzdGFydFBvc2l0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFdoZW4gdGhlIFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlLCB0aGlzIGlzIHRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIGxvb3AuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BFbmQsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbmRQb3NpdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKGVuZFBvc2l0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIGxvb3Agc3RhcnQgYW5kIHN0b3AgYXQgdGhlIHNhbWUgdGltZS4gXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gc3RhcnRQb3NpdGlvbiBcblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBlbmRQb3NpdGlvbiAgIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvb3Agb3ZlciB0aGUgZmlyc3QgbWVhc3VyZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNldExvb3BQb2ludHMoMCwgXCIxbVwiKTtcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5sb29wID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zZXRMb29wUG9pbnRzID0gZnVuY3Rpb24gKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG5cdCAgICAgICAgdGhpcy5sb29wU3RhcnQgPSBzdGFydFBvc2l0aW9uO1xuXHQgICAgICAgIHRoaXMubG9vcEVuZCA9IGVuZFBvc2l0aW9uO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc3dpbmcgdmFsdWUuIEJldHdlZW4gMC0xIHdoZXJlIDEgZXF1YWwgdG8gXG5cdFx0ICogIHRoZSBub3RlICsgaGFsZiB0aGUgc3ViZGl2aXNpb24uXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBzd2luZ1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3N3aW5nJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3dpbmdBbW91bnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcblx0ICAgICAgICAgICAgLy9zY2FsZSB0aGUgdmFsdWVzIHRvIGEgbm9ybWFsIHJhbmdlXG5cdCAgICAgICAgICAgIHRoaXMuX3N3aW5nQW1vdW50ID0gYW1vdW50O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgc3ViZGl2aXNpb24gd2hpY2ggdGhlIHN3aW5nIHdpbGwgYmUgYXBwbGllZCB0by4gXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGFuIDh0aCBub3RlLiBWYWx1ZSBtdXN0IGJlIGxlc3MgXG5cdFx0ICogIHRoYW4gYSBxdWFydGVyIG5vdGUuXG5cdFx0ICogIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqICBAbmFtZSBzd2luZ1N1YmRpdmlzaW9uXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnc3dpbmdTdWJkaXZpc2lvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVGltZSh0aGlzLl9zd2luZ1RpY2tzLCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHN1YmRpdmlzaW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N3aW5nVGlja3MgPSB0aGlzLnRvVGlja3Moc3ViZGl2aXNpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBUcmFuc3BvcnQncyBwb3NpdGlvbiBpbiBCYXJzOkJlYXRzOlNpeHRlZW50aHMuXG5cdFx0ICogIFNldHRpbmcgdGhlIHZhbHVlIHdpbGwganVtcCB0byB0aGF0IHBvc2l0aW9uIHJpZ2h0IGF3YXkuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtCYXJzQmVhdHNTaXh0ZWVudGhzfVxuXHRcdCAqICBAbmFtZSBwb3NpdGlvblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3Bvc2l0aW9uJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMudGlja3MsICdpJykudG9CYXJzQmVhdHNTaXh0ZWVudGhzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHQgICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3MocHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICB0aGlzLnRpY2tzID0gdGlja3M7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFRyYW5zcG9ydCdzIHBvc2l0aW9uIGluIHNlY29uZHNcblx0XHQgKiAgU2V0dGluZyB0aGUgdmFsdWUgd2lsbCBqdW1wIHRvIHRoYXQgcG9zaXRpb24gcmlnaHQgYXdheS4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge1NlY29uZHN9XG5cdFx0ICogIEBuYW1lIHNlY29uZHNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdzZWNvbmRzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMudGlja3MsICdpJykudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHQgICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3MocHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICB0aGlzLnRpY2tzID0gdGlja3M7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFRyYW5zcG9ydCdzIGxvb3AgcG9zaXRpb24gYXMgYSBub3JtYWxpemVkIHZhbHVlLiBBbHdheXNcblx0XHQgKiAgcmV0dXJucyAwIGlmIHRoZSB0cmFuc3BvcnQgaWYgbG9vcCBpcyBub3QgdHJ1ZS4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQG5hbWUgcHJvZ3Jlc3Ncblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3Byb2dyZXNzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudGlja3MgLSB0aGlzLl9sb29wU3RhcnQpIC8gKHRoaXMuX2xvb3BFbmQgLSB0aGlzLl9sb29wU3RhcnQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdHJhbnNwb3J0cyBjdXJyZW50IHRpY2sgcG9zaXRpb24uXG5cdFx0ICogIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHQgKiAgQG5hbWUgdGlja3Ncblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICd0aWNrcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb2NrLnRpY2tzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgLy9zdG9wIGV2ZXJ5dGhpbmcgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnRcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJywgbm93KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2Nsb2NrLnRpY2tzID0gdDtcblx0ICAgICAgICAgICAgICAgIC8vcmVzdGFydCBpdCB3aXRoIHRoZSBuZXcgdGltZVxuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIG5vdywgdGhpcy5zZWNvbmRzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2Nsb2NrLnRpY2tzID0gdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFB1bHNlcyBQZXIgUXVhcnRlciBub3RlLiBUaGlzIGlzIHRoZSBzbWFsbGVzdCByZXNvbHV0aW9uXG5cdFx0ICogIHRoZSBUcmFuc3BvcnQgdGltaW5nIHN1cHBvcnRzLiBUaGlzIHNob3VsZCBiZSBzZXQgb25jZVxuXHRcdCAqICBvbiBpbml0aWFsaXphdGlvbiBhbmQgbm90IHNldCBhZ2Fpbi4gQ2hhbmdpbmcgdGhpcyB2YWx1ZSBcblx0XHQgKiAgYWZ0ZXIgb3RoZXIgb2JqZWN0cyBoYXZlIGJlZW4gY3JlYXRlZCBjYW4gY2F1c2UgcHJvYmxlbXMuIFxuXHRcdCAqICBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSBQUFFcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdQUFEnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcHE7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcHEpIHtcblx0ICAgICAgICAgICAgdmFyIGJwbSA9IHRoaXMuYnBtLnZhbHVlO1xuXHQgICAgICAgICAgICB0aGlzLl9wcHEgPSBwcHE7XG5cdCAgICAgICAgICAgIHRoaXMuYnBtLnZhbHVlID0gYnBtO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBoaW50IHRvIHRoZSB0eXBlIG9mIHBsYXliYWNrLiBBZmZlY3RzIHRyYWRlb2ZmcyBiZXR3ZWVuIGF1ZGlvIFxuXHRcdCAqICBvdXRwdXQgbGF0ZW5jeSBhbmQgcmVzcG9uc2l2ZW5lc3MuIFxuXHRcdCAqICBcblx0XHQgKiAgSW4gYWRkaXRpb24gdG8gc2V0dGluZyB0aGUgdmFsdWUgaW4gc2Vjb25kcywgdGhlIGxhdGVuY3lIaW50IGFsc29cblx0XHQgKiAgYWNjZXB0cyB0aGUgc3RyaW5ncyBcImludGVyYWN0aXZlXCIgKHByaW9yaXRpemVzIGxvdyBsYXRlbmN5KSwgXG5cdFx0ICogIFwicGxheWJhY2tcIiAocHJpb3JpdGl6ZXMgc3VzdGFpbmVkIHBsYXliYWNrKSwgXCJiYWxhbmNlZFwiIChiYWxhbmNlc1xuXHRcdCAqICBsYXRlbmN5IGFuZCBwZXJmb3JtYW5jZSksIGFuZCBcImZhc3Rlc3RcIiAobG93ZXN0IGxhdGVuY3ksIG1pZ2h0IGdsaXRjaCBtb3JlIG9mdGVuKS4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge1NlY29uZHN8U3RyaW5nfVxuXHRcdCAqICBAbmFtZSBsYXRlbmN5SGludFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ2xhdGVuY3lIaW50Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5DbG9jay5sYXRlbmN5SGludDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGhpbnQpIHtcblx0ICAgICAgICAgICAgVG9uZS5DbG9jay5sYXRlbmN5SGludCA9IGhpbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBmcm9tIEJQTSB0byBmcmVxdWVuY3kgKGZhY3RvcmluZyBpbiBQUFEpXG5cdFx0ICogIEBwYXJhbSAge0JQTX0gIGJwbSBUaGUgQlBNIHZhbHVlIHRvIGNvbnZlcnQgdG8gZnJlcXVlbmN5XG5cdFx0ICogIEByZXR1cm4gIHtGcmVxdWVuY3l9ICBUaGUgQlBNIGFzIGEgZnJlcXVlbmN5IHdpdGggUFBRIGZhY3RvcmVkIGluLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl9mcm9tVW5pdHMgPSBmdW5jdGlvbiAoYnBtKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyAoNjAgLyBicG0gLyB0aGlzLlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgZnJvbSBmcmVxdWVuY3kgKHdpdGggUFBRKSBpbnRvIEJQTVxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l9ICBmcmVxIFRoZSBjbG9ja3MgZnJlcXVlbmN5IHRvIGNvbnZlcnQgdG8gQlBNXG5cdFx0ICogIEByZXR1cm4gIHtCUE19ICBUaGUgZnJlcXVlbmN5IHZhbHVlIGFzIEJQTS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5fdG9Vbml0cyA9IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgcmV0dXJuIGZyZXEgLyB0aGlzLlBQUSAqIDYwO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTWU5DSU5HXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdGltZSBhbGlnbmVkIHRvIHRoZSBuZXh0IHN1YmRpdmlzaW9uXG5cdFx0ICogIG9mIHRoZSBUcmFuc3BvcnQuIElmIHRoZSBUcmFuc3BvcnQgaXMgbm90IHN0YXJ0ZWQsXG5cdFx0ICogIGl0IHdpbGwgcmV0dXJuIDAuXG5cdFx0ICogIE5vdGU6IHRoaXMgd2lsbCBub3Qgd29yayBwcmVjaXNlbHkgZHVyaW5nIHRlbXBvIHJhbXBzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgc3ViZGl2aXNpb24gIFRoZSBzdWJkaXZpc2lvbiB0byBxdWFudGl6ZSB0b1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIGNvbnRleHQgdGltZSBvZiB0aGUgbmV4dCBzdWJkaXZpc2lvbi5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zdGFydCgpOyAvL3RoZSB0cmFuc3BvcnQgbXVzdCBiZSBzdGFydGVkXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQubmV4dFN1YmRpdmlzaW9uKFwiNG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUubmV4dFN1YmRpdmlzaW9uID0gZnVuY3Rpb24gKHN1YmRpdmlzaW9uKSB7XG5cdCAgICAgICAgc3ViZGl2aXNpb24gPSB0aGlzLnRvU2Vjb25kcyhzdWJkaXZpc2lvbik7XG5cdCAgICAgICAgLy9pZiB0aGUgdHJhbnNwb3J0J3Mgbm90IHN0YXJ0ZWQsIHJldHVybiAwXG5cdCAgICAgICAgdmFyIG5vdztcblx0ICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIG5vdyA9IHRoaXMuX2Nsb2NrLl9uZXh0VGljaztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHRyYW5zcG9ydFBvcyA9IFRvbmUuVGltZSh0aGlzLnRpY2tzLCAnaScpLmV2YWwoKTtcblx0ICAgICAgICB2YXIgcmVtYWluaW5nVGltZSA9IHN1YmRpdmlzaW9uIC0gdHJhbnNwb3J0UG9zICUgc3ViZGl2aXNpb247XG5cdCAgICAgICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IDApIHtcblx0ICAgICAgICAgICAgcmVtYWluaW5nVGltZSA9IHN1YmRpdmlzaW9uO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbm93ICsgcmVtYWluaW5nVGltZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQXR0YWNoZXMgdGhlIHNpZ25hbCB0byB0aGUgdGVtcG8gY29udHJvbCBzaWduYWwgc28gdGhhdCBcblx0XHQgKiAgYW55IGNoYW5nZXMgaW4gdGhlIHRlbXBvIHdpbGwgY2hhbmdlIHRoZSBzaWduYWwgaW4gdGhlIHNhbWVcblx0XHQgKiAgcmF0aW8uIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7VG9uZS5TaWduYWx9IHNpZ25hbCBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSByYXRpbyBPcHRpb25hbGx5IHBhc3MgaW4gdGhlIHJhdGlvIGJldHdlZW5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHdvIHNpZ25hbHMuIE90aGVyd2lzZSBpdCB3aWxsIGJlIGNvbXB1dGVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWQgb24gdGhlaXIgY3VycmVudCB2YWx1ZXMuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zeW5jU2lnbmFsID0gZnVuY3Rpb24gKHNpZ25hbCwgcmF0aW8pIHtcblx0ICAgICAgICBpZiAoIXJhdGlvKSB7XG5cdCAgICAgICAgICAgIC8vZ2V0IHRoZSBzeW5jIHJhdGlvXG5cdCAgICAgICAgICAgIGlmIChzaWduYWwuX3BhcmFtLnZhbHVlICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByYXRpbyA9IHNpZ25hbC5fcGFyYW0udmFsdWUgLyB0aGlzLmJwbS5fcGFyYW0udmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByYXRpbyA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJhdGlvU2lnbmFsID0gbmV3IFRvbmUuR2FpbihyYXRpbyk7XG5cdCAgICAgICAgdGhpcy5icG0uY2hhaW4ocmF0aW9TaWduYWwsIHNpZ25hbC5fcGFyYW0pO1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZFNpZ25hbHMucHVzaCh7XG5cdCAgICAgICAgICAgICdyYXRpbyc6IHJhdGlvU2lnbmFsLFxuXHQgICAgICAgICAgICAnc2lnbmFsJzogc2lnbmFsLFxuXHQgICAgICAgICAgICAnaW5pdGlhbCc6IHNpZ25hbC5fcGFyYW0udmFsdWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBzaWduYWwuX3BhcmFtLnZhbHVlID0gMDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVW5zeW5jcyBhIHByZXZpb3VzbHkgc3luY2VkIHNpZ25hbCBmcm9tIHRoZSB0cmFuc3BvcnQncyBjb250cm9sLiBcblx0XHQgKiAgU2VlIFRvbmUuVHJhbnNwb3J0LnN5bmNTaWduYWwuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuU2lnbmFsfSBzaWduYWwgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnVuc3luY1NpZ25hbCA9IGZ1bmN0aW9uIChzaWduYWwpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fc3luY2VkU2lnbmFscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICB2YXIgc3luY2VkU2lnbmFsID0gdGhpcy5fc3luY2VkU2lnbmFsc1tpXTtcblx0ICAgICAgICAgICAgaWYgKHN5bmNlZFNpZ25hbC5zaWduYWwgPT09IHNpZ25hbCkge1xuXHQgICAgICAgICAgICAgICAgc3luY2VkU2lnbmFsLnJhdGlvLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgIHN5bmNlZFNpZ25hbC5zaWduYWwuX3BhcmFtLnZhbHVlID0gc3luY2VkU2lnbmFsLmluaXRpYWw7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zeW5jZWRTaWduYWxzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jbG9jayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2JwbScpO1xuXHQgICAgICAgIHRoaXMuYnBtID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90aW1lbGluZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX29uY2VFdmVudHMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRlZEV2ZW50cyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdElOSVRJQUxJWkFUSU9OXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICB2YXIgVHJhbnNwb3J0Q29uc3RydWN0b3IgPSBUb25lLlRyYW5zcG9ydDtcblx0ICAgIFRvbmUuX2luaXRBdWRpb0NvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgVG9uZS5UcmFuc3BvcnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgLy9hIHNpbmdsZSB0cmFuc3BvcnQgb2JqZWN0XG5cdCAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0ID0gbmV3IFRvbmUuVHJhbnNwb3J0KCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9zdG9wIHRoZSBjbG9ja1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydC5zdG9wKCk7XG5cdCAgICAgICAgICAgIC8vZ2V0IHRoZSBwcmV2aW91cyB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIHByZXZTZXR0aW5ncyA9IFRvbmUuVHJhbnNwb3J0LmdldCgpO1xuXHQgICAgICAgICAgICAvL2Rlc3RvcnkgdGhlIG9sZCB0cmFuc3BvcnRcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICAvL21ha2UgbmV3IFRyYW5zcG9ydCBpbnNpZGVzXG5cdCAgICAgICAgICAgIFRyYW5zcG9ydENvbnN0cnVjdG9yLmNhbGwoVG9uZS5UcmFuc3BvcnQpO1xuXHQgICAgICAgICAgICAvL3NldCB0aGUgcHJldmlvdXMgY29uZmlnXG5cdCAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0LnNldChwcmV2U2V0dGluZ3MpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Wb2x1bWUgaXMgYSBzaW1wbGUgdm9sdW1lIG5vZGUsIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSB2b2x1bWUgZmFkZXIuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc30gW3ZvbHVtZT0wXSB0aGUgaW5pdGlhbCB2b2x1bWVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgdm9sID0gbmV3IFRvbmUuVm9sdW1lKC0xMik7XG5cdFx0ICogaW5zdHJ1bWVudC5jaGFpbih2b2wsIFRvbmUuTWFzdGVyKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWyd2b2x1bWUnXSwgVG9uZS5Wb2x1bWUuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogdGhlIG91dHB1dCBub2RlXG5cdFx0XHQgKiBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLnZvbHVtZSwgVG9uZS5UeXBlLkRlY2liZWxzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB1bm11dGVkIHZvbHVtZVxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3VubXV0ZWRWb2x1bWUgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGlmIHRoZSB2b2x1bWUgaXMgbXV0ZWRcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXV0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdm9sdW1lIGNvbnRyb2wgaW4gZGVjaWJlbHMuIFxuXHRcdFx0ICogIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMub3V0cHV0LmdhaW47XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBtdXRlIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlZvbHVtZSk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlZvbHVtZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Wb2x1bWUjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiB2b2x1bWUubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Wb2x1bWUucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX211dGVkO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuX211dGVkICYmIG11dGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3VubXV0ZWRWb2x1bWUgPSB0aGlzLnZvbHVtZS52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIC8vbWF5YmUgaXQgc2hvdWxkIHJhbXAgaGVyZT9cblx0ICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLnZhbHVlID0gLUluZmluaXR5O1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX211dGVkICYmICFtdXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZS52YWx1ZSA9IHRoaXMuX3VubXV0ZWRWb2x1bWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fbXV0ZWQgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlZvbHVtZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Wb2x1bWUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5kaXNwb3NlKCk7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCd2b2x1bWUnKTtcblx0ICAgICAgICB0aGlzLnZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlZvbHVtZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBBIHNpbmdsZSBtYXN0ZXIgb3V0cHV0IHdoaWNoIGlzIGNvbm5lY3RlZCB0byB0aGVcblx0XHQgKiAgICAgICAgICBBdWRpb0Rlc3RpbmF0aW9uTm9kZSAoYWthIHlvdXIgc3BlYWtlcnMpLiBcblx0XHQgKiAgICAgICAgICBJdCBwcm92aWRlcyB1c2VmdWwgY29udmVuaWVuY2VzIHN1Y2ggYXMgdGhlIGFiaWxpdHkgXG5cdFx0ICogICAgICAgICAgdG8gc2V0IHRoZSB2b2x1bWUgYW5kIG11dGUgdGhlIGVudGlyZSBhcHBsaWNhdGlvbi4gXG5cdFx0ICogICAgICAgICAgSXQgYWxzbyBnaXZlcyB5b3UgdGhlIGFiaWxpdHkgdG8gYXBwbHkgbWFzdGVyIGVmZmVjdHMgdG8geW91ciBhcHBsaWNhdGlvbi4gXG5cdFx0ICogICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgICBMaWtlIFRvbmUuVHJhbnNwb3J0LCBBIHNpbmdsZSBUb25lLk1hc3RlciBpcyBjcmVhdGVkXG5cdFx0ICogICAgICAgICAgb24gaW5pdGlhbGl6YXRpb24gYW5kIHlvdSBkbyBub3QgbmVlZCB0byBleHBsaWNpdGx5IGNvbnN0cnVjdCBvbmUuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAc2luZ2xldG9uXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy90aGUgYXVkaW8gd2lsbCBnbyBmcm9tIHRoZSBvc2NpbGxhdG9yIHRvIHRoZSBzcGVha2Vyc1xuXHRcdCAqIG9zY2lsbGF0b3IuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdFx0ICogLy9hIGNvbnZlbmllbmNlIGZvciBjb25uZWN0aW5nIHRvIHRoZSBtYXN0ZXIgb3V0cHV0IGlzIGFsc28gcHJvdmlkZWQ6XG5cdFx0ICogb3NjaWxsYXRvci50b01hc3RlcigpO1xuXHRcdCAqIC8vdGhlIGFib3ZlIHR3byBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cblx0XHQgKi9cblx0ICAgIFRvbmUuTWFzdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcHJpdmF0ZSB2b2x1bWUgbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Wb2x1bWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVm9sdW1lKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBtYXN0ZXIgb3V0cHV0LlxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5pbnB1dC5jaGFpbih0aGlzLm91dHB1dCwgdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1hc3Rlcik7XG5cdCAgICAvKipcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLk1hc3Rlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5NYXN0ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiBUb25lLk1hc3Rlci5tdXRlID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1hc3Rlci5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYSBtYXN0ZXIgZWZmZWN0cyBjaGFpbi4gTk9URTogdGhpcyB3aWxsIGRpc2Nvbm5lY3QgYW55IG5vZGVzIHdoaWNoIHdlcmUgcHJldmlvdXNseSBcblx0XHQgKiAgY2hhaW5lZCBpbiB0aGUgbWFzdGVyIGVmZmVjdHMgY2hhaW4uIFxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvTm9kZXxUb25lLi4ufSBhcmdzIEFsbCBhcmd1bWVudHMgd2lsbCBiZSBjb25uZWN0ZWQgaW4gYSByb3dcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIE1hc3RlciB3aWxsIGJlIHJvdXRlZCB0aHJvdWdoIGl0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NYXN0ZXJ9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zb21lIG92ZXJhbGwgY29tcHJlc3Npb24gdG8ga2VlcCB0aGUgbGV2ZWxzIGluIGNoZWNrXG5cdFx0ICogdmFyIG1hc3RlckNvbXByZXNzb3IgPSBuZXcgVG9uZS5Db21wcmVzc29yKHtcblx0XHQgKiBcdFwidGhyZXNob2xkXCIgOiAtNixcblx0XHQgKiBcdFwicmF0aW9cIiA6IDMsXG5cdFx0ICogXHRcImF0dGFja1wiIDogMC41LFxuXHRcdCAqIFx0XCJyZWxlYXNlXCIgOiAwLjFcblx0XHQgKiB9KTtcblx0XHQgKiAvL2dpdmUgYSBsaXR0bGUgYm9vc3QgdG8gdGhlIGxvd3Ncblx0XHQgKiB2YXIgbG93QnVtcCA9IG5ldyBUb25lLkZpbHRlcigyMDAsIFwibG93c2hlbGZcIik7XG5cdFx0ICogLy9yb3V0ZSBldmVyeXRoaW5nIHRocm91Z2ggdGhlIGZpbHRlciBcblx0XHQgKiAvL2FuZCBjb21wcmVzc29yIGJlZm9yZSBnb2luZyB0byB0aGUgc3BlYWtlcnNcblx0XHQgKiBUb25lLk1hc3Rlci5jaGFpbihsb3dCdW1wLCBtYXN0ZXJDb21wcmVzc29yKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWFzdGVyLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNoYWluLmFwcGx5KHRoaXMuaW5wdXQsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWFzdGVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NYXN0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCd2b2x1bWUnKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEFVR01FTlQgVE9ORSdzIFBST1RPVFlQRVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQ29ubmVjdCAndGhpcycgdG8gdGhlIG1hc3RlciBvdXRwdXQuIFNob3J0aGFuZCBmb3IgdGhpcy5jb25uZWN0KFRvbmUuTWFzdGVyKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY29ubmVjdCBhbiBvc2NpbGxhdG9yIHRvIHRoZSBtYXN0ZXIgb3V0cHV0XG5cdFx0ICogdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS50b01hc3RlcigpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUudG9NYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWxzbyBhdWdtZW50IEF1ZGlvTm9kZSdzIHByb3RvdHlwZSB0byBpbmNsdWRlIHRvTWFzdGVyXG5cdFx0ICogIGFzIGEgY29udmVuaWVuY2Vcblx0XHQgKiAgQHJldHVybnMge0F1ZGlvTm9kZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS50b01hc3RlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNvbm5lY3QoVG9uZS5NYXN0ZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHZhciBNYXN0ZXJDb25zdHJ1Y3RvciA9IFRvbmUuTWFzdGVyO1xuXHQgICAgLyoqXG5cdFx0ICogIGluaXRpYWxpemUgdGhlIG1vZHVsZSBhbmQgbGlzdGVuIGZvciBuZXcgYXVkaW8gY29udGV4dHNcblx0XHQgKi9cblx0ICAgIFRvbmUuX2luaXRBdWRpb0NvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vYSBzaW5nbGUgbWFzdGVyIG91dHB1dFxuXHQgICAgICAgIGlmICghVG9uZS5wcm90b3R5cGUuaXNVbmRlZihUb25lLk1hc3RlcikpIHtcblx0ICAgICAgICAgICAgVG9uZS5NYXN0ZXIgPSBuZXcgTWFzdGVyQ29uc3RydWN0b3IoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBNYXN0ZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKFRvbmUuTWFzdGVyKTtcblx0ICAgICAgICAgICAgTWFzdGVyQ29uc3RydWN0b3IuY2FsbChUb25lLk1hc3Rlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gVG9uZS5NYXN0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQmFzZSBjbGFzcyBmb3Igc291cmNlcy4gU291cmNlcyBoYXZlIHN0YXJ0L3N0b3AgbWV0aG9kc1xuXHRcdCAqICAgICAgICAgIGFuZCB0aGUgYWJpbGl0eSB0byBiZSBzeW5jZWQgdG8gdGhlIFxuXHRcdCAqICAgICAgICAgIHN0YXJ0L3N0b3Agb2YgVG9uZS5UcmFuc3BvcnQuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL011bHRpcGxlIHN0YXRlIGNoYW5nZSBldmVudHMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIsXG5cdFx0ICogLy9idXQgbXVzdCBiZSBzZXQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgYW5kIHdpdGggYXNjZW5kaW5nIHRpbWVzXG5cdFx0ICogXG5cdFx0ICogLy8gT0tcblx0XHQgKiBzdGF0ZS5zdGFydCgpLnN0b3AoXCIrMC4yXCIpO1xuXHRcdCAqIC8vIEFORFxuXHRcdCAqIHN0YXRlLnN0YXJ0KCkuc3RvcChcIiswLjJcIikuc3RhcnQoXCIrMC40XCIpLnN0b3AoXCIrMC43XCIpXG5cdFx0ICpcblx0XHQgKiAvLyBCQURcblx0XHQgKiBzdGF0ZS5zdG9wKFwiKzAuMlwiKS5zdGFydCgpO1xuXHRcdCAqIC8vIE9SXG5cdFx0ICogc3RhdGUuc3RhcnQoXCIrMC4zXCIpLnN0b3AoXCIrMC4yXCIpO1xuXHRcdCAqIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIC8vIHRoaXMuY3JlYXRlSW5zT3V0cygwLCAxKTtcblx0ICAgICAgICBvcHRpb25zID0gdGhpcy5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuU291cmNlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzLlxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHNvdXJjZS52b2x1bWUudmFsdWUgPSAtNjtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBcdEtlZXAgdHJhY2sgb2YgdGhlIHNjaGVkdWxlZCBzdGF0ZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZVN0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5tZW1vcnkgPSAxMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc3luY2VkIGBzdGFydGAgY2FsbGJhY2sgZnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNwb3J0XG5cdFx0XHQgKiAgQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBLZWVwIHRyYWNrIG9mIGFsbCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50IGlkc1xuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IFtdO1xuXHQgICAgICAgIC8vbWFrZSB0aGUgb3V0cHV0IGV4cGxpY2l0bHkgc3RlcmVvXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLm91dHB1dC5vdXRwdXQuY2hhbm5lbENvdW50ID0gMjtcblx0ICAgICAgICB0aGlzLl92b2x1bWUub3V0cHV0Lm91dHB1dC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgICAgICAvL211dGUgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIGVpdGhlciBcInN0YXJ0ZWRcIiBvciBcInN0b3BwZWRcIi5cblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Tb3VyY2UjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Tb3VyY2UucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLlRyYW5zcG9ydC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKFRvbmUuVHJhbnNwb3J0LnNlY29uZHMpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5TdGF0ZS5TdG9wcGVkO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRoaXMubm93KCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBNdXRlIHRoZSBvdXRwdXQuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNvdXJjZSNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL211dGUgdGhlIG91dHB1dFxuXHRcdCAqIHNvdXJjZS5tdXRlID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNvdXJjZS5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vb3ZlcndyaXRlIHRoZXNlIGZ1bmN0aW9uc1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLl9zdGFydCA9IFRvbmUubm9PcDtcblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5fc3RvcCA9IFRvbmUubm9PcDtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgc291cmNlIGF0IHRoZSBzcGVjaWZpZWQgdGltZS4gSWYgbm8gdGltZSBpcyBnaXZlbiwgXG5cdFx0ICogIHN0YXJ0IHRoZSBzb3VyY2Ugbm93LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHNvdXJjZSBzaG91bGQgYmUgc3RhcnRlZC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc291cmNlLnN0YXJ0KFwiKzAuNVwiKTsgLy9zdGFydHMgdGhlIHNvdXJjZSAwLjUgc2Vjb25kcyBmcm9tIG5vd1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCwgZHVyYXRpb24pIHtcblx0ICAgICAgICBpZiAodGhpcy5pc1VuZGVmKHRpbWUpICYmIHRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICB0aW1lID0gVG9uZS5UcmFuc3BvcnQuc2Vjb25kcztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vaWYgaXQncyBzdGFydGVkLCBzdG9wIGl0IGFuZCByZXN0YXJ0IGl0XG5cdCAgICAgICAgaWYgKCF0aGlzLnJldHJpZ2dlciAmJiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RvcCh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdGFydGVkLCB0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgIC8vIGFkZCB0aGUgb2Zmc2V0IHRpbWUgdG8gdGhlIGV2ZW50XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX3N0YXRlLmdldCh0aW1lKTtcblx0ICAgICAgICAgICAgZXZlbnQub2Zmc2V0ID0gdGhpcy5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdCAgICAgICAgICAgIGV2ZW50LmR1cmF0aW9uID0gZHVyYXRpb247XG5cdCAgICAgICAgICAgIHZhciBzY2hlZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCh0LCBvZmZzZXQsIGR1cmF0aW9uKTtcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkLnB1c2goc2NoZWQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBzb3VyY2UgYXQgdGhlIHNwZWNpZmllZCB0aW1lLiBJZiBubyB0aW1lIGlzIGdpdmVuLCBcblx0XHQgKiAgc3RvcCB0aGUgc291cmNlIG5vdy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBzb3VyY2Ugc2hvdWxkIGJlIHN0b3BwZWQuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Tb3VyY2V9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzb3VyY2Uuc3RvcCgpOyAvLyBzdG9wcyB0aGUgc291cmNlIGltbWVkaWF0ZWx5XG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNVbmRlZih0aW1lKSAmJiB0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgdGltZSA9IFRvbmUuVHJhbnNwb3J0LnNlY29uZHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zdGF0ZS5jYW5jZWwodGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCB0aW1lKTtcblx0ICAgICAgICBpZiAoIXRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHNjaGVkID0gVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUodGhpcy5fc3RvcC5iaW5kKHRoaXMpLCB0aW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkLnB1c2goc2NoZWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3luYyB0aGUgc291cmNlIHRvIHRoZSBUcmFuc3BvcnQgc28gdGhhdCBhbGwgc3Vic2VxdWVudFxuXHRcdCAqICBjYWxscyB0byBgc3RhcnRgIGFuZCBgc3RvcGAgYXJlIHN5bmNlZCB0byB0aGUgVHJhbnNwb3J0VGltZVxuXHRcdCAqICBpbnN0ZWFkIG9mIHRoZSBBdWRpb0NvbnRleHQgdGltZS4gXG5cdFx0ICpcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zeW5jIHRoZSBzb3VyY2Ugc28gdGhhdCBpdCBwbGF5cyBiZXR3ZWVuIDAgYW5kIDAuMyBvbiB0aGUgVHJhbnNwb3J0J3MgdGltZWxpbmVcblx0XHQgKiBzb3VyY2Uuc3luYygpLnN0YXJ0KDApLnN0b3AoMC4zKTtcblx0XHQgKiAvL3N0YXJ0IHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RhcnQoKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc3RhcnQgdGhlIHRyYW5zcG9ydCB3aXRoIGFuIG9mZnNldCBhbmQgdGhlIHN5bmMnZWQgc291cmNlc1xuXHRcdCAqIC8vd2lsbCBzdGFydCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuXHRcdCAqIHNvdXJjZS5zeW5jKCkuc3RhcnQoMC4xKTtcblx0XHQgKiAvL3RoZSBzb3VyY2Ugd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gb2Zmc2V0IG9mIDAuNFxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KFwiKzAuNVwiLCAwLjUpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc3luY2VkID0gdHJ1ZTtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC5vbignc3RhcnQgbG9vcFN0YXJ0JywgZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwbGF5YmFjayBzdGF0ZSBhdCB0aGF0IHRpbWVcblx0ICAgICAgICAgICAgICAgIHZhciBzdGF0ZUV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gZm9yIHN0YXJ0IGV2ZW50cyB3aGljaCBtYXkgb2NjdXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc3luYydlZCB0aW1lXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdGVFdmVudCAmJiBzdGF0ZUV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQgJiYgc3RhdGVFdmVudC50aW1lICE9PSBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG9mZnNldFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IG9mZnNldCAtIHRoaXMudG9TZWNvbmRzKHN0YXRlRXZlbnQudGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUV2ZW50LmR1cmF0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoc3RhdGVFdmVudC5kdXJhdGlvbikgLSBzdGFydE9mZnNldDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQodGltZSwgdGhpcy50b1NlY29uZHMoc3RhdGVFdmVudC5vZmZzZXQpICsgc3RhcnRPZmZzZXQsIGR1cmF0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnQub24oJ3N0b3AgcGF1c2UgbG9vcEVuZCcsIGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC5zZWNvbmRzKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdG9wKHRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVW5zeW5jIHRoZSBzb3VyY2UgdG8gdGhlIFRyYW5zcG9ydC4gU2VlIFRvbmUuU291cmNlLnN5bmNcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZCA9IGZhbHNlO1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9mZignc3RhcnQgc3RvcCBwYXVzZSBsb29wRW5kIGxvb3BTdGFydCcpO1xuXHQgICAgICAgIC8vIGNsZWFyIGFsbCBvZiB0aGUgc2NoZWR1bGVkIGlkc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2NoZWR1bGVkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3NjaGVkdWxlZFtpXTtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQuY2xlYXIoaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWQgPSBbXTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5jYW5jZWwoMCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICpcdENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlNvdXJjZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMudW5zeW5jKCk7XG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndm9sdW1lJyk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNvdXJjZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuT3NjaWxsYXRvciBzdXBwb3J0cyBhIG51bWJlciBvZiBmZWF0dXJlcyBpbmNsdWRpbmdcblx0XHQgKiAgICAgICAgIHBoYXNlIHJvdGF0aW9uLCBtdWx0aXBsZSBvc2NpbGxhdG9yIHR5cGVzIChzZWUgVG9uZS5Pc2NpbGxhdG9yLnR5cGUpLCBcblx0XHQgKiAgICAgICAgIGFuZCBUcmFuc3BvcnQgc3luY2luZyAoc2VlIFRvbmUuT3NjaWxsYXRvci5zeW5jRnJlcXVlbmN5KS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2ZyZXF1ZW5jeV0gU3RhcnRpbmcgZnJlcXVlbmN5XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVGhlIG9zY2lsbGF0b3IgdHlwZS4gUmVhZCBtb3JlIGFib3V0IHR5cGUgYmVsb3cuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9tYWtlIGFuZCBzdGFydCBhIDQ0MGh6IHNpbmUgdG9uZVxuXHRcdCAqIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKDQ0MCwgXCJzaW5lXCIpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJ1xuXHQgICAgICAgIF0sIFRvbmUuT3NjaWxsYXRvci5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWFpbiBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge09zY2lsbGF0b3JOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBlcmlvZGljIHdhdmVcblx0XHRcdCAqICBAdHlwZSB7UGVyaW9kaWNXYXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl93YXZlID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFydGlhbHMgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcnRpYWxzID0gdGhpcy5kZWZhdWx0QXJnKG9wdGlvbnMucGFydGlhbHMsIFsxXSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgYmV0d2VlbiAwIC0gMzYwXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge3N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XG5cdCAgICAgICAgLy9zZXR1cFxuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLnBoYXNlID0gdGhpcy5fcGhhc2U7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICdwYXJ0aWFscyc6IFtdXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBPc2NpbGxhdG9yIHR5cGVzXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IuVHlwZSA9IHtcblx0ICAgICAgICBTaW5lOiAnc2luZScsXG5cdCAgICAgICAgVHJpYW5nbGU6ICd0cmlhbmdsZScsXG5cdCAgICAgICAgU2F3dG9vdGg6ICdzYXd0b290aCcsXG5cdCAgICAgICAgU3F1YXJlOiAnc3F1YXJlJyxcblx0ICAgICAgICBDdXN0b206ICdjdXN0b20nXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgLy9uZXcgb3NjaWxsYXRvciB3aXRoIHByZXZpb3VzIHZhbHVlc1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSB0aGlzLmNvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMuX3dhdmUpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgY29udHJvbCBzaWduYWwgdG8gdGhlIG9zY2lsbGF0b3IgZnJlcXVlbmN5ICYgZGV0dW5lXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdGFydCh0aGlzLnRvU2Vjb25kcyh0aW1lKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0b3AgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAob3B0aW9uYWwpIHRpbWluZyBwYXJhbWV0ZXJcblx0XHQgKiAgQHJldHVybnMge1RvbmUuT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdG9wKHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTeW5jIHRoZSBzaWduYWwgdG8gdGhlIFRyYW5zcG9ydCdzIGJwbS4gQW55IGNoYW5nZXMgdG8gdGhlIHRyYW5zcG9ydHMgYnBtLFxuXHRcdCAqICB3aWxsIGFsc28gYWZmZWN0IHRoZSBvc2NpbGxhdG9ycyBmcmVxdWVuY3kuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gMTIwO1xuXHRcdCAqIG9zYy5mcmVxdWVuY3kudmFsdWUgPSA0NDA7XG5cdFx0ICogLy90aGUgcmF0aW9uIGJldHdlZW4gdGhlIGJwbSBhbmQgdGhlIGZyZXF1ZW5jeSB3aWxsIGJlIG1haW50YWluZWRcblx0XHQgKiBvc2Muc3luY0ZyZXF1ZW5jeSgpO1xuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSA9IDI0MDsgXG5cdFx0ICogLy8gdGhlIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvciBpcyBkb3VibGVkIHRvIDg4MFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5zeW5jRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0LnN5bmNTaWduYWwodGhpcy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBVbnN5bmMgdGhlIG9zY2lsbGF0b3IncyBmcmVxdWVuY3kgZnJvbSB0aGUgVHJhbnNwb3J0LiBcblx0XHQgKiAgU2VlIFRvbmUuT3NjaWxsYXRvci5zeW5jRnJlcXVlbmN5XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUudW5zeW5jRnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0LnVuc3luY1NpZ25hbCh0aGlzLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3I6IGVpdGhlciBzaW5lLCBzcXVhcmUsIHRyaWFuZ2xlLCBvciBzYXd0b290aC4gQWxzbyBjYXBhYmxlIG9mXG5cdFx0ICogc2V0dGluZyB0aGUgZmlyc3QgeCBudW1iZXIgb2YgcGFydGlhbHMgb2YgdGhlIG9zY2lsbGF0b3IuIEZvciBleGFtcGxlOiBcInNpbmU0XCIgd291bGRcblx0XHQgKiBzZXQgYmUgdGhlIGZpcnN0IDQgcGFydGlhbHMgb2YgdGhlIHNpbmUgd2F2ZSBhbmQgXCJ0cmlhbmdsZThcIiB3b3VsZCBzZXQgdGhlIGZpcnN0XG5cdFx0ICogOCBwYXJ0aWFscyBvZiB0aGUgdHJpYW5nbGUgd2F2ZS5cblx0XHQgKiA8YnI+PGJyPiBcblx0XHQgKiBVc2VzIFBlcmlvZGljV2F2ZSBpbnRlcm5hbGx5IGV2ZW4gZm9yIG5hdGl2ZSB0eXBlcyBzbyB0aGF0IGl0IGNhbiBzZXQgdGhlIHBoYXNlLiBcblx0XHQgKiBQZXJpb2RpY1dhdmUgZXF1YXRpb25zIGFyZSBmcm9tIHRoZSBcblx0XHQgKiBbV2Via2l0IFdlYiBBdWRpbyBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9jb2Rlc2VhcmNoI2Nocm9taXVtL3NyYy90aGlyZF9wYXJ0eS9XZWJLaXQvU291cmNlL21vZHVsZXMvd2ViYXVkaW8vUGVyaW9kaWNXYXZlLmNwcCZzcT1wYWNrYWdlOmNocm9taXVtKS5cblx0XHQgKiAgXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IGl0IHRvIGEgc3F1YXJlIHdhdmVcblx0XHQgKiBvc2MudHlwZSA9IFwic3F1YXJlXCI7XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL3NldCB0aGUgZmlyc3QgNiBwYXJ0aWFscyBvZiBhIHNhd3Rvb3RoIHdhdmVcblx0XHQgKiBvc2MudHlwZSA9IFwic2F3dG9vdGg2XCI7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB2YXIgY29lZnMgPSB0aGlzLl9nZXRSZWFsSW1hZ2luYXJ5KHR5cGUsIHRoaXMuX3BoYXNlKTtcblx0ICAgICAgICAgICAgdmFyIHBlcmlvZGljV2F2ZSA9IHRoaXMuY29udGV4dC5jcmVhdGVQZXJpb2RpY1dhdmUoY29lZnNbMF0sIGNvZWZzWzFdKTtcblx0ICAgICAgICAgICAgdGhpcy5fd2F2ZSA9IHBlcmlvZGljV2F2ZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3IgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMuX3dhdmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHJlYWwgYW5kIGltYWdpbmFyeSBjb21wb25lbnRzIGJhc2VkIFxuXHRcdCAqICBvbiB0aGUgb3NjaWxsYXRvciB0eXBlLlxuXHRcdCAqICBAcmV0dXJucyB7QXJyYXl9IFtyZWFsLCBpbWFnaW5hcnldXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9nZXRSZWFsSW1hZ2luYXJ5ID0gZnVuY3Rpb24gKHR5cGUsIHBoYXNlKSB7XG5cdCAgICAgICAgdmFyIGZmdFNpemUgPSA0MDk2O1xuXHQgICAgICAgIHZhciBwZXJpb2RpY1dhdmVTaXplID0gZmZ0U2l6ZSAvIDI7XG5cdCAgICAgICAgdmFyIHJlYWwgPSBuZXcgRmxvYXQzMkFycmF5KHBlcmlvZGljV2F2ZVNpemUpO1xuXHQgICAgICAgIHZhciBpbWFnID0gbmV3IEZsb2F0MzJBcnJheShwZXJpb2RpY1dhdmVTaXplKTtcblx0ICAgICAgICB2YXIgcGFydGlhbENvdW50ID0gMTtcblx0ICAgICAgICBpZiAodHlwZSA9PT0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tKSB7XG5cdCAgICAgICAgICAgIHBhcnRpYWxDb3VudCA9IHRoaXMuX3BhcnRpYWxzLmxlbmd0aCArIDE7XG5cdCAgICAgICAgICAgIHBlcmlvZGljV2F2ZVNpemUgPSBwYXJ0aWFsQ291bnQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSAvXihzaW5lfHRyaWFuZ2xlfHNxdWFyZXxzYXd0b290aCkoXFxkKykkLy5leGVjKHR5cGUpO1xuXHQgICAgICAgICAgICBpZiAocGFydGlhbCkge1xuXHQgICAgICAgICAgICAgICAgcGFydGlhbENvdW50ID0gcGFyc2VJbnQocGFydGlhbFsyXSkgKyAxO1xuXHQgICAgICAgICAgICAgICAgdHlwZSA9IHBhcnRpYWxbMV07XG5cdCAgICAgICAgICAgICAgICBwYXJ0aWFsQ291bnQgPSBNYXRoLm1heChwYXJ0aWFsQ291bnQsIDIpO1xuXHQgICAgICAgICAgICAgICAgcGVyaW9kaWNXYXZlU2l6ZSA9IHBhcnRpYWxDb3VudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBuID0gMTsgbiA8IHBlcmlvZGljV2F2ZVNpemU7ICsrbikge1xuXHQgICAgICAgICAgICB2YXIgcGlGYWN0b3IgPSAyIC8gKG4gKiBNYXRoLlBJKTtcblx0ICAgICAgICAgICAgdmFyIGI7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuT3NjaWxsYXRvci5UeXBlLlNpbmU6XG5cdCAgICAgICAgICAgICAgICBiID0gbiA8PSBwYXJ0aWFsQ291bnQgPyAxIDogMDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuT3NjaWxsYXRvci5UeXBlLlNxdWFyZTpcblx0ICAgICAgICAgICAgICAgIGIgPSBuICYgMSA/IDIgKiBwaUZhY3RvciA6IDA7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5TYXd0b290aDpcblx0ICAgICAgICAgICAgICAgIGIgPSBwaUZhY3RvciAqIChuICYgMSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5UcmlhbmdsZTpcblx0ICAgICAgICAgICAgICAgIGlmIChuICYgMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGIgPSAyICogKHBpRmFjdG9yICogcGlGYWN0b3IpICogKG4gLSAxID4+IDEgJiAxID8gLTEgOiAxKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b206XG5cdCAgICAgICAgICAgICAgICBiID0gdGhpcy5fcGFydGlhbHNbbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb25lLk9zY2lsbGF0b3I6IGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChiICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZWFsW25dID0gLWIgKiBNYXRoLnNpbihwaGFzZSAqIG4pO1xuXHQgICAgICAgICAgICAgICAgaW1hZ1tuXSA9IGIgKiBNYXRoLmNvcyhwaGFzZSAqIG4pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmVhbFtuXSA9IDA7XG5cdCAgICAgICAgICAgICAgICBpbWFnW25dID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICByZWFsLFxuXHQgICAgICAgICAgICBpbWFnXG5cdCAgICAgICAgXTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29tcHV0ZSB0aGUgaW52ZXJzZSBGRlQgZm9yIGEgZ2l2ZW4gcGhhc2UuXHRcblx0XHQgKiAgQHBhcmFtICB7RmxvYXQzMkFycmF5fSAgcmVhbFxuXHRcdCAqICBAcGFyYW0gIHtGbG9hdDMyQXJyYXl9ICBpbWFnIFxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gIHBoYXNlIFxuXHRcdCAqICBAcmV0dXJuICB7QXVkaW9SYW5nZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuX2ludmVyc2VGRlQgPSBmdW5jdGlvbiAocmVhbCwgaW1hZywgcGhhc2UpIHtcblx0ICAgICAgICB2YXIgc3VtID0gMDtcblx0ICAgICAgICB2YXIgbGVuID0gcmVhbC5sZW5ndGg7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICBzdW0gKz0gcmVhbFtpXSAqIE1hdGguY29zKGkgKiBwaGFzZSkgKyBpbWFnW2ldICogTWF0aC5zaW4oaSAqIHBoYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN1bTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgb3NjaWxsYXRvci5cblx0XHQgKiAgQHJldHVybiAge0F1ZGlvUmFuZ2V9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9nZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvZWZzID0gdGhpcy5fZ2V0UmVhbEltYWdpbmFyeSh0aGlzLl90eXBlLCAwKTtcblx0ICAgICAgICB2YXIgcmVhbCA9IGNvZWZzWzBdO1xuXHQgICAgICAgIHZhciBpbWFnID0gY29lZnNbMV07XG5cdCAgICAgICAgdmFyIG1heFZhbHVlID0gMDtcblx0ICAgICAgICB2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0ICAgICAgICAvL2NoZWNrIGZvciBwZWFrcyBpbiA4IHBsYWNlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgodGhpcy5faW52ZXJzZUZGVChyZWFsLCBpbWFnLCBpIC8gOCAqIHR3b1BpKSwgbWF4VmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gLXRoaXMuX2ludmVyc2VGRlQocmVhbCwgaW1hZywgdGhpcy5fcGhhc2UpIC8gbWF4VmFsdWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSB3YXZlZm9ybS4gQSBwYXJ0aWFsIHJlcHJlc2VudHMgXG5cdFx0ICogdGhlIGFtcGxpdHVkZSBhdCBhIGhhcm1vbmljLiBUaGUgZmlyc3QgaGFybW9uaWMgaXMgdGhlIFxuXHRcdCAqIGZ1bmRhbWVudGFsIGZyZXF1ZW5jeSwgdGhlIHNlY29uZCBpcyB0aGUgb2N0YXZlIGFuZCBzbyBvblxuXHRcdCAqIGZvbGxvd2luZyB0aGUgaGFybW9uaWMgc2VyaWVzLiBcblx0XHQgKiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgdHlwZSB0byBcImN1c3RvbVwiLiBcblx0XHQgKiBUaGUgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXkgd2hlbiB0aGUgdHlwZSBpcyBub3QgXCJjdXN0b21cIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG9zYy5wYXJ0aWFscyA9IFsxLCAwLjIsIDAuMDFdO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09IFRvbmUuT3NjaWxsYXRvci5UeXBlLkN1c3RvbSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRpYWxzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b207XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RGVncmVlc31cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBoYXNlID0gMTgwOyAvL2ZsaXBzIHRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BoYXNlICogKDE4MCAvIE1hdGguUEkpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGhhc2UgPSBwaGFzZSAqIE1hdGguUEkgLyAxODA7XG5cdCAgICAgICAgICAgIC8vcmVzZXQgdGhlIHR5cGVcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBEaXNwb3NlIGFuZCBkaXNjb25uZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLk9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9yICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fd2F2ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5aZXJvIG91dHB1dHMgMCdzIGF0IGF1ZGlvLXJhdGUuIFRoZSByZWFzb24gdGhpcyBoYXMgdG8gYmVcblx0XHQgKiAgICAgICAgIGl0J3Mgb3duIGNsYXNzIGlzIHRoYXQgbWFueSBicm93c2VycyBvcHRpbWl6ZSBvdXQgVG9uZS5TaWduYWxcblx0XHQgKiAgICAgICAgIHdpdGggYSB2YWx1ZSBvZiAwIGFuZCB3aWxsIG5vdCBwcm9jZXNzIG5vZGVzIGZ1cnRoZXIgZG93biB0aGUgZ3JhcGguIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuWmVybyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZ2FpbiBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2dhaW4gPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgVG9uZS5aZXJvLl96ZXJvcy5jb25uZWN0KHRoaXMuX2dhaW4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuWmVybyk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuWmVyb30gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuWmVyby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ2FpbiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdlbmVyYXRlcyBhIGNvbnN0YW50IG91dHB1dCBvZiAwLiBUaGlzIGlzIHNvIFxuXHRcdCAqICB0aGUgcHJvY2Vzc2luZyBncmFwaCBkb2Vzbid0IG9wdGltaXplIG91dCB0aGlzXG5cdFx0ICogIHNlZ21lbnQgb2YgdGhlIGdyYXBoLiBcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyU291cmNlTm9kZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuWmVyby5femVyb3MgPSBudWxsO1xuXHQgICAgLyoqXG5cdFx0ICogIGluaXRpYWxpemVyIGZ1bmN0aW9uXG5cdFx0ICovXG5cdCAgICBUb25lLl9pbml0QXVkaW9Db250ZXh0KGZ1bmN0aW9uIChhdWRpb0NvbnRleHQpIHtcblx0ICAgICAgICB2YXIgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxMjgsIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcblx0ICAgICAgICB2YXIgYXJyID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGFycltpXSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuWmVyby5femVyb3MgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdCAgICAgICAgVG9uZS5aZXJvLl96ZXJvcy5jaGFubmVsQ291bnQgPSAxO1xuXHQgICAgICAgIFRvbmUuWmVyby5femVyb3MuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgVG9uZS5aZXJvLl96ZXJvcy5idWZmZXIgPSBidWZmZXI7XG5cdCAgICAgICAgVG9uZS5aZXJvLl96ZXJvcy5sb29wID0gdHJ1ZTtcblx0ICAgICAgICBUb25lLlplcm8uX3plcm9zLnN0YXJ0KDApO1xuXHQgICAgICAgIFRvbmUuWmVyby5femVyb3Mubm9HQygpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gVG9uZS5aZXJvO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIExGTyBzdGFuZHMgZm9yIGxvdyBmcmVxdWVuY3kgb3NjaWxsYXRvci4gVG9uZS5MRk8gcHJvZHVjZXMgYW4gb3V0cHV0IHNpZ25hbCBcblx0XHQgKiAgICAgICAgICB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gQXVkaW9QYXJhbSBvciBUb25lLlNpZ25hbCBcblx0XHQgKiAgICAgICAgICBpbiBvcmRlciB0byBtb2R1bGF0ZSB0aGF0IHBhcmFtZXRlciB3aXRoIGFuIG9zY2lsbGF0b3IuIFRoZSBMRk8gY2FuIFxuXHRcdCAqICAgICAgICAgIGFsc28gYmUgc3luY2VkIHRvIHRoZSB0cmFuc3BvcnQgdG8gc3RhcnQvc3RvcCBhbmQgY2hhbmdlIHdoZW4gdGhlIHRlbXBvIGNoYW5nZXMuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRpb24uIFR5cGljYWxseSwgTEZPcyB3aWxsIGJlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGZyZXF1ZW5jeSByYW5nZSBvZiAwLjEgdG8gMTAgaGVydHouIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IG1pbiBUaGUgbWluaW11bSBvdXRwdXQgdmFsdWUgb2YgdGhlIExGTy4gXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBMRk8uIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBsZm8gPSBuZXcgVG9uZS5MRk8oXCI0blwiLCA0MDAsIDQwMDApO1xuXHRcdCAqIGxmby5jb25uZWN0KGZpbHRlci5mcmVxdWVuY3kpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbWluJyxcblx0ICAgICAgICAgICAgJ21heCdcblx0ICAgICAgICBdLCBUb25lLkxGTy5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yLiBcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcih7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ3R5cGUnOiBvcHRpb25zLnR5cGVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGZvJ3MgZnJlcXVlbmN5XG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX29zY2lsbGF0b3IuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGFtcGxpdHVkZSBvZiB0aGUgTEZPLCB3aGljaCBjb250cm9scyB0aGUgb3V0cHV0IHJhbmdlIGJldHdlZW5cblx0XHRcdCAqIHRoZSBtaW4gYW5kIG1heCBvdXRwdXQuIEZvciBleGFtcGxlIGlmIHRoZSBtaW4gaXMgLTEwIGFuZCB0aGUgbWF4IFxuXHRcdFx0ICogaXMgMTAsIHNldHRpbmcgdGhlIGFtcGxpdHVkZSB0byAwLjUgd291bGQgbWFrZSB0aGUgTEZPIG1vZHVsYXRlXG5cdFx0XHQgKiBiZXR3ZWVuIC01IGFuZCA1LiBcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmFtcGxpdHVkZSA9IHRoaXMuX29zY2lsbGF0b3Iudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlLnVuaXRzID0gVG9uZS5UeXBlLk5vcm1hbFJhbmdlO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlLnZhbHVlID0gb3B0aW9ucy5hbXBsaXR1ZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZ25hbCB3aGljaCBpcyBvdXRwdXQgd2hlbiB0aGUgTEZPIGlzIHN0b3BwZWRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKDAsIFRvbmUuVHlwZS5BdWRpb1JhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBKdXN0IG91dHB1dHMgemVyb3MuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuWmVyb31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5femVyb3MgPSBuZXcgVG9uZS5aZXJvKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlIHRoYXQgdGhlIExGTyBvdXRwdXRzIHdoZW4gaXQncyBzdG9wcGVkXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvUmFuZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRWYWx1ZSA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQXVkaW9Ub0dhaW59IFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hMmcgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNjYWxlfSBcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGVyID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5TY2FsZShvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB1bml0cyBvZiB0aGUgTEZPICh1c2VkIGZvciBjb252ZXJ0aW5nKVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlR5cGV9IFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl91bml0cyA9IFRvbmUuVHlwZS5EZWZhdWx0O1xuXHQgICAgICAgIHRoaXMudW5pdHMgPSBvcHRpb25zLnVuaXRzO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuY2hhaW4odGhpcy5fYTJnLCB0aGlzLl9zY2FsZXIpO1xuXHQgICAgICAgIHRoaXMuX3plcm9zLmNvbm5lY3QodGhpcy5fYTJnKTtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLmNvbm5lY3QodGhpcy5fYTJnKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdhbXBsaXR1ZGUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTEZPLCBUb25lLk9zY2lsbGF0b3IpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgJ21heCc6IDEsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnZnJlcXVlbmN5JzogJzRuJyxcblx0ICAgICAgICAnYW1wbGl0dWRlJzogMSxcblx0ICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRGVmYXVsdFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgTEZPLiBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgTEZPIHdpbGwgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIExGTy4gXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIExGTyB3aWxsIHN0b3Bcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwuc2V0VmFsdWVBdFRpbWUodGhpcy5fc3RvcHBlZFZhbHVlLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN5bmMgdGhlIHN0YXJ0L3N0b3AvcGF1c2UgdG8gdGhlIHRyYW5zcG9ydCBcblx0XHQgKiAgYW5kIHRoZSBmcmVxdWVuY3kgdG8gdGhlIGJwbSBvZiB0aGUgdHJhbnNwb3J0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxGT30gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICBsZm8uZnJlcXVlbmN5LnZhbHVlID0gXCI4blwiO1xuXHRcdCAqICBsZm8uc3luYygpLnN0YXJ0KDApXG5cdFx0ICogIC8vdGhlIHJhdGUgb2YgdGhlIExGTyB3aWxsIGFsd2F5cyBiZSBhbiBlaWdodGggbm90ZSwgXG5cdFx0ICogIC8vZXZlbiBhcyB0aGUgdGVtcG8gY2hhbmdlc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zeW5jKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zeW5jRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHVuc3luYyB0aGUgTEZPIGZyb20gdHJhbnNwb3J0IGNvbnRyb2xcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudW5zeW5jKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci51bnN5bmNGcmVxdWVuY3koKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWluaXVtdW0gb3V0cHV0IG9mIHRoZSBMRk8uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTEZPI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9Vbml0cyh0aGlzLl9zY2FsZXIubWluKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICBtaW4gPSB0aGlzLl9mcm9tVW5pdHMobWluKTtcblx0ICAgICAgICAgICAgdGhpcy5fc2NhbGVyLm1pbiA9IG1pbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIG91dHB1dCBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1heFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ21heCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvVW5pdHModGhpcy5fc2NhbGVyLm1heCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXgpIHtcblx0ICAgICAgICAgICAgbWF4ID0gdGhpcy5fZnJvbVVuaXRzKG1heCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlci5tYXggPSBtYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvcjogc2luZSwgc3F1YXJlLCBzYXd0b290aCwgdHJpYW5nbGUuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci50eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkVmFsdWUgPSB0aGlzLl9vc2NpbGxhdG9yLl9nZXRJbml0aWFsVmFsdWUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC52YWx1ZSA9IHRoaXMuX3N0b3BwZWRWYWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkVmFsdWUgPSB0aGlzLl9vc2NpbGxhdG9yLl9nZXRJbml0aWFsVmFsdWUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC52YWx1ZSA9IHRoaXMuX3N0b3BwZWRWYWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvdXRwdXQgdW5pdHMgb2YgdGhlIExGTy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5MRk8jXG5cdFx0ICogQHR5cGUge1RvbmUuVHlwZX1cblx0XHQgKiBAbmFtZSB1bml0c1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ3VuaXRzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5pdHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRNaW4gPSB0aGlzLm1pbjtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRNYXggPSB0aGlzLm1heDtcblx0ICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBtaW4gYW5kIHRoZSBtYXhcblx0ICAgICAgICAgICAgdGhpcy5fdW5pdHMgPSB2YWw7XG5cdCAgICAgICAgICAgIHRoaXMubWluID0gY3VycmVudE1pbjtcblx0ICAgICAgICAgICAgdGhpcy5tYXggPSBjdXJyZW50TWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5MRk8jXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiIG9yIFwic3RvcHBlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3Iuc3RhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoZSBMRk8gdG8gYW4gQXVkaW9QYXJhbSwgQXVkaW9Ob2RlLCBvciBUb25lIE5vZGUuIFxuXHRcdCAqICBUb25lLkxGTyB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCB0byB0aGUgZGVzdGluYXRpb24gdW5pdHMgb2YgdGhlIFxuXHRcdCAqICB3aWxsIGdldCB0aGUgdW5pdHMgZnJvbSB0aGUgY29ubmVjdGVkIG5vZGUuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUgfCBBdWRpb1BhcmFtIHwgQXVkaW9Ob2RlfSBub2RlIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE51bT0wXSBvcHRpb25hbGx5IHdoaWNoIG91dHB1dCB0byBjb25uZWN0IGZyb21cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bT0wXSBvcHRpb25hbGx5IHdoaWNoIGlucHV0IHRvIGNvbm5lY3QgdG9cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT09IFRvbmUuU2lnbmFsIHx8IG5vZGUuY29uc3RydWN0b3IgPT09IFRvbmUuUGFyYW0gfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbCkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnZlcnQgPSBub2RlLmNvbnZlcnQ7XG5cdCAgICAgICAgICAgIHRoaXMudW5pdHMgPSBub2RlLnVuaXRzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUb25lLlNpZ25hbC5wcm90b3R5cGUuY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBwcml2YXRlIG1ldGhvZCBib3Jyb3dlZCBmcm9tIFBhcmFtIGNvbnZlcnRzIFxuXHRcdCAqICB1bml0cyBmcm9tIHRoZWlyIGRlc3RpbmF0aW9uIHZhbHVlXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLl9mcm9tVW5pdHMgPSBUb25lLlBhcmFtLnByb3RvdHlwZS5fZnJvbVVuaXRzO1xuXHQgICAgLyoqXG5cdFx0ICogIHByaXZhdGUgbWV0aG9kIGJvcnJvd2VkIGZyb20gUGFyYW0gY29udmVydHMgXG5cdFx0ICogIHVuaXRzIHRvIHRoZWlyIGRlc3RpbmF0aW9uIHZhbHVlXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLl90b1VuaXRzID0gVG9uZS5QYXJhbS5wcm90b3R5cGUuX3RvVW5pdHM7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzY29ubmVjdCBhbmQgZGlzcG9zZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MRk99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdhbXBsaXR1ZGUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3plcm9zLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl96ZXJvcyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2EyZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYTJnID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5hbXBsaXR1ZGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxGTztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTGltaXRlciB3aWxsIGxpbWl0IHRoZSBsb3VkbmVzcyBvZiBhbiBpbmNvbWluZyBzaWduYWwuIFxuXHRcdCAqICAgICAgICAgSXQgaXMgY29tcG9zZWQgb2YgYSBUb25lLkNvbXByZXNzb3Igd2l0aCBhIGZhc3QgYXR0YWNrIFxuXHRcdCAqICAgICAgICAgYW5kIHJlbGVhc2UuIExpbWl0ZXJzIGFyZSBjb21tb25seSB1c2VkIHRvIHNhZmVndWFyZCBhZ2FpbnN0IFxuXHRcdCAqICAgICAgICAgc2lnbmFsIGNsaXBwaW5nLiBVbmxpa2UgYSBjb21wcmVzc29yLCBsaW1pdGVycyBkbyBub3QgcHJvdmlkZSBcblx0XHQgKiAgICAgICAgIHNtb290aCBnYWluIHJlZHVjdGlvbiBhbmQgYWxtb3N0IGNvbXBsZXRlbHkgcHJldmVudCBcblx0XHQgKiAgICAgICAgIGFkZGl0aW9uYWwgZ2FpbiBhYm92ZSB0aGUgdGhyZXNob2xkLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBUaGUgdGhlc2hvbGQgYWJvdmUgd2hpY2ggdGhlIGxpbWl0aW5nIGlzIGFwcGxpZWQuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgbGltaXRlciA9IG5ldyBUb25lLkxpbWl0ZXIoLTYpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MaW1pdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWyd0aHJlc2hvbGQnXSwgVG9uZS5MaW1pdGVyLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgY29tcHJlc3NvclxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Db21wcmVzc29yKHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDAxLFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjAwMSxcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCc6IG9wdGlvbnMudGhyZXNob2xkXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdGhyZXNob2xkIG9mIG9mIHRoZSBsaW1pdGVyXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbH1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudGhyZXNob2xkID0gdGhpcy5fY29tcHJlc3Nvci50aHJlc2hvbGQ7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3RocmVzaG9sZCcpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTGltaXRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGltaXRlci5kZWZhdWx0cyA9IHsgJ3RocmVzaG9sZCc6IC0xMiB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MaW1pdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxpbWl0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2NvbXByZXNzb3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCd0aHJlc2hvbGQnKTtcblx0ICAgICAgICB0aGlzLnRocmVzaG9sZCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTGltaXRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTG93cGFzcyBpcyBhIGxvd3Bhc3MgZmVlZGJhY2sgY29tYiBmaWx0ZXIuIEl0IGlzIHNpbWlsYXIgdG8gXG5cdFx0ICogICAgICAgICBUb25lLkZlZWRiYWNrQ29tYkZpbHRlciwgYnV0IGluY2x1ZGVzIGEgbG93cGFzcyBmaWx0ZXIuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbZGVsYXlUaW1lXSBUaGUgZGVsYXkgdGltZSBvZiB0aGUgY29tYiBmaWx0ZXJcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZT19IHJlc29uYW5jZSBUaGUgcmVzb25hbmNlIChmZWVkYmFjaykgb2YgdGhlIGNvbWIgZmlsdGVyXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5PX0gZGFtcGVuaW5nIFRoZSBjdXRvZmYgb2YgdGhlIGxvd3Bhc3MgZmlsdGVyIGRhbXBlbnMgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCBhcyBpdCBpcyBmZWRiYWNrLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDEpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSwgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlci5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRlbGF5IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7RGVsYXlOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheSA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5EZWxheShvcHRpb25zLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5VGltZSBvZiB0aGUgY29tYiBmaWx0ZXIuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gdGhpcy5fZGVsYXkuZGVsYXlUaW1lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsb3dwYXNzIGZpbHRlclxuXHRcdFx0ICogIEB0eXBlICB7QmlxdWFkRmlsdGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG93cGFzcyA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgIHRoaXMuX2xvd3Bhc3MuUS52YWx1ZSA9IC0zLjAxMDI5OTk1NjYzOTgxMjU7XG5cdCAgICAgICAgdGhpcy5fbG93cGFzcy50eXBlID0gJ2xvd3Bhc3MnO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkYW1wZW5pbmcgY29udHJvbCBvZiB0aGUgZmVlZGJhY2tcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGFtcGVuaW5nID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9sb3dwYXNzLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5kYW1wZW5pbmdcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZmVlZGJhY2sgZ2FpblxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLnJlc29uYW5jZSwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGZlZWRiYWNrIG9mIHRoZSBkZWxheWVkIHNpZ25hbC4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gdGhpcy5fZmVlZGJhY2suZ2Fpbjtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fZGVsYXkuY2hhaW4odGhpcy5fbG93cGFzcywgdGhpcy5fZmVlZGJhY2ssIHRoaXMuX2RlbGF5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnLFxuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkxvd3Bhc3NDb21iRmlsdGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkxvd3Bhc3NDb21iRmlsdGVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdkZWxheVRpbWUnOiAwLjEsXG5cdCAgICAgICAgJ3Jlc29uYW5jZSc6IDAuNSxcblx0ICAgICAgICAnZGFtcGVuaW5nJzogMzAwMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxvd3Bhc3NDb21iRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvd3Bhc3NDb21iRmlsdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnLFxuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmRhbXBlbmluZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbG93cGFzcy5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fbG93cGFzcyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2suZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Mb3dwYXNzQ29tYkZpbHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLk1lcmdlIGJyaW5ncyB0d28gc2lnbmFscyBpbnRvIHRoZSBsZWZ0IGFuZCByaWdodCBcblx0XHQgKiAgICAgICAgICBjaGFubmVscyBvZiBhIHNpbmdsZSBzdGVyZW8gY2hhbm5lbC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG1lcmdlID0gbmV3IFRvbmUuTWVyZ2UoKS50b01hc3RlcigpO1xuXHRcdCAqIC8vcm91dGluZyBhIHNpbmUgdG9uZSBpbiB0aGUgbGVmdCBjaGFubmVsXG5cdFx0ICogLy9hbmQgbm9pc2UgaW4gdGhlIHJpZ2h0IGNoYW5uZWxcblx0XHQgKiB2YXIgb3NjID0gbmV3IFRvbmUuT3NjaWxsYXRvcigpLmNvbm5lY3QobWVyZ2UubGVmdCk7XG5cdFx0ICogdmFyIG5vaXNlID0gbmV3IFRvbmUuTm9pc2UoKS5jb25uZWN0KG1lcmdlLnJpZ2h0KTtcblx0XHQgKiAvL3N0YXJ0aW5nIG91ciBvc2NpbGxhdG9yc1xuXHRcdCAqIG5vaXNlLnN0YXJ0KCk7XG5cdFx0ICogb3NjLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1lcmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbGVmdCBpbnB1dCBjaGFubmVsLlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLmlucHV0WzBdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByaWdodCBpbnB1dCBjaGFubmVsLlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5pbnB1dFsxXTwvY29kZT4uXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMuaW5wdXRbMV0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1lcmdlciBub2RlIGZvciB0aGUgdHdvIGNoYW5uZWxzXG5cdFx0XHQgKiAgQHR5cGUge0NoYW5uZWxNZXJnZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tZXJnZXIgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmxlZnQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuXHQgICAgICAgIHRoaXMucmlnaHQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMubGVmdC5jaGFubmVsQ291bnQgPSAxO1xuXHQgICAgICAgIHRoaXMucmlnaHQuY2hhbm5lbENvdW50ID0gMTtcblx0ICAgICAgICB0aGlzLmxlZnQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgdGhpcy5yaWdodC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1lcmdlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWVyZ2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVyZ2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMubGVmdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tZXJnZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWVyZ2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5NZXRlciBnZXRzIHRoZSBbUk1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb290X21lYW5fc3F1YXJlKVxuXHRcdCAqICAgICAgICAgIG9mIGFuIGlucHV0IHNpZ25hbCB3aXRoIHNvbWUgYXZlcmFnaW5nIGFwcGxpZWQuIEl0IGNhbiBhbHNvIGdldCB0aGUgcmF3IFxuXHRcdCAqICAgICAgICAgIHZhbHVlIG9mIHRoZSBpbnB1dCBzaWduYWwuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBFaXRoZXIgXCJsZXZlbFwiIG9yIFwic2lnbmFsXCIuIFxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gc21vb3RoaW5nIFRoZSBhbW91bnQgb2Ygc21vb3RoaW5nIGFwcGxpZWQgYmV0d2VlbiBmcmFtZXMuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG1ldGVyID0gbmV3IFRvbmUuTWV0ZXIoKTtcblx0XHQgKiB2YXIgbWljID0gbmV3IFRvbmUuVXNlck1lZGlhKCkuc3RhcnQoKTtcblx0XHQgKiAvL2Nvbm5lY3QgbWljIHRvIHRoZSBtZXRlclxuXHRcdCAqIG1pYy5jb25uZWN0KG1ldGVyKTtcblx0XHQgKiAvL3RoZSBjdXJyZW50IGxldmVsIG9mIHRoZSBtaWMgaW5wdXRcblx0XHQgKiB2YXIgbGV2ZWwgPSBtZXRlci52YWx1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ3Ntb290aGluZydcblx0ICAgICAgICBdLCBUb25lLk1ldGVyLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHlwZSBvZiB0aGUgbWV0ZXIsIGVpdGhlciBcImxldmVsXCIgb3IgXCJzaWduYWxcIi4gXG5cdFx0XHQgKiAgQSBcImxldmVsXCIgbWV0ZXIgd2lsbCByZXR1cm4gdGhlIHZvbHVtZSBsZXZlbCAocm1zKSBvZiB0aGUgXG5cdFx0XHQgKiAgaW5wdXQgc2lnbmFsIGFuZCBhIFwic2lnbmFsXCIgbWV0ZXIgd2lsbCByZXR1cm5cblx0XHRcdCAqICB0aGUgc2lnbmFsIHZhbHVlIG9mIHRoZSBpbnB1dC4gXG5cdFx0XHQgKiAgQHR5cGUgIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFuYWx5c2VyIG5vZGUgd2hpY2ggY29tcHV0ZXMgdGhlIGxldmVscy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5BbmFseXNlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuX2FuYWx5c2VyID0gbmV3IFRvbmUuQW5hbHlzZXIoJ3dhdmVmb3JtJywgNTEyKTtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlci5yZXR1cm5UeXBlID0gJ2Zsb2F0Jztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGNhcnJ5b3ZlciBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCBsYXN0IGZyYW1lLiBcblx0XHRcdCAqICBPbmx5IGFwcGxpZWQgbWV0ZXIgZm9yIFwibGV2ZWxcIiB0eXBlLlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zbW9vdGhpbmcgPSBvcHRpb25zLnNtb290aGluZztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbGFzdCBjb21wdXRlZCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xhc3RWYWx1ZSA9IDA7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZXRlcik7XG5cdCAgICAvKipcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQGVudW0ge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0ZXIuVHlwZSA9IHtcblx0ICAgICAgICBMZXZlbDogJ2xldmVsJyxcblx0ICAgICAgICBTaWduYWw6ICdzaWduYWwnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnc21vb3RoaW5nJzogMC44LFxuXHQgICAgICAgICd0eXBlJzogVG9uZS5NZXRlci5UeXBlLkxldmVsXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG1ldGVyLiBBIHZhbHVlIG9mIDEgaXNcblx0XHQgKiBcInVuaXR5XCIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTWV0ZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0ZXIucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduYWwgPSB0aGlzLl9hbmFseXNlci5hbmFseXNlKCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFRvbmUuTWV0ZXIuVHlwZS5MZXZlbCkge1xuXHQgICAgICAgICAgICAgICAgLy9ybXNcblx0ICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYWwubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdW0gKz0gTWF0aC5wb3coc2lnbmFsW2ldLCAyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBybXMgPSBNYXRoLnNxcnQoc3VtIC8gc2lnbmFsLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICAvL3Ntb290aCBpdFxuXHQgICAgICAgICAgICAgICAgcm1zID0gTWF0aC5tYXgocm1zLCB0aGlzLl9sYXN0VmFsdWUgKiB0aGlzLnNtb290aGluZyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSBybXM7XG5cdCAgICAgICAgICAgICAgICAvL3NjYWxlIGl0XG5cdCAgICAgICAgICAgICAgICB2YXIgdW5pdHkgPSAwLjM1O1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHJtcyAvIHVuaXR5O1xuXHQgICAgICAgICAgICAgICAgLy9zY2FsZSB0aGUgb3V0cHV0IGN1cnZlXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZhbCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsWzBdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1ldGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1ldGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqXHRAY2xhc3MgIFRvbmUuU3BsaXQgc3BsaXRzIGFuIGluY29taW5nIHNpZ25hbCBpbnRvIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxzLlxuXHRcdCAqXHRcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzcGxpdCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdFx0ICogc3RlcmVvU2lnbmFsLmNvbm5lY3Qoc3BsaXQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TcGxpdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMCwgMik7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEB0eXBlIHtDaGFubmVsU3BsaXR0ZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zcGxpdHRlciA9IHRoaXMuaW5wdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBMZWZ0IGNoYW5uZWwgb3V0cHV0LiBcblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+b3V0cHV0WzBdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLm91dHB1dFswXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBSaWdodCBjaGFubmVsIG91dHB1dC5cblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+b3V0cHV0WzFdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5vdXRwdXRbMV0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5sZWZ0LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMucmlnaHQsIDEsIDApO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3BsaXQpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3BsaXR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3BsaXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLmxlZnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubGVmdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yaWdodC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNwbGl0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWlkL1NpZGUgcHJvY2Vzc2luZyBzZXBhcmF0ZXMgdGhlIHRoZSAnbWlkJyBzaWduYWwgXG5cdFx0ICogICAgICAgICAod2hpY2ggY29tZXMgb3V0IG9mIGJvdGggdGhlIGxlZnQgYW5kIHRoZSByaWdodCBjaGFubmVsKSBcblx0XHQgKiAgICAgICAgIGFuZCB0aGUgJ3NpZGUnICh3aGljaCBvbmx5IGNvbWVzIG91dCBvZiB0aGUgdGhlIHNpZGUgY2hhbm5lbHMpLiA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgPGNvZGU+XG5cdFx0ICogICAgICAgICBNaWQgPSAoTGVmdCtSaWdodCkvc3FydCgyKTsgICAvLyBvYnRhaW4gbWlkLXNpZ25hbCBmcm9tIGxlZnQgYW5kIHJpZ2h0PGJyPlxuXHRcdCAqICAgICAgICAgU2lkZSA9IChMZWZ0LVJpZ2h0KS9zcXJ0KDIpOyAgIC8vIG9idGFpbiBzaWRlLXNpZ25hbCBmcm9tIGxlZnQgYW5kIHJpZ2g8YnI+XG5cdFx0ICogICAgICAgICA8L2NvZGU+XG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlU3BsaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDAsIDIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNwbGl0IHRoZSBpbmNvbWluZyBzaWduYWwgaW50byBsZWZ0IGFuZCByaWdodCBjaGFubmVsc1xuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5TcGxpdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3BsaXQgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuU3BsaXQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkIHNlbmQuIENvbm5lY3QgdG8gbWlkIHByb2Nlc3NpbmcuIEFsaWFzIGZvclxuXHRcdFx0ICogIDxjb2RlPm91dHB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWQgPSB0aGlzLm91dHB1dFswXSA9IG5ldyBUb25lLkV4cHIoJygkMCArICQxKSAqICQyJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZGUgb3V0cHV0LiBDb25uZWN0IHRvIHNpZGUgcHJvY2Vzc2luZy4gQWxpYXMgZm9yXG5cdFx0XHQgKiAgPGNvZGU+b3V0cHV0WzFdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLm91dHB1dFsxXSA9IG5ldyBUb25lLkV4cHIoJygkMCAtICQxKSAqICQyJyk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuY29ubmVjdCh0aGlzLm1pZCwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuY29ubmVjdCh0aGlzLm1pZCwgMSwgMSk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuY29ubmVjdCh0aGlzLnNpZGUsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5zaWRlLCAxLCAxKTtcblx0ICAgICAgICBzcXJ0VHdvLmNvbm5lY3QodGhpcy5taWQsIDAsIDIpO1xuXHQgICAgICAgIHNxcnRUd28uY29ubmVjdCh0aGlzLnNpZGUsIDAsIDIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWlkU2lkZVNwbGl0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBhIGNvbnN0YW50IHNpZ25hbCBlcXVhbCB0byAxIC8gc3FydCgyKVxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIHZhciBzcXJ0VHdvID0gbnVsbDtcblx0ICAgIFRvbmUuX2luaXRBdWRpb0NvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHNxcnRUd28gPSBuZXcgVG9uZS5TaWduYWwoMSAvIE1hdGguc3FydCgyKSk7XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NaWRTaWRlU3BsaXR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZVNwbGl0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLm1pZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5taWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuc2lkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5zaWRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zcGxpdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1pZFNpZGVTcGxpdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIE1pZC9TaWRlIHByb2Nlc3Npbmcgc2VwYXJhdGVzIHRoZSB0aGUgJ21pZCcgc2lnbmFsIFxuXHRcdCAqICAgICAgICAgKHdoaWNoIGNvbWVzIG91dCBvZiBib3RoIHRoZSBsZWZ0IGFuZCB0aGUgcmlnaHQgY2hhbm5lbCkgXG5cdFx0ICogICAgICAgICBhbmQgdGhlICdzaWRlJyAod2hpY2ggb25seSBjb21lcyBvdXQgb2YgdGhlIHRoZSBzaWRlIGNoYW5uZWxzKS4gXG5cdFx0ICogICAgICAgICBNaWRTaWRlTWVyZ2UgbWVyZ2VzIHRoZSBtaWQgYW5kIHNpZGUgc2lnbmFsIGFmdGVyIHRoZXkndmUgYmVlbiBzZXBlcmF0ZWRcblx0XHQgKiAgICAgICAgIGJ5IFRvbmUuTWlkU2lkZVNwbGl0Ljxicj48YnI+XG5cdFx0ICogICAgICAgICA8Y29kZT5cblx0XHQgKiAgICAgICAgIExlZnQgPSAoTWlkK1NpZGUpL3NxcnQoMik7ICAgLy8gb2J0YWluIGxlZnQgc2lnbmFsIGZyb20gbWlkIGFuZCBzaWRlPGJyPlxuXHRcdCAqICAgICAgICAgUmlnaHQgPSAoTWlkLVNpZGUpL3NxcnQoMik7ICAgLy8gb2J0YWluIHJpZ2h0IHNpZ25hbCBmcm9tIG1pZCBhbmQgc2lkZTxicj5cblx0XHQgKiAgICAgICAgIDwvY29kZT5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TdGVyZW9FZmZlY3R9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlTWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQgc2lnbmFsIGlucHV0LiBBbGlhcyBmb3Jcblx0XHRcdCAqICA8Y29kZT5pbnB1dFswXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gdGhpcy5pbnB1dFswXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICByZWNvbWJpbmUgdGhlIG1pZC9zaWRlIGludG8gTGVmdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xlZnQgPSBuZXcgVG9uZS5FeHByKCcoJDAgKyAkMSkgKiAkMicpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzaWRlIHNpZ25hbCBpbnB1dC4gQWxpYXMgZm9yXG5cdFx0XHQgKiAgPGNvZGU+aW5wdXRbMV08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHJlY29tYmluZSB0aGUgbWlkL3NpZGUgaW50byBSaWdodFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0ID0gbmV3IFRvbmUuRXhwcignKCQwIC0gJDEpICogJDInKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBNZXJnZSB0aGUgbGVmdC9yaWdodCBzaWduYWwgYmFjayBpbnRvIGEgc3RlcmVvIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1lcmdlKCk7XG5cdCAgICAgICAgdGhpcy5taWQuY29ubmVjdCh0aGlzLl9sZWZ0LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLnNpZGUuY29ubmVjdCh0aGlzLl9sZWZ0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLm1pZC5jb25uZWN0KHRoaXMuX3JpZ2h0LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLnNpZGUuY29ubmVjdCh0aGlzLl9yaWdodCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5fbGVmdC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9yaWdodC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAxKTtcblx0ICAgICAgICBzcXJ0VHdvLmNvbm5lY3QodGhpcy5fbGVmdCwgMCwgMik7XG5cdCAgICAgICAgc3FydFR3by5jb25uZWN0KHRoaXMuX3JpZ2h0LCAwLCAyKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1pZFNpZGVNZXJnZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQSBjb25zdGFudCBzaWduYWwgZXF1YWwgdG8gMSAvIHNxcnQoMikuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBzaWduYWxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgdmFyIHNxcnRUd28gPSBudWxsO1xuXHQgICAgVG9uZS5faW5pdEF1ZGlvQ29udGV4dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgc3FydFR3byA9IG5ldyBUb25lLlNpZ25hbCgxIC8gTWF0aC5zcXJ0KDIpKTtcblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1pZFNpZGVNZXJnZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlTWVyZ2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnNpZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xlZnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWVyZ2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NaWRTaWRlTWVyZ2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk1pZFNpZGVDb21wcmVzc29yIGFwcGxpZXMgdHdvIGRpZmZlcmVudCBjb21wcmVzc29ycyB0byB0aGUgbWlkXG5cdFx0ICogICAgICAgICBhbmQgc2lkZSBzaWduYWwgY29tcG9uZW50cy4gU2VlIFRvbmUuTWlkU2lkZVNwbGl0LiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtaWQgYW5kIHNpZGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NvcnMuIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUNvbXByZXNzb3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5NaWRTaWRlQ29tcHJlc3Nvci5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1pZC9zaWRlIHNwbGl0XG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk1pZFNpZGVTcGxpdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk1pZFNpZGVTcGxpdCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtaWQvc2lkZSByZWNvbWJpbmF0aW9uXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk1pZFNpZGVNZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NaWRTaWRlTWVyZ2UoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY29tcHJlc3NvciBhcHBsaWVkIHRvIHRoZSBtaWQgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkNvbXByZXNzb3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZCA9IG5ldyBUb25lLkNvbXByZXNzb3Iob3B0aW9ucy5taWQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjb21wcmVzc29yIGFwcGxpZWQgdG8gdGhlIHNpZGUgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkNvbXByZXNzb3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGUgPSBuZXcgVG9uZS5Db21wcmVzc29yKG9wdGlvbnMuc2lkZSk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0Lm1pZC5jaGFpbih0aGlzLm1pZCwgdGhpcy5fbWlkU2lkZU1lcmdlLm1pZCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0LnNpZGUuY2hhaW4odGhpcy5zaWRlLCB0aGlzLl9taWRTaWRlTWVyZ2Uuc2lkZSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ3NpZGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NaWRTaWRlQ29tcHJlc3Nvcik7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUNvbXByZXNzb3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21pZCc6IHtcblx0ICAgICAgICAgICAgJ3JhdGlvJzogMyxcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCc6IC0yNCxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjAzLFxuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMixcblx0ICAgICAgICAgICAgJ2tuZWUnOiAxNlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3NpZGUnOiB7XG5cdCAgICAgICAgICAgICdyYXRpbyc6IDYsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnOiAtMzAsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC4yNSxcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDMsXG5cdCAgICAgICAgICAgICdrbmVlJzogMTBcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NaWRTaWRlQ29tcHJlc3Nvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlQ29tcHJlc3Nvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ3NpZGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5taWQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnNpZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuc2lkZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NaWRTaWRlQ29tcHJlc3Nvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTW9ubyBjb2VyY2VzIHRoZSBpbmNvbWluZyBtb25vIG9yIHN0ZXJlbyBzaWduYWwgaW50byBhIG1vbm8gc2lnbmFsXG5cdFx0ICogICAgICAgICB3aGVyZSBib3RoIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxzIGhhdmUgdGhlIHNhbWUgdmFsdWUuIFRoaXMgY2FuIGJlIHVzZWZ1bCBcblx0XHQgKiAgICAgICAgIGZvciBbc3RlcmVvIGltYWdpbmddKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0ZXJlb19pbWFnaW5nKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIG1lcmdlIHRoZSBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1lcmdlKCk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fbWVyZ2UsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IHRoaXMuZGJUb0dhaW4oLTEwKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1vbm8pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9uby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbWVyZ2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Nb25vO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSBjb21wcmVzc29yIHdpdGggc2VwZXJhdGUgY29udHJvbHMgb3ZlciBsb3cvbWlkL2hpZ2ggZHluYW1pY3Ncblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBsb3cvbWlkL2hpZ2ggY29tcHJlc3NvciBzZXR0aW5ncy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIG11bHRpYmFuZCA9IG5ldyBUb25lLk11bHRpYmFuZENvbXByZXNzb3Ioe1xuXHRcdCAqICBcdFwibG93RnJlcXVlbmN5XCIgOiAyMDAsXG5cdFx0ICogIFx0XCJoaWdoRnJlcXVlbmN5XCIgOiAxMzAwXG5cdFx0ICogIFx0XCJsb3dcIiA6IHtcblx0XHQgKiAgXHRcdFwidGhyZXNob2xkXCIgOiAtMTJcblx0XHQgKiAgXHR9XG5cdFx0ICogIH0pXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZENvbXByZXNzb3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRBcmcoYXJndW1lbnRzLCBUb25lLk11bHRpYmFuZENvbXByZXNzb3IuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNwbGl0IHRoZSBpbmNvbWluZyBzaWduYWwgaW50byBoaWdoL21pZC9sb3dcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aWJhbmRTcGxpdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuTXVsdGliYW5kU3BsaXQoe1xuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5Jzogb3B0aW9ucy5sb3dGcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5Jzogb3B0aW9ucy5oaWdoRnJlcXVlbmN5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbG93L21pZCBjcm9zc292ZXIgZnJlcXVlbmN5LlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kgPSB0aGlzLl9zcGxpdHRlci5sb3dGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbWlkL2hpZ2ggY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IHRoaXMuX3NwbGl0dGVyLmhpZ2hGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG91dHB1dFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjb21wcmVzc29yIGFwcGxpZWQgdG8gdGhlIGxvdyBmcmVxdWVuY2llcy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3cgPSBuZXcgVG9uZS5Db21wcmVzc29yKG9wdGlvbnMubG93KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY29tcHJlc3NvciBhcHBsaWVkIHRvIHRoZSBtaWQgZnJlcXVlbmNpZXMuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLm1pZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNvbXByZXNzb3IgYXBwbGllZCB0byB0aGUgaGlnaCBmcmVxdWVuY2llcy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oaWdoID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLmhpZ2gpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgY29tcHJlc3NvclxuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmxvdy5jaGFpbih0aGlzLmxvdywgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLm1pZC5jaGFpbih0aGlzLm1pZCwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmhpZ2guY2hhaW4odGhpcy5oaWdoLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTXVsdGliYW5kQ29tcHJlc3Nvcik7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGliYW5kQ29tcHJlc3Nvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbG93JzogVG9uZS5Db21wcmVzc29yLmRlZmF1bHRzLFxuXHQgICAgICAgICdtaWQnOiBUb25lLkNvbXByZXNzb3IuZGVmYXVsdHMsXG5cdCAgICAgICAgJ2hpZ2gnOiBUb25lLkNvbXByZXNzb3IuZGVmYXVsdHMsXG5cdCAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IDI1MCxcblx0ICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IDIwMDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTXVsdGliYW5kQ29tcHJlc3Nvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRDb21wcmVzc29yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMubG93LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oaWdoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3cgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2ggPSBudWxsO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpYmFuZENvbXByZXNzb3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5QYW5uZXIgaXMgYW4gZXF1YWwgcG93ZXIgTGVmdC9SaWdodCBQYW5uZXIgYW5kIGRvZXMgbm90XG5cdFx0ICogICAgICAgICAgc3VwcG9ydCAzRC4gUGFubmVyIHVzZXMgdGhlIFN0ZXJlb1Bhbm5lck5vZGUgd2hlbiBhdmFpbGFibGUuIFxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbaW5pdGlhbFBhbj0wXSBUaGUgaW5pdGFpbCBwYW5uZXIgdmFsdWUgKGRlZmF1bHRzIHRvIDAgPSBjZW50ZXIpXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIC8vcGFuIHRoZSBpbnB1dCBzaWduYWwgaGFyZCByaWdodC4gXG5cdFx0ICogIHZhciBwYW5uZXIgPSBuZXcgVG9uZS5QYW5uZXIoMSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lciA9IGZ1bmN0aW9uIChpbml0aWFsUGFuKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2hhc1N0ZXJlb1Bhbm5lcikge1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIHRoZSBwYW5uZXIgbm9kZVxuXHRcdFx0XHQgKiAgQHR5cGUge1N0ZXJlb1Bhbm5lck5vZGV9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZVN0ZXJlb1Bhbm5lcigpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBwYW4gY29udHJvbC4gLTEgPSBoYXJkIGxlZnQsIDEgPSBoYXJkIHJpZ2h0LiBcblx0XHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdFx0ICogIEBzaWduYWxcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gdGhpcy5fcGFubmVyLnBhbjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIHRoZSBkcnkvd2V0IGtub2Jcblx0XHRcdFx0ICogIEB0eXBlIHtUb25lLkNyb3NzRmFkZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9jcm9zc0ZhZGUgPSBuZXcgVG9uZS5Dcm9zc0ZhZGUoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1lcmdlKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuU3BsaXR9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuU3BsaXQoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBUaGUgcGFuIGNvbnRyb2wuIC0xID0gaGFyZCBsZWZ0LCAxID0gaGFyZCByaWdodC4gXG5cdFx0XHRcdCAqICBAdHlwZSB7QXVkaW9SYW5nZX1cblx0XHRcdFx0ICogIEBzaWduYWxcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbmV3IFRvbmUuU2lnbmFsKDAsIFRvbmUuVHlwZS5BdWRpb1JhbmdlKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBhbHdheXMgc2VuZHMgMFxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuWmVyb31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl96ZXJvID0gbmV3IFRvbmUuWmVybygpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBhbmFsb2cgdG8gZ2FpbiBjb252ZXJzaW9uXG5cdFx0XHRcdCAqICBAdHlwZSAge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fYTJnID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0ICAgICAgICAgICAgLy9DT05ORUNUSU9OUzpcblx0ICAgICAgICAgICAgdGhpcy5femVyby5jb25uZWN0KHRoaXMuX2EyZyk7XG5cdCAgICAgICAgICAgIHRoaXMucGFuLmNoYWluKHRoaXMuX2EyZywgdGhpcy5fY3Jvc3NGYWRlLmZhZGUpO1xuXHQgICAgICAgICAgICAvL2xlZnQgY2hhbm5lbCBpcyBhLCByaWdodCBjaGFubmVsIGlzIGJcblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUsIDAsIDApO1xuXHQgICAgICAgICAgICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX2Nyb3NzRmFkZSwgMSwgMSk7XG5cdCAgICAgICAgICAgIC8vbWVyZ2UgaXQgYmFjayB0b2dldGhlclxuXHQgICAgICAgICAgICB0aGlzLl9jcm9zc0ZhZGUuYS5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5iLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pbml0aWFsIHZhbHVlXG5cdCAgICAgICAgdGhpcy5wYW4udmFsdWUgPSB0aGlzLmRlZmF1bHRBcmcoaW5pdGlhbFBhbiwgMCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3BhbicpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFubmVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBpbmRpY2F0ZXMgaWYgdGhlIHBhbm5lciBpcyB1c2luZyB0aGUgbmV3IFN0ZXJlb1Bhbm5lck5vZGUgaW50ZXJuYWxseVxuXHRcdCAqICBAdHlwZSAge2Jvb2xlYW59XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lci5wcm90b3R5cGUuX2hhc1N0ZXJlb1Bhbm5lciA9IFRvbmUucHJvdG90eXBlLmlzRnVuY3Rpb24oVG9uZS5jb250ZXh0LmNyZWF0ZVN0ZXJlb1Bhbm5lcik7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhbm5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdwYW4nKTtcblx0ICAgICAgICBpZiAodGhpcy5faGFzU3RlcmVvUGFubmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lciA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl96ZXJvLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5femVybyA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3NwbGl0dGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLnBhbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fYTJnLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fYTJnID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFubmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc3BhdGlhbGl6ZWQgcGFubmVyIG5vZGUgd2hpY2ggc3VwcG9ydHMgZXF1YWxwb3dlciBvciBIUlRGIHBhbm5pbmcuXG5cdFx0ICogICAgICAgICAgVHJpZXMgdG8gbm9ybWFsaXplIHRoZSBBUEkgYWNyb3NzIHZhcmlvdXMgYnJvd3NlcnMuIFNlZSBUb25lLkxpc3RlbmVyXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblggVGhlIGluaXRpYWwgeCBwb3NpdGlvbi5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uWSBUaGUgaW5pdGlhbCB5IHBvc2l0aW9uLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25aIFRoZSBpbml0aWFsIHogcG9zaXRpb24uXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNEID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncG9zaXRpb25YJyxcblx0ICAgICAgICAgICAgJ3Bvc2l0aW9uWScsXG5cdCAgICAgICAgICAgICdwb3NpdGlvblonXG5cdCAgICAgICAgXSwgVG9uZS5QYW5uZXIzRC5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBhbm5lciBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1Bhbm5lck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcblx0ICAgICAgICAvL3NldCBzb21lIHZhbHVlc1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5wYW5uaW5nTW9kZWwgPSBvcHRpb25zLnBhbm5pbmdNb2RlbDtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIubWF4RGlzdGFuY2UgPSBvcHRpb25zLm1heERpc3RhbmNlO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5kaXN0YW5jZU1vZGVsID0gb3B0aW9ucy5kaXN0YW5jZU1vZGVsO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5jb25lT3V0ZXJHYWluID0gb3B0aW9ucy5jb25lT3V0ZXJHYWluO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5jb25lT3V0ZXJBbmdsZSA9IG9wdGlvbnMuY29uZU91dGVyQW5nbGU7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmNvbmVJbm5lckFuZ2xlID0gb3B0aW9ucy5jb25lSW5uZXJBbmdsZTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIucmVmRGlzdGFuY2UgPSBvcHRpb25zLnJlZkRpc3RhbmNlO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5yb2xsb2ZmRmFjdG9yID0gb3B0aW9ucy5yb2xsb2ZmRmFjdG9yO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhvbGRzIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBbXG5cdCAgICAgICAgICAgIG9wdGlvbnMub3JpZW50YXRpb25YLFxuXHQgICAgICAgICAgICBvcHRpb25zLm9yaWVudGF0aW9uWSxcblx0ICAgICAgICAgICAgb3B0aW9ucy5vcmllbnRhdGlvblpcblx0ICAgICAgICBdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhvbGRzIHRoZSBjdXJyZW50IHBvc2l0aW9uXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBbXG5cdCAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb25YLFxuXHQgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uWSxcblx0ICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvblpcblx0ICAgICAgICBdO1xuXHQgICAgICAgIC8vIHNldCB0aGUgZGVmYXVsdCBwb3NpdGlvbi9vcmllbnRhdGlvblxuXHQgICAgICAgIHRoaXMub3JpZW50YXRpb25YID0gb3B0aW9ucy5vcmllbnRhdGlvblg7XG5cdCAgICAgICAgdGhpcy5vcmllbnRhdGlvblkgPSBvcHRpb25zLm9yaWVudGF0aW9uWTtcblx0ICAgICAgICB0aGlzLm9yaWVudGF0aW9uWiA9IG9wdGlvbnMub3JpZW50YXRpb25aO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb25YID0gb3B0aW9ucy5wb3NpdGlvblg7XG5cdCAgICAgICAgdGhpcy5wb3NpdGlvblkgPSBvcHRpb25zLnBvc2l0aW9uWTtcblx0ICAgICAgICB0aGlzLnBvc2l0aW9uWiA9IG9wdGlvbnMucG9zaXRpb25aO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFubmVyM0QpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgRGVmYXVsdHMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdwb3NpdGlvblgnOiAwLFxuXHQgICAgICAgICdwb3NpdGlvblknOiAwLFxuXHQgICAgICAgICdwb3NpdGlvblonOiAwLFxuXHQgICAgICAgICdvcmllbnRhdGlvblgnOiAwLFxuXHQgICAgICAgICdvcmllbnRhdGlvblknOiAwLFxuXHQgICAgICAgICdvcmllbnRhdGlvblonOiAwLFxuXHQgICAgICAgICdwYW5uaW5nTW9kZWwnOiAnZXF1YWxwb3dlcicsXG5cdCAgICAgICAgJ21heERpc3RhbmNlJzogMTAwMDAsXG5cdCAgICAgICAgJ2Rpc3RhbmNlTW9kZWwnOiAnaW52ZXJzZScsXG5cdCAgICAgICAgJ2NvbmVPdXRlckdhaW4nOiAwLFxuXHQgICAgICAgICdjb25lT3V0ZXJBbmdsZSc6IDM2MCxcblx0ICAgICAgICAnY29uZUlubmVyQW5nbGUnOiAzNjAsXG5cdCAgICAgICAgJ3JlZkRpc3RhbmNlJzogMSxcblx0ICAgICAgICAncm9sbG9mZkZhY3Rvcic6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcmFtcCB0aW1lIHdoaWNoIGlzIGFwcGxpZWQgdG8gdGhlIHNldFRhcmdldEF0VGltZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QucHJvdG90eXBlLl9yYW1wVGltZUNvbnN0YW50ID0gMC4wMTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc291cmNlIGluIDNkIHNwYWNlLlx0XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHhcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB6XG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUGFubmVyM0R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHgsIHksIHopIHtcblx0ICAgICAgICBpZiAodGhpcy5fcGFubmVyLnBvc2l0aW9uWCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLnBvc2l0aW9uWC5zZXRUYXJnZXRBdFRpbWUoeCwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLnBvc2l0aW9uWS5zZXRUYXJnZXRBdFRpbWUoeSwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLnBvc2l0aW9uWi5zZXRUYXJnZXRBdFRpbWUoeiwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIuc2V0UG9zaXRpb24oeCwgeSwgeik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0cyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHNvdXJjZSBpbiAzZCBzcGFjZS5cdFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB4XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgelxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBhbm5lcjNEfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblkuc2V0VGFyZ2V0QXRUaW1lKHksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblouc2V0VGFyZ2V0QXRUaW1lKHosIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLnNldE9yaWVudGF0aW9uKHgsIHksIHopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25YXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdwb3NpdGlvblgnLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzBdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvbllcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ3Bvc2l0aW9uWScsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblsxXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeiBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAncG9zaXRpb25aJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblsyXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzJdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB4IG9yaWVudGF0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgb3JpZW50YXRpb25YXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdvcmllbnRhdGlvblgnLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzBdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHkgb3JpZW50YXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBvcmllbnRhdGlvbllcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ29yaWVudGF0aW9uWScsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblsxXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeiBvcmllbnRhdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIG9yaWVudGF0aW9uWlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAnb3JpZW50YXRpb25aJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblsyXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzJdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFByb3h5IGEgcHJvcGVydHkgb24gdGhlIHBhbm5lciB0byBhbiBleHBvc2VkIHB1YmxpYyBwcm9wZXJ5XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHByb3Bcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCkge1xuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgcHJvcCwge1xuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3Bhbm5lcltwcm9wXSA9IHZhbDtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFubmVyW3Byb3BdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwYW5uaW5nIG1vZGVsLiBFaXRoZXIgXCJlcXVhbHBvd2VyXCIgb3IgXCJIUlRGXCIuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBwYW5uaW5nTW9kZWxcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ3Bhbm5pbmdNb2RlbCcpO1xuXHQgICAgLyoqXG5cdFx0ICogIEEgcmVmZXJlbmNlIGRpc3RhbmNlIGZvciByZWR1Y2luZyB2b2x1bWUgYXMgc291cmNlIG1vdmUgZnVydGhlciBmcm9tIHRoZSBsaXN0ZW5lclxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcmVmRGlzdGFuY2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ3JlZkRpc3RhbmNlJyk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVzY3JpYmVzIGhvdyBxdWlja2x5IHRoZSB2b2x1bWUgaXMgcmVkdWNlZCBhcyBzb3VyY2UgbW92ZXMgYXdheSBmcm9tIGxpc3RlbmVyLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcm9sbG9mZkZhY3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgncm9sbG9mZkZhY3RvcicpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkaXN0YW5jZSBtb2RlbCB1c2VkIGJ5LCAgXCJsaW5lYXJcIiwgXCJpbnZlcnNlXCIsIG9yIFwiZXhwb25lbnRpYWxcIi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIGRpc3RhbmNlTW9kZWxcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ2Rpc3RhbmNlTW9kZWwnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIGluc2lkZSBvZiB3aGljaCB0aGVyZSB3aWxsIGJlIG5vIHZvbHVtZSByZWR1Y3Rpb25cblx0XHQgKiAgQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBjb25lSW5uZXJBbmdsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgnY29uZUlubmVyQW5nbGUnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIG91dHNpZGUgb2Ygd2hpY2ggdGhlIHZvbHVtZSB3aWxsIGJlIHJlZHVjZWQgXG5cdFx0ICogIHRvIGEgY29uc3RhbnQgdmFsdWUgb2YgY29uZU91dGVyR2FpblxuXHRcdCAqICBAdHlwZSB7RGVncmVlc31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIGNvbmVPdXRlckFuZ2xlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELl9hbGlhc1Byb3BlcnR5KCdjb25lT3V0ZXJBbmdsZScpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBnYWluIG91dHNpZGUgb2YgdGhlIGNvbmVPdXRlckFuZ2xlXG5cdFx0ICogIEB0eXBlIHtHYWlufVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgY29uZU91dGVyR2FpblxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgnY29uZU91dGVyR2FpbicpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGJldHdlZW4gc291cmNlIGFuZCBsaXN0ZW5lciwgXG5cdFx0ICogIGFmdGVyIHdoaWNoIHRoZSB2b2x1bWUgd2lsbCBub3QgYmUgcmVkdWNlZCBhbnkgZnVydGhlci5cblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgbWF4RGlzdGFuY2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ21heERpc3RhbmNlJyk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhbm5lcjNEfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhbm5lcjNEO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QYW5Wb2wgaXMgYSBUb25lLlBhbm5lciBhbmQgVG9uZS5Wb2x1bWUgaW4gb25lLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtBdWRpb1JhbmdlfSBwYW4gdGhlIGluaXRpYWwgcGFuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgVGhlIG91dHB1dCB2b2x1bWUuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vcGFuIHRoZSBpbmNvbWluZyBzaWduYWwgbGVmdCBhbmQgZHJvcCB0aGUgdm9sdW1lXG5cdFx0ICogdmFyIHBhblZvbCA9IG5ldyBUb25lLlBhblZvbCgwLjI1LCAtMTIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5Wb2wgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdwYW4nLFxuXHQgICAgICAgICAgICAndm9sdW1lJ1xuXHQgICAgICAgIF0sIFRvbmUuUGFuVm9sLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFubmluZyBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUGFubmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuUGFubmVyKG9wdGlvbnMucGFuKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgTC9SIHBhbm5pbmcgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7QXVkaW9SYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnBhbiA9IHRoaXMuX3Bhbm5lci5wYW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2b2x1bWUgY29udHJvbCBpbiBkZWNpYmVscy4gXG5cdFx0XHQgKiAgQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmNvbm5lY3QodGhpcy5fdm9sdW1lKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdwYW4nLFxuXHQgICAgICAgICAgICAndm9sdW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFuVm9sKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLlBhblZvbC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncGFuJzogMC41LFxuXHQgICAgICAgICd2b2x1bWUnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhblZvbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5Wb2wucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3BhbicsXG5cdCAgICAgICAgICAgICd2b2x1bWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhblZvbDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQ3RybEludGVycG9sYXRlIHdpbGwgaW50ZXJwb2xhdGUgYmV0d2VlbiBnaXZlbiB2YWx1ZXMgYmFzZWRcblx0XHQgKiAgICAgICAgIG9uIHRoZSBcImluZGV4XCIgcHJvcGVydHkuIFBhc3NpbmcgaW4gYW4gYXJyYXkgb3Igb2JqZWN0IGxpdGVyYWxcblx0XHQgKiAgICAgICAgIHdpbGwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgcGFyYW1ldGVycy4gTm90ZSAoaS5lLiBcIkMzXCIpXG5cdFx0ICogICAgICAgICBhbmQgVGltZSAoaS5lLiBcIjRuICsgMlwiKSBjYW4gYmUgaW50ZXJwb2xhdGVkLiBBbGwgb3RoZXIgdmFsdWVzIGFyZVxuXHRcdCAqICAgICAgICAgYXNzdW1lZCB0byBiZSBudW1iZXJzLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgaW50ZXJwID0gbmV3IFRvbmUuQ3RybEludGVycG9sYXRlKFswLCAyLCA5LCA0XSk7XG5cdFx0ICogaW50ZXJwLmluZGV4ID0gMC43NTtcblx0XHQgKiBpbnRlcnAudmFsdWU7IC8vcmV0dXJucyAxLjVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBpbnRlcnAgPSBuZXcgVG9uZS5DdHJsSW50ZXJwb2xhdGUoW1xuXHRcdCAqIFx0WzIsIDQsIDVdLFxuXHRcdCAqIFx0WzksIDMsIDJdLFxuXHRcdCAqIF0pO1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGludGVycG9sYXRlIG92ZXJcblx0XHQgKiBAcGFyYW0ge1Bvc2l0aXZlfSBpbmRleCBUaGUgaW5pdGlhbCBpbnRlcnBvbGF0aW9uIGluZGV4LlxuXHRcdCAqIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd2YWx1ZXMnLFxuXHQgICAgICAgICAgICAnaW5kZXgnXG5cdCAgICAgICAgXSwgVG9uZS5DdHJsSW50ZXJwb2xhdGUuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgYmV0d2VlblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbnRlcnBvbGF0ZWQgaW5kZXggYmV0d2VlbiB2YWx1ZXMuIEZvciBleGFtcGxlOiBhIHZhbHVlIG9mIDEuNVxuXHRcdFx0ICogIHdvdWxkIGludGVycG9sYXRlIGVxdWFsbHkgYmV0d2VlbiB0aGUgdmFsdWUgYXQgaW5kZXggMVxuXHRcdFx0ICogIGFuZCB0aGUgdmFsdWUgYXQgaW5kZXggMi4gXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIGludGVycC5pbmRleCA9IDA7IFxuXHRcdFx0ICogaW50ZXJwLnZhbHVlOyAvL3JldHVybnMgdGhlIHZhbHVlIGF0IDBcblx0XHRcdCAqIGludGVycC5pbmRleCA9IDAuNTtcblx0XHRcdCAqIGludGVycC52YWx1ZTsgLy9yZXR1cm5zIHRoZSB2YWx1ZSBiZXR3ZWVuIGluZGljZXMgMCBhbmQgMS4gXG5cdFx0XHQgKiAgQHR5cGUgIHtQb3NpdGl2ZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ3RybEludGVycG9sYXRlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2luZGV4JzogMCxcblx0ICAgICAgICAndmFsdWVzJzogW11cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgaW50ZXJwb2xhdGVkIHZhbHVlIGJhc2VkIG9uIHRoZSBpbmRleFxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ3RybEludGVycG9sYXRlI1xuXHRcdCAqICBAdHlwZSB7Kn1cblx0XHQgKiAgQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxJbnRlcnBvbGF0ZS5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdGhpcy52YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgICAgIHZhciBsb3dlclBvc2l0aW9uID0gTWF0aC5mbG9vcihpbmRleCk7XG5cdCAgICAgICAgICAgIHZhciBsb3dlciA9IHRoaXMudmFsdWVzW2xvd2VyUG9zaXRpb25dO1xuXHQgICAgICAgICAgICB2YXIgdXBwZXIgPSB0aGlzLnZhbHVlc1tNYXRoLmNlaWwoaW5kZXgpXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRlKGluZGV4IC0gbG93ZXJQb3NpdGlvbiwgbG93ZXIsIHVwcGVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBpbnRlcnBvbGF0aW9uIHJvdXRpbmVcblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9ICBpbmRleCAgVGhlIGluZGV4IGJldHdlZW4gdGhlIGxvd2VyIGFuZCB1cHBlclxuXHRcdCAqICBAcGFyYW0gIHsqfSAgbG93ZXIgXG5cdFx0ICogIEBwYXJhbSAgeyp9ICB1cHBlciBcblx0XHQgKiAgQHJldHVybiAgeyp9ICBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxJbnRlcnBvbGF0ZS5wcm90b3R5cGUuX2ludGVycG9sYXRlID0gZnVuY3Rpb24gKGluZGV4LCBsb3dlciwgdXBwZXIpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc0FycmF5KGxvd2VyKSkge1xuXHQgICAgICAgICAgICB2YXIgcmV0QXJyYXkgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb3dlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcmV0QXJyYXlbaV0gPSB0aGlzLl9pbnRlcnBvbGF0ZShpbmRleCwgbG93ZXJbaV0sIHVwcGVyW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmV0QXJyYXk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzT2JqZWN0KGxvd2VyKSkge1xuXHQgICAgICAgICAgICB2YXIgcmV0T2JqID0ge307XG5cdCAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gbG93ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldE9ialthdHRyXSA9IHRoaXMuX2ludGVycG9sYXRlKGluZGV4LCBsb3dlclthdHRyXSwgdXBwZXJbYXR0cl0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXRPYmo7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbG93ZXIgPSB0aGlzLl90b051bWJlcihsb3dlcik7XG5cdCAgICAgICAgICAgIHVwcGVyID0gdGhpcy5fdG9OdW1iZXIodXBwZXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gKDEgLSBpbmRleCkgKiBsb3dlciArIGluZGV4ICogdXBwZXI7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGZyb20gdGhlIGdpdmVuIHR5cGUgaW50byBhIG51bWJlclxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSAgdmFsdWVcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZS5fdG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOdW1iZXIodmFsKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGFzc3VtZSB0aGF0IGl0J3MgVGltZS4uLlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZHModmFsKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkN0cmxJbnRlcnBvbGF0ZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsSW50ZXJwb2xhdGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkN0cmxNYXJrb3YgcmVwcmVzZW50cyBhIE1hcmtvdiBDaGFpbiB3aGVyZSBlYWNoIGNhbGxcblx0XHQgKiAgICAgICAgIHRvIFRvbmUuQ3RybE1hcmtvdi5uZXh0IHdpbGwgbW92ZSB0byB0aGUgbmV4dCBzdGF0ZS4gSWYgdGhlIG5leHRcblx0XHQgKiAgICAgICAgIHN0YXRlIGNob2ljZSBpcyBhbiBhcnJheSwgdGhlIG5leHQgc3RhdGUgaXMgY2hvc2VuIHJhbmRvbWx5IHdpdGhcblx0XHQgKiAgICAgICAgIGV2ZW4gcHJvYmFiaWxpdHkgZm9yIGFsbCBvZiB0aGUgY2hvaWNlcy4gRm9yIGEgd2VpZ2h0ZWQgcHJvYmFiaWxpdHlcblx0XHQgKiAgICAgICAgIG9mIHRoZSBuZXh0IGNob2ljZXMsIHBhc3MgaW4gYW4gb2JqZWN0IHdpdGggXCJzdGF0ZVwiIGFuZCBcInByb2JhYmlsaXR5XCIgYXR0cmlidXRlcy4gXG5cdFx0ICogICAgICAgICBUaGUgcHJvYmFiaWxpdGllcyB3aWxsIGJlIG5vcm1hbGl6ZWQgYW5kIHRoZW4gY2hvc2VuLiBJZiBubyBuZXh0IG9wdGlvbnNcblx0XHQgKiAgICAgICAgIGFyZSBnaXZlbiBmb3IgdGhlIGN1cnJlbnQgc3RhdGUsIHRoZSBzdGF0ZSB3aWxsIHN0YXkgdGhlcmUuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgY2hhaW4gPSBuZXcgVG9uZS5DdHJsTWFya292KHtcblx0XHQgKiBcdFwiYmVnaW5uaW5nXCIgOiBbXCJlbmRcIiwgXCJtaWRkbGVcIl0sXG5cdFx0ICogXHRcIm1pZGRsZVwiIDogXCJlbmRcIlxuXHRcdCAqIH0pO1xuXHRcdCAqIGNoYWluLnZhbHVlID0gXCJiZWdpbm5pbmdcIjtcblx0XHQgKiBjaGFpbi5uZXh0KCk7IC8vcmV0dXJucyBcImVuZFwiIG9yIFwibWlkZGxlXCIgd2l0aCA1MCUgcHJvYmFiaWxpdHlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjaGFpbiA9IG5ldyBUb25lLkN0cmxNYXJrb3Yoe1xuXHRcdCAqIFx0XCJiZWdpbm5pbmdcIiA6IFt7XCJ2YWx1ZVwiIDogXCJlbmRcIiwgXCJwcm9iYWJpbGl0eVwiIDogMC44fSwgXG5cdFx0ICogXHRcdFx0XHRcdHtcInZhbHVlXCIgOiBcIm1pZGRsZVwiLCBcInByb2JhYmlsaXR5XCIgOiAwLjJ9XSxcblx0XHQgKiBcdFwibWlkZGxlXCIgOiBcImVuZFwiXG5cdFx0ICogfSk7XG5cdFx0ICogY2hhaW4udmFsdWUgPSBcImJlZ2lubmluZ1wiO1xuXHRcdCAqIGNoYWluLm5leHQoKTsgLy9yZXR1cm5zIFwiZW5kXCIgd2l0aCA4MCUgcHJvYmFiaWxpdHkgb3IgXCJtaWRkbGVcIiB3aXRoIDIwJS5cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IHZhbHVlcyBBbiBvYmplY3Qgd2l0aCB0aGUgc3RhdGUgbmFtZXMgYXMgdGhlIGtleXNcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIG5leHQgc3RhdGUocykgYXMgdGhlIHZhbHVlcy4gXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxNYXJrb3YgPSBmdW5jdGlvbiAodmFsdWVzLCBpbml0aWFsKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIE1hcmtvdiB2YWx1ZXMgd2l0aCBzdGF0ZXMgYXMgdGhlIGtleXNcblx0XHRcdCAqICBhbmQgbmV4dCBzdGF0ZShzKSBhcyB0aGUgdmFsdWVzLiBcblx0XHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSB0aGlzLmRlZmF1bHRBcmcodmFsdWVzLCB7fSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIE1hcmtvdiB2YWx1ZXMuIFRoZSBuZXh0XG5cdFx0XHQgKiAgc3RhdGUgd2lsbCBiZSBldmFsdWF0ZWQgYW5kIHJldHVybmVkIHdoZW4gVG9uZS5DdHJsTWFya292Lm5leHRcblx0XHRcdCAqICBpcyBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5kZWZhdWx0QXJnKGluaXRpYWwsIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKVswXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsTWFya292KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSBNYXJrb3YgdmFsdWVzLiBcblx0XHQgKiAgQHJldHVybiAge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybE1hcmtvdi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy52YWx1ZXMuaGFzT3duUHJvcGVydHkodGhpcy52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLnZhbHVlc1t0aGlzLnZhbHVlXTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaXNBcnJheShuZXh0KSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHRoaXMuX2dldFByb2JEaXN0cmlidXRpb24obmV4dCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmFuZCA9IE1hdGgucmFuZG9tKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRpb24ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RyaWJ1dGlvbltpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmFuZCA+IHRvdGFsICYmIHJhbmQgPCB0b3RhbCArIGRpc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNob3NlbiA9IG5leHRbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KGNob3NlbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaG9zZW4udmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2hvc2VuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGRpc3Q7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2hvb3NlIHJhbmRvbWx5IGZyb20gYW4gYXJyYXkgd2VpZ2h0ZWQgb3B0aW9ucyBpbiB0aGUgZm9ybSBcblx0XHQgKiAge1wic3RhdGVcIiA6IHN0cmluZywgXCJwcm9iYWJpbGl0eVwiIDogbnVtYmVyfSBvciBhbiBhcnJheSBvZiB2YWx1ZXNcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICBvcHRpb25zIFxuXHRcdCAqICBAcmV0dXJuICB7QXJyYXl9ICBUaGUgcmFuZG9tbHkgc2VsZWN0ZWQgY2hvaWNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxNYXJrb3YucHJvdG90eXBlLl9nZXRQcm9iRGlzdHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gW107XG5cdCAgICAgICAgdmFyIHRvdGFsID0gMDtcblx0ICAgICAgICB2YXIgbmVlZHNOb3JtYWxpemluZyA9IGZhbHNlO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tpXTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaXNPYmplY3Qob3B0aW9uKSkge1xuXHQgICAgICAgICAgICAgICAgbmVlZHNOb3JtYWxpemluZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25baV0gPSBvcHRpb24ucHJvYmFiaWxpdHk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25baV0gPSAxIC8gb3B0aW9ucy5sZW5ndGg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdG90YWwgKz0gZGlzdHJpYnV0aW9uW2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmVlZHNOb3JtYWxpemluZykge1xuXHQgICAgICAgICAgICAvL25vcm1hbGl6ZSB0aGUgdmFsdWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGlzdHJpYnV0aW9uLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25bal0gPSBkaXN0cmlidXRpb25bal0gLyB0b3RhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5DdHJsTWFya292fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsTWFya292LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsTWFya292O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgR2VuZXJhdGUgcGF0dGVybnMgZnJvbSBhbiBhcnJheSBvZiB2YWx1ZXMuXG5cdFx0ICogICAgICAgICBIYXMgYSBudW1iZXIgb2YgYXJwZWdnaWF0aW9uIGFuZCByYW5kb21pemVkXG5cdFx0ICogICAgICAgICBzZWxlY3Rpb24gcGF0dGVybnMuIFxuXHRcdCAqICAgICAgICAgICA8dWw+XG5cdFx0ICogIFx0ICAgICAgICA8bGk+XCJ1cFwiIC0gY3ljbGVzIHVwd2FyZDwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cImRvd25cIiAtIGN5Y2xlcyBkb3dud2FyZDwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cInVwRG93blwiIC0gdXAgdGhlbiBhbmQgZG93bjwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cImRvd25VcFwiIC0gY3ljbGVzIGRvd24gdGhlbiBhbmQgdXA8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJhbHRlcm5hdGVVcFwiIC0ganVtcCB1cCB0d28gYW5kIGRvd24gb25lPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwiYWx0ZXJuYXRlRG93blwiIC0ganVtcCBkb3duIHR3byBhbmQgdXAgb25lPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwicmFuZG9tXCIgLSByYW5kb21seSBzZWxlY3QgYW4gaW5kZXg8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJyYW5kb21XYWxrXCIgLSByYW5kb21seSBtb3ZlcyBvbmUgaW5kZXggYXdheSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwicmFuZG9tT25jZVwiIC0gcmFuZG9tbHkgc2VsZWN0IGFuIGluZGV4IHdpdGhvdXQgcmVwZWF0aW5nIHVudGlsIGFsbCB2YWx1ZXMgaGF2ZSBiZWVuIGNob3Nlbi48L2xpPlxuXHRcdCAqICAgICBcdFx0PC91bD5cblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICB2YWx1ZXMgICBBbiBhcnJheSBvZiBvcHRpb25zIHRvIGNob29zZSBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkN0cmxQYXR0ZXJuLlR5cGU9fSAgdHlwZSAgVGhlIG5hbWUgb2YgdGhlIHBhdHRlcm4uXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3ZhbHVlcycsXG5cdCAgICAgICAgICAgICd0eXBlJ1xuXHQgICAgICAgIF0sIFRvbmUuQ3RybFBhdHRlcm4uZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gYXJwZWdnaWF0ZSBvdmVyXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgdmFsdWVzIGFycmF5XG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHlwZSBwbGFjZWhvbGRlclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkN0cmxQYXR0ZXJuLlR5cGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNodWZmbGVkIHZhbHVlcyBmb3IgdGhlIFJhbmRvbU9uY2UgdHlwZVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2h1ZmZsZWQgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkaXJlY3Rpb24gb2YgdGhlIG1vdmVtZW50XG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsUGF0dGVybik7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIENvbnRyb2wgUGF0dGVybnNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4uVHlwZSA9IHtcblx0ICAgICAgICBVcDogJ3VwJyxcblx0ICAgICAgICBEb3duOiAnZG93bicsXG5cdCAgICAgICAgVXBEb3duOiAndXBEb3duJyxcblx0ICAgICAgICBEb3duVXA6ICdkb3duVXAnLFxuXHQgICAgICAgIEFsdGVybmF0ZVVwOiAnYWx0ZXJuYXRlVXAnLFxuXHQgICAgICAgIEFsdGVybmF0ZURvd246ICdhbHRlcm5hdGVEb3duJyxcblx0ICAgICAgICBSYW5kb206ICdyYW5kb20nLFxuXHQgICAgICAgIFJhbmRvbVdhbGs6ICdyYW5kb21XYWxrJyxcblx0ICAgICAgICBSYW5kb21PbmNlOiAncmFuZG9tT25jZSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzLiBcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxQYXR0ZXJuLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd0eXBlJzogVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwLFxuXHQgICAgICAgICd2YWx1ZXMnOiBbXVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHBhdHRlcm4uXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsUGF0dGVybiNcblx0XHQgKiAgQHR5cGUgeyp9XG5cdFx0ICogIEBuYW1lIHZhbHVlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy9zb21lIHNhZmVndWFyZHNcblx0ICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzBdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLm1pbih0aGlzLmluZGV4LCB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWVzW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tT25jZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCAhPT0gdGhpcy5fc2h1ZmZsZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZVZhbHVlcygpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFsID0gdGhpcy52YWx1ZXNbdGhpcy5fc2h1ZmZsZWRbdGhpcy5pbmRleF1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBhdHRlcm4gdXNlZCB0byBzZWxlY3QgdGhlIG5leHRcblx0XHQgKiAgaXRlbSBmcm9tIHRoZSB2YWx1ZXMgYXJyYXlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ3RybFBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHtUb25lLkN0cmxQYXR0ZXJuLlR5cGV9XG5cdFx0ICogIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxQYXR0ZXJuLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZWQgPSBudWxsO1xuXHQgICAgICAgICAgICAvL3RoZSBmaXJzdCBpbmRleFxuXHQgICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcERvd24gfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbU9uY2UgfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkFsdGVybmF0ZVVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93biB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93blVwIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVEb3duKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL3RoZSBkaXJlY3Rpb25cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcERvd24gfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkFsdGVybmF0ZVVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXA7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd25VcCB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlRG93bikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9yYW5kb21zXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tT25jZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZVZhbHVlcygpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uUmFuZG9tKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy52YWx1ZXMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgbmV4dCB2YWx1ZSBnaXZlbiB0aGUgY3VycmVudCBwb3NpdGlvblxuXHRcdCAqICBhbmQgcGF0dGVybi5cblx0XHQgKiAgQHJldHVybiB7Kn0gVGhlIG5leHQgdmFsdWVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgLy9jaG9vc2UgdGhlIG5leHQgaW5kZXhcblx0ICAgICAgICBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd24pIHtcblx0ICAgICAgICAgICAgdGhpcy5pbmRleC0tO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXBEb3duIHx8IHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duVXApIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4LS07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbSkge1xuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy52YWx1ZXMubGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21XYWxrKSB7XG5cdCAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4LS07XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5tYXgodGhpcy5pbmRleCwgMCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gTWF0aC5taW4odGhpcy5pbmRleCwgdGhpcy52YWx1ZXMubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21PbmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcblx0ICAgICAgICAgICAgICAgIC8vcmVzaHVmZmxlIHRoZSB2YWx1ZXMgZm9yIG5leHQgdGltZVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2h1ZmZsZVZhbHVlcygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlVXApIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggLT0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlRG93bikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCAtPSAyO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2h1ZmZsZXMgdGhlIHZhbHVlcyBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIF9zaHVmZmxlZFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUuX3NodWZmbGVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvcHkgPSBbXTtcblx0ICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgY29weVtpXSA9IGk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlIChjb3B5Lmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIHJhbmRWYWwgPSBjb3B5LnNwbGljZShNYXRoLmZsb29yKGNvcHkubGVuZ3RoICogTWF0aC5yYW5kb20oKSksIDEpO1xuXHQgICAgICAgICAgICB0aGlzLl9zaHVmZmxlZC5wdXNoKHJhbmRWYWxbMF0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ3RybFBhdHRlcm59IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc2h1ZmZsZWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsUGF0dGVybjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBDaG9vc2UgYSByYW5kb20gdmFsdWUuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciByYW5kb21XYWxrID0gbmV3IFRvbmUuQ3RybFJhbmRvbSh7XG5cdFx0ICogXHRcIm1pblwiIDogMCxcblx0XHQgKiBcdFwibWF4XCIgOiAxMCxcblx0XHQgKiBcdFwiaW50ZWdlclwiIDogdHJ1ZVxuXHRcdCAqIH0pO1xuXHRcdCAqIHJhbmRvbVdhbGsuZXZhbCgpO1xuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfFRpbWU9fSBtaW4gVGhlIG1pbmltdW0gcmV0dXJuIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcnxUaW1lPX0gbWF4IFRoZSBtYXhpbXVtIHJldHVybiB2YWx1ZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ21pbicsXG5cdCAgICAgICAgICAgICdtYXgnXG5cdCAgICAgICAgXSwgVG9uZS5DdHJsUmFuZG9tLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWluaW11bSByZXR1cm4gdmFsdWVcblx0XHRcdCAqICBAdHlwZSAge051bWJlcnxUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taW4gPSBvcHRpb25zLm1pbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWF4aW11bSByZXR1cm4gdmFsdWVcblx0XHRcdCAqICBAdHlwZSAge051bWJlcnxUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tYXggPSBvcHRpb25zLm1heDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJZiB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBiZSBhbiBpbnRlZ2VyXG5cdFx0XHQgKiAgQHR5cGUgIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnRlZ2VyID0gb3B0aW9ucy5pbnRlZ2VyO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ3RybFJhbmRvbSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFJhbmRvbS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAnbWF4JzogMSxcblx0ICAgICAgICAnaW50ZWdlcic6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4LiBcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkN0cmxSYW5kb20jXG5cdFx0ICogIEB0eXBlIHsqfVxuXHRcdCAqICBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ3RybFJhbmRvbS5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMudG9TZWNvbmRzKHRoaXMubWluKTtcblx0ICAgICAgICAgICAgdmFyIG1heCA9IHRoaXMudG9TZWNvbmRzKHRoaXMubWF4KTtcblx0ICAgICAgICAgICAgdmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gcmFuZCAqIG1pbiArICgxIC0gcmFuZCkgKiBtYXg7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmludGVnZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmUuQ3RybFJhbmRvbTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBCdWZmZXIgbG9hZGluZyBhbmQgc3RvcmFnZS4gVG9uZS5CdWZmZXIgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IGFsbCBcblx0XHQgKiAgICAgICAgICBjbGFzc2VzIHRoYXQgbWFrZSByZXF1ZXN0cyBmb3IgYXVkaW8gZmlsZXMgc3VjaCBhcyBUb25lLlBsYXllcixcblx0XHQgKiAgICAgICAgICBUb25lLlNhbXBsZXIgYW5kIFRvbmUuQ29udm9sdmVyLlxuXHRcdCAqICAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgQXNpZGUgZnJvbSBsb2FkIGNhbGxiYWNrcyBmcm9tIGluZGl2aWR1YWwgYnVmZmVycywgVG9uZS5CdWZmZXIgXG5cdFx0ICogIFx0XHRwcm92aWRlcyBzdGF0aWMgbWV0aG9kcyB3aGljaCBrZWVwIHRyYWNrIG9mIHRoZSBsb2FkaW5nIHByb2dyZXNzIFxuXHRcdCAqICBcdFx0b2YgYWxsIG9mIHRoZSBidWZmZXJzLiBUaGVzZSBtZXRob2RzIGFyZSBUb25lLkJ1ZmZlci5vbihcImxvYWRcIiAvIFwicHJvZ3Jlc3NcIiAvIFwiZXJyb3JcIilcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3IgXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvQnVmZmVyfHN0cmluZ30gdXJsIFRoZSB1cmwgdG8gbG9hZCwgb3IgdGhlIGF1ZGlvIGJ1ZmZlciB0byBzZXQuIFxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9uPX0gb25sb2FkIEEgY2FsbGJhY2sgd2hpY2ggaXMgaW52b2tlZCBhZnRlciB0aGUgYnVmZmVyIGlzIGxvYWRlZC4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQncyByZWNvbW1lbmRlZCB0byB1c2UgVG9uZS5CdWZmZXIub25sb2FkIGluc3RlYWQgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luY2UgaXQgd2lsbCBnaXZlIHlvdSBhIGNhbGxiYWNrIHdoZW4gQUxMIGJ1ZmZlcnMgYXJlIGxvYWRlZC5cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbj19IG9uZXJyb3IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBpZiB0aGVyZSBpcyBhbiBlcnJvclxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBidWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoXCJwYXRoL3RvL3NvdW5kLm1wM1wiLCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly90aGUgYnVmZmVyIGlzIG5vdyBhdmFpbGFibGUuXG5cdFx0ICogXHR2YXIgYnVmZiA9IGJ1ZmZlci5nZXQoKTtcblx0XHQgKiB9KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndXJsJyxcblx0ICAgICAgICAgICAgJ29ubG9hZCcsXG5cdCAgICAgICAgICAgICdvbmVycm9yJ1xuXHQgICAgICAgIF0sIFRvbmUuQnVmZmVyLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzdG9yZXMgdGhlIGxvYWRlZCBBdWRpb0J1ZmZlclxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBpbmRpY2F0ZXMgaWYgdGhlIGJ1ZmZlciBzaG91bGQgYmUgcmV2ZXJzZWQgb3Igbm90XG5cdFx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JldmVyc2VkID0gb3B0aW9ucy5yZXZlcnNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBYSFJcblx0XHRcdCAqICBAdHlwZSAge1hNTEh0dHBSZXF1ZXN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl94aHIgPSBudWxsO1xuXHQgICAgICAgIGlmIChvcHRpb25zLnVybCBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyIHx8IG9wdGlvbnMudXJsIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5zZXQob3B0aW9ucy51cmwpO1xuXHQgICAgICAgICAgICAvLyBpbnZva2UgdGhlIG9ubG9hZCBjYWxsYmFja1xuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmxvYWQpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMub25sb2FkKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3RyaW5nKG9wdGlvbnMudXJsKSkge1xuXHQgICAgICAgICAgICB0aGlzLmxvYWQob3B0aW9ucy51cmwsIG9wdGlvbnMub25sb2FkLCBvcHRpb25zLm9uZXJyb3IpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkJ1ZmZlcik7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3VybCc6IHVuZGVmaW5lZCxcblx0ICAgICAgICAncmV2ZXJzZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBhc3MgaW4gYW4gQXVkaW9CdWZmZXIgb3IgVG9uZS5CdWZmZXIgdG8gc2V0IHRoZSB2YWx1ZVxuXHRcdCAqICBvZiB0aGlzIGJ1ZmZlci5cblx0XHQgKiAgQHBhcmFtIHtBdWRpb0J1ZmZlcnxUb25lLkJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXJcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXIuZ2V0KCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQHJldHVybiB7QXVkaW9CdWZmZXJ9IFRoZSBhdWRpbyBidWZmZXIgc3RvcmVkIGluIHRoZSBvYmplY3QuXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1ha2VzIGFuIHhociByZXFlc3QgZm9yIHRoZSBzZWxlY3RlZCB1cmwgdGhlbiBkZWNvZGVzXG5cdFx0ICogIHRoZSBmaWxlIGFzIGFuIGF1ZGlvIGJ1ZmZlci4gSW52b2tlc1xuXHRcdCAqICB0aGUgY2FsbGJhY2sgb25jZSB0aGUgYXVkaW8gYnVmZmVyIGxvYWRzLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwgb2YgdGhlIGJ1ZmZlciB0byBsb2FkLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIGZpbGV0eXBlIHN1cHBvcnQgZGVwZW5kcyBvbiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICBicm93c2VyLlxuXHRcdCAqICBAcmV0dXJucyB7UHJvbWlzZX0gcmV0dXJucyBhIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCB0aGUgVG9uZS5CdWZmZXJcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgb25sb2FkLCBvbmVycm9yKSB7XG5cdCAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAobG9hZCwgZXJyb3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5feGhyID0gVG9uZS5CdWZmZXIubG9hZCh1cmwsIC8vc3VjY2Vzc1xuXHQgICAgICAgICAgICBmdW5jdGlvbiAoYnVmZikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5feGhyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGJ1ZmYpO1xuXHQgICAgICAgICAgICAgICAgbG9hZCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChvbmxvYWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbmxvYWQodGhpcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgLy9lcnJvclxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl94aHIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgZXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChvbmVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb25lcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgYW5kIGRpc2Nvbm5lY3Rcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIGlmICh0aGlzLl94aHIpIHtcblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuX2N1cnJlbnREb3dubG9hZHMtLTtcblx0ICAgICAgICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3hociA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXIgaXMgbG9hZGVkIG9yIG5vdFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdsb2FkZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZHVyYXRpb24gb2YgdGhlIGJ1ZmZlci4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgZHVyYXRpb25cblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdkdXJhdGlvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5kdXJhdGlvbjtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaW4gc2FtcGxlc1xuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGxlbmd0aFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5sZW5ndGg7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBkaXNjcmV0ZSBhdWRpbyBjaGFubmVscy4gUmV0dXJucyAwIGlmIG5vIGJ1ZmZlclxuXHRcdCAqIGlzIGxvYWRlZC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSBudW1iZXJPZkNoYW5uZWxzXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCAnbnVtYmVyT2ZDaGFubmVscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIGF1ZGlvIGJ1ZmZlciBmcm9tIHRoZSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwgdGhlIGF1ZGlvIGJ1ZmZlclxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gW2NoYW5uZWxzPTFdIFRoZSBudW1iZXIgb2YgY2hhbm5lbHMgY29udGFpbmVkIGluIHRoZSBhcnJheS4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdGhlIGNoYW5uZWwgaXMgbW9yZSB0aGFuIDEsIHRoZSBpbnB1dCBhcnJheVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGV4cGVjdGVkIHRvIGJlIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggZGltZW5zaW9ucyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuXHQgICAgICAgIHZhciBpc011bHRpZGltZW5zaW9uYWwgPSBhcnJheVswXS5sZW5ndGggPiAwO1xuXHQgICAgICAgIHZhciBjaGFubmVscyA9IGlzTXVsdGlkaW1lbnNpb25hbCA/IGFycmF5Lmxlbmd0aCA6IDE7XG5cdCAgICAgICAgdmFyIGxlbiA9IGlzTXVsdGlkaW1lbnNpb25hbCA/IGFycmF5WzBdLmxlbmd0aCA6IGFycmF5Lmxlbmd0aDtcblx0ICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjaGFubmVscywgbGVuLCB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZSk7XG5cdCAgICAgICAgaWYgKCFpc011bHRpZGltZW5zaW9uYWwgJiYgY2hhbm5lbHMgPT09IDEpIHtcblx0ICAgICAgICAgICAgYXJyYXkgPSBbYXJyYXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNoYW5uZWxzOyBjKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaXNGdW5jdGlvbihidWZmZXIuY29weVRvQ2hhbm5lbCkpIHtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlci5jb3B5VG9DaGFubmVsKGFycmF5W2NdLCBjKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKGMpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxBcnJheSA9IGFycmF5W2NdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldID0gY2hhbm5lbEFycmF5W2ldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBcdEdldCB0aGUgYnVmZmVyIGFzIGFuIGFycmF5LiBTaW5nbGUgY2hhbm5lbCBidWZmZXJzIHdpbGwgcmV0dXJuIGEgMS1kaW1lbnNpb25hbCBcblx0XHQgKiBcdEZsb2F0MzJBcnJheSwgYW5kIG11bHRpY2hhbm5lbCBidWZmZXJzIHdpbGwgcmV0dXJuIG11bHRpZGltZW5zaW9uYWwgYXJyYXlzLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IGNoYW5uZWwgT3B0aW9uYWxseSBvbmx5IGNvcHkgYSBzaW5nbGUgY2hhbm5lbCBmcm9tIHRoZSBhcnJheS5cblx0XHQgKiAgQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOdW1iZXIoY2hhbm5lbCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5udW1iZXJPZkNoYW5uZWxzOyBjKyspIHtcblx0ICAgICAgICAgICAgICAgIHJldFtjXSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGdW5jdGlvbih0aGlzLl9idWZmZXIuY29weUZyb21DaGFubmVsKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5jb3B5RnJvbUNoYW5uZWwocmV0W2NdLCBjKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gdGhpcy5fYnVmZmVyLmdldENoYW5uZWxEYXRhKGMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXRBcnJheSA9IHJldFtjXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldEFycmF5W2ldID0gY2hhbm5lbERhdGFbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmV0WzBdO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ3V0IGEgc3Vic2VjdGlvbiBvZiB0aGUgYXJyYXkgYW5kIHJldHVybiBhIGJ1ZmZlciBvZiB0aGVcblx0XHQgKiAgc3Vic2VjdGlvbi4gRG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBidWZmZXJcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydCBUaGUgdGltZSB0byBzdGFydCB0aGUgc2xpY2Vcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gZW5kIFRoZSBlbmQgdGltZSB0byBzbGljZS4gSWYgbm9uZSBpcyBnaXZlblxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgd2lsbCBkZWZhdWx0IHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcblx0ICAgICAgICBlbmQgPSB0aGlzLmRlZmF1bHRBcmcoZW5kLCB0aGlzLmR1cmF0aW9uKTtcblx0ICAgICAgICB2YXIgc3RhcnRTYW1wbGVzID0gTWF0aC5mbG9vcih0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZSAqIHRoaXMudG9TZWNvbmRzKHN0YXJ0KSk7XG5cdCAgICAgICAgdmFyIGVuZFNhbXBsZXMgPSBNYXRoLmZsb29yKHRoaXMuY29udGV4dC5zYW1wbGVSYXRlICogdGhpcy50b1NlY29uZHMoZW5kKSk7XG5cdCAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuXHQgICAgICAgICAgICByZXBsYWNlbWVudFtpXSA9IHRoaXMudG9BcnJheShpKS5zbGljZShzdGFydFNhbXBsZXMsIGVuZFNhbXBsZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmV0QnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKCkuZnJvbUFycmF5KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICByZXR1cm4gcmV0QnVmZmVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXZlcnNlIHRoZSBidWZmZXIuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuX3JldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbCh0aGlzLl9idWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJldmVyc2UgdGhlIGJ1ZmZlci5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQG5hbWUgcmV2ZXJzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyLnByb3RvdHlwZSwgJ3JldmVyc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXZlcnNlZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJldikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fcmV2ZXJzZWQgIT09IHJldikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSByZXY7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXZlcnNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gU1RBVElDIE1FVEhPRFNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9zdGF0aWNhbGx5IGluaGVyaXRzIEVtaXR0ZXIgbWV0aG9kc1xuXHQgICAgVG9uZS5FbWl0dGVyLm1peGluKFRvbmUuQnVmZmVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgc3RhdGljIHF1ZXVlIGZvciBhbGwgb2YgdGhlIHhociByZXF1ZXN0c1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZSA9IFtdO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSB0b3RhbCBudW1iZXIgb2YgZG93bmxvYWRzXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5fY3VycmVudERvd25sb2FkcyA9IDA7XG5cdCAgICAvKipcblx0XHQgKiAgQSBwYXRoIHdoaWNoIGlzIHByZWZpeGVkIGJlZm9yZSBldmVyeSB1cmwuXG5cdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5iYXNlVXJsID0gJyc7XG5cdCAgICAvKipcblx0XHQgKiAgTG9hZHMgYSB1cmwgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB1cmxcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IG9uZXJyb3Jcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25wcm9ncmVzc1xuXHRcdCAqICBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBvbmxvYWQsIG9uZXJyb3IpIHtcblx0ICAgICAgICAvL2RlZmF1bHRcblx0ICAgICAgICBvbmxvYWQgPSBvbmxvYWQgfHwgVG9uZS5ub09wO1xuXHQgICAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuXHQgICAgICAgICAgICBpZiAob25lcnJvcikge1xuXHQgICAgICAgICAgICAgICAgb25lcnJvcihlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuXHQgICAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3Ncblx0ICAgICAgICAgICAgdmFyIHRvdGFsUHJvZ3Jlc3MgPSAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0b3RhbFByb2dyZXNzICs9IFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlW2ldLnByb2dyZXNzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLmVtaXQoJ3Byb2dyZXNzJywgdG90YWxQcm9ncmVzcyAvIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBUb25lLkJ1ZmZlci5iYXNlVXJsICsgdXJsLCB0cnVlKTtcblx0ICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgICAgICAgLy9zdGFydCBvdXQgYXMgMFxuXHQgICAgICAgIHJlcXVlc3QucHJvZ3Jlc3MgPSAwO1xuXHQgICAgICAgIFRvbmUuQnVmZmVyLl9jdXJyZW50RG93bmxvYWRzKys7XG5cdCAgICAgICAgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUucHVzaChyZXF1ZXN0KTtcblx0ICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG5cdCAgICAgICAgICAgICAgICBUb25lLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIGZ1bmN0aW9uIChidWZmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5wcm9ncmVzcyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIG9ubG9hZChidWZmKTtcblx0ICAgICAgICAgICAgICAgICAgICBUb25lLkJ1ZmZlci5fY3VycmVudERvd25sb2Fkcy0tO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLkJ1ZmZlci5fY3VycmVudERvd25sb2FkcyA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgZG93bmxvYWRzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vZW1pdCB0aGUgZXZlbnQgYXQgdGhlIGVuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUb25lLkJ1ZmZlci5lbWl0KCdsb2FkJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1RvbmUuQnVmZmVyOiBjb3VsZCBub3QgZGVjb2RlIGF1ZGlvIGRhdGE6ICcgKyB1cmwpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvbkVycm9yKCdUb25lLkJ1ZmZlcjogY291bGQgbm90IGxvY2F0ZSBmaWxlOiAnICsgdXJsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcblx0ICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAvL29ubHkgZ28gdG8gOTUlLCB0aGUgbGFzdCA1JSBpcyB3aGVuIHRoZSBhdWRpbyBpcyBkZWNvZGVkXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0LnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgKiAwLjk1O1xuXHQgICAgICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG5cdCAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgYWxsIG9mIHRoZSBkb3dubG9hZHMgaW4gcHJvZ3Jlc3Ncblx0XHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5zdG9wRG93bmxvYWRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0ICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIFRvbmUuQnVmZmVyLl9jdXJyZW50RG93bmxvYWRzID0gMDtcblx0ICAgICAgICByZXR1cm4gVG9uZS5CdWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENoZWNrcyBhIHVybCdzIGV4dGVuc2lvbiB0byBzZWUgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBjYW4gcGxheSB0aGF0IGZpbGUgdHlwZS5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXJsL2V4dGVuc2lvbiB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWxlIGV4dGVuc2lvbiBjYW4gYmUgcGxheWVkXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUoXCJ3YXZcIik7IC8vcmV0dXJucyB0cnVlXG5cdFx0ICogVG9uZS5CdWZmZXIuc3VwcG9ydHNUeXBlKFwicGF0aC90by9maWxlLndhdlwiKTsgLy9yZXR1cm5zIHRydWVcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnN1cHBvcnRzVHlwZSA9IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgICB2YXIgZXh0ZW5zaW9uID0gdXJsLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uW2V4dGVuc2lvbi5sZW5ndGggLSAxXTtcblx0ICAgICAgICB2YXIgcmVzcG9uc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpLmNhblBsYXlUeXBlKCdhdWRpby8nICsgZXh0ZW5zaW9uKTtcblx0ICAgICAgICByZXR1cm4gcmVzcG9uc2UgIT09ICcnO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJ1ZmZlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIGRhdGEgc3RydWN0dXJlIGZvciBob2xkaW5nIG11bHRpcGxlIGJ1ZmZlcnMuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgIHVybHMgICAgICBBbiBvYmplY3QgbGl0ZXJhbCBvciBhcnJheVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB1cmxzIHRvIGxvYWQuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPX0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvYWQgYSB3aG9sZSBiYW5rIG9mIHBpYW5vIHNhbXBsZXNcblx0XHQgKiB2YXIgcGlhbm9TYW1wbGVzID0gbmV3IFRvbmUuQnVmZmVycyh7XG5cdFx0ICogXHRcIkM0XCIgOiBcInBhdGgvdG8vQzQubXAzXCJcblx0XHQgKiBcdFwiQyM0XCIgOiBcInBhdGgvdG8vQyM0Lm1wM1wiXG5cdFx0ICogXHRcIkQ0XCIgOiBcInBhdGgvdG8vRDQubXAzXCJcblx0XHQgKiBcdFwiRCM0XCIgOiBcInBhdGgvdG8vRCM0Lm1wM1wiXG5cdFx0ICogXHQuLi5cblx0XHQgKiB9LCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly9wbGF5IG9uZSBvZiB0aGUgc2FtcGxlcyB3aGVuIHRoZXkgYWxsIGxvYWRcblx0XHQgKiBcdHBsYXllci5idWZmZXIgPSBwaWFub1NhbXBsZXMuZ2V0KFwiQzRcIik7XG5cdFx0ICogXHRwbGF5ZXIuc3RhcnQoKTtcblx0XHQgKiB9KTtcblx0XHQgKiBcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVycyA9IGZ1bmN0aW9uICh1cmxzLCBvbmxvYWQsIGJhc2VVcmwpIHtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGwgb2YgdGhlIGJ1ZmZlcnNcblx0XHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IHt9O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgcGF0aCB3aGljaCBpcyBwcmVmaXhlZCBiZWZvcmUgZXZlcnkgdXJsLlxuXHRcdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5iYXNlVXJsID0gdGhpcy5kZWZhdWx0QXJnKGJhc2VVcmwsICcnKTtcblx0ICAgICAgICB1cmxzID0gdGhpcy5fZmxhdHRlblVybHModXJscyk7XG5cdCAgICAgICAgdGhpcy5fbG9hZGluZ0NvdW50ID0gMDtcblx0ICAgICAgICAvL2FkZCBlYWNoIG9uZVxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiB1cmxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCsrO1xuXHQgICAgICAgICAgICB0aGlzLmFkZChrZXksIHVybHNba2V5XSwgdGhpcy5fYnVmZmVyTG9hZGVkLmJpbmQodGhpcywgb25sb2FkKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQnVmZmVycyk7XG5cdCAgICAvKipcblx0XHQgKiAgVHJ1ZSBpZiB0aGUgYnVmZmVycyBvYmplY3QgaGFzIGEgYnVmZmVyIGJ5IHRoYXQgbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIG5hbWUgIFRoZSBrZXkgb3IgaW5kZXggb2YgdGhlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuXHRcdCAqICBAcmV0dXJuICB7Qm9vbGVhbn1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVycy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IGEgYnVmZmVyIGJ5IG5hbWUuIElmIGFuIGFycmF5IHdhcyBsb2FkZWQsIFxuXHRcdCAqICB0aGVuIHVzZSB0aGUgYXJyYXkgaW5kZXguXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9ICBuYW1lICBUaGUga2V5IG9yIGluZGV4IG9mIHRoZSBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmhhcyhuYW1lKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyc1tuYW1lXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuQnVmZmVyczogbm8gYnVmZmVyIG5hbWVkICcgKyBuYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEEgYnVmZmVyIHdhcyBsb2FkZWQuIGRlY3JlbWVudCB0aGUgY291bnRlci5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVycy5wcm90b3R5cGUuX2J1ZmZlckxvYWRlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudC0tO1xuXHQgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nQ291bnQgPT09IDAgJiYgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQgb3Igbm90XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVycyNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlcnMucHJvdG90eXBlLCAnbG9hZGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaXNMb2FkZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBidWZmTmFtZSBpbiB0aGlzLl9idWZmZXJzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnVmZiA9IHRoaXMuZ2V0KGJ1ZmZOYW1lKTtcblx0ICAgICAgICAgICAgICAgIGlzTG9hZGVkID0gaXNMb2FkZWQgJiYgYnVmZi5sb2FkZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGlzTG9hZGVkO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIGJ1ZmZlciBieSBuYW1lIGFuZCB1cmwgdG8gdGhlIEJ1ZmZlcnNcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgICBuYW1lICAgICAgQSB1bmlxdWUgbmFtZSB0byBnaXZlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBidWZmZXJcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfFRvbmUuQnVmZmVyfEF1ZGlvYnVmZmVyfSAgdXJsICBFaXRoZXIgdGhlIHVybCBvZiB0aGUgYnVmZXIsIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgYnVmZmVyIHdoaWNoIHdpbGwgYmUgYWRkZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbj19ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHVybCBpcyBsb2FkZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCB1cmwsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgY2FsbGJhY2sgPSB0aGlzLmRlZmF1bHRBcmcoY2FsbGJhY2ssIFRvbmUubm9PcCk7XG5cdCAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIFRvbmUuQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnNbbmFtZV0gPSB1cmw7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodXJsIGluc3RhbmNlb2YgQXVkaW9CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tuYW1lXSA9IG5ldyBUb25lLkJ1ZmZlcih1cmwpO1xuXHQgICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdHJpbmcodXJsKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzW25hbWVdID0gbmV3IFRvbmUuQnVmZmVyKHRoaXMuYmFzZVVybCArIHVybCwgY2FsbGJhY2spO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRmxhdHRlbiBhbiBvYmplY3QgaW50byBhIHNpbmdsZSBkZXB0aCBvYmplY3QuIFxuXHRcdCAqICB0aGFua3MgdG8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGVuZ3VpbmJveS83NjIxOTdcblx0XHQgKiAgQHBhcmFtICAge09iamVjdH0gb2IgXHRcblx0XHQgKiAgQHJldHVybiAge09iamVjdH0gICAgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLl9mbGF0dGVuVXJscyA9IGZ1bmN0aW9uIChvYikge1xuXHQgICAgICAgIHZhciB0b1JldHVybiA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gb2IpIHtcblx0ICAgICAgICAgICAgaWYgKCFvYi5oYXNPd25Qcm9wZXJ0eShpKSlcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pc09iamVjdChvYltpXSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmbGF0T2JqZWN0ID0gdGhpcy5fZmxhdHRlblVybHMob2JbaV0pO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgeCBpbiBmbGF0T2JqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmbGF0T2JqZWN0Lmhhc093blByb3BlcnR5KHgpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB0b1JldHVybltpICsgJy4nICsgeF0gPSBmbGF0T2JqZWN0W3hdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdG9SZXR1cm5baV0gPSBvYltpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9SZXR1cm47XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5CdWZmZXJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9idWZmZXJzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnNbbmFtZV0uZGlzcG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5CdWZmZXJzO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBidXNlcyBhcmUgYW5vdGhlciB3YXkgb2Ygcm91dGluZyBhdWRpb1xuXHRcdCAqXG5cdFx0ICogIGF1Z21lbnRzIFRvbmUucHJvdG90eXBlIHRvIGluY2x1ZGUgc2VuZCBhbmQgcmVjaWV2ZVxuXHRcdCAqL1xuXHQgICAgLyoqXG5cdFx0ICAqICBBbGwgb2YgdGhlIHJvdXRlc1xuXHRcdCAgKiAgXG5cdFx0ICAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAgKiAgQHN0YXRpY1xuXHRcdCAgKiAgQHByaXZhdGVcblx0XHQgICovXG5cdCAgICB2YXIgQnVzZXMgPSB7fTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZW5kIHRoaXMgc2lnbmFsIHRvIHRoZSBjaGFubmVsIG5hbWUuIFxuXHRcdCAqICBAcGFyYW0gIHtzdHJpbmd9IGNoYW5uZWxOYW1lIEEgbmFtZWQgY2hhbm5lbCB0byBzZW5kIHRoZSBzaWduYWwgdG8uXG5cdFx0ICogIEBwYXJhbSAge0RlY2liZWxzfSBhbW91bnQgVGhlIGFtb3VudCBvZiB0aGUgc291cmNlIHRvIHNlbmQgdG8gdGhlIGJ1cy4gXG5cdFx0ICogIEByZXR1cm4ge0dhaW5Ob2RlfSBUaGUgZ2FpbiBub2RlIHdoaWNoIGNvbm5lY3RzIHRoaXMgbm9kZSB0byB0aGUgZGVzaXJlZCBjaGFubmVsLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgIENhbiBiZSB1c2VkIHRvIGFkanVzdCB0aGUgbGV2ZWxzIG9mIHRoZSBzZW5kLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHNvdXJjZS5zZW5kKFwicmV2ZXJiXCIsIC0xMik7XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lLCBhbW91bnQpIHtcblx0ICAgICAgICBpZiAoIUJ1c2VzLmhhc093blByb3BlcnR5KGNoYW5uZWxOYW1lKSkge1xuXHQgICAgICAgICAgICBCdXNlc1tjaGFubmVsTmFtZV0gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBhbW91bnQgPSB0aGlzLmRlZmF1bHRBcmcoYW1vdW50LCAwKTtcblx0ICAgICAgICB2YXIgc2VuZEtub2IgPSBuZXcgVG9uZS5HYWluKGFtb3VudCwgVG9uZS5UeXBlLkRlY2liZWxzKTtcblx0ICAgICAgICB0aGlzLm91dHB1dC5jaGFpbihzZW5kS25vYiwgQnVzZXNbY2hhbm5lbE5hbWVdKTtcblx0ICAgICAgICByZXR1cm4gc2VuZEtub2I7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlY2lldmUgdGhlIGlucHV0IGZyb20gdGhlIGRlc2lyZWQgY2hhbm5lbE5hbWUgdG8gdGhlIGlucHV0XG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7c3RyaW5nfSBjaGFubmVsTmFtZSBBIG5hbWVkIGNoYW5uZWwgdG8gc2VuZCB0aGUgc2lnbmFsIHRvLlxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvTm9kZX0gW2lucHV0XSBJZiBubyBpbnB1dCBpcyBzZWxlY3RlZCwgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0IG9mIHRoZSBjdXJyZW50IG5vZGUgaXNcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvc2VuLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiByZXZlcmJFZmZlY3QucmVjZWl2ZShcInJldmVyYlwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbiAoY2hhbm5lbE5hbWUsIGlucHV0KSB7XG5cdCAgICAgICAgaWYgKCFCdXNlcy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsTmFtZSkpIHtcblx0ICAgICAgICAgICAgQnVzZXNbY2hhbm5lbE5hbWVdID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuaXNVbmRlZihpbnB1dCkpIHtcblx0ICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmlucHV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBCdXNlc1tjaGFubmVsTmFtZV0uY29ubmVjdChpbnB1dCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy9yZW1vdmUgYWxsIHRoZSBzZW5kL3JlY2VpdmVzIHdoZW4gYSBuZXcgYXVkaW8gY29udGV4dCBpcyBwYXNzZWQgaW5cblx0ICAgIFRvbmUuX2luaXRBdWRpb0NvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIEJ1c2VzID0ge307XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5EcmF3IGlzIHVzZWZ1bCBmb3Igc3luY2hyb25pemluZyB2aXN1YWxzIGFuZCBhdWRpbyBldmVudHMuXG5cdFx0ICogICAgICAgICBDYWxsYmFja3MgZnJvbSBUb25lLlRyYW5zcG9ydCBvciBhbnkgb2YgdGhlIFRvbmUuRXZlbnQgY2xhc3Nlc1xuXHRcdCAqICAgICAgICAgYWx3YXlzIGhhcHBlbiBfYmVmb3JlXyB0aGUgc2NoZWR1bGVkIHRpbWUgYW5kIGFyZSBub3Qgc3luY2hyb25pemVkXG5cdFx0ICogICAgICAgICB0byB0aGUgYW5pbWF0aW9uIGZyYW1lIHNvIHRoZXkgYXJlIG5vdCBnb29kIGZvciB0cmlnZ2VyaW5nIHRpZ2h0bHlcblx0XHQgKiAgICAgICAgIHN5bmNocm9uaXplZCB2aXN1YWxzIGFuZCBzb3VuZC4gVG9uZS5EcmF3IG1ha2VzIGl0IGVhc3kgdG8gc2NoZWR1bGVcblx0XHQgKiAgICAgICAgIGNhbGxiYWNrcyB1c2luZyB0aGUgQXVkaW9Db250ZXh0IHRpbWUgYW5kIHVzZXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBzaW5nbGV0b25cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHQvL3VzZSB0aGUgdGltZSBhcmd1bWVudCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrIHdpdGggVG9uZS5EcmF3XG5cdFx0ICogXHRUb25lLkRyYXcuc2NoZWR1bGUoZnVuY3Rpb24oKXtcblx0XHQgKiBcdFx0Ly9kbyBkcmF3aW5nIG9yIERPTSBtYW5pcHVsYXRpb24gaGVyZVxuXHRcdCAqIFx0fSwgdGltZSlcblx0XHQgKiB9LCBcIiswLjVcIilcblx0XHQgKi9cblx0ICAgIFRvbmUuRHJhdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGwgb2YgdGhlIGV2ZW50cy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVGltZWxpbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBUb25lLlRpbWVsaW5lKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGR1cmF0aW9uIGFmdGVyIHdoaWNoIGV2ZW50cyBhcmUgbm90IGludm9rZWQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQGRlZmF1bHQgMC4yNVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5leHBpcmF0aW9uID0gMC4yNTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHRpbWUgYmVmb3JlIHRoZSBzY2hlZHVsZWQgdGltZSBcblx0XHRcdCAqICB0aGF0IHRoZSBjYWxsYmFjayBjYW4gYmUgaW52b2tlZC4gRGVmYXVsdCBpc1xuXHRcdFx0ICogIGhhbGYgdGhlIHRpbWUgb2YgYW4gYW5pbWF0aW9uIGZyYW1lICgwLjAwOCBzZWNvbmRzKS5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAZGVmYXVsdCAwLjAwOFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hbnRpY2lwYXRpb24gPSAwLjAwODtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZHJhdyBsb29wXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYm91bmREcmF3TG9vcCA9IHRoaXMuX2RyYXdMb29wLmJpbmQodGhpcyk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgbG9vcFxuXHQgICAgICAgIHRoaXMuX2RyYXdMb29wKCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5EcmF3KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB0aW1lIHRvIGJlIGludm9rZWRcblx0XHQgKiAgb24gdGhlIG5lYXJlc3QgYW5pbWF0aW9uIGZyYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBDYWxsYmFjayBpcyBpbnZva2VkIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgICB0aW1lICAgICAgVGhlIHRpbWUgcmVsYXRpdmUgdG8gdGhlIEF1ZGlvQ29udGV4dCB0aW1lXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBpbnZva2UgdGhlIGNhbGxiYWNrLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5EcmF3fSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRyYXcucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmFkZCh7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcblx0ICAgICAgICAgICAgdGltZTogdGhpcy50b1NlY29uZHModGltZSlcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGV2ZW50cyBzY2hlZHVsZWQgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBhZnRlciAgVGltZSBhZnRlciB3aGljaCBzY2hlZHVsZWQgZXZlbnRzIHdpbGwgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2NoZWR1bGluZyB0aW1lbGluZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRHJhd30gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRHJhdy5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmNhbmNlbCh0aGlzLnRvU2Vjb25kcyhhZnRlcikpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZHJhdyBsb29wXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkRyYXcucHJvdG90eXBlLl9kcmF3TG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYm91bmREcmF3TG9vcCk7XG5cdCAgICAgICAgdmFyIG5vdyA9IFRvbmUubm93KCk7XG5cdCAgICAgICAgd2hpbGUgKHRoaXMuX2V2ZW50cy5sZW5ndGggJiYgdGhpcy5fZXZlbnRzLnBlZWsoKS50aW1lIC0gdGhpcy5hbnRpY2lwYXRpb24gPD0gbm93KSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50cy5zaGlmdCgpO1xuXHQgICAgICAgICAgICBpZiAobm93IC0gZXZlbnQudGltZSA8PSB0aGlzLmV4cGlyYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LmNhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy9tYWtlIGEgc2luZ2xldG9uXG5cdCAgICBUb25lLkRyYXcgPSBuZXcgVG9uZS5EcmF3KCk7XG5cdCAgICByZXR1cm4gVG9uZS5EcmF3O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEJvdGggVG9uZS5QYW5uZXIzRCBhbmQgVG9uZS5MaXN0ZW5lciBoYXZlIGEgcG9zaXRpb24gaW4gM0Qgc3BhY2UgXG5cdFx0ICogICAgICAgICAgdXNpbmcgYSByaWdodC1oYW5kZWQgY2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtLiBcblx0XHQgKiAgICAgICAgICBUaGUgdW5pdHMgdXNlZCBpbiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gYXJlIG5vdCBkZWZpbmVkOyBcblx0XHQgKiAgICAgICAgICB0aGVzZSBjb29yZGluYXRlcyBhcmUgaW5kZXBlbmRlbnQvaW52YXJpYW50IG9mIGFueSBwYXJ0aWN1bGFyIFxuXHRcdCAqICAgICAgICAgIHVuaXRzIHN1Y2ggYXMgbWV0ZXJzIG9yIGZlZXQuIFRvbmUuUGFubmVyM0Qgb2JqZWN0cyBoYXZlIGFuIGZvcndhcmQgXG5cdFx0ICogICAgICAgICAgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIHRoZSBzb3VuZCBpcyBwcm9qZWN0aW5nLiBBZGRpdGlvbmFsbHksIFxuXHRcdCAqICAgICAgICAgIHRoZXkgaGF2ZSBhIHNvdW5kIGNvbmUgcmVwcmVzZW50aW5nIGhvdyBkaXJlY3Rpb25hbCB0aGUgc291bmQgaXMuIFxuXHRcdCAqICAgICAgICAgIEZvciBleGFtcGxlLCB0aGUgc291bmQgY291bGQgYmUgb21uaWRpcmVjdGlvbmFsLCBpbiB3aGljaCBjYXNlIGl0IHdvdWxkIFxuXHRcdCAqICAgICAgICAgIGJlIGhlYXJkIGFueXdoZXJlIHJlZ2FyZGxlc3Mgb2YgaXRzIGZvcndhcmQsIG9yIGl0IGNhbiBiZSBtb3JlIGRpcmVjdGlvbmFsIFxuXHRcdCAqICAgICAgICAgIGFuZCBoZWFyZCBvbmx5IGlmIGl0IGlzIGZhY2luZyB0aGUgbGlzdGVuZXIuIFRvbmUuTGlzdGVuZXIgb2JqZWN0cyBcblx0XHQgKiAgICAgICAgICAocmVwcmVzZW50aW5nIGEgcGVyc29uJ3MgZWFycykgaGF2ZSBhbiBmb3J3YXJkIGFuZCB1cCB2ZWN0b3IgXG5cdFx0ICogICAgICAgICAgcmVwcmVzZW50aW5nIGluIHdoaWNoIGRpcmVjdGlvbiB0aGUgcGVyc29uIGlzIGZhY2luZy4gQmVjYXVzZSBib3RoIHRoZSBcblx0XHQgKiAgICAgICAgICBzb3VyY2Ugc3RyZWFtIGFuZCB0aGUgbGlzdGVuZXIgY2FuIGJlIG1vdmluZywgdGhleSBib3RoIGhhdmUgYSB2ZWxvY2l0eSBcblx0XHQgKiAgICAgICAgICB2ZWN0b3IgcmVwcmVzZW50aW5nIGJvdGggdGhlIHNwZWVkIGFuZCBkaXJlY3Rpb24gb2YgbW92ZW1lbnQuIFRha2VuIHRvZ2V0aGVyLCBcblx0XHQgKiAgICAgICAgICB0aGVzZSB0d28gdmVsb2NpdGllcyBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBhIGRvcHBsZXIgc2hpZnQgZWZmZWN0IHdoaWNoIGNoYW5nZXMgdGhlIHBpdGNoLlxuXHRcdCAqICAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgTm90ZTogdGhlIHBvc2l0aW9uIG9mIHRoZSBMaXN0ZW5lciB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIG5vZGVzIG5vdCBjb25uZWN0ZWQgdG8gYSBUb25lLlBhbm5lcjNEXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBzaW5nbGV0b25cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uWCBUaGUgaW5pdGlhbCB4IHBvc2l0aW9uLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25ZIFRoZSBpbml0aWFsIHkgcG9zaXRpb24uXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblogVGhlIGluaXRpYWwgeiBwb3NpdGlvbi5cblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdwb3NpdGlvblgnLFxuXHQgICAgICAgICAgICAncG9zaXRpb25ZJyxcblx0ICAgICAgICAgICAgJ3Bvc2l0aW9uWidcblx0ICAgICAgICBdLCBMaXN0ZW5lckNvbnN0cnVjdG9yLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbGlzdGVuZXIgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb0xpc3RlbmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9saXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkcyB0aGUgY3VycmVudCBmb3J3YXJkIG9yaWVudGF0aW9uXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBbXG5cdCAgICAgICAgICAgIG9wdGlvbnMuZm9yd2FyZFgsXG5cdCAgICAgICAgICAgIG9wdGlvbnMuZm9yd2FyZFksXG5cdCAgICAgICAgICAgIG9wdGlvbnMuZm9yd2FyZFosXG5cdCAgICAgICAgICAgIG9wdGlvbnMudXBYLFxuXHQgICAgICAgICAgICBvcHRpb25zLnVwWSxcblx0ICAgICAgICAgICAgb3B0aW9ucy51cFpcblx0ICAgICAgICBdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhvbGRzIHRoZSBjdXJyZW50IHBvc2l0aW9uXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBbXG5cdCAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb25YLFxuXHQgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uWSxcblx0ICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvblpcblx0ICAgICAgICBdO1xuXHQgICAgICAgIC8vIHNldCB0aGUgZGVmYXVsdCBwb3NpdGlvbi9mb3J3YXJkXG5cdCAgICAgICAgdGhpcy5mb3J3YXJkWCA9IG9wdGlvbnMuZm9yd2FyZFg7XG5cdCAgICAgICAgdGhpcy5mb3J3YXJkWSA9IG9wdGlvbnMuZm9yd2FyZFk7XG5cdCAgICAgICAgdGhpcy5mb3J3YXJkWiA9IG9wdGlvbnMuZm9yd2FyZFo7XG5cdCAgICAgICAgdGhpcy51cFggPSBvcHRpb25zLnVwWDtcblx0ICAgICAgICB0aGlzLnVwWSA9IG9wdGlvbnMudXBZO1xuXHQgICAgICAgIHRoaXMudXBaID0gb3B0aW9ucy51cFo7XG5cdCAgICAgICAgdGhpcy5wb3NpdGlvblggPSBvcHRpb25zLnBvc2l0aW9uWDtcblx0ICAgICAgICB0aGlzLnBvc2l0aW9uWSA9IG9wdGlvbnMucG9zaXRpb25ZO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb25aID0gb3B0aW9ucy5wb3NpdGlvblo7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5MaXN0ZW5lcik7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBEZWZhdWx0cyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb25cblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3Bvc2l0aW9uWCc6IDAsXG5cdCAgICAgICAgJ3Bvc2l0aW9uWSc6IDAsXG5cdCAgICAgICAgJ3Bvc2l0aW9uWic6IDAsXG5cdCAgICAgICAgJ2ZvcndhcmRYJzogMCxcblx0ICAgICAgICAnZm9yd2FyZFknOiAwLFxuXHQgICAgICAgICdmb3J3YXJkWic6IDEsXG5cdCAgICAgICAgJ3VwWCc6IDAsXG5cdCAgICAgICAgJ3VwWSc6IDEsXG5cdCAgICAgICAgJ3VwWic6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcmFtcCB0aW1lIHdoaWNoIGlzIGFwcGxpZWQgdG8gdGhlIHNldFRhcmdldEF0VGltZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLl9yYW1wVGltZUNvbnN0YW50ID0gMC4wMTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIgaW4gM2Qgc3BhY2UuXHRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB5XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHpcblx0XHQgKiAgQHJldHVybiB7VG9uZS5MaXN0ZW5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuXHQgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lci5wb3NpdGlvblgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyLnBvc2l0aW9uWC5zZXRUYXJnZXRBdFRpbWUoeCwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIucG9zaXRpb25ZLnNldFRhcmdldEF0VGltZSh5LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLl9saXN0ZW5lci5wb3NpdGlvblouc2V0VGFyZ2V0QXRUaW1lKHosIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIuc2V0UG9zaXRpb24oeCwgeSwgeik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0cyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGxpc3RlbmVyIHVzaW5nIHR3byB2ZWN0b3JzLCB0aGUgZm9yd2FyZFxuXHRcdCAqICB2ZWN0b3IgKHdoaWNoIGRpcmVjdGlvbiB0aGUgbGlzdGVuZXIgaXMgZmFjaW5nKSBhbmQgdGhlIHVwIHZlY3RvciBcblx0XHQgKiAgKHdoaWNoIHRoZSB1cCBkaXJlY3Rpb24gb2YgdGhlIGxpc3RlbmVyKS4gQW4gdXAgdmVjdG9yXG5cdFx0ICogIG9mIDAsIDAsIDEgaXMgZXF1aXZhbGVudCB0byB0aGUgbGlzdGVuZXIgc3RhbmRpbmcgdXAgaW4gdGhlIFogZGlyZWN0aW9uLiBcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB5XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHpcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdXBYXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHVwWVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB1cFpcblx0XHQgKiAgQHJldHVybiB7VG9uZS5MaXN0ZW5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeiwgdXBYLCB1cFksIHVwWikge1xuXHQgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lci5mb3J3YXJkWCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIuZm9yd2FyZFguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyLmZvcndhcmRZLnNldFRhcmdldEF0VGltZSh5LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLl9saXN0ZW5lci5mb3J3YXJkWi5zZXRUYXJnZXRBdFRpbWUoeiwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIudXBYLnNldFRhcmdldEF0VGltZSh1cFgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyLnVwWS5zZXRUYXJnZXRBdFRpbWUodXBZLCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLl9saXN0ZW5lci51cFouc2V0VGFyZ2V0QXRUaW1lKHVwWiwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9saXN0ZW5lci5zZXRPcmllbnRhdGlvbih4LCB5LCB6LCB1cFgsIHVwWSwgdXBaKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAncG9zaXRpb25YJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblswXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzBdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25ZXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdwb3NpdGlvblknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzFdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvblpcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3Bvc2l0aW9uWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMl0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblsyXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcnMgZnJvbnQgZGlyZWN0aW9uLiBpLmUuIFxuXHRcdCAqICB3aGljaCB3YXkgdGhleSBhcmUgZmFjaW5nLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgZm9yd2FyZFhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ2ZvcndhcmRYJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblswXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzBdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVycyBmcm9udCBkaXJlY3Rpb24uIGkuZS4gXG5cdFx0ICogIHdoaWNoIHdheSB0aGV5IGFyZSBmYWNpbmcuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBmb3J3YXJkWVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAnZm9yd2FyZFknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzFdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXJzIGZyb250IGRpcmVjdGlvbi4gaS5lLiBcblx0XHQgKiAgd2hpY2ggd2F5IHRoZXkgYXJlIGZhY2luZy5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIGZvcndhcmRaXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdmb3J3YXJkWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMl0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblsyXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcidzIHVwIGRpcmVjdGlvbi4gaS5lLlxuXHRcdCAqICB0aGUgZGlyZWN0aW9uIHRoZSBsaXN0ZW5lciBpcyBzdGFuZGluZyBpbi5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHVwWFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAndXBYJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblszXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzNdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVyJ3MgdXAgZGlyZWN0aW9uLiBpLmUuXG5cdFx0ICogIHRoZSBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIHN0YW5kaW5nIGluLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgdXBZXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICd1cFknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzRdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bNF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXIncyB1cCBkaXJlY3Rpb24uIGkuZS5cblx0XHQgKiAgdGhlIGRpcmVjdGlvbiB0aGUgbGlzdGVuZXIgaXMgc3RhbmRpbmcgaW4uXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSB1cFpcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3VwWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bNV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbls1XTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTGlzdGVuZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2xpc3RlbmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vU0lOR0xFVE9OIFNFVFVQXG5cdCAgICB2YXIgTGlzdGVuZXJDb25zdHJ1Y3RvciA9IFRvbmUuTGlzdGVuZXI7XG5cdCAgICBUb25lLl9pbml0QXVkaW9Db250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIFRvbmUuTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgLy9hIHNpbmdsZSBsaXN0ZW5lciBvYmplY3Rcblx0ICAgICAgICAgICAgVG9uZS5MaXN0ZW5lciA9IG5ldyBUb25lLkxpc3RlbmVyKCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9tYWtlIG5ldyBMaXN0ZW5lciBpbnNpZGVzXG5cdCAgICAgICAgICAgIExpc3RlbmVyQ29uc3RydWN0b3IuY2FsbChUb25lLkxpc3RlbmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vRU5EIFNJTkdMRVRPTiBTRVRVUFxuXHQgICAgcmV0dXJuIFRvbmUuTGlzdGVuZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogXHRAY2xhc3MgIFRvbmUuRWZmZWN0IGlzIHRoZSBiYXNlIGNsYXNzIGZvciBlZmZlY3RzLiBDb25uZWN0IHRoZSBlZmZlY3QgYmV0d2VlblxuXHRcdCAqIFx0ICAgICAgICB0aGUgZWZmZWN0U2VuZCBhbmQgZWZmZWN0UmV0dXJuIEdhaW5Ob2RlcywgdGhlbiBjb250cm9sIHRoZSBhbW91bnQgb2Zcblx0XHQgKiBcdCAgICAgICAgZWZmZWN0IHdoaWNoIGdvZXMgdG8gdGhlIG91dHB1dCB1c2luZyB0aGUgd2V0IGNvbnRyb2wuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfE9iamVjdH0gW3dldF0gVGhlIHN0YXJ0aW5nIHdldCB2YWx1ZS4gXG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLy9nZXQgYWxsIG9mIHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWyd3ZXQnXSwgVG9uZS5FZmZlY3QuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkcnl3ZXQga25vYiB0byBjb250cm9sIHRoZSBhbW91bnQgb2YgZWZmZWN0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ3Jvc3NGYWRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kcnlXZXQgPSBuZXcgVG9uZS5Dcm9zc0ZhZGUob3B0aW9ucy53ZXQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB3ZXQgY29udHJvbCBpcyBob3cgbXVjaCBvZiB0aGUgZWZmZWN0ZWRcblx0XHRcdCAqICB3aWxsIHBhc3MgdGhyb3VnaCB0byB0aGUgb3V0cHV0LiAxID0gMTAwJSBlZmZlY3RlZFxuXHRcdFx0ICogIHNpZ25hbCwgMCA9IDEwMCUgZHJ5IHNpZ25hbC4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMud2V0ID0gdGhpcy5fZHJ5V2V0LmZhZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29ubmVjdCB0aGUgZWZmZWN0U2VuZCB0byB0aGUgaW5wdXQgb2YgaHRlIGVmZmVjdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBjb25uZWN0IHRoZSBvdXRwdXQgb2YgdGhlIGVmZmVjdCB0byB0aGUgZWZmZWN0UmV0dXJuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm4gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9kcnlXZXQuYSk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuZWZmZWN0U2VuZCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm4uY29ubmVjdCh0aGlzLl9kcnlXZXQuYik7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnd2V0J10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdC5kZWZhdWx0cyA9IHsgJ3dldCc6IDEgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjaGFpbnMgdGhlIGVmZmVjdCBpbiBiZXR3ZWVuIHRoZSBlZmZlY3RTZW5kIGFuZCBlZmZlY3RSZXR1cm5cblx0XHQgKiAgQHBhcmFtICB7VG9uZX0gZWZmZWN0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmNvbm5lY3RFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNoYWluKGVmZmVjdCwgdGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ3dldCddKTtcblx0ICAgICAgICB0aGlzLndldCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5BdXRvRmlsdGVyIGlzIGEgVG9uZS5GaWx0ZXIgd2l0aCBhIFRvbmUuTEZPIGNvbm5lY3RlZCB0byB0aGUgZmlsdGVyIGN1dG9mZiBmcmVxdWVuY3kuXG5cdFx0ICogICAgICAgICBTZXR0aW5nIHRoZSBMRk8gcmF0ZSBhbmQgZGVwdGggYWxsb3dzIGZvciBjb250cm9sIG92ZXIgdGhlIGZpbHRlciBtb2R1bGF0aW9uIHJhdGUgXG5cdFx0ICogICAgICAgICBhbmQgZGVwdGguXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2ZyZXF1ZW5jeV0gVGhlIHJhdGUgb2YgdGhlIExGTy5cblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3k9fSBiYXNlRnJlcXVlbmN5IFRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgTEZPcyBvc2NpbGxhdGlvblxuXHQgXHQgKiAgQHBhcmFtIHtGcmVxdWVuY3k9fSBvY3RhdmVzIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyBhYm92ZSB0aGUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY3JlYXRlIGFuIGF1dG9maWx0ZXIgYW5kIHN0YXJ0IGl0J3MgTEZPXG5cdFx0ICogdmFyIGF1dG9GaWx0ZXIgPSBuZXcgVG9uZS5BdXRvRmlsdGVyKFwiNG5cIikudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqIC8vcm91dGUgYW4gb3NjaWxsYXRvciB0aHJvdWdoIHRoZSBmaWx0ZXIgYW5kIHN0YXJ0IGl0XG5cdFx0ICogdmFyIG9zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdChhdXRvRmlsdGVyKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2Jhc2VGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnb2N0YXZlcydcblx0ICAgICAgICBdLCBUb25lLkF1dG9GaWx0ZXIuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBkcml2ZXMgdGhlIGZpbHRlciBjdXRvZmZcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2FtcGxpdHVkZSc6IG9wdGlvbnMuZGVwdGhcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSByYW5nZSBvZiB0aGUgZmlsdGVyIG1vZHVsYXRpbmcgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggZnJlcXVlbmN5LiBcblx0XHRcdCAqIDAgPSBubyBtb2R1bGF0aW9uLiAxID0gZnVsbCBtb2R1bGF0aW9uLlxuXHRcdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2xmby5hbXBsaXR1ZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBIb3cgZmFzdCB0aGUgZmlsdGVyIG1vZHVsYXRlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LiBcblx0XHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmby5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpbHRlciBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgVG9uZS5GaWx0ZXIob3B0aW9ucy5maWx0ZXIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvY3RhdmVzIHBsYWNlaG9sZGVyXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vY3RhdmVzID0gMDtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuZmlsdGVyKTtcblx0ICAgICAgICB0aGlzLl9sZm8uY29ubmVjdCh0aGlzLmZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIHRoaXMuYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgIH07XG5cdCAgICAvL2V4dGVuZCBFZmZlY3Rcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXV0b0ZpbHRlciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHRzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnZGVwdGgnOiAxLFxuXHQgICAgICAgICdiYXNlRnJlcXVlbmN5JzogMjAwLFxuXHQgICAgICAgICdvY3RhdmVzJzogMi42LFxuXHQgICAgICAgICdmaWx0ZXInOiB7XG5cdCAgICAgICAgICAgICd0eXBlJzogJ2xvd3Bhc3MnLFxuXHQgICAgICAgICAgICAncm9sbG9mZic6IC0xMixcblx0ICAgICAgICAgICAgJ1EnOiAxXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN0YXJ0IHRoZSBlZmZlY3QuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIExGTyB3aWxsIHN0YXJ0LiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RvcCB0aGUgZWZmZWN0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBMRk8gd2lsbCBzdG9wLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN5bmMgdGhlIGZpbHRlciB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW2RlbGF5PTBdIERlbGF5IHRpbWUgYmVmb3JlIHN0YXJ0aW5nIHRoZSBlZmZlY3QgYWZ0ZXIgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0IGhhcyBzdGFydGVkLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoZGVsYXkpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3luYyhkZWxheSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVW5zeW5jIHRoZSBmaWx0ZXIgZnJvbSB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2xmby51bnN5bmMoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUeXBlIG9mIG9zY2lsbGF0b3IgYXR0YWNoZWQgdG8gdGhlIEF1dG9GaWx0ZXIuIFxuXHRcdCAqIFBvc3NpYmxlIHZhbHVlczogXCJzaW5lXCIsIFwic3F1YXJlXCIsIFwidHJpYW5nbGVcIiwgXCJzYXd0b290aFwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9GaWx0ZXIjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvRmlsdGVyLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm8udHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIGZpbHRlcidzIGN1dG9mZiBmcmVxdWVuY3kuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b0ZpbHRlciNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUsICdiYXNlRnJlcXVlbmN5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGZyZXEpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLm1pbiA9IHRoaXMudG9GcmVxdWVuY3koZnJlcSk7XG5cdCAgICAgICAgICAgIC8vYW5kIHNldCB0aGUgbWF4XG5cdCAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgZmlsdGVyJ3MgY3V0b2ZmIGZyZXF1ZW5jeS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b0ZpbHRlciNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdCkge1xuXHQgICAgICAgICAgICB0aGlzLl9vY3RhdmVzID0gb2N0O1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8ubWF4ID0gdGhpcy5iYXNlRnJlcXVlbmN5ICogTWF0aC5wb3coMiwgb2N0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZpbHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXV0b0ZpbHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQXV0b1Bhbm5lciBpcyBhIFRvbmUuUGFubmVyIHdpdGggYW4gTEZPIGNvbm5lY3RlZCB0byB0aGUgcGFuIGFtb3VudC4gXG5cdFx0ICogICAgICAgICBNb3JlIG9uIHVzaW5nIGF1dG9wYW5uZXJzIFtoZXJlXShodHRwczovL3d3dy5hYmxldG9uLmNvbS9lbi9ibG9nL2F1dG9wYW4tY2hvcHBlci1lZmZlY3QtYW5kLW1vcmUtbGl2ZXNjaG9vbC8pLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gUmF0ZSBvZiBsZWZ0LXJpZ2h0IG9zY2lsbGF0aW9uLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NyZWF0ZSBhbiBhdXRvcGFubmVyIGFuZCBzdGFydCBpdCdzIExGT1xuXHRcdCAqIHZhciBhdXRvUGFubmVyID0gbmV3IFRvbmUuQXV0b1Bhbm5lcihcIjRuXCIpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKiAvL3JvdXRlIGFuIG9zY2lsbGF0b3IgdGhyb3VnaCB0aGUgcGFubmVyIGFuZCBzdGFydCBpdFxuXHRcdCAqIHZhciBvc2NpbGxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcigpLmNvbm5lY3QoYXV0b1Bhbm5lcikuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFsnZnJlcXVlbmN5J10sIFRvbmUuQXV0b1Bhbm5lci5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGZvIHdoaWNoIGRyaXZlcyB0aGUgcGFubmluZ1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAnYW1wbGl0dWRlJzogb3B0aW9ucy5kZXB0aCxcblx0ICAgICAgICAgICAgJ21pbic6IC0xLFxuXHQgICAgICAgICAgICAnbWF4JzogMVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGFtb3VudCBvZiBwYW5uaW5nIGJldHdlZW4gbGVmdCBhbmQgcmlnaHQuIFxuXHRcdFx0ICogMCA9IGFsd2F5cyBjZW50ZXIuIDEgPSBmdWxsIHJhbmdlIGJldHdlZW4gbGVmdCBhbmQgcmlnaHQuIFxuXHRcdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2xmby5hbXBsaXR1ZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBhbm5lciBub2RlIHdoaWNoIGRvZXMgdGhlIHBhbm5pbmdcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5QYW5uZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lciA9IG5ldyBUb25lLlBhbm5lcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogSG93IGZhc3QgdGhlIHBhbm5lciBtb2R1bGF0ZXMgYmV0d2VlbiBsZWZ0IGFuZCByaWdodC4gXG5cdFx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9sZm8uZnJlcXVlbmN5O1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmNvbm5lY3RFZmZlY3QodGhpcy5fcGFubmVyKTtcblx0ICAgICAgICB0aGlzLl9sZm8uY29ubmVjdCh0aGlzLl9wYW5uZXIucGFuKTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZGVwdGgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIC8vZXh0ZW5kIEVmZmVjdFxuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BdXRvUGFubmVyLCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdHNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvUGFubmVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiAxLFxuXHQgICAgICAgICd0eXBlJzogJ3NpbmUnLFxuXHQgICAgICAgICdkZXB0aCc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdGFydCB0aGUgZWZmZWN0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBMRk8gd2lsbCBzdGFydC4gXG5cdFx0ICogQHJldHVybnMge1RvbmUuQXV0b1Bhbm5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvUGFubmVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN0b3AgdGhlIGVmZmVjdC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgTEZPIHdpbGwgc3RvcC4gXG5cdFx0ICogQHJldHVybnMge1RvbmUuQXV0b1Bhbm5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvUGFubmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTeW5jIHRoZSBwYW5uZXIgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFtkZWxheT0wXSBEZWxheSB0aW1lIGJlZm9yZSBzdGFydGluZyB0aGUgZWZmZWN0IGFmdGVyIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zcG9ydCBoYXMgc3RhcnRlZC4gXG5cdFx0ICogQHJldHVybnMge1RvbmUuQXV0b1Bhbm5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvUGFubmVyLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKGRlbGF5KSB7XG5cdCAgICAgICAgdGhpcy5fbGZvLnN5bmMoZGVsYXkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFVuc3luYyB0aGUgcGFubmVyIGZyb20gdGhlIHRyYW5zcG9ydFxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2xmby51bnN5bmMoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUeXBlIG9mIG9zY2lsbGF0b3IgYXR0YWNoZWQgdG8gdGhlIEF1dG9GaWx0ZXIuIFxuXHRcdCAqIFBvc3NpYmxlIHZhbHVlczogXCJzaW5lXCIsIFwic3F1YXJlXCIsIFwidHJpYW5nbGVcIiwgXCJzYXd0b290aFwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9GaWx0ZXIjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvUGFubmVyLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm8udHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZGVwdGgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRlcHRoID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BdXRvUGFubmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuQXV0b1dhaCBjb25uZWN0cyBhIFRvbmUuRm9sbG93ZXIgdG8gYSBiYW5kcGFzcyBmaWx0ZXIgKFRvbmUuRmlsdGVyKS5cblx0XHQgKiAgICAgICAgICBUaGUgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXIgaXMgYWRqdXN0ZWQgcHJvcG9ydGlvbmFsbHkgdG8gdGhlIFxuXHRcdCAqICAgICAgICAgIGluY29taW5nIHNpZ25hbCdzIGFtcGxpdHVkZS4gSW5zcGlyYXRpb24gZnJvbSBbVHVuYS5qc10oaHR0cHM6Ly9naXRodWIuY29tL0RpbmFobW9lL3R1bmEpLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2Jhc2VGcmVxdWVuY3ldIFRoZSBmcmVxdWVuY3kgdGhlIGZpbHRlciBpcyBzZXQgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGF0IHRoZSBsb3cgcG9pbnQgb2YgdGhlIHdhaFxuXHRcdCAqICBAcGFyYW0ge1Bvc2l0aXZlfSBbb2N0YXZlc10gVGhlIG51bWJlciBvZiBvY3RhdmVzIGFib3ZlIHRoZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaWx0ZXIgd2lsbCBzd2VlcCB0byB3aGVuIGZ1bGx5IG9wZW5cblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc30gW3NlbnNpdGl2aXR5XSBUaGUgZGVjaWJlbCB0aHJlc2hvbGQgc2Vuc2l0aXZpdHkgZm9yIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgaW5jb21pbmcgc2lnbmFsLiBOb3JtYWwgcmFuZ2Ugb2YgLTQwIHRvIDAuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBhdXRvV2FoID0gbmV3IFRvbmUuQXV0b1dhaCg1MCwgNiwgLTMwKS50b01hc3RlcigpO1xuXHRcdCAqIC8vaW5pdGlhbGl6ZSB0aGUgc3ludGggYW5kIGNvbm5lY3QgdG8gYXV0b3dhaFxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBTeW50aC5jb25uZWN0KGF1dG9XYWgpO1xuXHRcdCAqIC8vUSB2YWx1ZSBpbmZsdWVuY2VzIHRoZSBlZmZlY3Qgb2YgdGhlIHdhaCAtIGRlZmF1bHQgaXMgMlxuXHRcdCAqIGF1dG9XYWguUS52YWx1ZSA9IDY7XG5cdFx0ICogLy9tb3JlIGF1ZGlibGUgb24gaGlnaGVyIG5vdGVzXG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjhuXCIpXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9XYWggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdiYXNlRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ29jdGF2ZXMnLFxuXHQgICAgICAgICAgICAnc2Vuc2l0aXZpdHknXG5cdCAgICAgICAgXSwgVG9uZS5BdXRvV2FoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBlbnZlbG9wZSBmb2xsb3dlci4gU2V0IHRoZSBhdHRhY2svcmVsZWFzZVxuXHRcdFx0ICogIHRpbWluZyB0byBhZGp1c3QgaG93IHRoZSBlbnZlbG9wZSBpcyBmb2xsb3dlZC4gXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRm9sbG93ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZm9sbG93ZXIgPSBuZXcgVG9uZS5Gb2xsb3dlcihvcHRpb25zLmZvbGxvd2VyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZXMgdGhlIGZvbGxvd2VyIHZhbHVlIHRvIHRoZSBmcmVxdWVuY3kgZG9tYWluXG5cdFx0XHQgKiAgQHR5cGUge1RvbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UgPSBuZXcgVG9uZS5TY2FsZUV4cCgwLCAxLCAwLjUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2Jhc2VGcmVxdWVuY3kgPSBvcHRpb25zLmJhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgaW5wdXQgZ2FpbiB0byBhZGp1c3QgdGhlIHNlbnNpdGl2aXR5XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5wdXRCb29zdCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7QmlxdWFkRmlsdGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmFuZHBhc3MgPSBuZXcgVG9uZS5GaWx0ZXIoe1xuXHQgICAgICAgICAgICAncm9sbG9mZic6IC00OCxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IDAsXG5cdCAgICAgICAgICAgICdRJzogb3B0aW9ucy5RXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wZWFraW5nID0gbmV3IFRvbmUuRmlsdGVyKDAsICdwZWFraW5nJyk7XG5cdCAgICAgICAgdGhpcy5fcGVha2luZy5nYWluLnZhbHVlID0gb3B0aW9ucy5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gb2YgdGhlIGZpbHRlci5cblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmdhaW4gPSB0aGlzLl9wZWFraW5nLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgcXVhbGl0eSBvZiB0aGUgZmlsdGVyLlxuXHRcdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5RID0gdGhpcy5fYmFuZHBhc3MuUTtcblx0ICAgICAgICAvL3RoZSBjb250cm9sIHNpZ25hbCBwYXRoXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNoYWluKHRoaXMuX2lucHV0Qm9vc3QsIHRoaXMuZm9sbG93ZXIsIHRoaXMuX3N3ZWVwUmFuZ2UpO1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UuY29ubmVjdCh0aGlzLl9iYW5kcGFzcy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UuY29ubmVjdCh0aGlzLl9wZWFraW5nLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy90aGUgZmlsdGVyZWQgcGF0aFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5jaGFpbih0aGlzLl9iYW5kcGFzcywgdGhpcy5fcGVha2luZywgdGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlXG5cdCAgICAgICAgdGhpcy5fc2V0U3dlZXBSYW5nZSgpO1xuXHQgICAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBvcHRpb25zLnNlbnNpdGl2aXR5O1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2dhaW4nLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkF1dG9XYWgsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9XYWguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAxMDAsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiA2LFxuXHQgICAgICAgICdzZW5zaXRpdml0eSc6IDAsXG5cdCAgICAgICAgJ1EnOiAyLFxuXHQgICAgICAgICdnYWluJzogMixcblx0ICAgICAgICAnZm9sbG93ZXInOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjMsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyB0aGF0IHRoZSBmaWx0ZXIgd2lsbCBzd2VlcCBhYm92ZSB0aGUgXG5cdFx0ICogYmFzZUZyZXF1ZW5jeS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b1dhaCNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIG9jdGF2ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9XYWgucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3RhdmVzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvY3RhdmVzO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRTd2VlcFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYmFzZSBmcmVxdWVuY3kgZnJvbSB3aGljaCB0aGUgc3dlZXAgd2lsbCBzdGFydCBmcm9tLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9XYWgjXG5cdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiBAbmFtZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvV2FoLnByb3RvdHlwZSwgJ2Jhc2VGcmVxdWVuY3knLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYmFzZUZyZXEpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYmFzZUZyZXF1ZW5jeSA9IGJhc2VGcmVxO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRTd2VlcFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc2Vuc2l0aXZpdHkgdG8gY29udHJvbCBob3cgcmVzcG9uc2l2ZSB0byB0aGUgaW5wdXQgc2lnbmFsIHRoZSBmaWx0ZXIgaXMuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9XYWgjXG5cdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdCAqIEBuYW1lIHNlbnNpdGl2aXR5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvV2FoLnByb3RvdHlwZSwgJ3NlbnNpdGl2aXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5nYWluVG9EYigxIC8gdGhpcy5faW5wdXRCb29zdC5nYWluLnZhbHVlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNlbnNpdGl2eSkge1xuXHQgICAgICAgICAgICB0aGlzLl9pbnB1dEJvb3N0LmdhaW4udmFsdWUgPSAxIC8gdGhpcy5kYlRvR2FpbihzZW5zaXRpdnkpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIHNldHMgdGhlIHN3ZWVwIHJhbmdlIG9mIHRoZSBzY2FsZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1dhaC5wcm90b3R5cGUuX3NldFN3ZWVwUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5taW4gPSB0aGlzLl9iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMuX3N3ZWVwUmFuZ2UubWF4ID0gTWF0aC5taW4odGhpcy5fYmFzZUZyZXF1ZW5jeSAqIE1hdGgucG93KDIsIHRoaXMuX29jdGF2ZXMpLCB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZSAvIDIpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXV0b1dhaH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvV2FoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5mb2xsb3dlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mb2xsb3dlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYmFuZHBhc3MuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2JhbmRwYXNzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9wZWFraW5nLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wZWFraW5nID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9pbnB1dEJvb3N0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9pbnB1dEJvb3N0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdnYWluJyxcblx0ICAgICAgICAgICAgJ1EnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5nYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkF1dG9XYWg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkJpdGNydXNoZXIgZG93bnNhbXBsZXMgdGhlIGluY29taW5nIHNpZ25hbCB0byBhIGRpZmZlcmVudCBiaXRkZXB0aC4gXG5cdFx0ICogICAgICAgICBMb3dlcmluZyB0aGUgYml0ZGVwdGggb2YgdGhlIHNpZ25hbCBjcmVhdGVzIGRpc3RvcnRpb24uIFJlYWQgbW9yZSBhYm91dCBCaXRjcnVzaGluZ1xuXHRcdCAqICAgICAgICAgb24gW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQml0Y3J1c2hlcikuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIGRvd25zYW1wbGUgdGhlIHNpZ25hbC4gTm9taW5hbCByYW5nZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICBvZiAxIHRvIDguIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaW5pdGlhbGl6ZSBjcnVzaGVyIGFuZCByb3V0ZSBhIHN5bnRoIHRocm91Z2ggaXRcblx0XHQgKiB2YXIgY3J1c2hlciA9IG5ldyBUb25lLkJpdENydXNoZXIoNCkudG9NYXN0ZXIoKTtcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5Nb25vU3ludGgoKS5jb25uZWN0KGNydXNoZXIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CaXRDcnVzaGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWydiaXRzJ10sIFRvbmUuQml0Q3J1c2hlci5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICB2YXIgaW52U3RlcFNpemUgPSAxIC8gTWF0aC5wb3coMiwgb3B0aW9ucy5iaXRzIC0gMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU3VidHJhY3QgdGhlIGlucHV0IHNpZ25hbCBhbmQgdGhlIG1vZHVsdXMgb2YgdGhlIGlucHV0IHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG5ldyBUb25lLlN1YnRyYWN0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZCBmdW5jdGlvblxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Nb2R1bG99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsbyA9IG5ldyBUb25lLk1vZHVsbyhpbnZTdGVwU2l6ZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAga2VlcHMgdHJhY2sgb2YgdGhlIGJpdHNcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iaXRzID0gb3B0aW9ucy5iaXRzO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5mYW4odGhpcy5fc3VidHJhY3QsIHRoaXMuX21vZHVsbyk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxvLmNvbm5lY3QodGhpcy5fc3VidHJhY3QsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQml0Q3J1c2hlciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJpdENydXNoZXIuZGVmYXVsdHMgPSB7ICdiaXRzJzogNCB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGJpdCBkZXB0aCBvZiB0aGUgZWZmZWN0LiBOb21pbmFsIHJhbmdlIG9mIDEtOC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQml0Q3J1c2hlciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGJpdHNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJpdENydXNoZXIucHJvdG90eXBlLCAnYml0cycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiaXRzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2JpdHMgPSBiaXRzO1xuXHQgICAgICAgICAgICB2YXIgaW52U3RlcFNpemUgPSAxIC8gTWF0aC5wb3coMiwgYml0cyAtIDEpO1xuXHQgICAgICAgICAgICB0aGlzLl9tb2R1bG8udmFsdWUgPSBpbnZTdGVwU2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkJpdENydXNoZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQml0Q3J1c2hlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bG8gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJpdENydXNoZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkNoZWJ5U2hldiBpcyBhIENoZWJ5c2hldiB3YXZlc2hhcGVyLCBhbiBlZmZlY3Qgd2hpY2ggaXMgZ29vZCBcblx0XHQgKiAgICAgICAgIGZvciBtYWtpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGRpc3RvcnRpb24gc291bmRzLlxuXHRcdCAqICAgICAgICAgTm90ZSB0aGF0IG9kZCBvcmRlcnMgc291bmQgdmVyeSBkaWZmZXJlbnQgZnJvbSBldmVuIG9uZXMsIFxuXHRcdCAqICAgICAgICAgYW5kIG9yZGVyID0gMSBpcyBubyBjaGFuZ2UuIFxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIGF0IFttdXNpYy5jb2x1bWJpYS5lZHVdKGh0dHA6Ly9tdXNpYy5jb2x1bWJpYS5lZHUvY21jL211c2ljYW5kY29tcHV0ZXJzL2NoYXB0ZXI0LzA0XzA2LnBocCkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtQb3NpdGl2ZXxPYmplY3R9IFtvcmRlcl0gVGhlIG9yZGVyIG9mIHRoZSBjaGVieXNoZXYgcG9seW5vbWlhbC4gTm9ybWFsIHJhbmdlIGJldHdlZW4gMS0xMDAuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY3JlYXRlIGEgbmV3IGNoZWJ5XG5cdFx0ICogdmFyIGNoZWJ5ID0gbmV3IFRvbmUuQ2hlYnlzaGV2KDUwKTtcblx0XHQgKiAvL2NyZWF0ZSBhIG1vbm9zeW50aCBjb25uZWN0ZWQgdG8gb3VyIGNoZWJ5XG5cdFx0ICogc3ludGggPSBuZXcgVG9uZS5Nb25vU3ludGgoKS5jb25uZWN0KGNoZWJ5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWydvcmRlciddLCBUb25lLkNoZWJ5c2hldi5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7V2F2ZVNoYXBlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG5ldyBUb25lLldhdmVTaGFwZXIoNDA5Nik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBob2xkcyBvbnRvIHRoZSBvcmRlciBvZiB0aGUgZmlsdGVyXG5cdFx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29yZGVyID0gb3B0aW9ucy5vcmRlcjtcblx0ICAgICAgICB0aGlzLmNvbm5lY3RFZmZlY3QodGhpcy5fc2hhcGVyKTtcblx0ICAgICAgICB0aGlzLm9yZGVyID0gb3B0aW9ucy5vcmRlcjtcblx0ICAgICAgICB0aGlzLm92ZXJzYW1wbGUgPSBvcHRpb25zLm92ZXJzYW1wbGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DaGVieXNoZXYsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DaGVieXNoZXYuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29yZGVyJzogMSxcblx0ICAgICAgICAnb3ZlcnNhbXBsZSc6ICdub25lJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBnZXQgdGhlIGNvZWZmaWNpZW50IGZvciB0aGF0IGRlZ3JlZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0geCB0aGUgeCB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gICB7bnVtYmVyfSBkZWdyZWUgXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBtZW1vIG1lbW9pemUgdGhlIGNvbXB1dGVkIHZhbHVlLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBzcGVlZHMgdXAgY29tcHV0YXRpb24gZ3JlYXRseS4gXG5cdFx0ICogIEByZXR1cm4gIHtudW1iZXJ9ICAgICAgIHRoZSBjb2VmZmljaWVudCBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2LnByb3RvdHlwZS5fZ2V0Q29lZmZpY2llbnQgPSBmdW5jdGlvbiAoeCwgZGVncmVlLCBtZW1vKSB7XG5cdCAgICAgICAgaWYgKG1lbW8uaGFzT3duUHJvcGVydHkoZGVncmVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWVtb1tkZWdyZWVdO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZGVncmVlID09PSAwKSB7XG5cdCAgICAgICAgICAgIG1lbW9bZGVncmVlXSA9IDA7XG5cdCAgICAgICAgfSBlbHNlIGlmIChkZWdyZWUgPT09IDEpIHtcblx0ICAgICAgICAgICAgbWVtb1tkZWdyZWVdID0geDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBtZW1vW2RlZ3JlZV0gPSAyICogeCAqIHRoaXMuX2dldENvZWZmaWNpZW50KHgsIGRlZ3JlZSAtIDEsIG1lbW8pIC0gdGhpcy5fZ2V0Q29lZmZpY2llbnQoeCwgZGVncmVlIC0gMiwgbWVtbyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBtZW1vW2RlZ3JlZV07XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG9yZGVyIG9mIHRoZSBDaGVieXNoZXYgcG9seW5vbWlhbCB3aGljaCBjcmVhdGVzXG5cdFx0ICogdGhlIGVxdWF0aW9uIHdoaWNoIGlzIGFwcGxpZWQgdG8gdGhlIGluY29taW5nIFxuXHRcdCAqIHNpZ25hbCB0aHJvdWdoIGEgVG9uZS5XYXZlU2hhcGVyLiBUaGUgZXF1YXRpb25zXG5cdFx0ICogYXJlIGluIHRoZSBmb3JtOjxicj5cblx0XHQgKiBvcmRlciAyOiAyeF4yICsgMTxicj5cblx0XHQgKiBvcmRlciAzOiA0eF4zICsgM3ggPGJyPlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkNoZWJ5c2hldiNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb3JkZXJcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNoZWJ5c2hldi5wcm90b3R5cGUsICdvcmRlcicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yZGVyO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob3JkZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcblx0ICAgICAgICAgICAgdmFyIGN1cnZlID0gbmV3IEFycmF5KDQwOTYpO1xuXHQgICAgICAgICAgICB2YXIgbGVuID0gY3VydmUubGVuZ3RoO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgeCA9IGkgKiAyIC8gbGVuIC0gMTtcblx0ICAgICAgICAgICAgICAgIGlmICh4ID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9zaG91bGQgb3V0cHV0IDAgd2hlbiBpbnB1dCBpcyAwXG5cdCAgICAgICAgICAgICAgICAgICAgY3VydmVbaV0gPSAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBjdXJ2ZVtpXSA9IHRoaXMuX2dldENvZWZmaWNpZW50KHgsIG9yZGVyLCB7fSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fc2hhcGVyLmN1cnZlID0gY3VydmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgb3ZlcnNhbXBsaW5nIG9mIHRoZSBlZmZlY3QuIENhbiBlaXRoZXIgYmUgXCJub25lXCIsIFwiMnhcIiBvciBcIjR4XCIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hlYnlzaGV2I1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgb3ZlcnNhbXBsZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hlYnlzaGV2LnByb3RvdHlwZSwgJ292ZXJzYW1wbGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG92ZXJzYW1wbGluZykge1xuXHQgICAgICAgICAgICB0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZSA9IG92ZXJzYW1wbGluZztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNoZWJ5c2hldn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DaGVieXNoZXYucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ2hlYnlzaGV2O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQmFzZSBjbGFzcyBmb3IgU3RlcmVvIGVmZmVjdHMuIFByb3ZpZGVzIGVmZmVjdFNlbmRML1IgYW5kIGVmZmVjdFJldHVybkwvUi4gXG5cdFx0ICpcblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvL2dldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFsnd2V0J10sIFRvbmUuRWZmZWN0LmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZHJ5d2V0IGtub2IgdG8gY29udHJvbCB0aGUgYW1vdW50IG9mIGVmZmVjdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkNyb3NzRmFkZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0ID0gbmV3IFRvbmUuQ3Jvc3NGYWRlKG9wdGlvbnMud2V0KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgd2V0IGNvbnRyb2wsIGkuZS4gaG93IG11Y2ggb2YgdGhlIGVmZmVjdGVkXG5cdFx0XHQgKiAgd2lsbCBwYXNzIHRocm91Z2ggdG8gdGhlIG91dHB1dC4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMud2V0ID0gdGhpcy5fZHJ5V2V0LmZhZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlbiBzcGxpdCBpdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNwbGl0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zcGxpdCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGVmZmVjdHMgc2VuZCBMRUZUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMID0gdGhpcy5fc3BsaXQubGVmdDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZWZmZWN0cyBzZW5kIFJJR0hUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSID0gdGhpcy5fc3BsaXQucmlnaHQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHN0ZXJlbyBlZmZlY3QgbWVyZ2VyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTWVyZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gbmV3IFRvbmUuTWVyZ2UoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZWZmZWN0IHJldHVybiBMRUZUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybkwgPSB0aGlzLl9tZXJnZS5sZWZ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBlZmZlY3QgcmV0dXJuIFJJR0hUXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVyblIgPSB0aGlzLl9tZXJnZS5yaWdodDtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX3NwbGl0KTtcblx0ICAgICAgICAvL2RyeSB3ZXQgY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fZHJ5V2V0LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZS5jb25uZWN0KHRoaXMuX2RyeVdldCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnd2V0J10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvRWZmZWN0LCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TdGVyZW9FZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9kcnlXZXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tZXJnZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5SID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ3dldCddKTtcblx0ICAgICAgICB0aGlzLndldCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3RlcmVvRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqIFx0QGNsYXNzICBUb25lLkZlZWRiYWNrRWZmZWN0IHByb3ZpZGVzIGEgbG9vcCBiZXR3ZWVuIGFuIFxuXHRcdCAqIFx0ICAgICAgICBhdWRpbyBzb3VyY2UgYW5kIGl0cyBvd24gb3V0cHV0LiBUaGlzIGlzIGEgYmFzZS1jbGFzc1xuXHRcdCAqIFx0ICAgICAgICBmb3IgZmVlZGJhY2sgZWZmZWN0cy4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFtmZWVkYmFja10gVGhlIGluaXRpYWwgZmVlZGJhY2sgdmFsdWUuXG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWydmZWVkYmFjayddKTtcblx0ICAgICAgICBvcHRpb25zID0gdGhpcy5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuRmVlZGJhY2tFZmZlY3QuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGdhaW4gd2hpY2ggY29udHJvbHMgdGhlIGZlZWRiYWNrXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tHYWluID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLmZlZWRiYWNrLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2Ygc2lnbmFsIHdoaWNoIGlzIGZlZCBiYWNrIGludG8gdGhlIGVmZmVjdCBpbnB1dC4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2sgPSB0aGlzLl9mZWVkYmFja0dhaW4uZ2Fpbjtcblx0ICAgICAgICAvL3RoZSBmZWVkYmFjayBsb29wXG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm4uY2hhaW4odGhpcy5fZmVlZGJhY2tHYWluLCB0aGlzLmVmZmVjdFNlbmQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZmVlZGJhY2snXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GZWVkYmFja0VmZmVjdCwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QuZGVmYXVsdHMgPSB7ICdmZWVkYmFjayc6IDAuMTI1IH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GZWVkYmFja0VmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnZmVlZGJhY2snXSk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tHYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0dhaW4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZlZWRiYWNrRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgSnVzdCBsaWtlIGEgc3RlcmVvIGZlZWRiYWNrIGVmZmVjdCwgYnV0IHRoZSBmZWVkYmFjayBpcyByb3V0ZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0XG5cdFx0ICogICAgICAgICBhbmQgcmlnaHQgdG8gbGVmdCBpbnN0ZWFkIG9mIG9uIHRoZSBzYW1lIGNoYW5uZWwuXG5cdFx0ICpcblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLkZlZWRiYWNrRWZmZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbJ2ZlZWRiYWNrJ10sIFRvbmUuRmVlZGJhY2tFZmZlY3QuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBmZWVkYmFjayBmcm9tIHRoZSBvdXRwdXRcblx0XHRcdCAqICBiYWNrIGludG8gdGhlIGlucHV0IG9mIHRoZSBlZmZlY3QgKHJvdXRlZFxuXHRcdFx0ICogIGFjcm9zcyBsZWZ0IGFuZCByaWdodCBjaGFubmVscykuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2sgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mZWVkYmFjaywgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGVmdCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByaWdodCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1JMID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTC5jaGFpbih0aGlzLl9mZWVkYmFja0xSLCB0aGlzLmVmZmVjdFNlbmRSKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVyblIuY2hhaW4odGhpcy5fZmVlZGJhY2tSTCwgdGhpcy5lZmZlY3RTZW5kTCk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5mYW4odGhpcy5fZmVlZGJhY2tMUi5nYWluLCB0aGlzLl9mZWVkYmFja1JMLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZmVlZGJhY2snXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QsIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrUkwuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrUkwgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQ2hvcnVzIGlzIGEgc3RlcmVvIGNob3J1cyBlZmZlY3Qgd2l0aCBmZWVkYmFjayBjb21wb3NlZCBvZiBcblx0XHQgKiAgICAgICAgIGEgbGVmdCBhbmQgcmlnaHQgZGVsYXkgd2l0aCBhIFRvbmUuTEZPIGFwcGxpZWQgdG8gdGhlIGRlbGF5VGltZSBvZiBlYWNoIGNoYW5uZWwuIFxuXHRcdCAqICAgICAgICAgSW5zcGlyYXRpb24gZnJvbSBbVHVuYS5qc10oaHR0cHM6Ly9naXRodWIuY29tL0RpbmFobW9lL3R1bmEvYmxvYi9tYXN0ZXIvdHVuYS5qcykuXG5cdFx0ICogICAgICAgICBSZWFkIG1vcmUgb24gdGhlIGNob3J1cyBlZmZlY3Qgb24gW1NvdW5kT25Tb3VuZF0oaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tL3Nvcy9qdW4wNC9hcnRpY2xlcy9zeW50aHNlY3JldHMuaHRtKS5cblx0XHQgKlxuXHRcdCAqXHRAY29uc3RydWN0b3Jcblx0XHQgKlx0QGV4dGVuZHMge1RvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0fVxuXHRcdCAqXHRAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtmcmVxdWVuY3ldIFRoZSBmcmVxdWVuY3kgb2YgdGhlIExGTy5cblx0XHQgKlx0QHBhcmFtIHtNaWxsaXNlY29uZHN9IFtkZWxheVRpbWVdIFRoZSBkZWxheSBvZiB0aGUgY2hvcnVzIGVmZmVjdCBpbiBtcy4gXG5cdFx0ICpcdEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFtkZXB0aF0gVGhlIGRlcHRoIG9mIHRoZSBjaG9ydXMuXG5cdFx0ICpcdEBleGFtcGxlXG5cdFx0ICogdmFyIGNob3J1cyA9IG5ldyBUb25lLkNob3J1cyg0LCAyLjUsIDAuNSk7XG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuUG9seVN5bnRoKDQsIFRvbmUuTW9ub1N5bnRoKS5jb25uZWN0KGNob3J1cyk7XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiQzNcIixcIkUzXCIsXCJHM1wiXSwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hvcnVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdLCBUb25lLkNob3J1cy5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVwdGggb2YgdGhlIGNob3J1c1xuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlcHRoID0gb3B0aW9ucy5kZXB0aDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXlUaW1lXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlUaW1lID0gb3B0aW9ucy5kZWxheVRpbWUgLyAxMDAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8gd2hpY2ggY29udHJvbHMgdGhlIGRlbGF5VGltZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvTCA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAxXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgYW5vdGhlciBMRk8gZm9yIHRoZSByaWdodCBzaWRlIHdpdGggYSAxODAgZGVncmVlIHBoYXNlIGRpZmZcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb1IgPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICAgICAnbWF4JzogMSxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogMTgwXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZGVsYXkgZm9yIGxlZnRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlTCA9IG5ldyBUb25lLkRlbGF5KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZGVsYXkgZm9yIHJpZ2h0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZVIgPSBuZXcgVG9uZS5EZWxheSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgTEZPIHdoaWNoIG1vZHVsYXRlcyB0aGUgZGVsYXlUaW1lLiBcblx0XHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmb0wuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNoYWluKHRoaXMuX2RlbGF5Tm9kZUwsIHRoaXMuZWZmZWN0UmV0dXJuTCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jaGFpbih0aGlzLl9kZWxheU5vZGVSLCB0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIC8vYW5kIHBhc3MgdGhyb3VnaCB0byBtYWtlIHRoZSBkZXR1bmUgYXBwYXJlbnRcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICAvL2xmbyBzZXR1cFxuXHQgICAgICAgIHRoaXMuX2xmb0wuY29ubmVjdCh0aGlzLl9kZWxheU5vZGVMLmRlbGF5VGltZSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5jb25uZWN0KHRoaXMuX2RlbGF5Tm9kZVIuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBsZm9cblx0ICAgICAgICB0aGlzLl9sZm9MLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zdGFydCgpO1xuXHQgICAgICAgIC8vaGF2ZSBvbmUgTEZPIGZyZXF1ZW5jeSBjb250cm9sIHRoZSBvdGhlclxuXHQgICAgICAgIHRoaXMuX2xmb0wuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fbGZvUi5mcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9kZXB0aDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS52YWx1ZSA9IG9wdGlvbnMuZnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZyZXF1ZW5jeSddKTtcblx0ICAgICAgICB0aGlzLnNwcmVhZCA9IG9wdGlvbnMuc3ByZWFkO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ2hvcnVzLCBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DaG9ydXMuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDEuNSxcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMy41LFxuXHQgICAgICAgICdkZXB0aCc6IDAuNyxcblx0ICAgICAgICAnZmVlZGJhY2snOiAwLjEsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ3NwcmVhZCc6IDE4MFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZXB0aCBvZiB0aGUgZWZmZWN0LiBBIGRlcHRoIG9mIDEgbWFrZXMgdGhlIGRlbGF5VGltZVxuXHRcdCAqIG1vZHVsYXRlIGJldHdlZW4gMCBhbmQgMipkZWxheVRpbWUgKGNlbnRlcmVkIGFyb3VuZCB0aGUgZGVsYXlUaW1lKS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hvcnVzI1xuXHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiBAbmFtZSBkZXB0aFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ2RlcHRoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkZXB0aCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kZXB0aCA9IGRlcHRoO1xuXHQgICAgICAgICAgICB2YXIgZGV2aWF0aW9uID0gdGhpcy5fZGVsYXlUaW1lICogZGVwdGg7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb0wubWluID0gTWF0aC5tYXgodGhpcy5fZGVsYXlUaW1lIC0gZGV2aWF0aW9uLCAwKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5tYXggPSB0aGlzLl9kZWxheVRpbWUgKyBkZXZpYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IubWluID0gTWF0aC5tYXgodGhpcy5fZGVsYXlUaW1lIC0gZGV2aWF0aW9uLCAwKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5tYXggPSB0aGlzLl9kZWxheVRpbWUgKyBkZXZpYXRpb247XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGVsYXlUaW1lIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgY2hvcnVzLiBBIGxhcmdlciBkZWxheVRpbWVcblx0XHQgKiB3aWxsIGdpdmUgYSBtb3JlIHByb25vdW5jZWQgZWZmZWN0LiBOb21pbmFsIHJhbmdlIGEgZGVsYXlUaW1lXG5cdFx0ICogaXMgYmV0d2VlbiAyIGFuZCAyMG1zLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge01pbGxpc2Vjb25kc31cblx0XHQgKiBAbmFtZSBkZWxheVRpbWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNob3J1cy5wcm90b3R5cGUsICdkZWxheVRpbWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxheVRpbWUgKiAxMDAwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGVsYXlUaW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IGRlbGF5VGltZSAvIDEwMDA7XG5cdCAgICAgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9kZXB0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvc2NpbGxhdG9yIHR5cGUgb2YgdGhlIExGTy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hvcnVzI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm9MLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb0wudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKiogXG5cdFx0ICogQW1vdW50IG9mIHN0ZXJlbyBzcHJlYWQuIFdoZW4gc2V0IHRvIDAsIGJvdGggTEZPJ3Mgd2lsbCBiZSBwYW5uZWQgY2VudHJhbGx5LlxuXHRcdCAqIFdoZW4gc2V0IHRvIDE4MCwgTEZPJ3Mgd2lsbCBiZSBwYW5uZWQgaGFyZCBsZWZ0IGFuZCByaWdodCByZXNwZWN0aXZlbHkuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQ2hvcnVzI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHNwcmVhZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ3NwcmVhZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmb1IucGhhc2UgLSB0aGlzLl9sZm9MLnBoYXNlOyAgICAvLzE4MFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ByZWFkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb0wucGhhc2UgPSA5MCAtIHNwcmVhZCAvIDI7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IucGhhc2UgPSBzcHJlYWQgLyAyICsgOTA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5DaG9ydXN9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hvcnVzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbGZvTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlTC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2ZyZXF1ZW5jeScpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DaG9ydXM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Db252b2x2ZXIgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgTmF0aXZlIFdlYiBBdWRpbyBcblx0XHQgKiAgICAgICAgICBbQ29udm9sdmVyTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtY29udm9sdmVybm9kZS1pbnRlcmZhY2UpLlxuXHRcdCAqICAgICAgICAgIENvbnZvbHV0aW9uIGlzIHVzZWZ1bCBmb3IgcmV2ZXJiIGFuZCBmaWx0ZXIgZW11bGF0aW9uLiBSZWFkIG1vcmUgYWJvdXQgY29udm9sdXRpb24gcmV2ZXJiIG9uXG5cdFx0ICogICAgICAgICAgW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udm9sdXRpb25fcmV2ZXJiKS5cblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfFRvbmUuQnVmZmVyfE9iamVjdH0gW3VybF0gVGhlIFVSTCBvZiB0aGUgaW1wdWxzZSByZXNwb25zZSBvciB0aGUgVG9uZS5CdWZmZXJcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aWFuaW5nIHRoZSBpbXB1bHNlIHJlc3BvbnNlLiBcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUgdXJsIGlzIGxvYWRlZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2luaXRpYWxpemluZyB0aGUgY29udm9sdmVyIHdpdGggYW4gaW1wdWxzZSByZXNwb25zZVxuXHRcdCAqIHZhciBjb252b2x2ZXIgPSBuZXcgVG9uZS5Db252b2x2ZXIoXCIuL3BhdGgvdG8vaXIud2F2XCIpLnRvTWFzdGVyKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnZvbHZlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5Db252b2x2ZXIuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udm9sdmVyIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7Q29udm9sdmVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29udm9sdmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb252b2x1dGlvbiBidWZmZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcigpO1xuXHQgICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKG9wdGlvbnMudXJsKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIubG9hZChvcHRpb25zLnVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm9ubG9hZCgpO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwpIHtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBvcHRpb25zLnVybDtcblx0ICAgICAgICAgICAgb3B0aW9ucy5vbmxvYWQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX2NvbnZvbHZlcik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Db252b2x2ZXIsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyLmRlZmF1bHRzID0geyAnb25sb2FkJzogVG9uZS5ub09wIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGNvbnZvbHZlcidzIGJ1ZmZlclxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Db252b2x2ZXIjXG5cdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0XHQgKiAgQG5hbWUgYnVmZmVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Db252b2x2ZXIucHJvdG90eXBlLCAnYnVmZmVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldCgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zZXQoYnVmZmVyKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29udm9sdmVyLmJ1ZmZlciA9IHRoaXMuX2J1ZmZlci5nZXQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBMb2FkIGFuIGltcHVsc2UgcmVzcG9uc2UgdXJsIGFzIGFuIGF1ZGlvIGJ1ZmZlci5cblx0XHQgKiAgRGVjb2RlcyB0aGUgYXVkaW8gYXN5bmNocm9ub3VzbHkgYW5kIGludm9rZXNcblx0XHQgKiAgdGhlIGNhbGxiYWNrIG9uY2UgdGhlIGF1ZGlvIGJ1ZmZlciBsb2Fkcy5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5cblx0XHQgKiAgQHBhcmFtICB7ZnVuY3Rpb249fSBjYWxsYmFja1xuXHRcdCAqICBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmxvYWQodXJsLCBmdW5jdGlvbiAoYnVmZikge1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmY7XG5cdCAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ29udm9sdmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnZvbHZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2NvbnZvbHZlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fY29udm9sdmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9idWZmZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ29udm9sdmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5EaXN0b3J0aW9uIGlzIGEgc2ltcGxlIGRpc3RvcnRpb24gZWZmZWN0IHVzaW5nIFRvbmUuV2F2ZVNoYXBlci5cblx0XHQgKiAgICAgICAgIEFsZ29yaXRobSBmcm9tIFthIHN0YWNrb3ZlcmZsb3cgYW5zd2VyXShodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjMxMzQwOCkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGlzdG9ydGlvbl0gVGhlIGFtb3VudCBvZiBkaXN0b3J0aW9uIChub21pbmFsIHJhbmdlIG9mIDAtMSlcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZGlzdCA9IG5ldyBUb25lLkRpc3RvcnRpb24oMC44KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciBmbSA9IG5ldyBUb25lLlNpbXBsZUZNKCkuY29ubmVjdChkaXN0KTtcblx0XHQgKiAvL3RoaXMgc291bmRzIGdvb2Qgb24gYmFzcyBub3Rlc1xuXHRcdCAqIGZtLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQTFcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRGlzdG9ydGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFsnZGlzdG9ydGlvbiddLCBUb25lLkRpc3RvcnRpb24uZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuV2F2ZVNoYXBlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbmV3IFRvbmUuV2F2ZVNoYXBlcig0MDk2KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIGhvbGRzIHRoZSBkaXN0b3J0aW9uIGFtb3VudFxuXHRcdFx0ICogQHR5cGUge251bWJlcn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kaXN0b3J0aW9uID0gb3B0aW9ucy5kaXN0b3J0aW9uO1xuXHQgICAgICAgIHRoaXMuY29ubmVjdEVmZmVjdCh0aGlzLl9zaGFwZXIpO1xuXHQgICAgICAgIHRoaXMuZGlzdG9ydGlvbiA9IG9wdGlvbnMuZGlzdG9ydGlvbjtcblx0ICAgICAgICB0aGlzLm92ZXJzYW1wbGUgPSBvcHRpb25zLm92ZXJzYW1wbGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5EaXN0b3J0aW9uLCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRGlzdG9ydGlvbi5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZGlzdG9ydGlvbic6IDAuNCxcblx0ICAgICAgICAnb3ZlcnNhbXBsZSc6ICdub25lJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhbW91bnQgb2YgZGlzdG9ydGlvbi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5EaXN0b3J0aW9uI1xuXHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiBAbmFtZSBkaXN0b3J0aW9uXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5EaXN0b3J0aW9uLnByb3RvdHlwZSwgJ2Rpc3RvcnRpb24nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXN0b3J0aW9uO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Rpc3RvcnRpb24gPSBhbW91bnQ7XG5cdCAgICAgICAgICAgIHZhciBrID0gYW1vdW50ICogMTAwO1xuXHQgICAgICAgICAgICB2YXIgZGVnID0gTWF0aC5QSSAvIDE4MDtcblx0ICAgICAgICAgICAgdGhpcy5fc2hhcGVyLnNldE1hcChmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgpIDwgMC4wMDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL3Nob3VsZCBvdXRwdXQgMCB3aGVuIGlucHV0IGlzIDBcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgzICsgaykgKiB4ICogMjAgKiBkZWcgLyAoTWF0aC5QSSArIGsgKiBNYXRoLmFicyh4KSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG92ZXJzYW1wbGluZyBvZiB0aGUgZWZmZWN0LiBDYW4gZWl0aGVyIGJlIFwibm9uZVwiLCBcIjJ4XCIgb3IgXCI0eFwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkRpc3RvcnRpb24jXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSBvdmVyc2FtcGxlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5EaXN0b3J0aW9uLnByb3RvdHlwZSwgJ292ZXJzYW1wbGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG92ZXJzYW1wbGluZykge1xuXHQgICAgICAgICAgICB0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZSA9IG92ZXJzYW1wbGluZztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkRpc3RvcnRpb259IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRGlzdG9ydGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5EaXN0b3J0aW9uO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRmVlZGJhY2tEZWxheSBpcyBhIERlbGF5Tm9kZSBpbiB3aGljaCBwYXJ0IG9mIG91dHB1dFxuXHRcdCAqICAgICAgICAgIHNpZ25hbCBpcyBmZWQgYmFjayBpbnRvIHRoZSBkZWxheS4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkZlZWRiYWNrRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbZGVsYXlUaW1lXSBUaGUgZGVsYXkgYXBwbGllZCB0byB0aGUgaW5jb21pbmcgc2lnbmFsLiBcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZT19IGZlZWRiYWNrIFRoZSBhbW91bnQgb2YgdGhlIGVmZmVjdGVkIHNpZ25hbCB3aGljaCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBmZWQgYmFjayB0aHJvdWdoIHRoZSBkZWxheS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZmVlZGJhY2tEZWxheSA9IG5ldyBUb25lLkZlZWRiYWNrRGVsYXkoXCI4blwiLCAwLjUpLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIHRvbSA9IG5ldyBUb25lLkRydW1TeW50aCh7XG5cdFx0ICogXHRcIm9jdGF2ZXNcIiA6IDQsXG5cdFx0ICogXHRcInBpdGNoRGVjYXlcIiA6IDAuMVxuXHRcdCAqIH0pLmNvbm5lY3QoZmVlZGJhY2tEZWxheSk7XG5cdFx0ICogdG9tLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQTJcIixcIjMyblwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tEZWxheSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZScsXG5cdCAgICAgICAgICAgICdmZWVkYmFjaydcblx0ICAgICAgICBdLCBUb25lLkZlZWRiYWNrRGVsYXkuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZGVsYXkgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBuZXcgVG9uZS5EZWxheShvcHRpb25zLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5VGltZSBvZiB0aGUgRGVsYXlOb2RlLiBcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IHRoaXMuX2RlbGF5Tm9kZS5kZWxheVRpbWU7XG5cdCAgICAgICAgLy8gY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuY29ubmVjdEVmZmVjdCh0aGlzLl9kZWxheU5vZGUpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZGVsYXlUaW1lJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRmVlZGJhY2tEZWxheSwgVG9uZS5GZWVkYmFja0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzLiBcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tEZWxheS5kZWZhdWx0cyA9IHsgJ2RlbGF5VGltZSc6IDAuMjUgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GZWVkYmFja0RlbGF5fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRGVsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ2RlbGF5VGltZSddKTtcblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRmVlZGJhY2tEZWxheTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgYW4gYXJyYXkgb2YgY29tYiBmaWx0ZXIgZGVsYXkgdmFsdWVzIGZyb20gRnJlZXZlcmIgaW1wbGVtZW50YXRpb25cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgY29tYkZpbHRlclR1bmluZ3MgPSBbXG5cdCAgICAgICAgMTU1NyAvIDQ0MTAwLFxuXHQgICAgICAgIDE2MTcgLyA0NDEwMCxcblx0ICAgICAgICAxNDkxIC8gNDQxMDAsXG5cdCAgICAgICAgMTQyMiAvIDQ0MTAwLFxuXHQgICAgICAgIDEyNzcgLyA0NDEwMCxcblx0ICAgICAgICAxMzU2IC8gNDQxMDAsXG5cdCAgICAgICAgMTE4OCAvIDQ0MTAwLFxuXHQgICAgICAgIDExMTYgLyA0NDEwMFxuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICBhbiBhcnJheSBvZiBhbGxwYXNzIGZpbHRlciBmcmVxdWVuY3kgdmFsdWVzIGZyb20gRnJlZXZlcmIgaW1wbGVtZW50YXRpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzID0gW1xuXHQgICAgICAgIDIyNSxcblx0ICAgICAgICA1NTYsXG5cdCAgICAgICAgNDQxLFxuXHQgICAgICAgIDM0MVxuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GcmVldmVyYiBpcyBhIHJldmVyYiBiYXNlZCBvbiBbRnJlZXZlcmJdKGh0dHBzOi8vY2NybWEuc3RhbmZvcmQuZWR1L35qb3MvcGFzcC9GcmVldmVyYi5odG1sKS5cblx0XHQgKiAgICAgICAgIFJlYWQgbW9yZSBvbiByZXZlcmIgb24gW1NvdW5kT25Tb3VuZF0oaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tL3Nvcy9tYXkwMC9hcnRpY2xlcy9yZXZlcmIuaHRtKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfE9iamVjdH0gW3Jvb21TaXplXSBDb3JyZWxhdGVkIHRvIHRoZSBkZWNheSB0aW1lLiBcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IFtkYW1wZW5pbmddIFRoZSBjdXRvZmYgZnJlcXVlbmN5IG9mIGEgbG93cGFzcyBmaWx0ZXIgYXMgcGFydCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSByZXZlcmIuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBmcmVldmVyYiA9IG5ldyBUb25lLkZyZWV2ZXJiKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBmcmVldmVyYi5kYW1wZW5pbmcudmFsdWUgPSAxMDAwO1xuXHRcdCAqIC8vcm91dGluZyBzeW50aCB0aHJvdWdoIHRoZSByZXZlcmJcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5BTVN5bnRoKCkuY29ubmVjdChmcmVldmVyYik7XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZWV2ZXJiID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncm9vbVNpemUnLFxuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJ1xuXHQgICAgICAgIF0sIFRvbmUuRnJlZXZlcmIuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJvb21TaXplIHZhbHVlIGJldHdlZW4uIEEgbGFyZ2VyIHJvb21TaXplXG5cdFx0XHQgKiAgd2lsbCByZXN1bHQgaW4gYSBsb25nZXIgZGVjYXkuIFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJvb21TaXplID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMucm9vbVNpemUsIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBkYW1wZW5pbmcgb2YgdGhlIHJldmVyYmVyYW50IHNpZ25hbC4gXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRhbXBlbmluZyA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRhbXBlbmluZywgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGNvbWIgZmlsdGVyc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29tYkZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYWxscGFzcyBmaWx0ZXJzIG9uIHRoZSBsZWZ0XG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0wgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYWxscGFzcyBmaWx0ZXJzIG9uIHRoZSByaWdodFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSID0gW107XG5cdCAgICAgICAgLy9tYWtlIHRoZSBhbGxwYXNzIGZpbHRlcnMgb24gdGVoIHJpZ2h0XG5cdCAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXMubGVuZ3RoOyBsKyspIHtcblx0ICAgICAgICAgICAgdmFyIGFsbHBhc3NMID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgICAgICBhbGxwYXNzTC50eXBlID0gJ2FsbHBhc3MnO1xuXHQgICAgICAgICAgICBhbGxwYXNzTC5mcmVxdWVuY3kudmFsdWUgPSBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXNbbF07XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTC5wdXNoKGFsbHBhc3NMKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9tYWtlIHRoZSBhbGxwYXNzIGZpbHRlcnMgb24gdGhlIGxlZnRcblx0ICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGFsbHBhc3NGaWx0ZXJGcmVxdWVuY2llcy5sZW5ndGg7IHIrKykge1xuXHQgICAgICAgICAgICB2YXIgYWxscGFzc1IgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgICAgIGFsbHBhc3NSLnR5cGUgPSAnYWxscGFzcyc7XG5cdCAgICAgICAgICAgIGFsbHBhc3NSLmZyZXF1ZW5jeS52YWx1ZSA9IGFsbHBhc3NGaWx0ZXJGcmVxdWVuY2llc1tyXTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSLnB1c2goYWxscGFzc1IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL21ha2UgdGhlIGNvbWIgZmlsdGVyc1xuXHQgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29tYkZpbHRlclR1bmluZ3MubGVuZ3RoOyBjKyspIHtcblx0ICAgICAgICAgICAgdmFyIGxmcGYgPSBuZXcgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlcihjb21iRmlsdGVyVHVuaW5nc1tjXSk7XG5cdCAgICAgICAgICAgIGlmIChjIDwgY29tYkZpbHRlclR1bmluZ3MubGVuZ3RoIC8gMikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jaGFpbihsZnBmLCB0aGlzLl9hbGxwYXNzRmlsdGVyc0xbMF0pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jaGFpbihsZnBmLCB0aGlzLl9hbGxwYXNzRmlsdGVyc1JbMF0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMucm9vbVNpemUuY29ubmVjdChsZnBmLnJlc29uYW5jZSk7XG5cdCAgICAgICAgICAgIHRoaXMuZGFtcGVuaW5nLmNvbm5lY3QobGZwZi5kYW1wZW5pbmcpO1xuXHQgICAgICAgICAgICB0aGlzLl9jb21iRmlsdGVycy5wdXNoKGxmcGYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2NoYWluIHRoZSBhbGxwYXNzIGZpbHRlcnMgdG9nZXRlaHJcblx0ICAgICAgICB0aGlzLmNvbm5lY3RTZXJpZXMuYXBwbHkodGhpcywgdGhpcy5fYWxscGFzc0ZpbHRlcnNMKTtcblx0ICAgICAgICB0aGlzLmNvbm5lY3RTZXJpZXMuYXBwbHkodGhpcywgdGhpcy5fYWxscGFzc0ZpbHRlcnNSKTtcblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0xbdGhpcy5fYWxscGFzc0ZpbHRlcnNMLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1JbdGhpcy5fYWxscGFzc0ZpbHRlcnNSLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdyb29tU2l6ZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GcmVldmVyYiwgVG9uZS5TdGVyZW9FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlZXZlcmIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3Jvb21TaXplJzogMC43LFxuXHQgICAgICAgICdkYW1wZW5pbmcnOiAzMDAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRnJlZXZlcmJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlZXZlcmIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBhbCA9IDA7IGFsIDwgdGhpcy5fYWxscGFzc0ZpbHRlcnNMLmxlbmd0aDsgYWwrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0xbYWxdLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMW2FsXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIgYXIgPSAwOyBhciA8IHRoaXMuX2FsbHBhc3NGaWx0ZXJzUi5sZW5ndGg7IGFyKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSW2FyXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUlthcl0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1IgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGNmID0gMDsgY2YgPCB0aGlzLl9jb21iRmlsdGVycy5sZW5ndGg7IGNmKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnNbY2ZdLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnNbY2ZdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fY29tYkZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jvb21TaXplJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRhbXBlbmluZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZyZWV2ZXJiO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBhbiBhcnJheSBvZiB0aGUgY29tYiBmaWx0ZXIgZGVsYXkgdGltZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgY29tYkZpbHRlckRlbGF5VGltZXMgPSBbXG5cdCAgICAgICAgMTY4NyAvIDI1MDAwLFxuXHQgICAgICAgIDE2MDEgLyAyNTAwMCxcblx0ICAgICAgICAyMDUzIC8gMjUwMDAsXG5cdCAgICAgICAgMjI1MSAvIDI1MDAwXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSByZXNvbmFuY2VzIG9mIGVhY2ggb2YgdGhlIGNvbWIgZmlsdGVyc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBjb21iRmlsdGVyUmVzb25hbmNlcyA9IFtcblx0ICAgICAgICAwLjc3Myxcblx0ICAgICAgICAwLjgwMixcblx0ICAgICAgICAwLjc1Myxcblx0ICAgICAgICAwLjczM1xuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgYWxscGFzcyBmaWx0ZXIgZnJlcXVlbmNpZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgYWxscGFzc0ZpbHRlckZyZXFzID0gW1xuXHQgICAgICAgIDM0Nyxcblx0ICAgICAgICAxMTMsXG5cdCAgICAgICAgMzdcblx0ICAgIF07XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuSkNSZXZlcmIgaXMgYSBzaW1wbGUgW1NjaHJvZWRlciBSZXZlcmJlcmF0b3JdKGh0dHBzOi8vY2NybWEuc3RhbmZvcmQuZWR1L35qb3MvcGFzcC9TY2hyb2VkZXJfUmV2ZXJiZXJhdG9ycy5odG1sKVxuXHRcdCAqICAgICAgICAgdHVuZWQgYnkgSm9obiBDaG93bmluZyBpbiAxOTcwLlxuXHRcdCAqICAgICAgICAgSXQgaXMgbWFkZSB1cCBvZiB0aHJlZSBhbGxwYXNzIGZpbHRlcnMgYW5kIGZvdXIgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIuIFxuXHRcdCAqICAgICAgICAgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFtyb29tU2l6ZV0gQ29vcmVsYXRlcyB0byB0aGUgZGVjYXkgdGltZS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcmV2ZXJiID0gbmV3IFRvbmUuSkNSZXZlcmIoMC40KS5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0XHQgKiB2YXIgZGVsYXkgPSBuZXcgVG9uZS5GZWVkYmFja0RlbGF5KDAuNSk7IFxuXHRcdCAqIC8vY29ubmVjdGluZyB0aGUgc3ludGggdG8gcmV2ZXJiIHRocm91Z2ggZGVsYXlcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5EdW9TeW50aCgpLmNoYWluKGRlbGF5LCByZXZlcmIpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQTRcIixcIjhuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5KQ1JldmVyYiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFsncm9vbVNpemUnXSwgVG9uZS5KQ1JldmVyYi5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICByb29tIHNpemUgY29udHJvbCB2YWx1ZXMgYmV0d2VlbiBbMCwxXVxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJvb21TaXplID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMucm9vbVNpemUsIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc2NhbGUgdGhlIHJvb20gc2l6ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNjYWxlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZVJvb21TaXplID0gbmV3IFRvbmUuU2NhbGUoLTAuNzMzLCAwLjE5Nyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgYSBzZXJpZXMgb2YgYWxscGFzcyBmaWx0ZXJzXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHBhcmFsbGVsIGZlZWRiYWNrIGNvbWIgZmlsdGVyc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVycyA9IFtdO1xuXHQgICAgICAgIC8vbWFrZSB0aGUgYWxscGFzcyBmaWx0ZXJzXG5cdCAgICAgICAgZm9yICh2YXIgYWYgPSAwOyBhZiA8IGFsbHBhc3NGaWx0ZXJGcmVxcy5sZW5ndGg7IGFmKyspIHtcblx0ICAgICAgICAgICAgdmFyIGFsbHBhc3MgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgICAgIGFsbHBhc3MudHlwZSA9ICdhbGxwYXNzJztcblx0ICAgICAgICAgICAgYWxscGFzcy5mcmVxdWVuY3kudmFsdWUgPSBhbGxwYXNzRmlsdGVyRnJlcXNbYWZdO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVycy5wdXNoKGFsbHBhc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2FuZCB0aGUgY29tYiBmaWx0ZXJzXG5cdCAgICAgICAgZm9yICh2YXIgY2YgPSAwOyBjZiA8IGNvbWJGaWx0ZXJEZWxheVRpbWVzLmxlbmd0aDsgY2YrKykge1xuXHQgICAgICAgICAgICB2YXIgZmJjZiA9IG5ldyBUb25lLkZlZWRiYWNrQ29tYkZpbHRlcihjb21iRmlsdGVyRGVsYXlUaW1lc1tjZl0sIDAuMSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlUm9vbVNpemUuY29ubmVjdChmYmNmLnJlc29uYW5jZSk7XG5cdCAgICAgICAgICAgIGZiY2YucmVzb25hbmNlLnZhbHVlID0gY29tYkZpbHRlclJlc29uYW5jZXNbY2ZdO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1t0aGlzLl9hbGxwYXNzRmlsdGVycy5sZW5ndGggLSAxXS5jb25uZWN0KGZiY2YpO1xuXHQgICAgICAgICAgICBpZiAoY2YgPCBjb21iRmlsdGVyRGVsYXlUaW1lcy5sZW5ndGggLyAyKSB7XG5cdCAgICAgICAgICAgICAgICBmYmNmLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGZiY2YuY29ubmVjdCh0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnMucHVzaChmYmNmKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9jaGFpbiB0aGUgYWxscGFzcyBmaWx0ZXJzIHRvZ2V0aGVyXG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZS5jb25uZWN0KHRoaXMuX3NjYWxlUm9vbVNpemUpO1xuXHQgICAgICAgIHRoaXMuY29ubmVjdFNlcmllcy5hcHBseSh0aGlzLCB0aGlzLl9hbGxwYXNzRmlsdGVycyk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jb25uZWN0KHRoaXMuX2FsbHBhc3NGaWx0ZXJzWzBdKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNvbm5lY3QodGhpcy5fYWxscGFzc0ZpbHRlcnNbMF0pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsncm9vbVNpemUnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5KQ1JldmVyYiwgVG9uZS5TdGVyZW9FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5KQ1JldmVyYi5kZWZhdWx0cyA9IHsgJ3Jvb21TaXplJzogMC41IH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5KQ1JldmVyYn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5KQ1JldmVyYi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGFwZiA9IDA7IGFwZiA8IHRoaXMuX2FsbHBhc3NGaWx0ZXJzLmxlbmd0aDsgYXBmKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNbYXBmXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzW2FwZl0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVycyA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIgZmJjZiA9IDA7IGZiY2YgPCB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzLmxlbmd0aDsgZmJjZisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnNbZmJjZl0uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzW2ZiY2ZdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVycyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydyb29tU2l6ZSddKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zY2FsZVJvb21TaXplLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZVJvb21TaXplID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5KQ1JldmVyYjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIE1pZC9TaWRlIHByb2Nlc3Npbmcgc2VwYXJhdGVzIHRoZSB0aGUgJ21pZCcgc2lnbmFsIFxuXHRcdCAqICAgICAgICAgKHdoaWNoIGNvbWVzIG91dCBvZiBib3RoIHRoZSBsZWZ0IGFuZCB0aGUgcmlnaHQgY2hhbm5lbCkgXG5cdFx0ICogICAgICAgICBhbmQgdGhlICdzaWRlJyAod2hpY2ggb25seSBjb21lcyBvdXQgb2YgdGhlIHRoZSBzaWRlIGNoYW5uZWxzKSBcblx0XHQgKiAgICAgICAgIGFuZCBlZmZlY3RzIHRoZW0gc2VwYXJhdGVseSBiZWZvcmUgYmVpbmcgcmVjb21iaW5lZC5cblx0XHQgKiAgICAgICAgIEFwcGxpZXMgYSBNaWQvU2lkZSBzZXBlcmF0aW9uIGFuZCByZWNvbWJpbmF0aW9uLlxuXHRcdCAqICAgICAgICAgQWxnb3JpdGhtIGZvdW5kIGluIFtrdnJhdWRpbyBmb3J1bXNdKGh0dHA6Ly93d3cua3ZyYXVkaW8uY29tL2ZvcnVtL3ZpZXd0b3BpYy5waHA/dD0yMTI1ODcpLlxuXHRcdCAqICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgIFRoaXMgaXMgYSBiYXNlLWNsYXNzIGZvciBNaWQvU2lkZSBFZmZlY3RzLiBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZC9zaWRlIHNwbGl0XG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk1pZFNpZGVTcGxpdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0ID0gbmV3IFRvbmUuTWlkU2lkZVNwbGl0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZC9zaWRlIG1lcmdlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk1pZFNpZGVNZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlID0gbmV3IFRvbmUuTWlkU2lkZU1lcmdlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZCBzZW5kLiBDb25uZWN0IHRvIG1pZCBwcm9jZXNzaW5nXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWRTZW5kID0gdGhpcy5fbWlkU2lkZVNwbGl0Lm1pZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2lkZSBzZW5kLiBDb25uZWN0IHRvIHNpZGUgcHJvY2Vzc2luZ1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuc2lkZVNlbmQgPSB0aGlzLl9taWRTaWRlU3BsaXQuc2lkZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkIHJldHVybiBjb25uZWN0aW9uXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZFJldHVybiA9IHRoaXMuX21pZFNpZGVNZXJnZS5taWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZGUgcmV0dXJuIGNvbm5lY3Rpb25cblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuc2lkZVJldHVybiA9IHRoaXMuX21pZFNpZGVNZXJnZS5zaWRlO1xuXHQgICAgICAgIC8vdGhlIGNvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNvbm5lY3QodGhpcy5fbWlkU2lkZVNwbGl0KTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UuY29ubmVjdCh0aGlzLmVmZmVjdFJldHVybik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NaWRTaWRlRWZmZWN0LCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NaWRTaWRlRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkU2VuZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlU2VuZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5taWRSZXR1cm4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuc2lkZVJldHVybiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWlkU2lkZUVmZmVjdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuUGhhc2VyIGlzIGEgcGhhc2VyIGVmZmVjdC4gUGhhc2VycyB3b3JrIGJ5IGNoYW5naW5nIHRoZSBwaGFzZVxuXHRcdCAqICAgICAgICAgb2YgZGlmZmVyZW50IGZyZXF1ZW5jeSBjb21wb25lbnRzIG9mIGFuIGluY29taW5nIHNpZ25hbC4gUmVhZCBtb3JlIG9uIFxuXHRcdCAqICAgICAgICAgW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGhhc2VyXyhlZmZlY3QpKS4gXG5cdFx0ICogICAgICAgICBJbnNwaXJhdGlvbiBmb3IgdGhpcyBwaGFzZXIgY29tZXMgZnJvbSBbVHVuYS5qc10oaHR0cHM6Ly9naXRodWIuY29tL0RpbmFobW9lL3R1bmEvKS5cblx0XHQgKlxuXHRcdCAqXHRAZXh0ZW5kcyB7VG9uZS5TdGVyZW9FZmZlY3R9XG5cdFx0ICpcdEBjb25zdHJ1Y3RvclxuXHRcdCAqXHRAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtmcmVxdWVuY3ldIFRoZSBzcGVlZCBvZiB0aGUgcGhhc2luZy4gXG5cdFx0ICpcdEBwYXJhbSB7bnVtYmVyfSBbb2N0YXZlc10gVGhlIG9jdGF2ZXMgb2YgdGhlIGVmZmVjdC4gXG5cdFx0ICpcdEBwYXJhbSB7RnJlcXVlbmN5fSBbYmFzZUZyZXF1ZW5jeV0gVGhlIGJhc2UgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXJzLiBcblx0XHQgKlx0QGV4YW1wbGVcblx0XHQgKiB2YXIgcGhhc2VyID0gbmV3IFRvbmUuUGhhc2VyKHtcblx0XHQgKiBcdFwiZnJlcXVlbmN5XCIgOiAxNSwgXG5cdFx0ICogXHRcIm9jdGF2ZXNcIiA6IDUsIFxuXHRcdCAqIFx0XCJiYXNlRnJlcXVlbmN5XCIgOiAxMDAwXG5cdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5GTVN5bnRoKCkuY29ubmVjdChwaGFzZXIpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiRTNcIiwgXCIyblwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGhhc2VyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vc2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ29jdGF2ZXMnLFxuXHQgICAgICAgICAgICAnYmFzZUZyZXF1ZW5jeSdcblx0ICAgICAgICBdLCBUb25lLlBoYXNlci5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGZvIHdoaWNoIGNvbnRyb2xzIHRoZSBmcmVxdWVuY3kgb24gdGhlIGxlZnQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvTCA9IG5ldyBUb25lLkxGTyhvcHRpb25zLmZyZXF1ZW5jeSwgMCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBjb250cm9scyB0aGUgZnJlcXVlbmN5IG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9SID0gbmV3IFRvbmUuTEZPKG9wdGlvbnMuZnJlcXVlbmN5LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLnBoYXNlID0gMTgwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBiYXNlIG1vZHVsYXRpb24gZnJlcXVlbmN5XG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb2N0YXZlcyBvZiB0aGUgcGhhc2luZ1xuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHF1YWxpdHkgZmFjdG9yIG9mIHRoZSBmaWx0ZXJzXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuUSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLlEsIFRvbmUuVHlwZS5Qb3NpdGl2ZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFycmF5IG9mIGZpbHRlcnMgZm9yIHRoZSBsZWZ0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNMID0gdGhpcy5fbWFrZUZpbHRlcnMob3B0aW9ucy5zdGFnZXMsIHRoaXMuX2xmb0wsIHRoaXMuUSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFycmF5IG9mIGZpbHRlcnMgZm9yIHRoZSBsZWZ0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNSID0gdGhpcy5fbWFrZUZpbHRlcnMob3B0aW9ucy5zdGFnZXMsIHRoaXMuX2xmb1IsIHRoaXMuUSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiB0aGUgZnJlcXVlbmN5IG9mIHRoZSBlZmZlY3Rcblx0XHRcdCAqIEB0eXBlIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbGZvTC5mcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kudmFsdWUgPSBvcHRpb25zLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlbSB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY29ubmVjdCh0aGlzLl9maWx0ZXJzTFswXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jb25uZWN0KHRoaXMuX2ZpbHRlcnNSWzBdKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXJzTFtvcHRpb25zLnN0YWdlcyAtIDFdLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXJzUltvcHRpb25zLnN0YWdlcyAtIDFdLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICAvL2NvbnRyb2wgdGhlIGZyZXF1ZW5jeSB3aXRoIG9uZSBMRk9cblx0ICAgICAgICB0aGlzLl9sZm9MLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX2xmb1IuZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3NldCB0aGUgb3B0aW9uc1xuXHQgICAgICAgIHRoaXMuYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgICAgICB0aGlzLm9jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgbGZvXG5cdCAgICAgICAgdGhpcy5fbGZvTC5zdGFydCgpO1xuXHQgICAgICAgIHRoaXMuX2xmb1Iuc3RhcnQoKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBoYXNlciwgVG9uZS5TdGVyZW9FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHRzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge29iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGhhc2VyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiAwLjUsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiAzLFxuXHQgICAgICAgICdzdGFnZXMnOiAxMCxcblx0ICAgICAgICAnUSc6IDEwLFxuXHQgICAgICAgICdiYXNlRnJlcXVlbmN5JzogMzUwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBzdGFnZXNcblx0XHQgKiAgQHJldHVybnMge0FycmF5fSB0aGUgbnVtYmVyIG9mIGZpbHRlcnMgYWxsIGNvbm5lY3RlZCB0b2dldGhlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QaGFzZXIucHJvdG90eXBlLl9tYWtlRmlsdGVycyA9IGZ1bmN0aW9uIChzdGFnZXMsIGNvbm5lY3RUb0ZyZXEsIFEpIHtcblx0ICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBBcnJheShzdGFnZXMpO1xuXHQgICAgICAgIC8vbWFrZSBhbGwgdGhlIGZpbHRlcnNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWdlczsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgICAgIGZpbHRlci50eXBlID0gJ2FsbHBhc3MnO1xuXHQgICAgICAgICAgICBRLmNvbm5lY3QoZmlsdGVyLlEpO1xuXHQgICAgICAgICAgICBjb25uZWN0VG9GcmVxLmNvbm5lY3QoZmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgICAgIGZpbHRlcnNbaV0gPSBmaWx0ZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29ubmVjdFNlcmllcy5hcHBseSh0aGlzLCBmaWx0ZXJzKTtcblx0ICAgICAgICByZXR1cm4gZmlsdGVycztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgdGhlIHBoYXNlIGdvZXMgYWJvdmVcblx0XHQgKiB0aGUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBoYXNlciNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGhhc2VyLnByb3RvdHlwZSwgJ29jdGF2ZXMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vY3RhdmVzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob2N0YXZlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vY3RhdmVzID0gb2N0YXZlcztcblx0ICAgICAgICAgICAgdmFyIG1heCA9IHRoaXMuX2Jhc2VGcmVxdWVuY3kgKiBNYXRoLnBvdygyLCBvY3RhdmVzKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5tYXggPSBtYXg7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IubWF4ID0gbWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHRoZSBiYXNlIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVycy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGhhc2VyI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGhhc2VyLnByb3RvdHlwZSwgJ2Jhc2VGcmVxdWVuY3knLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZnJlcSkge1xuXHQgICAgICAgICAgICB0aGlzLl9iYXNlRnJlcXVlbmN5ID0gZnJlcTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5taW4gPSBmcmVxO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9SLm1pbiA9IGZyZXE7XG5cdCAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGhhc2VyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBoYXNlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuUS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5RID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9MLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9SLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ZpbHRlcnNMLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNMW2ldLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc0xbaV0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9maWx0ZXJzTCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9maWx0ZXJzUi5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzUltqXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNSW2pdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyc1IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QaGFzZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5QaW5nUG9uZ0RlbGF5IGlzIGEgZmVlZGJhY2sgZGVsYXkgZWZmZWN0IHdoZXJlIHRoZSBlY2hvIGlzIGhlYXJkXG5cdFx0ICogICAgICAgICAgZmlyc3QgaW4gb25lIGNoYW5uZWwgYW5kIG5leHQgaW4gdGhlIG9wcG9zaXRlIGNoYW5uZWwuIEluIGEgc3RlcmVvXG5cdFx0ICogICAgICAgICAgc3lzdGVtIHRoZXNlIGFyZSB0aGUgcmlnaHQgYW5kIGxlZnQgY2hhbm5lbHMuXG5cdFx0ICogICAgICAgICAgUGluZ1BvbmdEZWxheSBpbiBtb3JlIHNpbXBsaWZpZWQgdGVybXMgaXMgdHdvIFRvbmUuRmVlZGJhY2tEZWxheXMgXG5cdFx0ICogICAgICAgICAgd2l0aCBpbmRlcGVuZGVudCBkZWxheSB2YWx1ZXMuIEVhY2ggZGVsYXkgaXMgcm91dGVkIHRvIG9uZSBjaGFubmVsXG5cdFx0ICogICAgICAgICAgKGxlZnQgb3IgcmlnaHQpLCBhbmQgdGhlIGNoYW5uZWwgdHJpZ2dlcmVkIHNlY29uZCB3aWxsIGFsd2F5cyBcblx0XHQgKiAgICAgICAgICB0cmlnZ2VyIGF0IHRoZSBzYW1lIGludGVydmFsIGFmdGVyIHRoZSBmaXJzdC5cblx0XHQgKlxuXHRcdCAqIFx0QGNvbnN0cnVjdG9yXG5cdFx0ICogXHRAZXh0ZW5kcyB7VG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFtkZWxheVRpbWVdIFRoZSBkZWxheVRpbWUgYmV0d2VlbiBjb25zZWN1dGl2ZSBlY2hvcy5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZT19IGZlZWRiYWNrIFRoZSBhbW91bnQgb2YgdGhlIGVmZmVjdGVkIHNpZ25hbCB3aGljaCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGZlZCBiYWNrIHRocm91Z2ggdGhlIGRlbGF5LlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwaW5nUG9uZyA9IG5ldyBUb25lLlBpbmdQb25nRGVsYXkoXCI0blwiLCAwLjIpLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIGRydW0gPSBuZXcgVG9uZS5EcnVtU3ludGgoKS5jb25uZWN0KHBpbmdQb25nKTtcblx0XHQgKiBkcnVtLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCIzMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAnZmVlZGJhY2snXG5cdCAgICAgICAgXSwgVG9uZS5QaW5nUG9uZ0RlbGF5LmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlIG9uIHRoZSBsZWZ0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGVmdERlbGF5ID0gbmV3IFRvbmUuRGVsYXkoMCwgb3B0aW9ucy5tYXhEZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlIG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0RGVsYXkgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHByZWRlbGF5IG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0UHJlRGVsYXkgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRlbGF5IHRpbWUgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZWxheVRpbWUsIFRvbmUuVHlwZS5UaW1lKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgaXQgdXBcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNoYWluKHRoaXMuX2xlZnREZWxheSwgdGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNoYWluKHRoaXMuX3JpZ2h0UHJlRGVsYXksIHRoaXMuX3JpZ2h0RGVsYXksIHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUuZmFuKHRoaXMuX2xlZnREZWxheS5kZWxheVRpbWUsIHRoaXMuX3JpZ2h0RGVsYXkuZGVsYXlUaW1lLCB0aGlzLl9yaWdodFByZURlbGF5LmRlbGF5VGltZSk7XG5cdCAgICAgICAgLy9yZWFycmFuZ2VkIHRoZSBmZWVkYmFjayB0byBiZSBhZnRlciB0aGUgcmlnaHRQcmVEZWxheVxuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIuY29ubmVjdCh0aGlzLl9yaWdodERlbGF5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2RlbGF5VGltZSddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBpbmdQb25nRGVsYXksIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAuMjUsXG5cdCAgICAgICAgJ21heERlbGF5VGltZSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QaW5nUG9uZ0RlbGF5fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZWZ0RGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xlZnREZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmlnaHREZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHREZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmlnaHRQcmVEZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHRQcmVEZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydkZWxheVRpbWUnXSk7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QaW5nUG9uZ0RlbGF5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QaXRjaFNoaWZ0IGRvZXMgbmVhci1yZWFsdGltZSBwaXRjaCBzaGlmdGluZyB0byB0aGUgaW5jb21pbmcgc2lnbmFsLiBcblx0XHQgKiAgICAgICAgIFRoZSBlZmZlY3QgaXMgYWNoaWV2ZWQgYnkgc3BlZWRpbmcgdXAgb3Igc2xvd2luZyBkb3duIHRoZSBkZWxheVRpbWVcblx0XHQgKiAgICAgICAgIG9mIGEgRGVsYXlOb2RlIHVzaW5nIGEgc2F3dG9vdGggd2F2ZS4gXG5cdFx0ICogICAgICAgICBBbGdvcml0aG0gZm91bmQgaW4gW3RoaXMgcGRmXShodHRwOi8vZHNwLWJvb2submFyb2QucnUvc291bmRwcm9jLnBkZikuXG5cdFx0ICogICAgICAgICBBZGRpdGlvbmFsIHJlZmVyZW5jZSBieSBbTWlsbGVyIFB1Y2tldF0oaHR0cDovL21zcC51Y3NkLmVkdS90ZWNobmlxdWVzL3YwLjExL2Jvb2staHRtbC9ub2RlMTE1Lmh0bWwpLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkZlZWRiYWNrRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ludGVydmFsPX0gcGl0Y2ggVGhlIGludGVydmFsIHRvIHRyYW5zcG9zZSB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuUGl0Y2hTaGlmdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFsncGl0Y2gnXSwgVG9uZS5QaXRjaFNoaWZ0LmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkZlZWRiYWNrRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBpdGNoIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5TaWduYWx9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbCgwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBVc2VzIHR3byBEZWxheU5vZGVzIHRvIGNvdmVyIHVwIHRoZSBqdW1wIGluXG5cdFx0XHQgKiAgdGhlIHNhd3Rvb3RoIHdhdmUuIFxuXHRcdFx0ICogIEB0eXBlICB7RGVsYXlOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheUEgPSBuZXcgVG9uZS5EZWxheSgwLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmlyc3QgTEZPLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb0EgPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAgICAgJ21heCc6IDAuMSxcblx0ICAgICAgICAgICAgJ3R5cGUnOiAnc2F3dG9vdGgnXG5cdCAgICAgICAgfSkuY29ubmVjdCh0aGlzLl9kZWxheUEuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2Vjb25kIERlbGF5Tm9kZVxuXHRcdFx0ICogIEB0eXBlICB7RGVsYXlOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheUIgPSBuZXcgVG9uZS5EZWxheSgwLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmlyc3QgTEZPLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb0IgPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAgICAgJ21heCc6IDAuMSxcblx0ICAgICAgICAgICAgJ3R5cGUnOiAnc2F3dG9vdGgnLFxuXHQgICAgICAgICAgICAncGhhc2UnOiAxODBcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMuX2RlbGF5Qi5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIENyb3NzZmFkZSBxdWlja2x5IGJldHdlZW4gdGhlIHR3byBkZWxheSBsaW5lc1xuXHRcdFx0ICogIHRvIGNvdmVyIHVwIHRoZSBqdW1wIGluIHRoZSBzYXd0b290aCB3YXZlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkNyb3NzRmFkZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlID0gbmV3IFRvbmUuQ3Jvc3NGYWRlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgTEZPIHdoaWNoIGFsdGVybmF0ZXMgYmV0d2VlbiB0aGUgdHdvXG5cdFx0XHQgKiAgZGVsYXkgbGluZXMgdG8gY292ZXIgdXAgdGhlIGRpc3Bhcml0eSBpbiB0aGVcblx0XHRcdCAqICBzYXd0b290aCB3YXZlLiBcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGVMRk8gPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAgICAgJ21heCc6IDEsXG5cdCAgICAgICAgICAgICd0eXBlJzogJ3RyaWFuZ2xlJyxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogOTBcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMuX2Nyb3NzRmFkZS5mYWRlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGVsYXkgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0RlbGF5ID0gbmV3IFRvbmUuRGVsYXkob3B0aW9ucy5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZGVsYXkgb24gdGhlIGlucHV0IHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gdGhpcy5fZmVlZGJhY2tEZWxheS5kZWxheVRpbWU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ2RlbGF5VGltZScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhvbGQgdGhlIGN1cnJlbnQgcGl0Y2hcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9waXRjaCA9IG9wdGlvbnMucGl0Y2g7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZCB0aGUgY3VycmVudCB3aW5kb3dTaXplXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fd2luZG93U2l6ZSA9IG9wdGlvbnMud2luZG93U2l6ZTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIHR3byBkZWxheSBsaW5lcyB1cFxuXHQgICAgICAgIHRoaXMuX2RlbGF5QS5jb25uZWN0KHRoaXMuX2Nyb3NzRmFkZS5hKTtcblx0ICAgICAgICB0aGlzLl9kZWxheUIuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUuYik7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3kuZmFuKHRoaXMuX2xmb0EuZnJlcXVlbmN5LCB0aGlzLl9sZm9CLmZyZXF1ZW5jeSwgdGhpcy5fY3Jvc3NGYWRlTEZPLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy9yb3V0ZSB0aGUgaW5wdXRcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuZmFuKHRoaXMuX2RlbGF5QSwgdGhpcy5fZGVsYXlCKTtcblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGUuY2hhaW4odGhpcy5fZmVlZGJhY2tEZWxheSwgdGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIExGT3MgYXQgdGhlIHNhbWUgdGltZVxuXHQgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgIHRoaXMuX2xmb0Euc3RhcnQobm93KTtcblx0ICAgICAgICB0aGlzLl9sZm9CLnN0YXJ0KG5vdyk7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlTEZPLnN0YXJ0KG5vdyk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGluaXRpYWwgdmFsdWVcblx0ICAgICAgICB0aGlzLndpbmRvd1NpemUgPSB0aGlzLl93aW5kb3dTaXplO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGl0Y2hTaGlmdCwgVG9uZS5GZWVkYmFja0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuUGl0Y2hTaGlmdC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncGl0Y2gnOiAwLFxuXHQgICAgICAgICd3aW5kb3dTaXplJzogMC4xLFxuXHQgICAgICAgICdkZWxheVRpbWUnOiAwLFxuXHQgICAgICAgICdmZWVkYmFjayc6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZXBpdGNoIHRoZSBpbmNvbWluZyBzaWduYWwgYnkgc29tZSBpbnRlcnZhbCAobWVhc3VyZWRcblx0XHQgKiBpbiBzZW1pLXRvbmVzKS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGl0Y2hTaGlmdCNcblx0XHQgKiBAdHlwZSB7SW50ZXJ2YWx9XG5cdFx0ICogQG5hbWUgcGl0Y2hcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHBpdGNoU2hpZnQucGl0Y2ggPSAtMTI7IC8vZG93biBvbmUgb2N0YXZlXG5cdFx0ICogcGl0Y2hTaGlmdC5waXRjaCA9IDc7IC8vdXAgYSBmaWZ0aFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGl0Y2hTaGlmdC5wcm90b3R5cGUsICdwaXRjaCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpdGNoO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGl0Y2ggPSBpbnRlcnZhbDtcblx0ICAgICAgICAgICAgdmFyIGZhY3RvciA9IDA7XG5cdCAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0EubWluID0gMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0EubWF4ID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0IubWluID0gMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0IubWF4ID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICAgICAgICAgIGZhY3RvciA9IHRoaXMuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGludGVydmFsIC0gMSkgKyAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQS5taW4gPSB0aGlzLl93aW5kb3dTaXplO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQS5tYXggPSAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQi5taW4gPSB0aGlzLl93aW5kb3dTaXplO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGZvQi5tYXggPSAwO1xuXHQgICAgICAgICAgICAgICAgZmFjdG9yID0gdGhpcy5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oaW50ZXJ2YWwpIC0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9mcmVxdWVuY3kudmFsdWUgPSBmYWN0b3IgKiAoMS4yIC8gdGhpcy5fd2luZG93U2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgd2luZG93IHNpemUgY29ycmVzcG9uZHMgcm91Z2hseSB0byB0aGUgc2FtcGxlIGxlbmd0aCBpbiBhIGxvb3Bpbmcgc2FtcGxlci4gXG5cdFx0ICogU21hbGxlciB2YWx1ZXMgYXJlIGRlc2lyYWJsZSBmb3IgYSBsZXNzIG5vdGljZWFibGUgZGVsYXkgdGltZSBvZiB0aGUgcGl0Y2ggc2hpZnRlZFxuXHRcdCAqIHNpZ25hbCwgYnV0IGxhcmdlciB2YWx1ZXMgd2lsbCByZXN1bHQgaW4gc21vb3RoZXIgcGl0Y2ggc2hpZnRpbmcgZm9yIGxhcmdlciBpbnRlcnZhbHMuIFxuXHRcdCAqIEEgbm9taW5hbCByYW5nZSBvZiAwLjAzIHRvIDAuMSBpcyByZWNvbW1lbmRlZC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGl0Y2hTaGlmdCNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSB3aW5kb3dTaXplXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBwaXRjaFNoaWZ0LndpbmRvd1NpemUgPSAwLjE7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QaXRjaFNoaWZ0LnByb3RvdHlwZSwgJ3dpbmRvd1NpemUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl93aW5kb3dTaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl93aW5kb3dTaXplID0gdGhpcy50b1NlY29uZHMoc2l6ZSk7XG5cdCAgICAgICAgICAgIHRoaXMucGl0Y2ggPSB0aGlzLl9waXRjaDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGl0Y2hTaGlmdH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGl0Y2hTaGlmdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5QS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlBID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheUIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5QiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbGZvQS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvQSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbGZvQi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvQiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZUxGTy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlTEZPID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZGVsYXlUaW1lJyk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tEZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tEZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBpdGNoU2hpZnQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBCYXNlIGNsYXNzIGZvciBzdGVyZW8gZmVlZGJhY2sgZWZmZWN0cyB3aGVyZSB0aGUgZWZmZWN0UmV0dXJuXG5cdFx0ICogICAgICAgICBpcyBmZWQgYmFjayBpbnRvIHRoZSBzYW1lIGNoYW5uZWwuIFxuXHRcdCAqXG5cdFx0ICpcdEBjb25zdHJ1Y3RvclxuXHRcdCAqXHRAZXh0ZW5kcyB7VG9uZS5GZWVkYmFja0VmZmVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbJ2ZlZWRiYWNrJ10sIFRvbmUuRmVlZGJhY2tFZmZlY3QuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udHJvbHMgdGhlIGFtb3VudCBvZiBmZWVkYmFja1xuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZmVlZGJhY2ssIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxlZnQgc2lkZSBmZWViYWNrXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByaWdodCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1IgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLy9jb25uZWN0IGl0IHVwXG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5MLmNoYWluKHRoaXMuX2ZlZWRiYWNrTCwgdGhpcy5lZmZlY3RTZW5kTCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5SLmNoYWluKHRoaXMuX2ZlZWRiYWNrUiwgdGhpcy5lZmZlY3RTZW5kUik7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5mYW4odGhpcy5fZmVlZGJhY2tMLmdhaW4sIHRoaXMuX2ZlZWRiYWNrUi5nYWluKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3QsIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN0ZXJlb0ZlZWRiYWNrRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb0ZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydmZWVkYmFjayddKTtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0wuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1IgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlN0ZXJlb0ZlZWRiYWNrRWZmZWN0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQXBwbGllcyBhIHdpZHRoIGZhY3RvciB0byB0aGUgbWlkL3NpZGUgc2VwZXJhdGlvbi4gXG5cdFx0ICogICAgICAgICAwIGlzIGFsbCBtaWQgYW5kIDEgaXMgYWxsIHNpZGUuXG5cdFx0ICogICAgICAgICBBbGdvcml0aG0gZm91bmQgaW4gW2t2cmF1ZGlvIGZvcnVtc10oaHR0cDovL3d3dy5rdnJhdWRpby5jb20vZm9ydW0vdmlld3RvcGljLnBocD90PTIxMjU4NykuXG5cdFx0ICogICAgICAgICA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgPGNvZGU+XG5cdFx0ICogICAgICAgICBNaWQgKj0gMiooMS13aWR0aCk8YnI+XG5cdFx0ICogICAgICAgICBTaWRlICo9IDIqd2lkdGhcblx0XHQgKiAgICAgICAgIDwvY29kZT5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5NaWRTaWRlRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFt3aWR0aF0gVGhlIHN0ZXJlbyB3aWR0aC4gQSB3aWR0aCBvZiAwIGlzIG1vbm8gYW5kIDEgaXMgc3RlcmVvLiAwLjUgaXMgbm8gY2hhbmdlLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9XaWRlbmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWyd3aWR0aCddLCBUb25lLlN0ZXJlb1dpZGVuZXIuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTWlkU2lkZUVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB3aWR0aCBjb250cm9sLiAwID0gMTAwJSBtaWQuIDEgPSAxMDAlIHNpZGUuIDAuNSA9IG5vIGNoYW5nZS4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMud2lkdGggPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy53aWR0aCwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBNaWQgbXVsdGlwbGllclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZE11bHQgPSBuZXcgVG9uZS5FeHByKCckMCAqICgkMSAqICgxIC0gJDIpKScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNpZGUgbXVsdGlwbGllclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NpZGVNdWx0ID0gbmV3IFRvbmUuRXhwcignJDAgKiAoJDEgKiAkMiknKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBjb25zdGFudCBvdXRwdXQgb2YgMlxuXHRcdFx0ICogIEB0eXBlIHtUb25lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90d28gPSBuZXcgVG9uZS5TaWduYWwoMik7XG5cdCAgICAgICAgLy90aGUgbWlkIGNoYWluXG5cdCAgICAgICAgdGhpcy5fdHdvLmNvbm5lY3QodGhpcy5fbWlkTXVsdCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5jb25uZWN0KHRoaXMuX21pZE11bHQsIDAsIDIpO1xuXHQgICAgICAgIC8vdGhlIHNpZGUgY2hhaW5cblx0ICAgICAgICB0aGlzLl90d28uY29ubmVjdCh0aGlzLl9zaWRlTXVsdCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5jb25uZWN0KHRoaXMuX3NpZGVNdWx0LCAwLCAyKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgaXQgdG8gdGhlIGVmZmVjdCBzZW5kL3JldHVyblxuXHQgICAgICAgIHRoaXMubWlkU2VuZC5jaGFpbih0aGlzLl9taWRNdWx0LCB0aGlzLm1pZFJldHVybik7XG5cdCAgICAgICAgdGhpcy5zaWRlU2VuZC5jaGFpbih0aGlzLl9zaWRlTXVsdCwgdGhpcy5zaWRlUmV0dXJuKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ3dpZHRoJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvV2lkZW5lciwgVG9uZS5NaWRTaWRlRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9XaWRlbmVyLmRlZmF1bHRzID0geyAnd2lkdGgnOiAwLjUgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN0ZXJlb1dpZGVuZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvV2lkZW5lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1pZFNpZGVFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ3dpZHRoJ10pO1xuXHQgICAgICAgIHRoaXMud2lkdGguZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMud2lkdGggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZE11bHQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21pZE11bHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NpZGVNdWx0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaWRlTXVsdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdHdvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl90d28gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlN0ZXJlb1dpZGVuZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlRyZW1vbG8gbW9kdWxhdGVzIHRoZSBhbXBsaXR1ZGUgb2YgYW4gaW5jb21pbmcgc2lnbmFsIHVzaW5nIGEgVG9uZS5MRk8uXG5cdFx0ICogICAgICAgICBUaGUgdHlwZSwgZnJlcXVlbmN5LCBhbmQgZGVwdGggb2YgdGhlIExGTyBpcyBjb250cm9sbGFibGUuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU3RlcmVvRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IFtmcmVxdWVuY3ldIFRoZSByYXRlIG9mIHRoZSBlZmZlY3QuXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFtkZXB0aF0gVGhlIGRlcHRoIG9mIHRoZSBlZmZlY3QuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jcmVhdGUgYSB0cmVtb2xvIGFuZCBzdGFydCBpdCdzIExGT1xuXHRcdCAqIHZhciB0cmVtb2xvID0gbmV3IFRvbmUuVHJlbW9sbyg5LCAwLjc1KS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICogLy9yb3V0ZSBhbiBvc2NpbGxhdG9yIHRocm91Z2ggdGhlIHRyZW1vbG8gYW5kIHN0YXJ0IGl0XG5cdFx0ICogdmFyIG9zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdCh0cmVtb2xvKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmVtb2xvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuVHJlbW9sby5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHJlbWVsbyBMRk8gaW4gdGhlIGxlZnQgY2hhbm5lbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb0wgPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAncGhhc2UnOiBvcHRpb25zLnNwcmVhZCxcblx0ICAgICAgICAgICAgJ21pbic6IDEsXG5cdCAgICAgICAgICAgICdtYXgnOiAwXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRyZW1lbG8gTEZPIGluIHRoZSBsZWZ0IGNoYW5uZWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9SID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ3BoYXNlJzogb3B0aW9ucy5zcHJlYWQsXG5cdCAgICAgICAgICAgICdtaW4nOiAxLFxuXHQgICAgICAgICAgICAnbWF4JzogMFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFdoZXJlIHRoZSBnYWluIGlzIG11bHRpcGxpZWRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWRlTCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBXaGVyZSB0aGUgZ2FpbiBpcyBtdWx0aXBsaWVkXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVkZVIgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBvZiB0aGUgdHJlbW9sby5cblx0XHRcdCAqICBAdHlwZSAge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlcHRoIG9mIHRoZSBlZmZlY3QuIEEgZGVwdGggb2YgMCwgaGFzIG5vIGVmZmVjdFxuXHRcdFx0ICogIG9uIHRoZSBhbXBsaXR1ZGUsIGFuZCBhIGRlcHRoIG9mIDEgbWFrZXMgdGhlIGFtcGxpdHVkZVxuXHRcdFx0ICogIG1vZHVsYXRlIGZ1bGx5IGJldHdlZW4gMCBhbmQgMS5cblx0XHRcdCAqICBAdHlwZSAge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXB0aCwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jaGFpbih0aGlzLl9hbXBsaXR1ZGVMLCB0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY2hhaW4odGhpcy5fYW1wbGl0dWRlUiwgdGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmNvbm5lY3QodGhpcy5fYW1wbGl0dWRlTC5nYWluKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLmNvbm5lY3QodGhpcy5fYW1wbGl0dWRlUi5nYWluKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5mYW4odGhpcy5fbGZvTC5mcmVxdWVuY3ksIHRoaXMuX2xmb1IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRlcHRoLmZhbih0aGlzLl9sZm9SLmFtcGxpdHVkZSwgdGhpcy5fbGZvTC5hbXBsaXR1ZGUpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLnNwcmVhZCA9IG9wdGlvbnMuc3ByZWFkO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJlbW9sbywgVG9uZS5TdGVyZW9FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDEwLFxuXHQgICAgICAgICd0eXBlJzogJ3NpbmUnLFxuXHQgICAgICAgICdkZXB0aCc6IDAuNSxcblx0ICAgICAgICAnc3ByZWFkJzogMTgwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RhcnQgdGhlIHRyZW1vbG8uXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHRyZW1vbG8gYmVnaW5zLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zdGFydCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdG9wIHRoZSB0cmVtb2xvLlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSB0cmVtb2xvIHN0b3BzLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvTC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2xmb1Iuc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTeW5jIHRoZSBlZmZlY3QgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFtkZWxheT0wXSBEZWxheSB0aW1lIGJlZm9yZSBzdGFydGluZyB0aGUgZWZmZWN0IGFmdGVyIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0IGhhcyBzdGFydGVkLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChkZWxheSkge1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3luYyhkZWxheSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zeW5jKGRlbGF5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBVbnN5bmMgdGhlIGZpbHRlciBmcm9tIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5UcmVtb2xvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8ucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9sZm9MLnVuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX2xmb1IudW5zeW5jKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIFRyZW1vbG8ncyBvc2NpbGxhdG9yIHR5cGUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJlbW9sbyNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyZW1vbG8ucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmb0wudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKiBcblx0XHQgKiBBbW91bnQgb2Ygc3RlcmVvIHNwcmVhZC4gV2hlbiBzZXQgdG8gMCwgYm90aCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBjZW50cmFsbHkuXG5cdFx0ICogV2hlbiBzZXQgdG8gMTgwLCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBoYXJkIGxlZnQgYW5kIHJpZ2h0IHJlc3BlY3RpdmVseS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UcmVtb2xvI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHNwcmVhZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJlbW9sby5wcm90b3R5cGUsICdzcHJlYWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm9SLnBoYXNlIC0gdGhpcy5fbGZvTC5waGFzZTsgICAgLy8xODBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNwcmVhZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLnBoYXNlID0gOTAgLSBzcHJlYWQgLyAyO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9SLnBoYXNlID0gc3ByZWFkIC8gMiArIDkwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9SLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVMID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVSID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVHJlbW9sbztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgVmlicmF0byBlZmZlY3QgY29tcG9zZWQgb2YgYSBUb25lLkRlbGF5IGFuZCBhIFRvbmUuTEZPLiBUaGUgTEZPXG5cdFx0ICogICAgICAgICBtb2R1bGF0ZXMgdGhlIGRlbGF5VGltZSBvZiB0aGUgZGVsYXksIGNhdXNpbmcgdGhlIHBpdGNoIHRvIHJpc2Vcblx0XHQgKiAgICAgICAgIGFuZCBmYWxsLiBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBmcmVxdWVuY3kgb2YgdGhlIHZpYnJhdG8uXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IGRlcHRoIFRoZSBhbW91bnQgdGhlIHBpdGNoIGlzIG1vZHVsYXRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuVmlicmF0byA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdLCBUb25lLlZpYnJhdG8uZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5IG5vZGUgdXNlZCBmb3IgdGhlIHZpYnJhdG8gZWZmZWN0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZSA9IG5ldyBUb25lLkRlbGF5KDAsIG9wdGlvbnMubWF4RGVsYXkpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBMRk8gdXNlZCB0byBjb250cm9sIHRoZSB2aWJyYXRvXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm8gPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAndHlwZSc6IG9wdGlvbnMudHlwZSxcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiBvcHRpb25zLm1heERlbGF5LFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdwaGFzZSc6IC05MCAgICAvL29mZnNlIHRoZSBwaGFzZSBzbyB0aGUgcmVzdGluZyBwb3NpdGlvbiBpcyBpbiB0aGUgY2VudGVyXG5cdCAgICAgICAgfSkuc3RhcnQoKS5jb25uZWN0KHRoaXMuX2RlbGF5Tm9kZS5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHZpYnJhdG9cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbGZvLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGVwdGggb2YgdGhlIHZpYnJhdG8uIFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5fbGZvLmFtcGxpdHVkZTtcblx0ICAgICAgICB0aGlzLmRlcHRoLnZhbHVlID0gb3B0aW9ucy5kZXB0aDtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNoYWluKHRoaXMuX2RlbGF5Tm9kZSwgdGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVmlicmF0bywgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlZpYnJhdG8uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21heERlbGF5JzogMC4wMDUsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDUsXG5cdCAgICAgICAgJ2RlcHRoJzogMC4xLFxuXHQgICAgICAgICd0eXBlJzogJ3NpbmUnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVHlwZSBvZiBvc2NpbGxhdG9yIGF0dGFjaGVkIHRvIHRoZSBWaWJyYXRvLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlZpYnJhdG8jXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5WaWJyYXRvLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm8udHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5WaWJyYXRvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlZpYnJhdG8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbGZvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm8gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVmlicmF0bztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkV2ZW50IGFic3RyYWN0cyBhd2F5IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlIGFuZCBwcm92aWRlcyBhIHNjaGVkdWxhYmxlXG5cdFx0ICogICAgICAgICAgY2FsbGJhY2sgZm9yIGEgc2luZ2xlIG9yIHJlcGVhdGFibGUgZXZlbnRzIGFsb25nIHRoZSB0aW1lbGluZS4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2UgYXQgdGhlIHRpbWUuIFxuXHRcdCAqICBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvciB2YWx1ZXMgd2hpY2ggc2hvdWxkIGJlIHBhc3NlZCB0b1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvbiBpbnZvY2F0aW9uLiAgXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGNob3JkID0gbmV3IFRvbmUuRXZlbnQoZnVuY3Rpb24odGltZSwgY2hvcmQpe1xuXHRcdCAqIFx0Ly90aGUgY2hvcmQgYXMgd2VsbCBhcyB0aGUgZXhhY3QgdGltZSBvZiB0aGUgZXZlbnRcblx0XHQgKiBcdC8vYXJlIHBhc3NlZCBpbiBhcyBhcmd1bWVudHMgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdFx0ICogfSwgW1wiRDRcIiwgXCJFNFwiLCBcIkY0XCJdKTtcblx0XHQgKiAvL3N0YXJ0IHRoZSBjaG9yZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0cmFuc3BvcnQgdGltZWxpbmVcblx0XHQgKiBjaG9yZC5zdGFydCgpO1xuXHRcdCAqIC8vbG9vcCBpdCBldmVyeSBtZWFzdXJlIGZvciA4IG1lYXN1cmVzXG5cdFx0ICogY2hvcmQubG9vcCA9IDg7XG5cdFx0ICogY2hvcmQubG9vcEVuZCA9IFwiMW1cIjtcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICd2YWx1ZSdcblx0ICAgICAgICBdLCBUb25lLkV2ZW50LmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBMb29wIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUgIHtCb29sZWFufFBvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYWxsYmFjayB0byBpbnZva2UuIFxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdmFsdWUgd2hpY2ggaXMgcGFzc2VkIHRvIHRoZVxuXHRcdFx0ICogIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHRcdFx0ICogIEB0eXBlICB7Kn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgV2hlbiB0aGUgbm90ZSBpcyBzY2hlZHVsZWQgdG8gc3RhcnQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhvcHRpb25zLmxvb3BTdGFydCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgV2hlbiB0aGUgbm90ZSBpcyBzY2hlZHVsZWQgdG8gc3RhcnQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvVGlja3Mob3B0aW9ucy5sb29wRW5kKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUcmFja3MgdGhlIHNjaGVkdWxlZCBldmVudHNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZVN0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG5vdGUuIEEgc3BlZWQgb2YgMVxuXHRcdFx0ICogIGlzIG5vIGNoYW5nZS4gXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSAxO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgZGVsYXkgdGltZSBmcm9tIHdoZW4gdGhlIGV2ZW50IGlzIHNjaGVkdWxlZCB0byBzdGFydFxuXHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhcnRPZmZzZXQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwcm9iYWJpbGl0eSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcblx0XHRcdCAqICBhdCB0aGUgc2NoZWR1bGVkIHRpbWUuIFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy90aGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIDUwJSBvZiB0aGUgdGltZVxuXHRcdFx0ICogZXZlbnQucHJvYmFiaWxpdHkgPSAwLjU7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnByb2JhYmlsaXR5ID0gb3B0aW9ucy5wcm9iYWJpbGl0eTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCBhcHBseSBzbWFsbCAoKy8tMC4wMiBzZWNvbmRzKSByYW5kb20gdmFyaWF0aW9uXG5cdFx0XHQgKiAgdG8gdGhlIGNhbGxiYWNrIHRpbWUuIElmIHRoZSB2YWx1ZSBpcyBnaXZlbiBhcyBhIHRpbWUsIGl0IHdpbGwgcmFuZG9taXplXG5cdFx0XHQgKiAgYnkgdGhhdCBhbW91bnQuXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIGV2ZW50Lmh1bWFuaXplID0gdHJ1ZTtcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5odW1hbml6ZSA9IG9wdGlvbnMuaHVtYW5pemU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgbXV0ZSBpcyB0cnVlLCB0aGUgY2FsbGJhY2sgd29uJ3QgYmVcblx0XHRcdCAqICBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FdmVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ2xvb3BFbmQnOiAnMW0nLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxLFxuXHQgICAgICAgICd2YWx1ZSc6IG51bGwsXG5cdCAgICAgICAgJ3Byb2JhYmlsaXR5JzogMSxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlLFxuXHQgICAgICAgICdodW1hbml6ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlc2NoZWR1bGUgYWxsIG9mIHRoZSBldmVudHMgYWxvbmcgdGhlIHRpbWVsaW5lXG5cdFx0ICogIHdpdGggdGhlIHVwZGF0ZWQgdmFsdWVzLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGFmdGVyIE9ubHkgcmVzY2hlZHVsZXMgZXZlbnRzIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLl9yZXNjaGVkdWxlRXZlbnRzID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgLy9pZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgc2NoZWR1bGVzIGFsbCBvZiB0aGUgZXZlbnRzXG5cdCAgICAgICAgYWZ0ZXIgPSB0aGlzLmRlZmF1bHRBcmcoYWZ0ZXIsIC0xKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoRnJvbShhZnRlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBkdXJhdGlvbjtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKGV2ZW50LmlkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0LmNsZWFyKGV2ZW50LmlkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydFRpY2sgPSBldmVudC50aW1lICsgTWF0aC5yb3VuZCh0aGlzLnN0YXJ0T2Zmc2V0IC8gdGhpcy5fcGxheWJhY2tSYXRlKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBJbmZpbml0eTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc051bWJlcih0aGlzLl9sb29wKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuX2xvb3AgKiB0aGlzLl9nZXRMb29wRHVyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRFdmVudCA9IHRoaXMuX3N0YXRlLmdldEFmdGVyKHN0YXJ0VGljayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFdmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWluKGR1cmF0aW9uLCBuZXh0RXZlbnQudGltZSAtIHN0YXJ0VGljayk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiAhPT0gSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9zY2hlZHVsZSBhIHN0b3Agc2luY2UgaXQncyBmaW5pdGUgZHVyYXRpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCBzdGFydFRpY2sgKyBkdXJhdGlvbiArIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IFRvbmUuVGltZShkdXJhdGlvbiwgJ2knKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gVG9uZS5UaW1lKHRoaXMuX2dldExvb3BEdXJhdGlvbigpLCAnaScpO1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LmlkID0gVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGVSZXBlYXQodGhpcy5fdGljay5iaW5kKHRoaXMpLCBpbnRlcnZhbCwgVG9uZS5UcmFuc3BvcnRUaW1lKHN0YXJ0VGljaywgJ2knKSwgZHVyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5pZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKHRoaXMuX3RpY2suYmluZCh0aGlzKSwgc3RhcnRUaWNrICsgJ2knKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBub3RlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQudGlja3MpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdGFydCBmcm9tIHRoZSBzY2hlZHVsZWQgc3RhcnQgdGltZVxuXHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAbmFtZSBzdGFydE9mZnNldFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnc3RhcnRPZmZzZXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydE9mZnNldDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGFydE9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgbm90ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb259ICB0aW1lICBXaGVuIHRoZSBub3RlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRXZlbnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RvcHBlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5hZGQoe1xuXHQgICAgICAgICAgICAgICAgJ3N0YXRlJzogVG9uZS5TdGF0ZS5TdGFydGVkLFxuXHQgICAgICAgICAgICAgICAgJ3RpbWUnOiB0aW1lLFxuXHQgICAgICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgRXZlbnQgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb259ICB0aW1lICBXaGVuIHRoZSBub3RlIHNob3VsZCBzdG9wLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpbWUpID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCB0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzRXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXRCZWZvcmUodGltZSk7XG5cdCAgICAgICAgICAgIHZhciByZXNjaGVkdWxUaW1lID0gdGltZTtcblx0ICAgICAgICAgICAgaWYgKHByZXZpb3VzRXZlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJlc2NoZWR1bFRpbWUgPSBwcmV2aW91c0V2ZW50LnRpbWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cyhyZXNjaGVkdWxUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbCBhbGwgc2NoZWR1bGVkIGV2ZW50cyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIFt0aW1lPTBdICBUaGUgdGltZSBhZnRlciB3aGljaCBldmVudHMgd2lsbCBiZSBjYW5jZWwuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkV2ZW50fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy5kZWZhdWx0QXJnKHRpbWUsIC1JbmZpbml0eSk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoRnJvbSh0aW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQuY2xlYXIoZXZlbnQuaWQpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZXIuIEFsc28gXG5cdFx0ICogIGNoZWNrcyBpZiB0aGUgRXZlbnQgaXMgZG9uZSBwbGF5aW5nXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBzZWNvbmRzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm11dGUgJiYgdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQudGlja3MpID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMucHJvYmFiaWxpdHkgPCAxICYmIE1hdGgucmFuZG9tKCkgPiB0aGlzLnByb2JhYmlsaXR5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuaHVtYW5pemUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YXJpYXRpb24gPSAwLjAyO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQm9vbGVhbih0aGlzLmh1bWFuaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhcmlhdGlvbiA9IHRoaXMudG9TZWNvbmRzKHRoaXMuaHVtYW5pemUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGltZSArPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIHZhcmlhdGlvbjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRpbWUsIHRoaXMudmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgbG9vcC5cblx0XHQgKiAgQHJldHVybiAge1RpY2tzfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuX2dldExvb3BEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgodGhpcy5fbG9vcEVuZCAtIHRoaXMuX2xvb3BTdGFydCkgLyB0aGlzLl9wbGF5YmFja1JhdGUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiB0aGUgbm90ZSBzaG91bGQgbG9vcCBvciBub3Rcblx0XHQgKiAgYmV0d2VlbiBUb25lLkV2ZW50Lmxvb3BTdGFydCBhbmQgXG5cdFx0ICogIFRvbmUuRXZlbnQubG9vcEVuZC4gQW4gaW50ZWdlclxuXHRcdCAqICB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgbnVtYmVyIG9mXG5cdFx0ICogIGxvb3BzIHRoZSBFdmVudCBkb2VzIGFmdGVyIGl0IHN0YXJ0cy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFBvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBsb29wXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdsb29wJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3ApIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3A7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jlc2NoZWR1bGVFdmVudHMoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0VGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIG5vdGUuIERlZmF1bHRzIHRvIDEuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIHBsYXliYWNrUmF0ZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIG5vdGUubG9vcCA9IHRydWU7XG5cdFx0ICogLy9yZXBlYXQgdGhlIG5vdGUgdHdpY2UgYXMgZmFzdFxuXHRcdCAqIG5vdGUucGxheWJhY2tSYXRlID0gMjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3BsYXliYWNrUmF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gcmF0ZTtcblx0ICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBsb29wRW5kIHBvaW50IGlzIHRoZSB0aW1lIHRoZSBldmVudCB3aWxsIGxvb3Bcblx0XHQgKiAgaWYgVG9uZS5FdmVudC5sb29wIGlzIHRydWUuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAdHlwZSB7VHJhbnNwb3J0VGltZX1cblx0XHQgKiAgQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnbG9vcEVuZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZSh0aGlzLl9sb29wRW5kLCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BFbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcEVuZCA9IHRoaXMudG9UaWNrcyhsb29wRW5kKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2NoZWR1bGVFdmVudHMoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB0aW1lIHdoZW4gdGhlIGxvb3Agc2hvdWxkIHN0YXJ0LiBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqICBAbmFtZSBsb29wU3RhcnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZSh0aGlzLl9sb29wU3RhcnQsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcFN0YXJ0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhsb29wU3RhcnQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGxvb3AgaW50ZXJ2YWwuXG5cdFx0ICogIFJldHVybnMgMCBpZiB0aGUgZXZlbnQgaXMgbm90IHN0YXJ0ZWQgeWV0IG9yXG5cdFx0ICogIGl0IGlzIG5vdCBzZXQgdG8gbG9vcC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvZ3Jlc3Ncblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0aWNrcyA9IFRvbmUuVHJhbnNwb3J0LnRpY2tzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhc3RFdmVudCA9IHRoaXMuX3N0YXRlLmdldCh0aWNrcyk7XG5cdCAgICAgICAgICAgICAgICBpZiAobGFzdEV2ZW50ICE9PSBudWxsICYmIGxhc3RFdmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxvb3BEdXJhdGlvbiA9IHRoaXMuX2dldExvb3BEdXJhdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9ICh0aWNrcyAtIGxhc3RFdmVudC50aW1lKSAlIGxvb3BEdXJhdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3MgLyBsb29wRHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jYW5jZWwoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkV2ZW50O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuTG9vcCBjcmVhdGVzIGEgbG9vcGVkIGNhbGxiYWNrIGF0IHRoZSBcblx0XHQgKiAgICAgICAgIHNwZWNpZmllZCBpbnRlcnZhbC4gVGhlIGNhbGxiYWNrIGNhbiBiZSBcblx0XHQgKiAgICAgICAgIHN0YXJ0ZWQsIHN0b3BwZWQgYW5kIHNjaGVkdWxlZCBhbG9uZ1xuXHRcdCAqICAgICAgICAgdGhlIFRyYW5zcG9ydCdzIHRpbWVsaW5lLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbG9vcCA9IG5ldyBUb25lLkxvb3AoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHQvL3RyaWdnZXJlZCBldmVyeSBlaWdodGggbm90ZS4gXG5cdFx0ICogXHRjb25zb2xlLmxvZyh0aW1lKTtcblx0XHQgKiB9LCBcIjhuXCIpLnN0YXJ0KDApO1xuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KCk7XG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGludGVydmFsIFRoZSB0aW1lIGJldHdlZW4gc3VjY2Vzc2l2ZSBjYWxsYmFjayBjYWxscy4gXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdpbnRlcnZhbCdcblx0ICAgICAgICBdLCBUb25lLkxvb3AuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBldmVudCB3aGljaCBwcm9kdWNlcyB0aGUgY2FsbGJhY2tzXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ldmVudCA9IG5ldyBUb25lLkV2ZW50KHtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJzogdGhpcy5fdGljay5iaW5kKHRoaXMpLFxuXHQgICAgICAgICAgICAnbG9vcCc6IHRydWUsXG5cdCAgICAgICAgICAgICdsb29wRW5kJzogb3B0aW9ucy5pbnRlcnZhbCxcblx0ICAgICAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IG9wdGlvbnMucGxheWJhY2tSYXRlLFxuXHQgICAgICAgICAgICAncHJvYmFiaWxpdHknOiBvcHRpb25zLnByb2JhYmlsaXR5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIHRoZSBuZXh0IGV2ZW50IGluIHRoZSBwYXR0ZXJuXG5cdFx0XHQgKiAgQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cdCAgICAgICAgLy9zZXQgdGhlIGl0ZXJhdGlvbnNcblx0ICAgICAgICB0aGlzLml0ZXJhdGlvbnMgPSBvcHRpb25zLml0ZXJhdGlvbnM7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Mb29wKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb29wLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdpbnRlcnZhbCc6ICc0bicsXG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxLFxuXHQgICAgICAgICdpdGVyYXRpb25zJzogSW5maW5pdHksXG5cdCAgICAgICAgJ3Byb2JhYmlsaXR5JzogdHJ1ZSxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBsb29wIGF0IHRoZSBzcGVjaWZpZWQgdGltZSBhbG9uZyB0aGUgVHJhbnNwb3J0J3Ncblx0XHQgKiAgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb249fSAgdGltZSAgV2hlbiB0byBzdGFydCB0aGUgTG9vcC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTG9vcH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50LnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBsb29wIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9uPX0gIHRpbWUgIFdoZW4gdG8gc3RvcCB0aGUgQXJwZWdnaW9cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTG9vcH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQuc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGFsbCBzY2hlZHVsZWQgZXZlbnRzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9ufSAgW3RpbWU9MF0gIFRoZSB0aW1lIGFmdGVyIHdoaWNoIGV2ZW50cyB3aWxsIGJlIGNhbmNlbC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTG9vcH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudC5jYW5jZWwodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBub3RlcyBzaG91bGQgYmUgY2FsbGVkXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRoZSBldmVudCBvY2N1cnNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdGF0ZSBvZiB0aGUgTG9vcCwgZWl0aGVyIHN0YXJ0ZWQgb3Igc3RvcHBlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQuc3RhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHByb2dyZXNzIG9mIHRoZSBsb29wIGFzIGEgdmFsdWUgYmV0d2VlbiAwLTEuIDAsIHdoZW5cblx0XHQgKiAgdGhlIGxvb3AgaXMgc3RvcHBlZCBvciBkb25lIGl0ZXJhdGluZy4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvZ3Jlc3Ncblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ3Byb2dyZXNzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQucHJvZ3Jlc3M7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHRpbWUgYmV0d2VlbiBzdWNjZXNzaXZlIGNhbGxiYWNrcy4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogbG9vcC5pbnRlcnZhbCA9IFwiOG5cIjsgLy9sb29wIGV2ZXJ5IDhuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqICBAbmFtZSBpbnRlcnZhbFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdpbnRlcnZhbCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50Lmxvb3BFbmQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudC5sb29wRW5kID0gaW50ZXJ2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIGxvb3AuIFRoZSBub3JtYWwgcGxheWJhY2sgcmF0ZSBpcyAxIChubyBjaGFuZ2UpLiBcblx0XHQgKiAgQSBgcGxheWJhY2tSYXRlYCBvZiAyIHdvdWxkIGJlIHR3aWNlIGFzIGZhc3QuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHQgKiAgQG5hbWUgcGxheWJhY2tSYXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ3BsYXliYWNrUmF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50LnBsYXliYWNrUmF0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnQucGxheWJhY2tSYXRlID0gcmF0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSYW5kb20gdmFyaWF0aW9uICsvLTAuMDFzIHRvIHRoZSBzY2hlZHVsZWQgdGltZS4gXG5cdFx0ICogIE9yIGdpdmUgaXQgYSB0aW1lIHZhbHVlIHdoaWNoIGl0IHdpbGwgcmFuZG9taXplIGJ5LlxuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxUaW1lfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAbmFtZSBodW1hbml6ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdodW1hbml6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50Lmh1bWFuaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFyaWF0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50Lmh1bWFuaXplID0gdmFyaWF0aW9uO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwcm9iYWJseSBvZiB0aGUgY2FsbGJhY2sgYmVpbmcgaW52b2tlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBwcm9iYWJpbGl0eVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdwcm9iYWJpbGl0eScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50LnByb2JhYmlsaXR5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocHJvYikge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudC5wcm9iYWJpbGl0eSA9IHByb2I7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgTXV0aW5nIHRoZSBMb29wIG1lYW5zIHRoYXQgbm8gY2FsbGJhY2tzIGFyZSBpbnZva2VkLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiAgQG5hbWUgbXV0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnQubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIG9mIHRoZSBsb29wLiBUaGUgZGVmYXVsdFxuXHRcdCAqICB2YWx1ZSBpcyBJbmZpbml0eSAobG9vcCBmb3JldmVyKS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBpdGVyYXRpb25zXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Mb29wLnByb3RvdHlwZSwgJ2l0ZXJhdGlvbnMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudC5sb29wID09PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQubG9vcDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0dGVybi5pbmRleDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGl0ZXJzKSB7XG5cdCAgICAgICAgICAgIGlmIChpdGVycyA9PT0gSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Lmxvb3AgPSB0cnVlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnQubG9vcCA9IGl0ZXJzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuTG9vcH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxvb3A7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhcnQgaXMgYSBjb2xsZWN0aW9uIFRvbmUuRXZlbnRzIHdoaWNoIGNhbiBiZVxuXHRcdCAqICAgICAgICAgc3RhcnRlZC9zdG9wZWQgYW5kIGxvb3BlZCBhcyBhIHNpbmdsZSB1bml0LlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkV2ZW50fVxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggZXZlbnRcblx0XHQgKiAgQHBhcmFtIHtBcnJheX0gZXZlbnRzIHRoZSBhcnJheSBvZiBldmVudHNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcGFydCA9IG5ldyBUb25lLlBhcnQoZnVuY3Rpb24odGltZSwgbm90ZSl7XG5cdFx0ICogXHQvL3RoZSBub3RlcyBnaXZlbiBhcyB0aGUgc2Vjb25kIGVsZW1lbnQgaW4gdGhlIGFycmF5XG5cdFx0ICogXHQvL3dpbGwgYmUgcGFzc2VkIGluIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcblx0XHQgKiBcdHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKG5vdGUsIFwiOG5cIiwgdGltZSk7XG5cdFx0ICogfSwgW1swLCBcIkMyXCJdLCBbXCIwOjJcIiwgXCJDM1wiXSwgW1wiMDozOjJcIiwgXCJHMlwiXV0pO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdXNlIGFuIGFycmF5IG9mIG9iamVjdHMgYXMgbG9uZyBhcyB0aGUgb2JqZWN0IGhhcyBhIFwidGltZVwiIGF0dHJpYnV0ZVxuXHRcdCAqIHZhciBwYXJ0ID0gbmV3IFRvbmUuUGFydChmdW5jdGlvbih0aW1lLCB2YWx1ZSl7XG5cdFx0ICogXHQvL3RoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgYm90aCB0aGUgbm90ZSBhbmQgdGhlIHZlbG9jaXR5XG5cdFx0ICogXHRzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZSh2YWx1ZS5ub3RlLCBcIjhuXCIsIHRpbWUsIHZhbHVlLnZlbG9jaXR5KTtcblx0XHQgKiB9LCBbe1widGltZVwiIDogMCwgXCJub3RlXCIgOiBcIkMzXCIsIFwidmVsb2NpdHlcIjogMC45fSwgXG5cdFx0ICogXHQgICB7XCJ0aW1lXCIgOiBcIjA6MlwiLCBcIm5vdGVcIiA6IFwiQzRcIiwgXCJ2ZWxvY2l0eVwiOiAwLjV9XG5cdFx0ICogXSkuc3RhcnQoMCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdldmVudHMnXG5cdCAgICAgICAgXSwgVG9uZS5QYXJ0LmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJZiB0aGUgcGFydCBpcyBsb29waW5nIG9yIG5vdFxuXHRcdFx0ICogIEB0eXBlICB7Qm9vbGVhbnxQb3NpdGl2ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcCA9IG9wdGlvbnMubG9vcDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBXaGVuIHRoZSBub3RlIGlzIHNjaGVkdWxlZCB0byBzdGFydC5cblx0XHRcdCAqICBAdHlwZSAge1RpY2tzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSB0aGlzLnRvVGlja3Mob3B0aW9ucy5sb29wU3RhcnQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFdoZW4gdGhlIG5vdGUgaXMgc2NoZWR1bGVkIHRvIHN0YXJ0LlxuXHRcdFx0ICogIEB0eXBlICB7VGlja3N9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvVGlja3Mob3B0aW9ucy5sb29wRW5kKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2sgcmF0ZSBvZiB0aGUgcGFydFxuXHRcdFx0ICogIEB0eXBlICB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHByaXZhdGUgaG9sZGVyIG9mIHByb2JhYmlsaXR5IHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wcm9iYWJpbGl0eSA9IG9wdGlvbnMucHJvYmFiaWxpdHk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFtb3VudCBvZiB2YXJpYXRpb24gZnJvbSB0aGVcblx0XHRcdCAqICBnaXZlbiB0aW1lLiBcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxUaW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9odW1hbml6ZSA9IG9wdGlvbnMuaHVtYW5pemU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHN0YXJ0IG9mZnNldFxuXHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhcnRPZmZzZXQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IHN0YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgVG9uZS5UaW1lbGluZVN0YXRlKFRvbmUuU3RhdGUuU3RvcHBlZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQW4gYXJyYXkgb2YgT2JqZWN0cy4gXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBhdCBhbGwgdGhlIHNjaGVkdWxlZCBldmVudHMuXG5cdFx0XHQgKiAgQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgbXV0ZSBpcyB0cnVlLCB0aGUgY2FsbGJhY2sgd29uJ3QgYmVcblx0XHRcdCAqICBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgICAgIC8vYWRkIHRoZSBldmVudHNcblx0ICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5kZWZhdWx0QXJnKG9wdGlvbnMuZXZlbnRzLCBbXSk7XG5cdCAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWYob3B0aW9ucy5ldmVudHMpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudHNbaV0pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoZXZlbnRzW2ldWzBdLCBldmVudHNbaV1bMV0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChldmVudHNbaV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFydCwgVG9uZS5FdmVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnY2FsbGJhY2snOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ2xvb3AnOiBmYWxzZSxcblx0ICAgICAgICAnbG9vcEVuZCc6ICcxbScsXG5cdCAgICAgICAgJ2xvb3BTdGFydCc6IDAsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDEsXG5cdCAgICAgICAgJ3Byb2JhYmlsaXR5JzogMSxcblx0ICAgICAgICAnaHVtYW5pemUnOiBmYWxzZSxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBwYXJ0IGF0IHRoZSBnaXZlbiB0aW1lLiBcblx0XHQgKiAgQHBhcmFtICB7VHJhbnNwb3J0VGltZX0gIHRpbWUgICAgV2hlbiB0byBzdGFydCB0aGUgcGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBvZmZzZXQgIFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhcnRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlZ2luIHBsYXlpbmcgYXQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgIHZhciB0aWNrcyA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGlja3MpICE9PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZGVmYXVsdEFyZyhvZmZzZXQsIHRoaXMuX2xvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvVGlja3Mob2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuYWRkKHtcblx0ICAgICAgICAgICAgICAgICdzdGF0ZSc6IFRvbmUuU3RhdGUuU3RhcnRlZCxcblx0ICAgICAgICAgICAgICAgICd0aW1lJzogdGlja3MsXG5cdCAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnROb3RlKGV2ZW50LCB0aWNrcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGV2ZW50IGF0IHRoZSBjb3JyZWN0IHRpbWUgZ2l2ZW5cblx0XHQgKiAgdGhlIHRpY2tzIGFuZCBvZmZzZXQgYW5kIGxvb3BpbmcuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuRXZlbnR9ICBldmVudCBcblx0XHQgKiAgQHBhcmFtICB7VGlja3N9ICB0aWNrc1xuXHRcdCAqICBAcGFyYW0gIHtUaWNrc30gIG9mZnNldFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5fc3RhcnROb3RlID0gZnVuY3Rpb24gKGV2ZW50LCB0aWNrcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgdGlja3MgLT0gb2Zmc2V0O1xuXHQgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA+PSB0aGlzLl9sb29wU3RhcnQgJiYgZXZlbnQuc3RhcnRPZmZzZXQgPCB0aGlzLl9sb29wRW5kKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0IGl0IG9uIHRoZSBuZXh0IGxvb3Bcblx0ICAgICAgICAgICAgICAgICAgICB0aWNrcyArPSB0aGlzLl9nZXRMb29wRHVyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0YXJ0KFRvbmUuVHJhbnNwb3J0VGltZSh0aWNrcywgJ2knKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPCB0aGlzLl9sb29wU3RhcnQgJiYgZXZlbnQuc3RhcnRPZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5sb29wID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBldmVudC5zdGFydChUb25lLlRyYW5zcG9ydFRpbWUodGlja3MsICdpJykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0ID49IG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuc3RhcnQoVG9uZS5UcmFuc3BvcnRUaW1lKHRpY2tzLCAnaScpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHN0YXJ0IGZyb20gdGhlIHNjaGVkdWxlZCBzdGFydCB0aW1lXG5cdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQG5hbWUgc3RhcnRPZmZzZXRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnc3RhcnRPZmZzZXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydE9mZnNldDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGFydE9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0YXJ0T2Zmc2V0ICs9IHRoaXMuX3N0YXJ0T2Zmc2V0O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBwYXJ0IGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9ufSAgdGltZSAgV2hlbiB0byBzdG9wIHRoZSBwYXJ0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpY2tzKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpY2tzKTtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQvU2V0IGFuIEV2ZW50J3MgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFxuXHRcdCAqICBJZiBhIHZhbHVlIGlzIHBhc3NlZCBpbiBhbmQgbm8gZXZlbnQgZXhpc3RzIGF0XG5cdFx0ICogIHRoZSBnaXZlbiB0aW1lLCBvbmUgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhhdCB2YWx1ZS4gXG5cdFx0ICogIElmIHR3byBldmVudHMgYXJlIGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBmaXJzdCBvbmUgd2lsbFxuXHRcdCAqICBiZSByZXR1cm5lZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBwYXJ0LmF0KFwiMW1cIik7IC8vcmV0dXJucyB0aGUgcGFydCBhdCB0aGUgZmlyc3QgbWVhc3VyZVxuXHRcdCAqXG5cdFx0ICogcGFydC5hdChcIjJtXCIsIFwiQzJcIik7IC8vc2V0IHRoZSB2YWx1ZSBhdCBcIjJtXCIgdG8gQzIuIFxuXHRcdCAqIC8vaWYgYW4gZXZlbnQgZGlkbid0IGV4aXN0IGF0IHRoYXQgdGltZSwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50IHRvIGdldCBvciBzZXQuXG5cdFx0ICogIEBwYXJhbSB7Kj19IHZhbHVlIElmIGEgdmFsdWUgaXMgcGFzc2VkIGluLCB0aGUgdmFsdWUgb2YgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgIGV2ZW50IGF0IHRoZSBnaXZlbiB0aW1lIHdpbGwgYmUgc2V0IHRvIGl0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkV2ZW50fSB0aGUgZXZlbnQgYXQgdGhlIHRpbWVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUpIHtcblx0ICAgICAgICB0aW1lID0gVG9uZS5UcmFuc3BvcnRUaW1lKHRpbWUpO1xuXHQgICAgICAgIHZhciB0aWNrVGltZSA9IFRvbmUuVGltZSgxLCAnaScpLnRvU2Vjb25kcygpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRpbWUudG9UaWNrcygpIC0gZXZlbnQuc3RhcnRPZmZzZXQpIDwgdGlja1RpbWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pZiB0aGVyZSB3YXMgbm8gZXZlbnQgYXQgdGhhdCB0aW1lLCBjcmVhdGUgb25lXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWYodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuYWRkKHRpbWUsIHZhbHVlKTtcblx0ICAgICAgICAgICAgLy9yZXR1cm4gdGhlIG5ldyBldmVudFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzW3RoaXMuX2V2ZW50cy5sZW5ndGggLSAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIGFuIGV2ZW50IHRvIHRoZSBwYXJ0LiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lIFRoZSB0aW1lIHRoZSBub3RlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGluLCBpdCBzaG91bGRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGEgJ3RpbWUnIGF0dHJpYnV0ZSBhbmQgdGhlIHJlc3Rcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyB0aGUgJ3ZhbHVlJy5cblx0XHQgKiAgQHBhcmFtICB7VG9uZS5FdmVudHwqfSAgdmFsdWUgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBwYXJ0LmFkZChcIjFtXCIsIFwiQyMrMTFcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vZXh0cmFjdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmICh0aW1lLmhhc093blByb3BlcnR5KCd0aW1lJykpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aW1lO1xuXHQgICAgICAgICAgICB0aW1lID0gdmFsdWUudGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICB2YXIgZXZlbnQ7XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVG9uZS5FdmVudCkge1xuXHQgICAgICAgICAgICBldmVudCA9IHZhbHVlO1xuXHQgICAgICAgICAgICBldmVudC5jYWxsYmFjayA9IHRoaXMuX3RpY2suYmluZCh0aGlzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBldmVudCA9IG5ldyBUb25lLkV2ZW50KHtcblx0ICAgICAgICAgICAgICAgICdjYWxsYmFjayc6IHRoaXMuX3RpY2suYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3RoZSBzdGFydCBvZmZzZXRcblx0ICAgICAgICBldmVudC5zdGFydE9mZnNldCA9IHRpbWU7XG5cdCAgICAgICAgLy9pbml0aWFsaXplIHRoZSB2YWx1ZXNcblx0ICAgICAgICBldmVudC5zZXQoe1xuXHQgICAgICAgICAgICAnbG9vcEVuZCc6IHRoaXMubG9vcEVuZCxcblx0ICAgICAgICAgICAgJ2xvb3BTdGFydCc6IHRoaXMubG9vcFN0YXJ0LFxuXHQgICAgICAgICAgICAnbG9vcCc6IHRoaXMubG9vcCxcblx0ICAgICAgICAgICAgJ2h1bWFuaXplJzogdGhpcy5odW1hbml6ZSxcblx0ICAgICAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IHRoaXMucGxheWJhY2tSYXRlLFxuXHQgICAgICAgICAgICAncHJvYmFiaWxpdHknOiB0aGlzLnByb2JhYmlsaXR5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG5vdGUgaWYgaXQgc2hvdWxkIGJlIHBsYXllZCByaWdodCBub3dcblx0ICAgICAgICB0aGlzLl9yZXN0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXN0YXJ0IHRoZSBnaXZlbiBldmVudFxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkV2ZW50fSAgZXZlbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl9yZXN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZUV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChzdGF0ZUV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Tm90ZShldmVudCwgc3RhdGVFdmVudC50aW1lLCBzdGF0ZUV2ZW50Lm9mZnNldCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvL3N0b3AgdGhlIG5vdGVcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0b3AoVG9uZS5UcmFuc3BvcnRUaW1lKHN0YXRlRXZlbnQudGltZSwgJ2knKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgcGFydC4gV2lsbCByZWN1cnNpdmVseSBpdGVyYXRlXG5cdFx0ICogIGludG8gbmVzdGVkIHBhcnRzIHRvIGZpbmQgdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uYWxseSBzZWxlY3Qgb25seSBhIHNwZWNpZmljIGV2ZW50IHZhbHVlXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vZXh0cmFjdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmICh0aW1lLmhhc093blByb3BlcnR5KCd0aW1lJykpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aW1lO1xuXHQgICAgICAgICAgICB0aW1lID0gdmFsdWUudGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fZXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgVG9uZS5QYXJ0KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5yZW1vdmUodGltZSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0ID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZih2YWx1ZSkgfHwgIXRoaXMuaXNVbmRlZih2YWx1ZSkgJiYgZXZlbnQudmFsdWUgPT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSBhbGwgb2YgdGhlIG5vdGVzIGZyb20gdGhlIGdyb3VwLiBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGFydH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIHNjaGVkdWxlZCBzdGF0ZSBjaGFuZ2UgZXZlbnRzOiBpLmUuIFwic3RhcnRcIiBhbmQgXCJzdG9wXCIuXG5cdFx0ICogIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbn0gYWZ0ZXIgVGhlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgZXZlbnRzLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICBhZnRlciA9IHRoaXMudG9UaWNrcyhhZnRlcik7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgZXZlbnQuY2FuY2VsKGFmdGVyKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBldmVudHNcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IGN0eCBUaGUgY29udGV4dFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5fZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XG5cdCAgICAgICAgY3R4ID0gdGhpcy5kZWZhdWx0QXJnKGN0eCwgdGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2V2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICB2YXIgZSA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBUb25lLlBhcnQpIHtcblx0ICAgICAgICAgICAgICAgIGUuX2ZvckVhY2goY2FsbGJhY2ssIGN0eCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgYXR0cmlidXRlIG9mIGFsbCBvZiB0aGUgZXZlbnRzXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGF0dHIgIHRoZSBhdHRyaWJ1dGUgdG8gc2V0XG5cdFx0ICogIEBwYXJhbSAgeyp9ICB2YWx1ZSAgICAgIFRoZSB2YWx1ZSB0byBzZXQgaXQgdG9cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuX3NldEFsbCA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50W2F0dHJdID0gdmFsdWU7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIHRpY2sgbWV0aG9kXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBzZWNvbmRzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZXRlcm1pbmUgaWYgdGhlIGV2ZW50IHNob3VsZCBiZSBjdXJyZW50bHkgbG9vcGluZ1xuXHRcdCAqICBnaXZlbiB0aGUgbG9vcCBib3VuZHJpZXMgb2YgdGhpcyBQYXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkV2ZW50fSAgZXZlbnQgIFRoZSBldmVudCB0byB0ZXN0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl90ZXN0TG9vcEJvdW5kcmllcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA8IHRoaXMuX2xvb3BTdGFydCB8fCBldmVudC5zdGFydE9mZnNldCA+PSB0aGlzLl9sb29wRW5kKSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmNhbmNlbCgwKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL3Jlc2NoZWR1bGUgaXQgaWYgaXQncyBzdG9wcGVkXG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdG9wcGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXN0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvYmFiaWxpdHkgb2YgdGhlIG5vdGVzIGJlaW5nIHRyaWdnZXJlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBwcm9iYWJpbGl0eVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdwcm9iYWJpbGl0eScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2JhYmlsaXR5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocHJvYikge1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9iYWJpbGl0eSA9IHByb2I7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEFsbCgncHJvYmFiaWxpdHknLCBwcm9iKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCBhcHBseSBzbWFsbCByYW5kb20gdmFyaWF0aW9uXG5cdFx0ICogIHRvIHRoZSBjYWxsYmFjayB0aW1lLiBJZiB0aGUgdmFsdWUgaXMgZ2l2ZW4gYXMgYSB0aW1lLCBpdCB3aWxsIHJhbmRvbWl6ZVxuXHRcdCAqICBieSB0aGF0IGFtb3VudC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBldmVudC5odW1hbml6ZSA9IHRydWU7XG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFRpbWV9XG5cdFx0ICogIEBuYW1lIGh1bWFuaXplXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXJ0LnByb3RvdHlwZSwgJ2h1bWFuaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faHVtYW5pemU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YXJpYXRpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5faHVtYW5pemUgPSB2YXJpYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEFsbCgnaHVtYW5pemUnLCB2YXJpYXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIElmIHRoZSBwYXJ0IHNob3VsZCBsb29wIG9yIG5vdFxuXHRcdCAqICBiZXR3ZWVuIFRvbmUuUGFydC5sb29wU3RhcnQgYW5kIFxuXHRcdCAqICBUb25lLlBhcnQubG9vcEVuZC4gQW4gaW50ZWdlclxuXHRcdCAqICB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgbnVtYmVyIG9mXG5cdFx0ICogIGxvb3BzIHRoZSBQYXJ0IGRvZXMgYWZ0ZXIgaXQgc3RhcnRzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJ0I1xuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgbG9vcFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbG9vcCB0aGUgcGFydCA4IHRpbWVzXG5cdFx0ICogcGFydC5sb29wID0gODtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnbG9vcCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuX2xvb3BTdGFydCA9IHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Ll9sb29wRW5kID0gdGhpcy5fbG9vcEVuZDtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Lmxvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGVzdExvb3BCb3VuZHJpZXMoZXZlbnQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbG9vcEVuZCBwb2ludCBkZXRlcm1pbmVzIHdoZW4gaXQgd2lsbCBcblx0XHQgKiAgbG9vcCBpZiBUb25lLlBhcnQubG9vcCBpcyB0cnVlLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJ0I1xuXHRcdCAqICBAdHlwZSB7VHJhbnNwb3J0VGltZX1cblx0XHQgKiAgQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BFbmQsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcEVuZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKGxvb3BFbmQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5sb29wRW5kID0gbG9vcEVuZDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXN0TG9vcEJvdW5kcmllcyhldmVudCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBsb29wU3RhcnQgcG9pbnQgZGV0ZXJtaW5lcyB3aGVuIGl0IHdpbGwgXG5cdFx0ICogIGxvb3AgaWYgVG9uZS5QYXJ0Lmxvb3AgaXMgdHJ1ZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy5fbG9vcFN0YXJ0LCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BTdGFydCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSB0aGlzLnRvVGlja3MobG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXZlbnQubG9vcFN0YXJ0ID0gdGhpcy5sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVzdExvb3BCb3VuZHJpZXMoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0VGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIHBhcnRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBwbGF5YmFja1JhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBbGwoJ3BsYXliYWNrUmF0ZScsIHJhdGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRUaGUgbnVtYmVyIG9mIHNjaGVkdWxlZCBub3RlcyBpbiB0aGUgcGFydC4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhcnQjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgbGVuZ3RoXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFydDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhdHRlcm4gYXJwZWdnaWF0ZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gbm90ZXNcblx0XHQgKiAgICAgICAgIGluIGEgbnVtYmVyIG9mIHBhdHRlcm5zLiBTZWUgVG9uZS5DdHJsUGF0dGVybiBmb3Jcblx0XHQgKiAgICAgICAgIGEgZnVsbCBsaXN0IG9mIHBhdHRlcm5zLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwYXR0ZXJuID0gbmV3IFRvbmUuUGF0dGVybihmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiAgIC8vdGhlIG9yZGVyIG9mIHRoZSBub3RlcyBwYXNzZWQgaW4gZGVwZW5kcyBvbiB0aGUgcGF0dGVyblxuXHRcdCAqIH0sIFtcIkMyXCIsIFwiRDRcIiwgXCJFNVwiLCBcIkE2XCJdLCBcInVwRG93blwiKTtcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTG9vcH1cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5cblx0XHQgKiAgQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXJwZWdnaWF0ZSBvdmVyLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnY2FsbGJhY2snLFxuXHQgICAgICAgICAgICAndmFsdWVzJyxcblx0ICAgICAgICAgICAgJ3BhdHRlcm4nXG5cdCAgICAgICAgXSwgVG9uZS5QYXR0ZXJuLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkxvb3AuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGF0dGVybiBtYW5hZ2VyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ3RybFBhdHRlcm59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhdHRlcm4gPSBuZXcgVG9uZS5DdHJsUGF0dGVybih7XG5cdCAgICAgICAgICAgICd2YWx1ZXMnOiBvcHRpb25zLnZhbHVlcyxcblx0ICAgICAgICAgICAgJ3R5cGUnOiBvcHRpb25zLnBhdHRlcm4sXG5cdCAgICAgICAgICAgICdpbmRleCc6IG9wdGlvbnMuaW5kZXhcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBhdHRlcm4sIFRvbmUuTG9vcCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGF0dGVybi5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncGF0dGVybic6IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcCxcblx0ICAgICAgICAndmFsdWVzJzogW11cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIG5vdGVzIHNob3VsZCBiZSBjYWxsZWRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdGhlIGV2ZW50IG9jY3Vyc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lLCB0aGlzLl9wYXR0ZXJuLnZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuLm5leHQoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIHZhbHVlcyBhcnJheS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGF0dGVybiNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBpbmRleFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGF0dGVybi5wcm90b3R5cGUsICdpbmRleCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4uaW5kZXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4uaW5kZXggPSBpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBhcnJheSBvZiBldmVudHMuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKiAgQG5hbWUgdmFsdWVzXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXR0ZXJuLnByb3RvdHlwZSwgJ3ZhbHVlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4udmFsdWVzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXR0ZXJuLnZhbHVlcyA9IHZhbHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhdHRlcm4uXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHsqfVxuXHRcdCAqICBAbmFtZSB2YWx1ZVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhdHRlcm4ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXR0ZXJuLnZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwYXR0ZXJuIHR5cGUuIFNlZSBUb25lLkN0cmxQYXR0ZXJuIGZvciB0aGUgZnVsbCBsaXN0IG9mIHBhdHRlcm5zLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXR0ZXJuI1xuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAbmFtZSBwYXR0ZXJuXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXR0ZXJuLnByb3RvdHlwZSwgJ3BhdHRlcm4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXR0ZXJuLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4udHlwZSA9IHBhdHRlcm47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGF0dGVybn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGF0dGVybi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkxvb3AucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QYXR0ZXJuO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSBzZXF1ZW5jZSBpcyBhbiBhbHRlcm5hdGUgbm90YXRpb24gb2YgYSBwYXJ0LiBJbnN0ZWFkXG5cdFx0ICogICAgICAgICBvZiBwYXNzaW5nIGluIGFuIGFycmF5IG9mIFt0aW1lLCBldmVudF0gcGFpcnMsIHBhc3Ncblx0XHQgKiAgICAgICAgIGluIGFuIGFycmF5IG9mIGV2ZW50cyB3aGljaCB3aWxsIGJlIHNwYWNlZCBhdCB0aGVcblx0XHQgKiAgICAgICAgIGdpdmVuIHN1YmRpdmlzaW9uLiBTdWItYXJyYXlzIHdpbGwgc3ViZGl2aWRlIHRoYXQgYmVhdFxuXHRcdCAqICAgICAgICAgYnkgdGhlIG51bWJlciBvZiBpdGVtcyBhcmUgaW4gdGhlIGFycmF5LiBcblx0XHQgKiAgICAgICAgIFNlcXVlbmNlIG5vdGF0aW9uIGluc3BpcmF0aW9uIGZyb20gW1RpZGFsXShodHRwOi8veWF4dS5vcmcvdGlkYWwvKVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgbm90ZVxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gICAgZXZlbnRzICBUaGUgc2VxdWVuY2Vcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gc3ViZGl2aXNpb24gIFRoZSBzdWJkaXZpc2lvbiBiZXR3ZWVuIHdoaWNoIGV2ZW50cyBhcmUgcGxhY2VkLiBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuUGFydH1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2VxID0gbmV3IFRvbmUuU2VxdWVuY2UoZnVuY3Rpb24odGltZSwgbm90ZSl7XG5cdFx0ICogXHRjb25zb2xlLmxvZyhub3RlKTtcblx0XHQgKiAvL3N0cmFpZ2h0IHF1YXRlciBub3Rlc1xuXHRcdCAqIH0sIFtcIkM0XCIsIFwiRTRcIiwgXCJHNFwiLCBcIkE0XCJdLCBcIjRuXCIpO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzZXEgPSBuZXcgVG9uZS5TZXF1ZW5jZShmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiBcdGNvbnNvbGUubG9nKG5vdGUpO1xuXHRcdCAqIC8vc3ViZGl2aXNpb25zIGFyZSBnaXZlbiBhcyBzdWJhcnJheXNcblx0XHQgKiB9LCBbXCJDNFwiLCBbXCJFNFwiLCBcIkQ0XCIsIFwiRTRcIl0sIFwiRzRcIiwgW1wiQTRcIiwgXCJHNFwiXV0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ2V2ZW50cycsXG5cdCAgICAgICAgICAgICdzdWJkaXZpc2lvbidcblx0ICAgICAgICBdLCBUb25lLlNlcXVlbmNlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvL3JlbW92ZSB0aGUgZXZlbnRzXG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuXHQgICAgICAgIGRlbGV0ZSBvcHRpb25zLmV2ZW50cztcblx0ICAgICAgICBUb25lLlBhcnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc3ViZGl2aXNvbiBvZiBlYWNoIG5vdGVcblx0XHRcdCAqICBAdHlwZSAge1RpY2tzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWJkaXZpc2lvbiA9IHRoaXMudG9UaWNrcyhvcHRpb25zLnN1YmRpdmlzaW9uKTtcblx0ICAgICAgICAvL2lmIG5vIHRpbWUgd2FzIHBhc3NlZCBpbiwgdGhlIGxvb3AgZW5kIGlzIHRoZSBlbmQgb2YgdGhlIGN5Y2xlXG5cdCAgICAgICAgaWYgKHRoaXMuaXNVbmRlZihvcHRpb25zLmxvb3BFbmQpICYmICF0aGlzLmlzVW5kZWYoZXZlbnRzKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gZXZlbnRzLmxlbmd0aCAqIHRoaXMuX3N1YmRpdmlzaW9uO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2RlZmF1bHRzIHRvIGxvb3Bpbmdcblx0ICAgICAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblx0ICAgICAgICAvL2FkZCBhbGwgb2YgdGhlIGV2ZW50c1xuXHQgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKGV2ZW50cykpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKGksIGV2ZW50c1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TZXF1ZW5jZSwgVG9uZS5QYXJ0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5kZWZhdWx0cyA9IHsgJ3N1YmRpdmlzaW9uJzogJzRuJyB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdWJkaXZpc2lvbiBvZiB0aGUgc2VxdWVuY2UuIFRoaXMgY2FuIG9ubHkgYmUgXG5cdFx0ICogIHNldCBpbiB0aGUgY29uc3RydWN0b3IuIFRoZSBzdWJkaXZpc2lvbiBpcyB0aGUgXG5cdFx0ICogIGludGVydmFsIGJldHdlZW4gc3VjY2Vzc2l2ZSBzdGVwcy4gXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5TZXF1ZW5jZSNcblx0XHQgKiAgQG5hbWUgc3ViZGl2aXNpb25cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUsICdzdWJkaXZpc2lvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVGltZSh0aGlzLl9zdWJkaXZpc2lvbiwgJ2knKS50b05vdGF0aW9uKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgR2V0L1NldCBhbiBpbmRleCBvZiB0aGUgc2VxdWVuY2UuIElmIHRoZSBpbmRleCBjb250YWlucyBhIHN1YmFycmF5LCBcblx0XHQgKiAgYSBUb25lLlNlcXVlbmNlIHJlcHJlc2VudGluZyB0aGF0IHN1Yi1hcnJheSB3aWxsIGJlIHJldHVybmVkLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2VxdWVuY2UgPSBuZXcgVG9uZS5TZXF1ZW5jZShwbGF5Tm90ZSwgW1wiRTRcIiwgXCJDNFwiLCBcIkYjNFwiLCBbXCJBNFwiLCBcIkJiM1wiXV0pXG5cdFx0ICogc2VxdWVuY2UuYXQoMCkvLyA9PiByZXR1cm5zIFwiRTRcIlxuXHRcdCAqIC8vc2V0IGEgdmFsdWVcblx0XHQgKiBzZXF1ZW5jZS5hdCgwLCBcIkczXCIpO1xuXHRcdCAqIC8vZ2V0IGEgbmVzdGVkIHNlcXVlbmNlXG5cdFx0ICogc2VxdWVuY2UuYXQoMykuYXQoMSkvLyA9PiByZXR1cm5zIFwiQmIzXCJcblx0XHQgKiBAcGFyYW0ge1Bvc2l0aXZlfSBpbmRleCBUaGUgaW5kZXggdG8gZ2V0IG9yIHNldFxuXHRcdCAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uYWxseSBwYXNzIGluIHRoZSB2YWx1ZSB0byBzZXQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgLy9pZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIFxuXHQgICAgICAgIGlmICh0aGlzLmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBjdXJyZW50IGV2ZW50IGF0IHRoYXQgaW5kZXhcblx0ICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2NhbGwgdGhlIHBhcmVudCdzIG1ldGhvZFxuXHQgICAgICAgIHJldHVybiBUb25lLlBhcnQucHJvdG90eXBlLmF0LmNhbGwodGhpcywgdGhpcy5faW5kZXhUaW1lKGluZGV4KSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYW4gZXZlbnQgYXQgYW4gaW5kZXgsIGlmIHRoZXJlJ3MgYWxyZWFkeSBzb21ldGhpbmdcblx0XHQgKiAgYXQgdGhhdCBpbmRleCwgb3ZlcndyaXRlIGl0LiBJZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBcblx0XHQgKiAgaXQgd2lsbCBiZSBwYXJzZWQgYXMgYSBzdWJzZXF1ZW5jZS5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBhZGQgdGhlIGV2ZW50IHRvXG5cdFx0ICogIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCBhdCB0aGF0IGluZGV4XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNlcXVlbmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAvL21ha2UgYSBzdWJzZXF1ZW5jZSBhbmQgYWRkIHRoYXQgdG8gdGhlIHNlcXVlbmNlXG5cdCAgICAgICAgICAgIHZhciBzdWJTdWJkaXZpc2lvbiA9IE1hdGgucm91bmQodGhpcy5fc3ViZGl2aXNpb24gLyB2YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IG5ldyBUb25lLlNlcXVlbmNlKHRoaXMuX3RpY2suYmluZCh0aGlzKSwgdmFsdWUsIFRvbmUuVGltZShzdWJTdWJkaXZpc2lvbiwgJ2knKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuUGFydC5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdGhpcy5faW5kZXhUaW1lKGluZGV4KSwgdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBzZXF1ZW5jZSBieSBpbmRleFxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBldmVudCB0byByZW1vdmVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2VxdWVuY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICBUb25lLlBhcnQucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIHRoaXMuX2luZGV4VGltZShpbmRleCksIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSB0aW1lIG9mIHRoZSBpbmRleCBnaXZlbiB0aGUgU2VxdWVuY2UncyBzdWJkaXZpc2lvblxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBpbmRleCBcblx0XHQgKiAgQHJldHVybiAge1RpbWV9ICBUaGUgdGltZSBvZiB0aGF0IGluZGV4XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5faW5kZXhUaW1lID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdCAgICAgICAgaWYgKGluZGV4IGluc3RhbmNlb2YgVG9uZS5UcmFuc3BvcnRUaW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbmRleDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKGluZGV4ICogdGhpcy5fc3ViZGl2aXNpb24gKyB0aGlzLnN0YXJ0T2Zmc2V0LCAnaScpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuU2VxdWVuY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2VxdWVuY2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlB1bHNlT3NjaWxsYXRvciBpcyBhIHB1bHNlIG9zY2lsbGF0b3Igd2l0aCBjb250cm9sIG92ZXIgcHVsc2Ugd2lkdGgsXG5cdFx0ICogICAgICAgICBhbHNvIGtub3duIGFzIHRoZSBkdXR5IGN5Y2xlLiBBdCA1MCUgZHV0eSBjeWNsZSAod2lkdGggPSAwLjUpIHRoZSB3YXZlIGlzIFxuXHRcdCAqICAgICAgICAgYSBzcXVhcmUgYW5kIG9ubHkgb2RkLW51bWJlcmVkIGhhcm1vbmljcyBhcmUgcHJlc2VudC4gQXQgYWxsIG90aGVyIHdpZHRocyBcblx0XHQgKiAgICAgICAgIGV2ZW4tbnVtYmVyZWQgaGFybW9uaWNzIGFyZSBwcmVzZW50LiBSZWFkIG1vcmUgXG5cdFx0ICogICAgICAgICBbaGVyZV0oaHR0cHM6Ly93aWdnbGV3YXZlLndvcmRwcmVzcy5jb20vMjAxNC8wOC8xNi9wdWxzZS13YXZlZm9ybXMtYW5kLWhhcm1vbmljcy8pLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2ZyZXF1ZW5jeV0gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbd2lkdGhdIFRoZSB3aWR0aCBvZiB0aGUgcHVsc2Vcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcHVsc2UgPSBuZXcgVG9uZS5QdWxzZU9zY2lsbGF0b3IoXCJFNVwiLCAwLjQpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUHVsc2VPc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3dpZHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuT3NjaWxsYXRvci5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgd2lkdGggb2YgdGhlIHB1bHNlLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLndpZHRoLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGdhdGUgdGhlIHdpZHRoIGFtb3VudFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3dpZHRoR2F0ZSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc2F3dG9vdGggb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoID0gbmV3IFRvbmUuT3NjaWxsYXRvcih7XG5cdCAgICAgICAgICAgIGZyZXF1ZW5jeTogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgIGRldHVuZTogb3B0aW9ucy5kZXR1bmUsXG5cdCAgICAgICAgICAgIHR5cGU6ICdzYXd0b290aCcsXG5cdCAgICAgICAgICAgIHBoYXNlOiBvcHRpb25zLnBoYXNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBjb250cm9sLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9zYXd0b290aC5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50cy4gXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5fc2F3dG9vdGguZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRocmVzaG9sZCB0aGUgc2lnbmFsIHRvIHR1cm4gaXQgaW50byBhIHNxdWFyZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RocmVzaCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fc2F3dG9vdGguY2hhaW4odGhpcy5fdGhyZXNoLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5jaGFpbih0aGlzLl93aWR0aEdhdGUsIHRoaXMuX3RocmVzaCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnd2lkdGgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlB1bHNlT3NjaWxsYXRvciwgVG9uZS5Pc2NpbGxhdG9yKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICd3aWR0aCc6IDAuMlxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3dpZHRoR2F0ZS5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdG9wIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zYXd0b290aC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIC8vdGhlIHdpZHRoIGlzIHN0aWxsIGNvbm5lY3RlZCB0byB0aGUgb3V0cHV0LiBcblx0ICAgICAgICAvL3RoYXQgbmVlZHMgdG8gYmUgc3RvcHBlZCBhbHNvXG5cdCAgICAgICAgdGhpcy5fd2lkdGhHYXRlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUHVsc2VPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zYXd0b290aC5waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvci4gQWx3YXlzIHJldHVybnMgXCJwdWxzZVwiLlxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlB1bHNlT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJ3B1bHNlJztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgd2F2ZWZvcm0uIENhbm5vdCBzZXQgcGFydGlhbHMgZm9yIHRoaXMgd2F2ZWZvcm0gdHlwZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlB1bHNlT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUHVsc2VPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAgbWV0aG9kLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlB1bHNlT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zYXd0b290aC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2F3dG9vdGggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3dpZHRoJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd2lkdGhHYXRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl93aWR0aEdhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3RocmVzaC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGhyZXNoID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlB1bHNlT3NjaWxsYXRvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuUFdNT3NjaWxsYXRvciBtb2R1bGF0ZXMgdGhlIHdpZHRoIG9mIGEgVG9uZS5QdWxzZU9zY2lsbGF0b3IgXG5cdFx0ICogICAgICAgICBhdCB0aGUgbW9kdWxhdGlvbkZyZXF1ZW5jeS4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBjb250aW51b3VzbHlcblx0XHQgKiAgICAgICAgIGNoYW5naW5nIHRoZSB0aW1icmUgb2YgdGhlIG9zY2lsbGF0b3IgYnkgYWx0ZXJpbmcgdGhlIGhhcm1vbmljcyBcblx0XHQgKiAgICAgICAgIGdlbmVyYXRlZC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgc3RhcnRpbmcgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yLiBcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IG1vZHVsYXRpb25GcmVxdWVuY3kgVGhlIG1vZHVsYXRpb24gZnJlcXVlbmN5IG9mIHRoZSB3aWR0aCBvZiB0aGUgcHVsc2UuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgcHdtID0gbmV3IFRvbmUuUFdNT3NjaWxsYXRvcihcIkFiM1wiLCAwLjMpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUFdNT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRnJlcXVlbmN5J1xuXHQgICAgICAgIF0sIFRvbmUuUFdNT3NjaWxsYXRvci5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcHVsc2Ugb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlB1bHNlT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcHVsc2UgPSBuZXcgVG9uZS5QdWxzZU9zY2lsbGF0b3Iob3B0aW9ucy5tb2R1bGF0aW9uRnJlcXVlbmN5KTtcblx0ICAgICAgICAvL2NoYW5nZSB0aGUgcHVsc2Ugb3NjaWxsYXRvciB0eXBlXG5cdCAgICAgICAgdGhpcy5fcHVsc2UuX3Nhd3Rvb3RoLnR5cGUgPSAnc2luZSc7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1vZHVsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3Ioe1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jzogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgICdkZXR1bmUnOiBvcHRpb25zLmRldHVuZSxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogb3B0aW9ucy5waGFzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFNjYWxlIHRoZSBvc2NpbGxhdG9yIHNvIGl0IGRvZXNuJ3QgZ28gc2lsZW50IFxuXHRcdFx0ICogIGF0IHRoZSBleHRyZW1lIHZhbHVlcy5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBuZXcgVG9uZS5NdWx0aXBseSgyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX21vZHVsYXRvci5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBvZiB0aGUgb3NjaWxsYXRvci5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSB0aGlzLl9tb2R1bGF0b3IuZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0aW9uIHJhdGUgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRnJlcXVlbmN5ID0gdGhpcy5fcHVsc2UuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuY2hhaW4odGhpcy5fc2NhbGUsIHRoaXMuX3B1bHNlLndpZHRoKTtcblx0ICAgICAgICB0aGlzLl9wdWxzZS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QV01Pc2NpbGxhdG9yLCBUb25lLk9zY2lsbGF0b3IpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlBXTU9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICdtb2R1bGF0aW9uRnJlcXVlbmN5JzogMC40XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUFdNT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlLnN0YXJ0KHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdG9wIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgKG9wdGlvbmFsKSB0aW1pbmcgcGFyYW1ldGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgdGhpcy5fcHVsc2Uuc3RvcCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvci4gQWx3YXlzIHJldHVybnMgXCJwd21cIi5cblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QV01Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUFdNT3NjaWxsYXRvci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJ3B3bSc7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGFydGlhbHMgb2YgdGhlIHdhdmVmb3JtLiBDYW5ub3Qgc2V0IHBhcnRpYWxzIGZvciB0aGlzIHdhdmVmb3JtIHR5cGVcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QV01Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QV01Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2R1bGF0b3IucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2R1bGF0b3IucGhhc2UgPSBwaGFzZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5QV01Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wdWxzZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcHVsc2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25GcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUFdNT3NjaWxsYXRvcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRk1Pc2NpbGxhdG9yIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBzdGFydGluZyBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gbW9kdWxhdGlvblR5cGUgVGhlIHR5cGUgb2YgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYSBzaW5lIG9zY2lsbGF0b3IgZnJlcXVlbmN5LW1vZHVsYXRlZCBieSBhIHNxdWFyZSB3YXZlXG5cdFx0ICogdmFyIGZtT3NjID0gbmV3IFRvbmUuRk1Pc2NpbGxhdG9yKFwiQWIzXCIsIFwic2luZVwiLCBcInNxdWFyZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25UeXBlJ1xuXHQgICAgICAgIF0sIFRvbmUuRk1Pc2NpbGxhdG9yLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbmV3IFRvbmUuT3NjaWxsYXRvcihvcHRpb25zLmZyZXF1ZW5jeSwgb3B0aW9ucy50eXBlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgY29udHJvbCBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5fY2Fycmllci5kZXR1bmU7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUudmFsdWUgPSBvcHRpb25zLmRldHVuZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdGlvbiBpbmRleCB3aGljaCBpcyBpbiBlc3NlbmNlIHRoZSBkZXB0aCBvciBhbW91bnQgb2YgdGhlIG1vZHVsYXRpb24uIEluIG90aGVyIHRlcm1zIGl0IGlzIHRoZSBcblx0XHRcdCAqICByYXRpbyBvZiB0aGUgZnJlcXVlbmN5IG9mIHRoZSBtb2R1bGF0aW5nIHNpZ25hbCAobWYpIHRvIHRoZSBhbXBsaXR1ZGUgb2YgdGhlIFxuXHRcdFx0ICogIG1vZHVsYXRpbmcgc2lnbmFsIChtYSkgLS0gYXMgaW4gbWEvbWYuIFxuXHRcdFx0ICpcdEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqXHRAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMubW9kdWxhdGlvbkluZGV4KTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleC51bml0cyA9IFRvbmUuVHlwZS5Qb3NpdGl2ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdGluZyBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3Iob3B0aW9ucy5mcmVxdWVuY3ksIG9wdGlvbnMubW9kdWxhdGlvblR5cGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhhcm1vbmljaXR5IGlzIHRoZSBmcmVxdWVuY3kgcmF0aW8gYmV0d2VlbiB0aGUgY2FycmllciBhbmQgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9ycy4gXG5cdFx0XHQgKiAgQSBoYXJtb25pY2l0eSBvZiAxIGdpdmVzIGJvdGggb3NjaWxsYXRvcnMgdGhlIHNhbWUgZnJlcXVlbmN5LiBcblx0XHRcdCAqICBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3BpdGNoIHRoZSBtb2R1bGF0b3IgYW4gb2N0YXZlIGJlbG93IGNhcnJpZXJcblx0XHRcdCAqIHN5bnRoLmhhcm1vbmljaXR5LnZhbHVlID0gMC41O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMuaGFybW9uaWNpdHkpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5vZGUgd2hlcmUgdGhlIG1vZHVsYXRpb24gaGFwcGVuc1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbmV3IFRvbmUuR2FpbigwKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5tb2R1bGF0aW9uSW5kZXgsIHRoaXMuX21vZHVsYXRpb25Ob2RlKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuY29ubmVjdCh0aGlzLl9tb2R1bGF0aW9uTm9kZS5nYWluKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZS5jb25uZWN0KHRoaXMuX2NhcnJpZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3QodGhpcy5fbW9kdWxhdG9yLmRldHVuZSk7XG5cdCAgICAgICAgdGhpcy5waGFzZSA9IG9wdGlvbnMucGhhc2U7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkluZGV4Jyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GTU9zY2lsbGF0b3IsIFRvbmUuT3NjaWxsYXRvcik7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1Pc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnbW9kdWxhdGlvbkluZGV4JzogMixcblx0ICAgICAgICAnbW9kdWxhdGlvblR5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdG9wKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvclxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBuYW1lIG1vZHVsYXRpb25UeXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvblR5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2R1bGF0b3IudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRk1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBhcnRpYWxzID0gcGFydGlhbHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuRk1Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRk1Pc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5BTU9zY2lsbGF0b3IgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuT3NjaWxsYXRvcn1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGF0aW9uVHlwZSBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHNpbmUgb3NjaWxsYXRvciBmcmVxdWVuY3ktbW9kdWxhdGVkIGJ5IGEgc3F1YXJlIHdhdmVcblx0XHQgKiB2YXIgZm1Pc2MgPSBuZXcgVG9uZS5BTU9zY2lsbGF0b3IoXCJBYjNcIiwgXCJzaW5lXCIsIFwic3F1YXJlXCIpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3R5cGUnLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvblR5cGUnXG5cdCAgICAgICAgXSwgVG9uZS5BTU9zY2lsbGF0b3IuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuU291cmNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKG9wdGlvbnMuZnJlcXVlbmN5LCBvcHRpb25zLnR5cGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yJ3MgZnJlcXVlbmN5XG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2NhcnJpZXIuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgY29udHJvbCBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5fY2Fycmllci5kZXR1bmU7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUudmFsdWUgPSBvcHRpb25zLmRldHVuZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdGluZyBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3Iob3B0aW9ucy5mcmVxdWVuY3ksIG9wdGlvbnMubW9kdWxhdGlvblR5cGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbnZlcnQgdGhlIC0xLDEgb3V0cHV0IHRvIDAsMVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkF1ZGlvVG9HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhhcm1vbmljaXR5IGlzIHRoZSBmcmVxdWVuY3kgcmF0aW8gYmV0d2VlbiB0aGUgY2FycmllciBhbmQgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9ycy4gXG5cdFx0XHQgKiAgQSBoYXJtb25pY2l0eSBvZiAxIGdpdmVzIGJvdGggb3NjaWxsYXRvcnMgdGhlIHNhbWUgZnJlcXVlbmN5LiBcblx0XHRcdCAqICBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3BpdGNoIHRoZSBtb2R1bGF0b3IgYW4gb2N0YXZlIGJlbG93IGNhcnJpZXJcblx0XHRcdCAqIHN5bnRoLmhhcm1vbmljaXR5LnZhbHVlID0gMC41O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMuaGFybW9uaWNpdHkpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5vZGUgd2hlcmUgdGhlIG1vZHVsYXRpb24gaGFwcGVuc1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbmV3IFRvbmUuR2FpbigwKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuY29ubmVjdCh0aGlzLl9tb2R1bGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuY2hhaW4odGhpcy5fbW9kdWxhdGlvblNjYWxlLCB0aGlzLl9tb2R1bGF0aW9uTm9kZS5nYWluKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmNoYWluKHRoaXMuX21vZHVsYXRpb25Ob2RlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5waGFzZSA9IG9wdGlvbnMucGhhc2U7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdoYXJtb25pY2l0eSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkFNT3NjaWxsYXRvciwgVG9uZS5Pc2NpbGxhdG9yKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5BTU9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICdtb2R1bGF0aW9uVHlwZSc6ICdzcXVhcmUnLFxuXHQgICAgICAgICdoYXJtb25pY2l0eSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5zdGFydCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLnN0YXJ0KHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdG9wIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgKG9wdGlvbmFsKSB0aW1pbmcgcGFyYW1ldGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RvcCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLnN0b3AodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIGNhcnJpZXIgb3NjaWxsYXRvclxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkFNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2Fycmllci50eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9yXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQU1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgbW9kdWxhdGlvblR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUsICdtb2R1bGF0aW9uVHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vZHVsYXRvci50eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2R1bGF0b3IudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BoYXNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2Fycmllci5waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NhcnJpZXIucGhhc2UgPSBwaGFzZTtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGFydGlhbHMgb2YgdGhlIGNhcnJpZXIgd2F2ZWZvcm0uIEEgcGFydGlhbCByZXByZXNlbnRzIFxuXHRcdCAqIHRoZSBhbXBsaXR1ZGUgYXQgYSBoYXJtb25pYy4gVGhlIGZpcnN0IGhhcm1vbmljIGlzIHRoZSBcblx0XHQgKiBmdW5kYW1lbnRhbCBmcmVxdWVuY3ksIHRoZSBzZWNvbmQgaXMgdGhlIG9jdGF2ZSBhbmQgc28gb25cblx0XHQgKiBmb2xsb3dpbmcgdGhlIGhhcm1vbmljIHNlcmllcy4gXG5cdFx0ICogU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhlIHR5cGUgdG8gXCJjdXN0b21cIi4gXG5cdFx0ICogVGhlIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5IHdoZW4gdGhlIHR5cGUgaXMgbm90IFwiY3VzdG9tXCIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkFNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG9zYy5wYXJ0aWFscyA9IFsxLCAwLjIsIDAuMDFdO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2Fycmllci5wYXJ0aWFscztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBhcnRpYWxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NhcnJpZXIucGFydGlhbHMgPSBwYXJ0aWFscztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5BTU9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdoYXJtb25pY2l0eSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvblNjYWxlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BTU9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkZhdE9zY2lsbGF0b3IgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuT3NjaWxsYXRvcn1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGF0aW9uVHlwZSBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHNpbmUgb3NjaWxsYXRvciBmcmVxdWVuY3ktbW9kdWxhdGVkIGJ5IGEgc3F1YXJlIHdhdmVcblx0XHQgKiB2YXIgZm1Pc2MgPSBuZXcgVG9uZS5GYXRPc2NpbGxhdG9yKFwiQWIzXCIsIFwic2luZVwiLCBcInNxdWFyZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZScsXG5cdCAgICAgICAgICAgICdzcHJlYWQnXG5cdCAgICAgICAgXSwgVG9uZS5GYXRPc2NpbGxhdG9yLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yJ3MgZnJlcXVlbmN5XG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIG9zY2lsbGF0b3JzXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0b3RhbCBzcHJlYWQgb2YgdGhlIG9zY2lsbGF0b3JzXG5cdFx0XHQgKiAgQHR5cGUgIHtDZW50c31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3ByZWFkID0gb3B0aW9ucy5zcHJlYWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvcnNcblx0XHRcdCAqICBAdHlwZSB7RGVncmVlc31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwYXJ0aWFscyBhcnJheVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSB0aGlzLmRlZmF1bHRBcmcob3B0aW9ucy5wYXJ0aWFscywgW10pO1xuXHQgICAgICAgIC8vc2V0IHRoZSBjb3VudCBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLmNvdW50ID0gb3B0aW9ucy5jb3VudDtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRmF0T3NjaWxsYXRvciwgVG9uZS5Pc2NpbGxhdG9yKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnc3ByZWFkJzogMjAsXG5cdCAgICAgICAgJ2NvdW50JzogMyxcblx0ICAgICAgICAndHlwZSc6ICdzYXd0b290aCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgb3NjLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdG9wIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgKG9wdGlvbmFsKSB0aW1pbmcgcGFyYW1ldGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgIG9zYy5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBvc2NpbGxhdG9yc1xuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGl0ZXJhdG9yICBUaGUgaXRlcmF0b3IgZnVuY3Rpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRmF0T3NjaWxsYXRvci5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwodGhpcywgdGhpcy5fb3NjaWxsYXRvcnNbaV0sIGkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgIG9zYy50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGV0dW5lIHNwcmVhZCBiZXR3ZWVuIHRoZSBvc2NpbGxhdG9ycy4gSWYgXCJjb3VudFwiIGlzXG5cdFx0ICogc2V0IHRvIDMgb3NjaWxsYXRvcnMgYW5kIHRoZSBcInNwcmVhZFwiIGlzIHNldCB0byA0MCxcblx0XHQgKiB0aGUgdGhyZWUgb3NjaWxsYXRvcnMgd291bGQgYmUgZGV0dW5lZCBsaWtlIHRoaXM6IFstMjAsIDAsIDIwXVxuXHRcdCAqIGZvciBhIHRvdGFsIGRldHVuZSBzcHJlYWQgb2YgNDAgY2VudHMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7Q2VudHN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3NwcmVhZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NwcmVhZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNwcmVhZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zcHJlYWQgPSBzcHJlYWQ7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAtc3ByZWFkIC8gMjtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGVwID0gc3ByZWFkIC8gKHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjLCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLmRldHVuZS52YWx1ZSA9IHN0YXJ0ICsgc3RlcCAqIGk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBkZXR1bmVkIG9zY2lsbGF0b3JzXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGNvdW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ2NvdW50Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoY291bnQpIHtcblx0ICAgICAgICAgICAgY291bnQgPSBNYXRoLm1heChjb3VudCwgMSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGggIT09IGNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgcGFydGlhbHMgPSB0aGlzLnBhcnRpYWxzO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgICAgICAgICAvL2Rpc3Bvc2UgdGhlIHByZXZpb3VzIG9zY2lsbGF0b3JzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvc2MuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b20pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3NjLnBhcnRpYWxzID0gdGhpcy5fcGFydGlhbHM7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3NjLnR5cGUgPSB0aGlzLl90eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBvc2MucGhhc2UgPSB0aGlzLl9waGFzZTtcblx0ICAgICAgICAgICAgICAgICAgICBvc2Mudm9sdW1lLnZhbHVlID0gLTYgLSBjb3VudDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KG9zYy5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3Qob3NjLmRldHVuZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzW2ldID0gb3NjO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy9zZXQgdGhlIHNwcmVhZFxuXHQgICAgICAgICAgICAgICAgdGhpcy5zcHJlYWQgPSB0aGlzLl9zcHJlYWQ7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zYy5zdGFydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GYXRPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKG9zYykge1xuXHQgICAgICAgICAgICAgICAgb3NjLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GYXRPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBhcnRpYWxzID0gWzEsIDAuMiwgMC4wMV07XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgIG9zYy5wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5GYXRPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgb3NjLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZhdE9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk9tbmlPc2NpbGxhdG9yIGFnZ3JlZ2F0ZXMgVG9uZS5Pc2NpbGxhdG9yLCBUb25lLlB1bHNlT3NjaWxsYXRvcixcblx0XHQgKiAgICAgICAgIFRvbmUuUFdNT3NjaWxsYXRvciwgVG9uZS5GTU9zY2lsbGF0b3IsIFRvbmUuQU1Pc2NpbGxhdG9yLCBhbmQgVG9uZS5GYXRPc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICBpbnRvIG9uZSBjbGFzcy4gVGhlIG9zY2lsbGF0b3IgY2xhc3MgY2FuIGJlIGNoYW5nZWQgYnkgc2V0dGluZyB0aGUgYHR5cGVgLiBcblx0XHQgKiAgICAgICAgIGBvbW5pT3NjLnR5cGUgPSBcInB3bVwiYCB3aWxsIHNldCBpdCB0byB0aGUgVG9uZS5QV01Pc2NpbGxhdG9yLiBQcmVmaXhpbmdcblx0XHQgKiAgICAgICAgIGFueSBvZiB0aGUgYmFzaWMgdHlwZXMgKFwic2luZVwiLCBcInNxdWFyZTRcIiwgZXRjLikgd2l0aCBcImZtXCIsIFwiYW1cIiwgb3IgXCJmYXRcIlxuXHRcdCAqICAgICAgICAgd2lsbCB1c2UgdGhlIEZNT3NjaWxsYXRvciwgQU1Pc2NpbGxhdG9yIG9yIEZhdE9zY2lsbGF0b3IgcmVzcGVjdGl2ZWx5LiBcblx0XHQgKiAgICAgICAgIEZvciBleGFtcGxlOiBgb21uaU9zYy50eXBlID0gXCJmYXRzYXd0b290aFwiYCB3aWxsIGNyZWF0ZSBzZXQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgICAgICAgIHRvIGEgRmF0T3NjaWxsYXRvciBvZiB0eXBlIFwic2F3dG9vdGhcIi4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuT3NjaWxsYXRvcn1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIGluaXRpYWwgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvci5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIG9tbmlPc2MgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcihcIkMjNFwiLCBcInB3bVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuT21uaU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZSdcblx0ICAgICAgICBdLCBUb25lLk9tbmlPc2NpbGxhdG9yLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2xcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3Igc291cmNlXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIC8vc2V0IHRoZSBvc2NpbGxhdG9yXG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIG9wdGlvbnNcblx0ICAgICAgICB0aGlzLnNldChvcHRpb25zKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9tbmlPc2NpbGxhdG9yLCBUb25lLk9zY2lsbGF0b3IpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ3BoYXNlJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAZW51bSB7U3RyaW5nfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgdmFyIE9tbmlPc2NUeXBlID0ge1xuXHQgICAgICAgIFB1bHNlOiAnUHVsc2VPc2NpbGxhdG9yJyxcblx0ICAgICAgICBQV006ICdQV01Pc2NpbGxhdG9yJyxcblx0ICAgICAgICBPc2M6ICdPc2NpbGxhdG9yJyxcblx0ICAgICAgICBGTTogJ0ZNT3NjaWxsYXRvcicsXG5cdCAgICAgICAgQU06ICdBTU9zY2lsbGF0b3InLFxuXHQgICAgICAgIEZhdDogJ0ZhdE9zY2lsbGF0b3InXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0byBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0YXJ0KHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdG8gc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0b3AodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3IuIENhbiBiZSBhbnkgb2YgdGhlIGJhc2ljIHR5cGVzOiBzaW5lLCBzcXVhcmUsIHRyaWFuZ2xlLCBzYXd0b290aC4gT3Jcblx0XHQgKiBwcmVmaXggdGhlIGJhc2ljIHR5cGVzIHdpdGggXCJmbVwiLCBcImFtXCIsIG9yIFwiZmF0XCIgdG8gdXNlIHRoZSBGTU9zY2lsbGF0b3IsIEFNT3NjaWxsYXRvciBvciBGYXRPc2NpbGxhdG9yXG5cdFx0ICogdHlwZXMuIFRoZSBvc2NpbGxhdG9yIGNvdWxkIGFsc28gYmUgc2V0IHRvIFwicHdtXCIgb3IgXCJwdWxzZVwiLiBBbGwgb2YgdGhlIHBhcmFtZXRlcnMgb2YgdGhlXG5cdFx0ICogb3NjaWxsYXRvcidzIGNsYXNzIGFyZSBhY2Nlc3NpYmxlIHdoZW4gdGhlIG9zY2lsbGF0b3IgaXMgc2V0IHRvIHRoYXQgdHlwZSwgYnV0IHRocm93cyBhbiBlcnJvciBcblx0XHQgKiB3aGVuIGl0J3Mgbm90LlxuXHRcdCAqIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb21uaU9zYy50eXBlID0gXCJwd21cIjtcblx0XHQgKiAvL21vZHVsYXRpb25GcmVxdWVuY3kgaXMgcGFyYW1ldGVyIHdoaWNoIGlzIGF2YWlsYWJsZVxuXHRcdCAqIC8vb25seSB3aGVuIHRoZSB0eXBlIGlzIFwicHdtXCIuIFxuXHRcdCAqIG9tbmlPc2MubW9kdWxhdGlvbkZyZXF1ZW5jeS52YWx1ZSA9IDAuNTtcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vYW4gc3F1YXJlIHdhdmUgZnJlcXVlbmN5IG1vZHVsYXRlZCBieSBhIHNhd3Rvb3RoXG5cdFx0ICogb21uaU9zYy50eXBlID0gXCJmbXNxdWFyZVwiO1xuXHRcdCAqIG9tbmlPc2MubW9kdWxhdGlvblR5cGUgPSBcInNhd3Rvb3RoXCI7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GTSkge1xuXHQgICAgICAgICAgICAgICAgcHJlZml4ID0gJ2ZtJztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5BTSkge1xuXHQgICAgICAgICAgICAgICAgcHJlZml4ID0gJ2FtJztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHByZWZpeCA9ICdmYXQnO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyB0aGlzLl9vc2NpbGxhdG9yLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlLnN1YnN0cigwLCAyKSA9PT0gJ2ZtJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5GTSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlLnN1YnN0cigyKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN1YnN0cigwLCAyKSA9PT0gJ2FtJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5BTSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlLnN1YnN0cigyKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN1YnN0cigwLCAzKSA9PT0gJ2ZhdCcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5ld09zY2lsbGF0b3IoT21uaU9zY1R5cGUuRmF0KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGUuc3Vic3RyKDMpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwd20nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLlBXTSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3B1bHNlJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5QdWxzZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLk9zYyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGFydGlhbHMgb2YgdGhlIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBUaGlzIGlzIG5vdCBhdmFpbGFibGUgb24gXCJwd21cIiBhbmQgXCJwdWxzZVwiIG9zY2lsbGF0b3IgdHlwZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5wYXJ0aWFscztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBhcnRpYWxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IucGFydGlhbHMgPSBwYXJ0aWFscztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYSBtZW1iZXIvYXR0cmlidXRlIG9mIHRoZSBvc2NpbGxhdG9yLiBcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwYXJhbXNcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSByYW1wVGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5PbW5pT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUpIHtcblx0ICAgICAgICAvL21ha2Ugc3VyZSB0aGUgdHlwZSBpcyBzZXQgZmlyc3Rcblx0ICAgICAgICBpZiAocGFyYW1zID09PSAndHlwZScpIHtcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gdmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzT2JqZWN0KHBhcmFtcykgJiYgcGFyYW1zLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gcGFyYW1zLnR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vdGhlbiBzZXQgdGhlIHJlc3Rcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY29ubmVjdCB0aGUgb3NjaWxsYXRvciB0byB0aGUgZnJlcXVlbmN5IGFuZCBkZXR1bmUgc2lnbmFsc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuX2NyZWF0ZU5ld09zY2lsbGF0b3IgPSBmdW5jdGlvbiAob3NjVHlwZSkge1xuXHQgICAgICAgIGlmIChvc2NUeXBlICE9PSB0aGlzLl9zb3VyY2VUeXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZVR5cGUgPSBvc2NUeXBlO1xuXHQgICAgICAgICAgICB2YXIgT3NjaWxsYXRvckNvbnN0cnVjdG9yID0gVG9uZVtvc2NUeXBlXTtcblx0ICAgICAgICAgICAgLy9zaG9ydCBkZWxheSB0byBhdm9pZCBjbGlja3Mgb24gdGhlIGNoYW5nZVxuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKSArIHRoaXMuYmxvY2tUaW1lO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvciAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9sZE9zYyA9IHRoaXMuX29zY2lsbGF0b3I7XG5cdCAgICAgICAgICAgICAgICBvbGRPc2Muc3RvcChub3cpO1xuXHQgICAgICAgICAgICAgICAgLy9kaXNwb3NlIHRoZSBvbGQgb25lXG5cdCAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRPc2MuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIG9sZE9zYyA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9LCB0aGlzLmJsb2NrVGltZSAqIDEwMDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBuZXcgT3NjaWxsYXRvckNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fb3NjaWxsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdGFydChub3cpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvciBpbiBkZWdyZWVzLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RGVncmVlc31cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHdpZHRoIG9mIHRoZSBvc2NpbGxhdG9yIChvbmx5IGlmIHRoZSBvc2NpbGxhdG9yIGlzIHNldCB0byBcInB1bHNlXCIpXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSB3aWR0aFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIG9tbmlPc2MgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcig0NDAsIFwicHVsc2VcIik7XG5cdFx0ICogLy9jYW4gYWNjZXNzIHRoZSB3aWR0aCBhdHRyaWJ1dGUgb25seSBpZiB0eXBlID09PSBcInB1bHNlXCJcblx0XHQgKiBvbW5pT3NjLndpZHRoLnZhbHVlID0gMC4yOyBcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3dpZHRoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuUHVsc2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLndpZHRoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGRldHVuZWQgb3NjaWxsYXRvcnNcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGNvdW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdjb3VudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZhdCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IuY291bnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuY291bnQgPSBjb3VudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRldHVuZSBzcHJlYWQgYmV0d2VlbiB0aGUgb3NjaWxsYXRvcnMuIElmIFwiY291bnRcIiBpc1xuXHRcdCAqIHNldCB0byAzIG9zY2lsbGF0b3JzIGFuZCB0aGUgXCJzcHJlYWRcIiBpcyBzZXQgdG8gNDAsXG5cdFx0ICogdGhlIHRocmVlIG9zY2lsbGF0b3JzIHdvdWxkIGJlIGRldHVuZWQgbGlrZSB0aGlzOiBbLTIwLCAwLCAyMF1cblx0XHQgKiBmb3IgYSB0b3RhbCBkZXR1bmUgc3ByZWFkIG9mIDQwIGNlbnRzLiBTZWUgVG9uZS5GYXRPc2NpbGxhdG9yXG5cdFx0ICogZm9yIG1vcmUgaW5mby5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7Q2VudHN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdzcHJlYWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnNwcmVhZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ByZWFkKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3ByZWFkID0gc3ByZWFkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuIE9ubHkgaWYgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiBpcyBzZXQgdG8gXCJhbVwiIG9yIFwiZm1cIiB0eXBlcy4gc2VlLiBUb25lLkFNT3NjaWxsYXRvciBvciBUb25lLkZNT3NjaWxsYXRvclxuXHRcdCAqIGZvciBtb3JlIGluZm8uIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQG5hbWUgbW9kdWxhdGlvblR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25UeXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLm1vZHVsYXRpb25UeXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtVHlwZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IubW9kdWxhdGlvblR5cGUgPSBtVHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1vZHVsYXRpb24gaW5kZXggd2hpY2ggaXMgaW4gZXNzZW5jZSB0aGUgZGVwdGggb3IgYW1vdW50IG9mIHRoZSBtb2R1bGF0aW9uLiBJbiBvdGhlciB0ZXJtcyBpdCBpcyB0aGUgXG5cdFx0ICogcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBcblx0XHQgKiBtb2R1bGF0aW5nIHNpZ25hbCAobWEpIC0tIGFzIGluIG1hL21mLiBcblx0XHQgKiBTZWUgVG9uZS5GTU9zY2lsbGF0b3IgZm9yIG1vcmUgaW5mby4gXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uSW5kZXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25JbmRleCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5tb2R1bGF0aW9uSW5kZXg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIGNhcnJpZXIgYW5kIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvcnMuIFxuXHRcdCAqICBBIGhhcm1vbmljaXR5IG9mIDEgZ2l2ZXMgYm90aCBvc2NpbGxhdG9ycyB0aGUgc2FtZSBmcmVxdWVuY3kuIFxuXHRcdCAqICBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBTZWUgVG9uZS5BTU9zY2lsbGF0b3Igb3IgVG9uZS5GTU9zY2lsbGF0b3Jcblx0XHQgKiAgZm9yIG1vcmUgaW5mby4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgaGFybW9uaWNpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ2hhcm1vbmljaXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLmhhcm1vbmljaXR5O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbW9kdWxhdGlvbkZyZXF1ZW5jeSBTaWduYWwgb2YgdGhlIG9zY2lsbGF0b3IgXG5cdFx0ICogKG9ubHkgaWYgdGhlIG9zY2lsbGF0b3IgdHlwZSBpcyBzZXQgdG8gcHdtKS4gU2VlIFxuXHRcdCAqIFRvbmUuUFdNT3NjaWxsYXRvciBmb3IgbW9yZSBpbmZvLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uRnJlcXVlbmN5XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgb21uaU9zYyA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKDQ0MCwgXCJwd21cIik7XG5cdFx0ICogLy9jYW4gYWNjZXNzIHRoZSBtb2R1bGF0aW9uRnJlcXVlbmN5IGF0dHJpYnV0ZSBvbmx5IGlmIHR5cGUgPT09IFwicHdtXCJcblx0XHQgKiBvbW5pT3NjLm1vZHVsYXRpb25GcmVxdWVuY3kudmFsdWUgPSAwLjI7IFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvbkZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLlBXTSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IubW9kdWxhdGlvbkZyZXF1ZW5jeTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLk9tbmlPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuT21uaU9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQmFzZS1jbGFzcyBmb3IgYWxsIGluc3RydW1lbnRzXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5JbnN0cnVtZW50LmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IGFuZCB2b2x1bWUgdHJpbWluZyBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzLlxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHNvdXJjZS52b2x1bWUudmFsdWUgPSAtNjtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5JbnN0cnVtZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzXG5cdFx0ICogIEB0eXBlIHtvYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgLyoqIHRoZSB2b2x1bWUgb2YgdGhlIG91dHB1dCBpbiBkZWNpYmVscyAqL1xuXHQgICAgICAgICd2b2x1bWUnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBhYnN0cmFjdFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vdGUgdGhlIG5vdGUgdG8gdHJpZ2dlclxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdG8gdHJpZ2dlciB0aGUgbnRvZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSB0byB0cmlnZ2VyIHRoZSBub3RlXG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBUb25lLm5vT3A7XG5cdCAgICAvKipcblx0XHQgKiAgQGFic3RyYWN0XG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB3aGVuIHRvIHRyaWdnZXIgdGhlIHJlbGVhc2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBUb25lLm5vT3A7XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlIGFmdGVyIHRoZSBkdXJhdGlvbi4gXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgVGhlIG5vdGUgdG8gdHJpZ2dlci5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZHVyYXRpb24gSG93IGxvbmcgdGhlIG5vdGUgc2hvdWxkIGJlIGhlbGQgZm9yIGJlZm9yZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyaW5nIHRoZSByZWxlYXNlLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gIFdoZW4gdGhlIG5vdGUgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgdGhlIG5vdGUgc2hvdWxkIGJlIHRyaWdnZXJlZCBhdC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW5zdHJ1bWVudH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciBcIkM0XCIgZm9yIHRoZSBkdXJhdGlvbiBvZiBhbiA4dGggbm90ZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAobm90ZSwgZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNVbmRlZih0aW1lKSkge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy5ub3coKSArIHRoaXMuYmxvY2tUaW1lO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKG5vdGUsIHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKHRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkluc3RydW1lbnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsndm9sdW1lJ10pO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5JbnN0cnVtZW50O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3Igb3RoZXIgbW9ub3Bob25pYyBpbnN0cnVtZW50cyB0byBcblx0XHQgKiAgICAgICAgICBleHRlbmQuIElNUE9SVEFOVDogSXQgZG9lcyBub3QgbWFrZSBhbnkgc291bmQgb24gaXRzIG93biBhbmRcblx0XHQgKiAgICAgICAgICBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgaW5zdGFudGlhdGVkLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuSW5zdHJ1bWVudH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub3Bob25pYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1vbm9waG9uaWMuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnbGlkZSB0aW1lIGJldHdlZW4gbm90ZXMuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5wb3J0YW1lbnRvID0gb3B0aW9ucy5wb3J0YW1lbnRvO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTW9ub3Bob25pYywgVG9uZS5JbnN0cnVtZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLmRlZmF1bHRzID0geyAncG9ydGFtZW50byc6IDAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgb2YgdGhlIG5vdGUgb3B0aW9uYWxseSB3aXRoIGEgZ2l2ZW4gdmVsb2NpdHkuIFxuXHRcdCAqICBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgVGhlIG5vdGUgdG8gdHJpZ2dlci5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgICAgV2hlbiB0aGUgbm90ZSBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gW3ZlbG9jaXR5PTFdIHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSBzY2FsZXIgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZXMgaG93IFwibG91ZFwiIHRoZSBub3RlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub3Bob25pY30gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2soXCJDNFwiKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgdGhlIG5vdGUgYSBoYWxmIHNlY29uZCBmcm9tIG5vdyBhdCBoYWxmIHZlbG9jaXR5XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFjayhcIkM0XCIsIFwiKzAuNVwiLCAwLjUpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKG5vdGUsIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNVbmRlZih0aW1lKSkge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy5ub3coKSArIHRoaXMuYmxvY2tUaW1lO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fdHJpZ2dlckVudmVsb3BlQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnNldE5vdGUobm90ZSwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBJZiBubyB0aW1lIGlzIGdpdmVuLCB0aGUgcmVsZWFzZSBoYXBwZW5zIGltbWVkaWF0bHlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub3Bob25pY30gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJSZWxlYXNlKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc1VuZGVmKHRpbWUpKSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLm5vdygpICsgdGhpcy5ibG9ja1RpbWU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl90cmlnZ2VyRW52ZWxvcGVSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBvdmVycmlkZSB0aGlzIG1ldGhvZCB3aXRoIHRoZSBhY3R1YWwgbWV0aG9kXG5cdFx0ICogIEBhYnN0cmFjdFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlQXR0YWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBvdmVycmlkZSB0aGlzIG1ldGhvZCB3aXRoIHRoZSBhY3R1YWwgbWV0aG9kXG5cdFx0ICogIEBhYnN0cmFjdFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSBub3RlIGF0IHRoZSBnaXZlbiB0aW1lLiBJZiBubyB0aW1lIGlzIGdpdmVuLCB0aGUgbm90ZVxuXHRcdCAqICB3aWxsIHNldCBpbW1lZGlhdGVseS4gXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBub3RlIFRoZSBub3RlIHRvIGNoYW5nZSB0by5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSBub3RlIHNob3VsZCBiZSBzZXQuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb25vcGhvbmljfSB0aGlzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL2NoYW5nZSB0byBGIzYgaW4gb25lIHF1YXJ0ZXIgbm90ZSBmcm9tIG5vdy5cblx0XHQgKiBzeW50aC5zZXROb3RlKFwiRiM2XCIsIFwiKzRuXCIpO1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9jaGFuZ2UgdG8gQmI0IHJpZ2h0IG5vd1xuXHRcdCAqIHN5bnRoLnNldE5vdGUoXCJCYjRcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLnNldE5vdGUgPSBmdW5jdGlvbiAobm90ZSwgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5wb3J0YW1lbnRvID4gMCkge1xuXHQgICAgICAgICAgICB2YXIgY3VycmVudE5vdGUgPSB0aGlzLmZyZXF1ZW5jeS52YWx1ZTtcblx0ICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUoY3VycmVudE5vdGUsIHRpbWUpO1xuXHQgICAgICAgICAgICB2YXIgcG9ydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLnBvcnRhbWVudG8pO1xuXHQgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKG5vdGUsIHRpbWUgKyBwb3J0VGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUobm90ZSwgdGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1vbm9waG9uaWM7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5TeW50aCBpcyBjb21wb3NlZCBzaW1wbHkgb2YgYSBUb25lLk9tbmlPc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICAgcm91dGVkIHRocm91Z2ggYSBUb25lLkFtcGxpdHVkZUVudmVsb3BlLiBcblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMS0xXzBZVzJaMUoyRVBJMzZQOGZOQ01jWkc3TjF3MUdabHVQczRvZzRldm8vcHViP3c9MTE2MyZoPTIzMVwiPlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Nb25vcGhvbmljfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgZGVmYXVsdHMgYmVsb3dcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5TeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjhuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLlN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvci5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5PbW5pT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKG9wdGlvbnMub3NjaWxsYXRvcik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBjb250cm9sLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSB0aGlzLm9zY2lsbGF0b3IuZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBvc2NpbGxhdG9ycyB0byB0aGUgb3V0cHV0XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmNoYWluKHRoaXMuZW52ZWxvcGUsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBvc2NpbGxhdG9yc1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5zdGFydCgpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlN5bnRoLCBUb25lLk1vbm9waG9uaWMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlN5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICd0cmlhbmdsZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4xLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDAuMyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAxXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgYXR0YWNrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TeW50aH0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIC8vdGhlIGVudmVsb3Blc1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgcmVsZWFzZSBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQU1TeW50aCB1c2VzIHRoZSBvdXRwdXQgb2Ygb25lIFRvbmUuU3ludGggdG8gbW9kdWxhdGUgdGhlXG5cdFx0ICogICAgICAgICAgYW1wbGl0dWRlIG9mIGFub3RoZXIgVG9uZS5TeW50aC4gVGhlIGhhcm1vbmljaXR5ICh0aGUgcmF0aW8gYmV0d2VlblxuXHRcdCAqICAgICAgICAgIHRoZSB0d28gc2lnbmFscykgYWZmZWN0cyB0aGUgdGltYnJlIG9mIHRoZSBvdXRwdXQgc2lnbmFsIGdyZWF0bHkuXG5cdFx0ICogICAgICAgICAgUmVhZCBtb3JlIGFib3V0IEFtcGxpdHVkZSBNb2R1bGF0aW9uIFN5bnRoZXNpcyBvbiBcblx0XHQgKiAgICAgICAgICBbU291bmRPblNvdW5kXShodHRwOi8vd3d3LnNvdW5kb25zb3VuZC5jb20vc29zL21hcjAwL2FydGljbGVzL3N5bnRoc2VjcmV0cy5odG0pLlxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xVFF1OEVkNGlGcjFZVExLcEIzVTFfaHVyLVV3QnJoNWdkQlhjOEJ4ZkdLdy9wdWI/dz0xMDA5Jmg9NDU3XCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuQU1TeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjRuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BTVN5bnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gdGhpcy5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuQU1TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIgdm9pY2UuIFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbmV3IFRvbmUuU3ludGgoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllcidzIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gdGhpcy5fY2Fycmllci5vc2NpbGxhdG9yO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IHRoaXMuX2NhcnJpZXIuZW52ZWxvcGUuc2V0KG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3Igdm9pY2UuIFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5TeW50aCgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRvcidzIG9zY2lsbGF0b3Igd2hpY2ggaXMgYXBwbGllZFxuXHRcdFx0ICogIHRvIHRoZSBhbXBsaXR1ZGUgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uID0gdGhpcy5fbW9kdWxhdG9yLm9zY2lsbGF0b3Iuc2V0KG9wdGlvbnMubW9kdWxhdGlvbik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRvcidzIGVudmVsb3BlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gdGhpcy5fbW9kdWxhdG9yLmVudmVsb3BlLnNldChvcHRpb25zLm1vZHVsYXRpb25FbnZlbG9wZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKDQ0MCwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50c1xuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcy4gQSBoYXJtb25pY2l0eSBvZlxuXHRcdFx0ICogIDEgaXMgbm8gY2hhbmdlLiBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3BpdGNoIHZvaWNlMSBhbiBvY3RhdmUgYmVsb3cgdm9pY2UwXG5cdFx0XHQgKiBzeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbnZlcnQgdGhlIC0xLDEgb3V0cHV0IHRvIDAsMVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkF1ZGlvVG9HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvL2NvbnRyb2wgdGhlIHR3byB2b2ljZXMgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZmFuKHRoaXMuX2NhcnJpZXIuZGV0dW5lLCB0aGlzLl9tb2R1bGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuY2hhaW4odGhpcy5fbW9kdWxhdGlvblNjYWxlLCB0aGlzLl9tb2R1bGF0aW9uTm9kZS5nYWluKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmNoYWluKHRoaXMuX21vZHVsYXRpb25Ob2RlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbicsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQU1TeW50aCwgVG9uZS5Nb25vcGhvbmljKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkFNU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogMyxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjAxLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnbW9kdWxhdGlvbic6IHsgJ3R5cGUnOiAnc3F1YXJlJyB9LFxuXHQgICAgICAgICdtb2R1bGF0aW9uRW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjUsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBub3RlIHdpbGwgb2NjdXJcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFNU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBwb3J0IGdsaWRlXG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIC8vdGhlIGVudmVsb3Blc1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgbm90ZSB3aWxsIHJlbGVhc2Vcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQU1TeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BTVN5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQU1TeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BTVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdoYXJtb25pY2l0eScsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb24nLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvblNjYWxlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQU1TeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLk1vbm9TeW50aCBpcyBjb21wb3NlZCBvZiBvbmUgb3NjaWxsYXRvciwgb25lIGZpbHRlciwgYW5kIHR3byBlbnZlbG9wZXMuXG5cdFx0ICogICAgICAgICAgVGhlIGFtcGxpdHVkZSBvZiB0aGUgVG9uZS5Pc2NpbGxhdG9yIGFuZCB0aGUgY3V0b2ZmIGZyZXF1ZW5jeSBvZiB0aGUgXG5cdFx0ICogICAgICAgICAgVG9uZS5GaWx0ZXIgYXJlIGNvbnRyb2xsZWQgYnkgVG9uZS5FbnZlbG9wZXMuIFxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xZ2FZMURGOV9IemtvZHFmOEpJMUNnMlZaZndTRWxwRlFmSTk0SVF3YWQzOC9wdWI/dz05MjQmaD0yNDBcIj5cblx0XHQgKiAgICAgICAgICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLk1vbm9TeW50aCh7XG5cdFx0ICogXHRcIm9zY2lsbGF0b3JcIiA6IHtcblx0XHQgKiBcdFx0XCJ0eXBlXCIgOiBcInNxdWFyZVwiXG5cdFx0ICogIH0sXG5cdFx0ICogIFwiZW52ZWxvcGVcIiA6IHtcblx0XHQgKiAgXHRcImF0dGFja1wiIDogMC4xXG5cdFx0ICogIH1cblx0XHQgKiB9KS50b01hc3RlcigpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub1N5bnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICAvL2dldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICBvcHRpb25zID0gdGhpcy5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuTW9ub1N5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvci5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5PbW5pT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKG9wdGlvbnMub3NjaWxsYXRvcik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBjb250cm9sLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSB0aGlzLm9zY2lsbGF0b3IuZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmaWx0ZXIuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgVG9uZS5GaWx0ZXIob3B0aW9ucy5maWx0ZXIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmaWx0ZXIgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRnJlcXVlbmN5RW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlID0gbmV3IFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUob3B0aW9ucy5maWx0ZXJFbnZlbG9wZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtcGxpdHVkZSBlbnZlbG9wZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BbXBsaXR1ZGVFbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBuZXcgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZShvcHRpb25zLmVudmVsb3BlKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIG9zY2lsbGF0b3JzIHRvIHRoZSBvdXRwdXRcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuY2hhaW4odGhpcy5maWx0ZXIsIHRoaXMuZW52ZWxvcGUsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBvc2NpbGxhdG9yc1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5zdGFydCgpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgZmlsdGVyIGVudmVsb3BlXG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZS5jb25uZWN0KHRoaXMuZmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2ZpbHRlcicsXG5cdCAgICAgICAgICAgICdmaWx0ZXJFbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1vbm9TeW50aCwgVG9uZS5Nb25vcGhvbmljKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6ICdDNCcsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ29zY2lsbGF0b3InOiB7ICd0eXBlJzogJ3NxdWFyZScgfSxcblx0ICAgICAgICAnZmlsdGVyJzoge1xuXHQgICAgICAgICAgICAnUSc6IDYsXG5cdCAgICAgICAgICAgICd0eXBlJzogJ2xvd3Bhc3MnLFxuXHQgICAgICAgICAgICAncm9sbG9mZic6IC0yNFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMDUsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMSxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAwLjksXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2ZpbHRlckVudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wNixcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4yLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDAuNSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAyLFxuXHQgICAgICAgICAgICAnYmFzZUZyZXF1ZW5jeSc6IDIwMCxcblx0ICAgICAgICAgICAgJ29jdGF2ZXMnOiA3LFxuXHQgICAgICAgICAgICAnZXhwb25lbnQnOiAyXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgYXR0YWNrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IG9mIHRoZSBub3RlICgwLTEpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm9TeW50aH0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyRW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSByZWxlYXNlIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb25vU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub1N5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb25vU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub1N5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdmaWx0ZXInLFxuXHQgICAgICAgICAgICAnZmlsdGVyRW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyRW52ZWxvcGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyRW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZmlsdGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Nb25vU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5EdW9TeW50aCBpcyBhIG1vbm9waG9uaWMgc3ludGggY29tcG9zZWQgb2YgdHdvIFxuXHRcdCAqICAgICAgICAgIE1vbm9TeW50aHMgcnVuIGluIHBhcmFsbGVsIHdpdGggY29udHJvbCBvdmVyIHRoZSBcblx0XHQgKiAgICAgICAgICBmcmVxdWVuY3kgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcyBhbmQgdmlicmF0byBlZmZlY3QuXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kcmF3aW5ncy9kLzFiTDRHWHZmUk1NbHFTN1h5Qm05Q2pMOUtKUFNVS2JjZEJOcHFPbGtGTHhrL3B1Yj93PTEwMTImaD00NDhcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTW9ub3Bob25pY31cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGR1b1N5bnRoID0gbmV3IFRvbmUuRHVvU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIGR1b1N5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCIyblwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRHVvU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5EdW9TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGZpcnN0IHZvaWNlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTW9ub1N5bnRofVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2ljZTAgPSBuZXcgVG9uZS5Nb25vU3ludGgob3B0aW9ucy52b2ljZTApO1xuXHQgICAgICAgIHRoaXMudm9pY2UwLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc2Vjb25kIHZvaWNlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTW9ub1N5bnRofVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2ljZTEgPSBuZXcgVG9uZS5Nb25vU3ludGgob3B0aW9ucy52b2ljZTEpO1xuXHQgICAgICAgIHRoaXMudm9pY2UxLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdmlicmF0byBMRk8uIFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdmlicmF0byA9IG5ldyBUb25lLkxGTyhvcHRpb25zLnZpYnJhdG9SYXRlLCAtNTAsIDUwKTtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvLnN0YXJ0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiB0aGUgdmlicmF0byBmcmVxdWVuY3lcblx0XHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZpYnJhdG9SYXRlID0gdGhpcy5fdmlicmF0by5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHZpYnJhdG8gZ2FpblxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG9HYWluID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLnZpYnJhdG9BbW91bnQsIFRvbmUuVHlwZS5Qb3NpdGl2ZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgYW1vdW50IG9mIHZpYnJhdG9cblx0XHRcdCAqIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudmlicmF0b0Ftb3VudCA9IHRoaXMuX3ZpYnJhdG9HYWluLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGZyZXF1ZW5jeSBjb250cm9sXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbCg0NDAsIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhhcm1vbmljaXR5IGlzIHRoZSByYXRpbyBiZXR3ZWVuIHRoZSB0d28gdm9pY2VzLiBBIGhhcm1vbmljaXR5IG9mXG5cdFx0XHQgKiAgMSBpcyBubyBjaGFuZ2UuIEhhcm1vbmljaXR5ID0gMiBtZWFucyBhIGNoYW5nZSBvZiBhbiBvY3RhdmUuIFxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vcGl0Y2ggdm9pY2UxIGFuIG9jdGF2ZSBiZWxvdyB2b2ljZTBcblx0XHRcdCAqIGR1b1N5bnRoLmhhcm1vbmljaXR5LnZhbHVlID0gMC41O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMuaGFybW9uaWNpdHkpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLy9jb250cm9sIHRoZSB0d28gdm9pY2VzIGZyZXF1ZW5jeVxuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy52b2ljZTAuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLmhhcm1vbmljaXR5LCB0aGlzLnZvaWNlMS5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG8uY29ubmVjdCh0aGlzLl92aWJyYXRvR2Fpbik7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0b0dhaW4uZmFuKHRoaXMudm9pY2UwLmRldHVuZSwgdGhpcy52b2ljZTEuZGV0dW5lKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMC5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLnZvaWNlMS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICd2b2ljZTAnLFxuXHQgICAgICAgICAgICAndm9pY2UxJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd2aWJyYXRvQW1vdW50Jyxcblx0ICAgICAgICAgICAgJ3ZpYnJhdG9SYXRlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRHVvU3ludGgsIFRvbmUuTW9ub3Bob25pYyk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EdW9TeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndmlicmF0b0Ftb3VudCc6IDAuNSxcblx0ICAgICAgICAndmlicmF0b1JhdGUnOiA1LFxuXHQgICAgICAgICdoYXJtb25pY2l0eSc6IDEuNSxcblx0ICAgICAgICAndm9pY2UwJzoge1xuXHQgICAgICAgICAgICAndm9sdW1lJzogLTEwLFxuXHQgICAgICAgICAgICAncG9ydGFtZW50byc6IDAsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICAgICAnZmlsdGVyRW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICAgICAnYXR0YWNrJzogMC4wMSxcblx0ICAgICAgICAgICAgICAgICdkZWNheSc6IDAsXG5cdCAgICAgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICAgICAnYXR0YWNrJzogMC4wMSxcblx0ICAgICAgICAgICAgICAgICdkZWNheSc6IDAsXG5cdCAgICAgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAndm9pY2UxJzoge1xuXHQgICAgICAgICAgICAndm9sdW1lJzogLTEwLFxuXHQgICAgICAgICAgICAncG9ydGFtZW50byc6IDAsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICAgICAnZmlsdGVyRW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICAgICAnYXR0YWNrJzogMC4wMSxcblx0ICAgICAgICAgICAgICAgICdkZWNheSc6IDAsXG5cdCAgICAgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICAgICAnYXR0YWNrJzogMC4wMSxcblx0ICAgICAgICAgICAgICAgICdkZWNheSc6IDAsXG5cdCAgICAgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIGVudmVsb3Blc1xuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBhdHRhY2sgc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSB0aGUgdmVsb2NpdHkgb2YgdGhlIG5vdGUgKDAtMSlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRHVvU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRHVvU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAuZmlsdGVyRW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMS5maWx0ZXJFbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZXNcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgcmVsZWFzZSBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRHVvU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRHVvU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLnZvaWNlMC50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRHVvU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRHVvU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAndm9pY2UwJyxcblx0ICAgICAgICAgICAgJ3ZvaWNlMScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndmlicmF0b0Ftb3VudCcsXG5cdCAgICAgICAgICAgICd2aWJyYXRvUmF0ZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9pY2UxLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvR2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0b0dhaW4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG8gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudmlicmF0b0Ftb3VudC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy52aWJyYXRvQW1vdW50ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZpYnJhdG9SYXRlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5EdW9TeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBGTVN5bnRoIGlzIGNvbXBvc2VkIG9mIHR3byBUb25lLlN5bnRocyB3aGVyZSBvbmUgVG9uZS5TeW50aCBtb2R1bGF0ZXNcblx0XHQgKiAgICAgICAgICB0aGUgZnJlcXVlbmN5IG9mIGEgc2Vjb25kIFRvbmUuU3ludGguIEEgbG90IG9mIHNwZWN0cmFsIGNvbnRlbnQgXG5cdFx0ICogICAgICAgICAgY2FuIGJlIGV4cGxvcmVkIHVzaW5nIHRoZSBtb2R1bGF0aW9uSW5kZXggcGFyYW1ldGVyLiBSZWFkIG1vcmUgYWJvdXRcblx0XHQgKiAgICAgICAgICBmcmVxdWVuY3kgbW9kdWxhdGlvbiBzeW50aGVzaXMgb24gW1NvdW5kT25Tb3VuZF0oaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tL3Nvcy9hcHIwMC9hcnRpY2xlcy9zeW50aHNlY3JldHMuaHRtKS5cblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMWgwUFVEWlhQZ2k0SWt4NmJWVDZvbmNyWVBMbHVGS3k3bGo1M3B1eGotRE0vcHViP3c9OTAyJmg9NDYyXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBmbVN5bnRoID0gbmV3IFRvbmUuRk1TeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogZm1TeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM1XCIsIFwiNG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5GTVN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllciB2b2ljZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TeW50aH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG5ldyBUb25lLlN5bnRoKG9wdGlvbnMuY2Fycmllcik7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIncyBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IHRoaXMuX2NhcnJpZXIub3NjaWxsYXRvcjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllcidzIGVudmVsb3BlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSB0aGlzLl9jYXJyaWVyLmVudmVsb3BlLnNldChvcHRpb25zLmVudmVsb3BlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yIHZvaWNlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5TeW50aChvcHRpb25zLm1vZHVsYXRvcik7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3Mgb3NjaWxsYXRvciB3aGljaCBpcyBhcHBsaWVkXG5cdFx0XHQgKiAgdG8gdGhlIGFtcGxpdHVkZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSB0aGlzLl9tb2R1bGF0b3Iub3NjaWxsYXRvci5zZXQob3B0aW9ucy5tb2R1bGF0aW9uKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUgPSB0aGlzLl9tb2R1bGF0b3IuZW52ZWxvcGUuc2V0KG9wdGlvbnMubW9kdWxhdGlvbkVudmVsb3BlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbCg0NDAsIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgaW4gY2VudHNcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgaXMgdGhlIHJhdGlvIGJldHdlZW4gdGhlIHR3byB2b2ljZXMuIEEgaGFybW9uaWNpdHkgb2Zcblx0XHRcdCAqICAxIGlzIG5vIGNoYW5nZS4gSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS4gXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy9waXRjaCB2b2ljZTEgYW4gb2N0YXZlIGJlbG93IHZvaWNlMFxuXHRcdFx0ICogc3ludGguaGFybW9uaWNpdHkudmFsdWUgPSAwLjU7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbmV3IFRvbmUuTXVsdGlwbHkob3B0aW9ucy5oYXJtb25pY2l0eSk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS51bml0cyA9IFRvbmUuVHlwZS5Qb3NpdGl2ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdGlvbiBpbmRleCB3aGljaCBlc3NlbnRpYWxseSB0aGUgZGVwdGggb3IgYW1vdW50IG9mIHRoZSBtb2R1bGF0aW9uLiBJdCBpcyB0aGUgXG5cdFx0XHQgKiAgcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBcblx0XHRcdCAqICBtb2R1bGF0aW5nIHNpZ25hbCAobWEpIC0tIGFzIGluIG1hL21mLiBcblx0XHRcdCAqXHRAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKlx0QHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXggPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLm1vZHVsYXRpb25JbmRleCk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXgudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5vZGUgd2hlcmUgdGhlIG1vZHVsYXRpb24gaGFwcGVuc1xuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBuZXcgVG9uZS5HYWluKDApO1xuXHQgICAgICAgIC8vY29udHJvbCB0aGUgdHdvIHZvaWNlcyBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX2NhcnJpZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLmhhcm1vbmljaXR5LCB0aGlzLl9tb2R1bGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLm1vZHVsYXRpb25JbmRleCwgdGhpcy5fbW9kdWxhdGlvbk5vZGUpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmZhbih0aGlzLl9jYXJyaWVyLmRldHVuZSwgdGhpcy5fbW9kdWxhdG9yLmRldHVuZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmNvbm5lY3QodGhpcy5fbW9kdWxhdGlvbk5vZGUuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkluZGV4Jyxcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbicsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRk1TeW50aCwgVG9uZS5Nb25vcGhvbmljKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogMyxcblx0ICAgICAgICAnbW9kdWxhdGlvbkluZGV4JzogMTAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ29zY2lsbGF0b3InOiB7ICd0eXBlJzogJ3NpbmUnIH0sXG5cdCAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4wMSxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ21vZHVsYXRpb24nOiB7ICd0eXBlJzogJ3NxdWFyZScgfSxcblx0ICAgICAgICAnbW9kdWxhdGlvbkVudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC41LFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDEsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC41XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0dHJpZ2dlciB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIG5vdGVcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCBvY2N1clxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GTVN5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgLy90aGUgZW52ZWxvcGVzXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0cmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIG5vdGVcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCByZWxlYXNlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZNU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb24nLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZNU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5NZW1icmFuZVN5bnRoIG1ha2VzIGtpY2sgYW5kIHRvbSBzb3VuZHMgdXNpbmcgYSBzaW5nbGUgb3NjaWxsYXRvclxuXHRcdCAqICAgICAgICAgIHdpdGggYW4gYW1wbGl0dWRlIGVudmVsb3BlIGFuZCBmcmVxdWVuY3kgcmFtcC4gQSBUb25lLk9tbmlPc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICAgaXMgcm91dGVkIHRocm91Z2ggYSBUb25lLkFtcGxpdHVkZUVudmVsb3BlIHRvIHRoZSBvdXRwdXQuIFRoZSBkcnVtXG5cdFx0ICogICAgICAgICAgcXVhbGl0eSBvZiB0aGUgc291bmQgY29tZXMgZnJvbSB0aGUgZnJlcXVlbmN5IGVudmVsb3BlIGFwcGxpZWRcblx0XHQgKiAgICAgICAgICBkdXJpbmcgZHVyaW5nIFRvbmUuTWVtYnJhbmVTeW50aC50cmlnZ2VyQXR0YWNrKG5vdGUpLiBUaGUgZnJlcXVlbmN5XG5cdFx0ICogICAgICAgICAgZW52ZWxvcGUgc3RhcnRzIGF0IDxjb2RlPm5vdGUgKiAub2N0YXZlczwvY29kZT4gYW5kIHJhbXBzIHRvIFxuXHRcdCAqICAgICAgICAgIDxjb2RlPm5vdGU8L2NvZGU+IG92ZXIgdGhlIGR1cmF0aW9uIG9mIDxjb2RlPi5waXRjaERlY2F5PC9jb2RlPi4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLk1lbWJyYW5lU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzJcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1lbWJyYW5lU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9tbmlPc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbmV3IFRvbmUuT21uaU9zY2lsbGF0b3Iob3B0aW9ucy5vc2NpbGxhdG9yKS5zdGFydCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG51bWJlciBvZiBvY3RhdmVzIHRoZSBwaXRjaCBlbnZlbG9wZSByYW1wcy5cblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiB0aW1lIHRoZSBmcmVxdWVuY3kgZW52ZWxvcGUgdGFrZXMuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5waXRjaERlY2F5ID0gb3B0aW9ucy5waXRjaERlY2F5O1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5jaGFpbih0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1lbWJyYW5lU3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NZW1icmFuZVN5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdwaXRjaERlY2F5JzogMC4wNSxcblx0ICAgICAgICAnb2N0YXZlcyc6IDEwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDAxLFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjQsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMC4wMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAxLjQsXG5cdCAgICAgICAgICAgICdhdHRhY2tDdXJ2ZSc6ICdleHBvbmVudGlhbCdcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIG5vdGUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aCB0aGUgZ2l2ZW4gdmVsb2NpdHkuIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICB0aGUgbm90ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddICAgICB0aGUgdGltZSwgaWYgbm90IGdpdmVuIGlzIG5vd1xuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSB2ZWxvY2l0eSBkZWZhdWx0cyB0byAxXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1lbWJyYW5lU3ludGh9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAga2ljay50cmlnZ2VyQXR0YWNrKDYwKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlLCB0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBub3RlID0gdGhpcy50b0ZyZXF1ZW5jeShub3RlKTtcblx0ICAgICAgICB2YXIgbWF4Tm90ZSA9IG5vdGUgKiB0aGlzLm9jdGF2ZXM7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZShtYXhOb3RlLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUobm90ZSwgdGltZSArIHRoaXMudG9TZWNvbmRzKHRoaXMucGl0Y2hEZWNheSkpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgbm90ZS5cblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCByZWxlYXNlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1lbWJyYW5lU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZW1icmFuZVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWVtYnJhbmVTeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEluaGFybW9uaWMgcmF0aW8gb2YgZnJlcXVlbmNpZXMgYmFzZWQgb24gdGhlIFJvbGFuZCBUUi04MDhcblx0XHQgKiAgVGFrZW4gZnJvbSBodHRwczovL2Njcm1hLnN0YW5mb3JkLmVkdS9wYXBlcnMvdHItODA4LWN5bWJhbC1waHlzaWNhbGx5LWluZm9ybWVkLWNpcmN1aXQtYmVuZGFibGUtZGlnaXRhbC1tb2RlbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBpbmhhcm1SYXRpb3MgPSBbXG5cdCAgICAgICAgMSxcblx0ICAgICAgICAxLjQ4Myxcblx0ICAgICAgICAxLjkzMixcblx0ICAgICAgICAyLjU0Nixcblx0ICAgICAgICAyLjYzLFxuXHQgICAgICAgIDMuODk3XG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBoaWdobHkgaW5oYXJtb25pYyBhbmQgc3BlY3RyYWxseSBjb21wbGV4IHNvdXJjZSB3aXRoIGEgaGlnaHBhc3MgZmlsdGVyXG5cdFx0ICogICAgICAgICAgYW5kIGFtcGxpdHVkZSBlbnZlbG9wZSB3aGljaCBpcyBnb29kIGZvciBtYWtpbmcgbWV0YWxvcGhvbmUgc291bmRzLiBCYXNlZFxuXHRcdCAqICAgICAgICAgIG9uIEN5bWJhbFN5bnRoIGJ5IFtAcG9seXJoeXRobWF0aWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9wb2x5cmh5dGhtYXRpYykuXG5cdFx0ICogICAgICAgICAgSW5zcGlyYXRpb24gZnJvbSBbU291bmQgb24gU291bmRdKGh0dHA6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvanVsMDIvYXJ0aWNsZXMvc3ludGhzZWNyZXRzMDcwMi5hc3ApLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGF2YWlsYmxlIGZvciB0aGUgc3ludGhcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5NZXRhbFN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IG9mIHRoZSBjeW1iYWxcblx0XHRcdCAqICBAdHlwZSAge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIEZNT3NjaWxsYXRvcnNcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgbXVsdGlwbGllcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZyZXFNdWx0aXBsaWVycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZm9yIHRoZSBib2R5XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWUgPSBuZXcgVG9uZS5HYWluKDApLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGhpZ2hwYXNzIHRoZSBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2hpZ2hwYXNzID0gbmV3IFRvbmUuRmlsdGVyKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiAnaGlnaHBhc3MnLFxuXHQgICAgICAgICAgICAnUSc6IC0zLjAxMDI5OTk1NjYzOTgxMjVcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMuX2FtcGxpdHVlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgdGhlIGhpZ2hwYXNzXG5cdFx0XHQgKiAgZmlsdGVyIGZyZXF1ZW5jeSByYW1wc1xuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2NhbGUgdGhlIGJvZHkgZW52ZWxvcGVcblx0XHRcdCAqICBmb3IgdGhlIGJhbmRwYXNzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2NhbGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIgPSBuZXcgVG9uZS5TY2FsZShvcHRpb25zLnJlc29uYW5jZSwgNzAwMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGVudmVsb3BlIHdoaWNoIGlzIGNvbm5lY3RlZCBib3RoIHRvIHRoZSBcblx0XHRcdCAqICBhbXBsaXR1ZGUgYW5kIGhpZ2hwYXNzIGZpbHRlcidzIGN1dG9mZiBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuRW52ZWxvcGUoe1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogb3B0aW9ucy5lbnZlbG9wZS5hdHRhY2ssXG5cdCAgICAgICAgICAgICdhdHRhY2tDdXJ2ZSc6ICdsaW5lYXInLFxuXHQgICAgICAgICAgICAnZGVjYXknOiBvcHRpb25zLmVudmVsb3BlLmRlY2F5LFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDAsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogb3B0aW9ucy5lbnZlbG9wZS5yZWxlYXNlXG5cdCAgICAgICAgfSkuY2hhaW4odGhpcy5fZmlsdGVyRnJlcVNjYWxlciwgdGhpcy5faGlnaHBhc3MuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmNvbm5lY3QodGhpcy5fYW1wbGl0dWUuZ2Fpbik7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmhhcm1SYXRpb3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG9zYyA9IG5ldyBUb25lLkZNT3NjaWxsYXRvcih7XG5cdCAgICAgICAgICAgICAgICAndHlwZSc6ICdzcXVhcmUnLFxuXHQgICAgICAgICAgICAgICAgJ21vZHVsYXRpb25UeXBlJzogJ3NxdWFyZScsXG5cdCAgICAgICAgICAgICAgICAnaGFybW9uaWNpdHknOiBvcHRpb25zLmhhcm1vbmljaXR5LFxuXHQgICAgICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCc6IG9wdGlvbnMubW9kdWxhdGlvbkluZGV4XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBvc2MuY29ubmVjdCh0aGlzLl9oaWdocGFzcykuc3RhcnQoMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzW2ldID0gb3NjO1xuXHQgICAgICAgICAgICB2YXIgbXVsdCA9IG5ldyBUb25lLk11bHRpcGx5KGluaGFybVJhdGlvc1tpXSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZyZXFNdWx0aXBsaWVyc1tpXSA9IG11bHQ7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKG11bHQsIG9zYy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3NldCB0aGUgb2N0YXZlc1xuXHQgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1ldGFsU3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMjAwLFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDAxLFxuXHQgICAgICAgICAgICAnZGVjYXknOiAxLjQsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC4yXG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiA1LjEsXG5cdCAgICAgICAgJ21vZHVsYXRpb25JbmRleCc6IDMyLFxuXHQgICAgICAgICdyZXNvbmFuY2UnOiA0MDAwLFxuXHQgICAgICAgICdvY3RhdmVzJzogMS41XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjay5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgICAgICBXaGVuIHRoZSBhdHRhY2sgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2U9MX0gIHZlbG9jaXR5ICBUaGUgdmVsb2NpdHkgdGhhdCB0aGUgZW52ZWxvcGUgc2hvdWxkIGJlIHRyaWdnZXJlZCBhdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWV0YWxTeW50aH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWwpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmVsID0gdGhpcy5kZWZhdWx0QXJnKHZlbCwgMSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICAgIFdoZW4gdGhlIHJlbGVhc2Ugc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWV0YWxTeW50aH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgYW5kIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlIGFmdGVyIHRoZSBnaXZlbiBcblx0XHQgKiAgZHVyYXRpb24uIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgZHVyYXRpb24gIFRoZSBkdXJhdGlvbiBiZWZvcmUgdHJpZ2dlcmluZyB0aGUgcmVsZWFzZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICAgIFdoZW4gdGhlIGF0dGFjayBzaG91bGQgYmUgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZT0xfSAgdmVsb2NpdHkgIFRoZSB2ZWxvY2l0eSB0aGF0IHRoZSBlbnZlbG9wZSBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NZXRhbFN5bnRofSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRhbFN5bnRoLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKHRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtb2R1bGF0aW9uSW5kZXggb2YgdGhlIG9zY2lsbGF0b3JzIHdoaWNoIG1ha2UgdXAgdGhlIHNvdXJjZS5cblx0XHQgKiAgc2VlIFRvbmUuRk1Pc2NpbGxhdG9yLm1vZHVsYXRpb25JbmRleFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5NZXRhbFN5bnRoI1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lICBtb2R1bGF0aW9uSW5kZXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAnbW9kdWxhdGlvbkluZGV4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvcnNbMF0ubW9kdWxhdGlvbkluZGV4LnZhbHVlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzW2ldLm1vZHVsYXRpb25JbmRleC52YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBoYXJtb25pY2l0eSBvZiB0aGUgb3NjaWxsYXRvcnMgd2hpY2ggbWFrZSB1cCB0aGUgc291cmNlLlxuXHRcdCAqICBzZWUgVG9uZS5GTU9zY2lsbGF0b3IuaGFybW9uaWNpdHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSAgaGFybW9uaWNpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAnaGFybW9uaWNpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yc1swXS5oYXJtb25pY2l0eS52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXS5oYXJtb25pY2l0eS52YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGhpZ2hwYXNzIGZpbHRlciBhdHRhY2hlZCB0byB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiAgQG5hbWUgIHJlc29uYW5jZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUsICdyZXNvbmFuY2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLm1pbiA9IHZhbDtcblx0ICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgYWJvdmUgdGhlIFwicmVzb25hbmNlXCIgZnJlcXVlbmN5XG5cdFx0ICogIHRoYXQgdGhlIGZpbHRlciByYW1wcyBkdXJpbmcgdGhlIGF0dGFjay9kZWNheSBlbnZlbG9wZVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5NZXRhbFN5bnRoI1xuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSAgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9jdHM7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIubWF4ID0gdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5taW4gKiBNYXRoLnBvdygyLCBvY3RzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZXRhbFN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZyZXFNdWx0aXBsaWVyc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mcmVxTXVsdGlwbGllcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9oaWdocGFzcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5faGlnaHBhc3MgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1ldGFsU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Ob2lzZSBpcyBhIG5vaXNlIGdlbmVyYXRvci4gSXQgdXNlcyBsb29wZWQgbm9pc2UgYnVmZmVycyB0byBzYXZlIG9uIHBlcmZvcm1hbmNlLlxuXHRcdCAqICAgICAgICAgIFRvbmUuTm9pc2Ugc3VwcG9ydHMgdGhlIG5vaXNlIHR5cGVzOiBcInBpbmtcIiwgXCJ3aGl0ZVwiLCBhbmQgXCJicm93blwiLiBSZWFkIG1vcmUgYWJvdXRcblx0XHQgKiAgICAgICAgICBjb2xvcnMgb2Ygbm9pc2Ugb24gW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29sb3JzX29mX25vaXNlKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfVxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gdHlwZSB0aGUgbm9pc2UgdHlwZSAod2hpdGV8cGlua3xicm93bilcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2luaXRpYWxpemUgdGhlIG5vaXNlIGFuZCBzdGFydFxuXHRcdCAqIHZhciBub2lzZSA9IG5ldyBUb25lLk5vaXNlKFwicGlua1wiKS5zdGFydCgpO1xuXHRcdCAqIFxuXHRcdCAqIC8vbWFrZSBhbiBhdXRvZmlsdGVyIHRvIHNoYXBlIHRoZSBub2lzZVxuXHRcdCAqIHZhciBhdXRvRmlsdGVyID0gbmV3IFRvbmUuQXV0b0ZpbHRlcih7XG5cdFx0ICogXHRcImZyZXF1ZW5jeVwiIDogXCI4bVwiLCBcblx0XHQgKiBcdFwibWluXCIgOiA4MDAsIFxuXHRcdCAqIFx0XCJtYXhcIiA6IDE1MDAwXG5cdFx0ICogfSkuY29ubmVjdChUb25lLk1hc3Rlcik7XG5cdFx0ICogXG5cdFx0ICogLy9jb25uZWN0IHRoZSBub2lzZVxuXHRcdCAqIG5vaXNlLmNvbm5lY3QoYXV0b0ZpbHRlcik7XG5cdFx0ICogLy9zdGFydCB0aGUgYXV0b2ZpbHRlciBMRk9cblx0XHQgKiBhdXRvRmlsdGVyLnN0YXJ0KClcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbJ3R5cGUnXSwgVG9uZS5Ob2lzZS5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBidWZmZXJcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIG5vaXNlLiBBZmZlY3RzXG5cdFx0XHQgKiAgdGhlIFwiZnJlcXVlbmN5XCIgb2YgdGhlIG5vaXNlLlxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Ob2lzZSwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndHlwZSc6ICd3aGl0ZScsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgbm9pc2UuIENhbiBiZSBcIndoaXRlXCIsIFwiYnJvd25cIiwgb3IgXCJwaW5rXCIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk5vaXNlI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogbm9pc2UudHlwZSA9IFwid2hpdGVcIjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk5vaXNlLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXIgPT09IF93aGl0ZU5vaXNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3doaXRlJztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9idWZmZXIgPT09IF9icm93bk5vaXNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ2Jyb3duJztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9idWZmZXIgPT09IF9waW5rTm9pc2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAncGluayc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICd3aGl0ZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gX3doaXRlTm9pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdwaW5rJzpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBfcGlua05vaXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnYnJvd24nOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IF9icm93bk5vaXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb25lLk5vaXNlOiBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vaWYgaXQncyBwbGF5aW5nLCBzdG9wIGFuZCByZXN0YXJ0IGl0XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCkgKyB0aGlzLmJsb2NrVGltZTtcblx0ICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wKG5vdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQobm93KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwbGF5YmFjayByYXRlIG9mIHRoZSBub2lzZS4gQWZmZWN0c1xuXHRcdCAqICB0aGUgXCJmcmVxdWVuY3lcIiBvZiB0aGUgbm9pc2UuXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQHNpZ25hbFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTm9pc2UucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmF0ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGludGVybmFsIHN0YXJ0IG1ldGhvZFxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdCAgICAgICAgdGhpcy5fc291cmNlLmJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UubG9vcCA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5fc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fc291cmNlLnN0YXJ0KHRoaXMudG9TZWNvbmRzKHRpbWUpLCBNYXRoLnJhbmRvbSgpICogKHRoaXMuX2J1ZmZlci5kdXJhdGlvbiAtIDAuMDAxKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGludGVybmFsIHN0b3AgbWV0aG9kXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2Uuc3RvcCh0aGlzLnRvU2Vjb25kcyh0aW1lKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTm9pc2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBpZiAodGhpcy5fc291cmNlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBUSEUgQlVGRkVSU1xuXHQgICAgLy8gYm9ycm93ZWQgaGVhdmlseSBmcm9tIGh0dHA6Ly9ub2lzZWhhY2suY29tL2dlbmVyYXRlLW5vaXNlLXdlYi1hdWRpby1hcGkvXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqXHRzdGF0aWMgbm9pc2UgYnVmZmVyc1xuXHRcdCAqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyfVxuXHRcdCAqL1xuXHQgICAgdmFyIF9waW5rTm9pc2UgPSBudWxsLCBfYnJvd25Ob2lzZSA9IG51bGwsIF93aGl0ZU5vaXNlID0gbnVsbDtcblx0ICAgIFRvbmUuX2luaXRBdWRpb0NvbnRleHQoZnVuY3Rpb24gKGF1ZGlvQ29udGV4dCkge1xuXHQgICAgICAgIHZhciBzYW1wbGVSYXRlID0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAgICAgLy9mb3VyIHNlY29uZHMgcGVyIGJ1ZmZlclxuXHQgICAgICAgIHZhciBidWZmZXJMZW5ndGggPSBzYW1wbGVSYXRlICogNDtcblx0ICAgICAgICAvL2ZpbGwgdGhlIGJ1ZmZlcnNcblx0ICAgICAgICBfcGlua05vaXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigyLCBidWZmZXJMZW5ndGgsIHNhbXBsZVJhdGUpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjaGFubmVsTnVtID0gMDsgY2hhbm5lbE51bSA8IGJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBjaGFubmVsTnVtKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWxOdW0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2O1xuXHQgICAgICAgICAgICAgICAgYjAgPSBiMSA9IGIyID0gYjMgPSBiNCA9IGI1ID0gYjYgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBiMCA9IDAuOTk4ODYgKiBiMCArIHdoaXRlICogMC4wNTU1MTc5O1xuXHQgICAgICAgICAgICAgICAgICAgIGIxID0gMC45OTMzMiAqIGIxICsgd2hpdGUgKiAwLjA3NTA3NTk7XG5cdCAgICAgICAgICAgICAgICAgICAgYjIgPSAwLjk2OSAqIGIyICsgd2hpdGUgKiAwLjE1Mzg1Mjtcblx0ICAgICAgICAgICAgICAgICAgICBiMyA9IDAuODY2NSAqIGIzICsgd2hpdGUgKiAwLjMxMDQ4NTY7XG5cdCAgICAgICAgICAgICAgICAgICAgYjQgPSAwLjU1ICogYjQgKyB3aGl0ZSAqIDAuNTMyOTUyMjtcblx0ICAgICAgICAgICAgICAgICAgICBiNSA9IC0wLjc2MTYgKiBiNSAtIHdoaXRlICogMC4wMTY4OTg7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSA9IGIwICsgYjEgKyBiMiArIGIzICsgYjQgKyBiNSArIGI2ICsgd2hpdGUgKiAwLjUzNjI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSAqPSAwLjExO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIChyb3VnaGx5KSBjb21wZW5zYXRlIGZvciBnYWluXG5cdCAgICAgICAgICAgICAgICAgICAgYjYgPSB3aGl0ZSAqIDAuMTE1OTI2O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIF9icm93bk5vaXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigyLCBidWZmZXJMZW5ndGgsIHNhbXBsZVJhdGUpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjaGFubmVsTnVtID0gMDsgY2hhbm5lbE51bSA8IGJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBjaGFubmVsTnVtKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWxOdW0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhc3RPdXQgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldID0gKGxhc3RPdXQgKyAwLjAyICogd2hpdGUpIC8gMS4wMjtcblx0ICAgICAgICAgICAgICAgICAgICBsYXN0T3V0ID0gY2hhbm5lbFtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldICo9IDMuNTsgICAgLy8gKHJvdWdobHkpIGNvbXBlbnNhdGUgZm9yIGdhaW5cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXHQgICAgICAgIH0oKTtcblx0ICAgICAgICBfd2hpdGVOb2lzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMiwgYnVmZmVyTGVuZ3RoLCBzYW1wbGVSYXRlKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbE51bSA9IDA7IGNoYW5uZWxOdW0gPCBidWZmZXIubnVtYmVyT2ZDaGFubmVsczsgY2hhbm5lbE51bSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsTnVtKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gVG9uZS5Ob2lzZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLk5vaXNlU3ludGggaXMgY29tcG9zZWQgb2YgYSBub2lzZSBnZW5lcmF0b3IgKFRvbmUuTm9pc2UpLCBvbmUgZmlsdGVyIChUb25lLkZpbHRlciksIFxuXHRcdCAqICAgICAgICAgIGFuZCB0d28gZW52ZWxvcGVzIChUb25lLkVudmVsb3ApLiBPbmUgZW52ZWxvcGUgY29udHJvbHMgdGhlIGFtcGxpdHVkZVxuXHRcdCAqICAgICAgICAgIG9mIHRoZSBub2lzZSBhbmQgdGhlIG90aGVyIGlzIGNvbnRyb2xzIHRoZSBjdXRvZmYgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXIuIFxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xcnF6dVg5ckJsaFQ1ME1SdkQyVEttbDliblpoY1ptelhGMXJmX283dmRuRS9wdWI/dz05MTgmaD0yNDJcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuSW5zdHJ1bWVudH1cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgbm9pc2VTeW50aCA9IG5ldyBUb25lLk5vaXNlU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIG5vaXNlU3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk5vaXNlU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBub2lzZSBzb3VyY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTm9pc2V9XG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIG5vaXNlU3ludGguc2V0KFwibm9pc2UudHlwZVwiLCBcImJyb3duXCIpO1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5ub2lzZSA9IG5ldyBUb25lLk5vaXNlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtcGxpdHVkZSBlbnZlbG9wZS4gXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBub2lzZSB0byB0aGUgb3V0cHV0XG5cdCAgICAgICAgdGhpcy5ub2lzZS5jaGFpbih0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgbm9pc2Vcblx0ICAgICAgICB0aGlzLm5vaXNlLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnbm9pc2UnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Ob2lzZVN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ25vaXNlJzogeyAndHlwZSc6ICd3aGl0ZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4xLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDBcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVzLiBVbmxpa2Ugb3RoZXIgXG5cdFx0ICogIGluc3RydW1lbnRzLCBUb25lLk5vaXNlU3ludGggZG9lc24ndCBoYXZlIGEgbm90ZS4gXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgYXR0YWNrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Ob2lzZVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogbm9pc2VTeW50aC50cmlnZ2VyQXR0YWNrKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZXMuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgcmVsZWFzZSBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTm9pc2VTeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZVN5bnRoLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlLiBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZHVyYXRpb24gdGhlIGR1cmF0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gICAgIHRoZSB0aW1lIG9mIHRoZSBhdHRhY2tcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgZHVyYXRpb24pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdub2lzZScsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLm5vaXNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm5vaXNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Ob2lzZVN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgS2FycGx1cy1TdHJpbmcgc3RyaW5nIHN5bnRoZXNpcy4gT2Z0ZW4gb3V0IG9mIHR1bmUuIFxuXHRcdCAqICAgICAgICAgV2lsbCBjaGFuZ2Ugd2hlbiB0aGUgQXVkaW9Xb3JrZXJOb2RlIGlzIGF2YWlsYWJsZSBhY3Jvc3Ncblx0XHQgKiAgICAgICAgIGJyb3dzZXJzLiBcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgZGVmYXVsdHNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcGx1Y2t5ID0gbmV3IFRvbmUuUGx1Y2tTeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogcGx1Y2t5LnRyaWdnZXJBdHRhY2soXCJDNFwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLlBsdWNrU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk5vaXNlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ub2lzZSA9IG5ldyBUb25lLk5vaXNlKCdwaW5rJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBub2lzZSBhdCB0aGUgYXR0YWNrLiBcblx0XHRcdCAqICBOb21pbmFsIHJhbmdlIG9mIFswLjEsIDIwXVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFja05vaXNlID0gb3B0aW9ucy5hdHRhY2tOb2lzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgTEZDRlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxvd3Bhc3NDb21iRmlsdGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZmNmID0gbmV3IFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIoe1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJzogb3B0aW9ucy5yZXNvbmFuY2UsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnOiBvcHRpb25zLmRhbXBlbmluZ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByZXNvbmFuY2UgY29udHJvbC4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gdGhpcy5fbGZjZi5yZXNvbmFuY2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRhbXBlbmluZyBjb250cm9sLiBpLmUuIHRoZSBsb3dwYXNzIGZpbHRlciBmcmVxdWVuY3kgb2YgdGhlIGNvbWIgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRhbXBlbmluZyA9IHRoaXMuX2xmY2YuZGFtcGVuaW5nO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9ub2lzZS5jb25uZWN0KHRoaXMuX2xmY2YpO1xuXHQgICAgICAgIHRoaXMuX2xmY2YuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBsdWNrU3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYXR0YWNrTm9pc2UnOiAxLFxuXHQgICAgICAgICdkYW1wZW5pbmcnOiA0MDAwLFxuXHQgICAgICAgICdyZXNvbmFuY2UnOiAwLjlcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgbm90ZS4gXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBub3RlIFRoZSBub3RlIHRvIHRyaWdnZXIuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsdWNrU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlLCB0aW1lKSB7XG5cdCAgICAgICAgbm90ZSA9IHRoaXMudG9GcmVxdWVuY3kobm90ZSk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhciBkZWxheUFtb3VudCA9IDEgLyBub3RlO1xuXHQgICAgICAgIHRoaXMuX2xmY2YuZGVsYXlUaW1lLnNldFZhbHVlQXRUaW1lKGRlbGF5QW1vdW50LCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5zdGFydCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5zdG9wKHRpbWUgKyBkZWxheUFtb3VudCAqIHRoaXMuYXR0YWNrTm9pc2UpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsdWNrU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZjZi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9pc2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmY2YgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QbHVja1N5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuUG9seVN5bnRoIGhhbmRsZXMgdm9pY2UgY3JlYXRpb24gYW5kIGFsbG9jYXRpb24gZm9yIGFueVxuXHRcdCAqICAgICAgICAgIGluc3RydW1lbnRzIHBhc3NlZCBpbiBhcyB0aGUgc2Vjb25kIHBhcmFtdGVyLiBQb2x5U3ludGggaXMgXG5cdFx0ICogICAgICAgICAgbm90IGEgc3ludGhlc2l6ZXIgYnkgaXRzZWxmLCBpdCBtZXJlbHkgbWFuYWdlcyB2b2ljZXMgb2YgXG5cdFx0ICogICAgICAgICAgb25lIG9mIHRoZSBvdGhlciB0eXBlcyBvZiBzeW50aHMsIGFsbG93aW5nIGFueSBvZiB0aGUgXG5cdFx0ICogICAgICAgICAgbW9ub3Bob25pYyBzeW50aGVzaXplcnMgdG8gYmUgcG9seXBob25pYy4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gW3BvbHlwaG9ueT00XSBUaGUgbnVtYmVyIG9mIHZvaWNlcyB0byBjcmVhdGVcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW3ZvaWNlPVRvbmUuU3ludGhdIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgdm9pY2VzXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXMgVG9uZS5TeW50aCBieSBkZWZhdWx0LiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2EgcG9seXN5bnRoIGNvbXBvc2VkIG9mIDYgVm9pY2VzIG9mIFN5bnRoXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuUG9seVN5bnRoKDYsIFRvbmUuU3ludGgpLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9zZXQgdGhlIGF0dHJpYnV0ZXMgdXNpbmcgdGhlIHNldCBpbnRlcmZhY2Vcblx0XHQgKiBzeW50aC5zZXQoXCJkZXR1bmVcIiwgLTEyMDApO1xuXHRcdCAqIC8vcGxheSBhIGNob3JkXG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiQzRcIiwgXCJFNFwiLCBcIkE0XCJdLCBcIjRuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LmNhbGwodGhpcyk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdwb2x5cGhvbnknLFxuXHQgICAgICAgICAgICAndm9pY2UnXG5cdCAgICAgICAgXSwgVG9uZS5Qb2x5U3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5JbnN0cnVtZW50LmRlZmF1bHRzKTtcblx0ICAgICAgICAvL21heCBwb2x5cGhvbnlcblx0ICAgICAgICBvcHRpb25zLnBvbHlwaG9ueSA9IE1hdGgubWluKFRvbmUuUG9seVN5bnRoLk1BWF9QT0xZUEhPTlksIG9wdGlvbnMucG9seXBob255KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYXJyYXkgb2Ygdm9pY2VzXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2ljZXMgPSBuZXcgQXJyYXkob3B0aW9ucy5wb2x5cGhvbnkpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBxdWV1ZSBvZiB2b2ljZXMgd2l0aCBkYXRhIGFib3V0IGxhc3QgdHJpZ2dlclxuXHRcdFx0ICogIGFuZCB0aGUgdHJpZ2dlcmVkIG5vdGVcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RyaWdnZXJzID0gbmV3IEFycmF5KG9wdGlvbnMucG9seXBob255KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGluIGNlbnRzXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZGV0dW5lLCBUb25lLlR5cGUuQ2VudHMpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdkZXR1bmUnKTtcblx0ICAgICAgICAvL2NyZWF0ZSB0aGUgdm9pY2VzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnBvbHlwaG9ueTsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB2ID0gbmV3IG9wdGlvbnMudm9pY2UoYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuXHQgICAgICAgICAgICB0aGlzLnZvaWNlc1tpXSA9IHY7XG5cdCAgICAgICAgICAgIHYuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgICAgIGlmICh2Lmhhc093blByb3BlcnR5KCdkZXR1bmUnKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kZXR1bmUuY29ubmVjdCh2LmRldHVuZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcnNbaV0gPSB7XG5cdCAgICAgICAgICAgICAgICByZWxlYXNlOiAtMSxcblx0ICAgICAgICAgICAgICAgIG5vdGU6IG51bGwsXG5cdCAgICAgICAgICAgICAgICB2b2ljZTogdlxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3NldCB0aGUgdm9sdW1lIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMudm9sdW1lLnZhbHVlID0gb3B0aW9ucy52b2x1bWU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Qb2x5U3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncG9seXBob255JzogNCxcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAndm9pY2UnOiBUb25lLlN5bnRoXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeXxBcnJheX0gbm90ZXMgVGhlIG5vdGVzIHRvIHBsYXkuIEFjY2VwdHMgYSBzaW5nbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGcmVxdWVuY3kgb3IgYW4gYXJyYXkgb2YgZnJlcXVlbmNpZXMuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBub3RlLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIFRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy90cmlnZ2VyIGEgY2hvcmQgaW1tZWRpYXRlbHkgd2l0aCBhIHZlbG9jaXR5IG9mIDAuMlxuXHRcdCAqIHBvbHkudHJpZ2dlckF0dGFjayhbXCJBYjNcIiwgXCJDNFwiLCBcIkY1XCJdLCB1bmRlZmluZWQsIDAuMik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlcywgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm90ZXMpKSB7XG5cdCAgICAgICAgICAgIG5vdGVzID0gW25vdGVzXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IG5vdGVzW2ldO1xuXHQgICAgICAgICAgICAvL3RyaWdnZXIgdGhlIG9sZGVzdCB2b2ljZVxuXHQgICAgICAgICAgICB2YXIgb2xkZXN0ID0gdGhpcy5fdHJpZ2dlcnNbMF07XG5cdCAgICAgICAgICAgIHZhciBvbGRlc3RJbmRleCA9IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgdGhpcy5fdHJpZ2dlcnMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2Vyc1tqXS5yZWxlYXNlIDwgb2xkZXN0LnJlbGVhc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRlc3QgPSB0aGlzLl90cmlnZ2Vyc1tqXTtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRlc3RJbmRleCA9IGo7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb2xkZXN0LnJlbGVhc2UgPSBJbmZpbml0eTtcblx0ICAgICAgICAgICAgb2xkZXN0Lm5vdGUgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHQgICAgICAgICAgICBvbGRlc3Qudm9pY2UudHJpZ2dlckF0dGFjayh2YWwsIHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSBhZnRlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l8QXJyYXl9IG5vdGVzIFRoZSBub3RlcyB0byBwbGF5LiBBY2NlcHRzIGEgc2luZ2xlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRnJlcXVlbmN5IG9yIGFuIGFycmF5IG9mIGZyZXF1ZW5jaWVzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBkdXJhdGlvbiB0aGUgZHVyYXRpb24gb2YgdGhlIG5vdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgICAgaWYgbm8gdGltZSBpcyBnaXZlbiwgZGVmYXVsdHMgdG8gbm93XG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgYXR0YWNrICgwLTEpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciBhIGNob3JkIGZvciBhIGR1cmF0aW9uIG9mIGEgaGFsZiBub3RlIFxuXHRcdCAqIHBvbHkudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiRWIzXCIsIFwiRzRcIiwgXCJDNVwiXSwgXCIyblwiKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NhbiBwYXNzIGluIGFuIGFycmF5IG9mIGR1cmF0aW9ucyBhcyB3ZWxsXG5cdFx0ICogcG9seS50cmlnZ2VyQXR0YWNrUmVsZWFzZShbXCJFYjNcIiwgXCJHNFwiLCBcIkM1XCJdLCBbXCIyblwiLCBcIjRuXCIsIFwiNG5cIl0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKG5vdGVzLCBkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKG5vdGVzLCB0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNBcnJheShkdXJhdGlvbikgJiYgdGhpcy5pc0FycmF5KG5vdGVzKSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZCA9IGR1cmF0aW9uW01hdGgubWluKGksIGR1cmF0aW9uLmxlbmd0aCAtIDEpXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2Uobm90ZXNbaV0sIHRpbWUgKyB0aGlzLnRvU2Vjb25kcyhkKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKG5vdGVzLCB0aW1lICsgdGhpcy50b1NlY29uZHMoZHVyYXRpb24pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2Ugb2YgdGhlIG5vdGUuIFVubGlrZSBtb25vcGhvbmljIGluc3RydW1lbnRzLCBcblx0XHQgKiAgYSBub3RlIChvciBhcnJheSBvZiBub3RlcykgbmVlZHMgdG8gYmUgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fEFycmF5fSBub3RlcyBUaGUgbm90ZXMgdG8gcGxheS4gQWNjZXB0cyBhIHNpbmdsZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyZXF1ZW5jeSBvciBhbiBhcnJheSBvZiBmcmVxdWVuY2llcy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgV2hlbiB0aGUgcmVsZWFzZSB3aWxsIGJlIHRyaWdnZXJlZC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHBvbHkudHJpZ2dlclJlbGVhc2UoW1wiQWIzXCIsIFwiQzRcIiwgXCJGNVwiXSwgXCIrMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAobm90ZXMsIHRpbWUpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm90ZXMpKSB7XG5cdCAgICAgICAgICAgIG5vdGVzID0gW25vdGVzXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgLy9nZXQgdGhlIHZvaWNlXG5cdCAgICAgICAgICAgIHZhciBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KG5vdGVzW2ldKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCB0aGlzLl90cmlnZ2Vycy5sZW5ndGg7IHYrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB0aGlzLl90cmlnZ2Vyc1t2XTtcblx0ICAgICAgICAgICAgICAgIGlmIChkZXNjLm5vdGUgPT09IHN0cmluZ2lmaWVkICYmIGRlc2MucmVsZWFzZSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZXNjLnZvaWNlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlc2MucmVsZWFzZSA9IHRpbWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCBhIG1lbWJlci9hdHRyaWJ1dGUgb2YgdGhlIHZvaWNlcy4gXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcGFyYW1zXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gcmFtcFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogcG9seS5zZXQoe1xuXHRcdCAqIFx0XCJmaWx0ZXJcIiA6IHtcblx0XHQgKiBcdFx0XCJ0eXBlXCIgOiBcImhpZ2hwYXNzXCJcblx0XHQgKiBcdH0sXG5cdFx0ICogXHRcImVudmVsb3BlXCIgOiB7XG5cdFx0ICogXHRcdFwiYXR0YWNrXCIgOiAwLjI1XG5cdFx0ICogXHR9XG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUsIHJhbXBUaW1lKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZvaWNlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLnZvaWNlc1tpXS5zZXQocGFyYW1zLCB2YWx1ZSwgcmFtcFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzeW50aCdzIGF0dHJpYnV0ZXMuIEdpdmVuIG5vIGFyZ3VtZW50cyBnZXRcblx0XHQgKiAgd2lsbCByZXR1cm4gYWxsIGF2YWlsYWJsZSBvYmplY3QgcHJvcGVydGllcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZ1xuXHRcdCAqICB2YWx1ZXMuIFBhc3MgaW4gYSBzaW5nbGUgYXR0cmlidXRlIHRvIHJldHJpZXZlIG9yIGFuIGFycmF5XG5cdFx0ICogIG9mIGF0dHJpYnV0ZXMuIFRoZSBhdHRyaWJ1dGUgc3RyaW5ncyBjYW4gYWxzbyBpbmNsdWRlIGEgXCIuXCJcblx0XHQgKiAgdG8gYWNjZXNzIGRlZXBlciBwcm9wZXJ0aWVzLlxuXHRcdCAqICBAcGFyYW0ge0FycmF5PX0gcGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHRvIGdldCwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIFxuXHRcdCAqICBcdFx0XHRcdFx0ICAgYWxsIGF2YWlsYWJsZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudm9pY2VzWzBdLmdldChwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlIHZvaWNlcy5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIG5vdGVzIHNob3VsZCBiZSByZWxlYXNlZC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5yZWxlYXNlQWxsID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cmlnZ2Vycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZGVzYyA9IHRoaXMuX3RyaWdnZXJzW2ldO1xuXHQgICAgICAgICAgICBpZiAoZGVzYy5yZWxlYXNlID4gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgZGVzYy5yZWxlYXNlID0gdGltZTtcblx0ICAgICAgICAgICAgICAgIGRlc2Mudm9pY2UudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52b2ljZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy52b2ljZXNbaV0uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLnZvaWNlc1tpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdkZXR1bmUnKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9pY2VzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90cmlnZ2VycyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub3RlcyB0aGF0IGNhbiBiZSBhbGxvY2F0ZWQgXG5cdFx0ICogIHRvIGEgcG9seXN5bnRoLiBcblx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLk1BWF9QT0xZUEhPTlkgPSAyMDtcblx0ICAgIHJldHVybiBUb25lLlBvbHlTeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlBsYXllciBpcyBhbiBhdWRpbyBmaWxlIHBsYXllciB3aXRoIHN0YXJ0LCBsb29wLCBhbmQgc3RvcCBmdW5jdGlvbnMuXG5cdFx0ICogIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfSBcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8QXVkaW9CdWZmZXJ9IHVybCBFaXRoZXIgdGhlIEF1ZGlvQnVmZmVyIG9yIHRoZSB1cmwgZnJvbVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIHRvIGxvYWQgdGhlIEF1ZGlvQnVmZmVyXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb249fSBvbmxvYWQgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBidWZmZXIgaXMgbG9hZGVkLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWNvbW1lbmRlZCB0byB1c2UgVG9uZS5CdWZmZXIub24oJ2xvYWQnKSBpbnN0ZWFkLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwbGF5ZXIgPSBuZXcgVG9uZS5QbGF5ZXIoXCIuL3BhdGgvdG8vc2FtcGxlLm1wM1wiKS50b01hc3RlcigpO1xuXHRcdCAqIC8vcGxheSBhcyBzb29uIGFzIHRoZSBidWZmZXIgaXMgbG9hZGVkXG5cdFx0ICogcGxheWVyLmF1dG9zdGFydCA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllciA9IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucztcblx0ICAgICAgICBpZiAodXJsIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdXJsID0gdXJsLmdldCgpO1xuXHQgICAgICAgICAgICBvcHRpb25zID0gVG9uZS5QbGF5ZXIuZGVmYXVsdHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgICAgICd1cmwnLFxuXHQgICAgICAgICAgICAgICAgJ29ubG9hZCdcblx0ICAgICAgICAgICAgXSwgVG9uZS5QbGF5ZXIuZGVmYXVsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyU291cmNlTm9kZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlIGZpbGUgc2hvdWxkIHBsYXkgYXMgc29vblxuXHRcdFx0ICogIGFzIHRoZSBidWZmZXIgaXMgbG9hZGVkLiBcblx0XHRcdCAqICBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy93aWxsIHBsYXkgYXMgc29vbiBhcyBpdCdzIGxvYWRlZFxuXHRcdFx0ICogdmFyIHBsYXllciA9IG5ldyBUb25lLlBsYXllcih7XG5cdFx0XHQgKiBcdFwidXJsXCIgOiBcIi4vcGF0aC90by9zYW1wbGUubXAzXCIsXG5cdFx0XHQgKiBcdFwiYXV0b3N0YXJ0XCIgOiB0cnVlLFxuXHRcdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuYXV0b3N0YXJ0ID0gb3B0aW9ucy5hdXRvc3RhcnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGJ1ZmZlclxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQnVmZmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKHtcblx0ICAgICAgICAgICAgJ3VybCc6IG9wdGlvbnMudXJsLFxuXHQgICAgICAgICAgICAnb25sb2FkJzogdGhpcy5fb25sb2FkLmJpbmQodGhpcywgb3B0aW9ucy5vbmxvYWQpLFxuXHQgICAgICAgICAgICAncmV2ZXJzZSc6IG9wdGlvbnMucmV2ZXJzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIuc2V0KHVybCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGlmIHRoZSBidWZmZXIgc2hvdWxkIGxvb3Agb25jZSBpdCdzIG92ZXJcblx0XHRcdCAqICBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcCA9IG9wdGlvbnMubG9vcDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBpZiAnbG9vcCcgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBzdGFydCBhdCB0aGlzIHBvc2l0aW9uXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IG9wdGlvbnMubG9vcFN0YXJ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGlmICdsb29wJyBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIGVuZCBhdCB0aGlzIHBvc2l0aW9uXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BFbmQgPSBvcHRpb25zLmxvb3BFbmQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBsYXliYWNrIHJhdGVcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBFbmFibGluZyByZXRyaWdnZXIgd2lsbCBhbGxvdyBhIHBsYXllciB0byBiZSByZXN0YXJ0ZWRcblx0XHRcdCAqICBiZWZvcmUgdGhlIHRoZSBwcmV2aW91cyAnc3RhcnQnIGlzIGRvbmUgcGxheWluZy4gT3RoZXJ3aXNlLCBcblx0XHRcdCAqICBzdWNjZXNzaXZlIGNhbGxzIHRvIFRvbmUuUGxheWVyLnN0YXJ0IHdpbGwgb25seSBzdGFydFxuXHRcdFx0ICogIHRoZSBzYW1wbGUgaWYgaXQgaGFkIHBsYXllZCBhbGwgdGhlIHdheSB0aHJvdWdoLiBcblx0XHRcdCAqICBAdHlwZSB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmV0cmlnZ2VyID0gb3B0aW9ucy5yZXRyaWdnZXI7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QbGF5ZXIsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ2F1dG9zdGFydCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdsb29wRW5kJzogMCxcblx0ICAgICAgICAncmV0cmlnZ2VyJzogZmFsc2UsXG5cdCAgICAgICAgJ3JldmVyc2UnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBMb2FkIHRoZSBhdWRpbyBmaWxlIGFzIGFuIGF1ZGlvIGJ1ZmZlci5cblx0XHQgKiAgRGVjb2RlcyB0aGUgYXVkaW8gYXN5bmNocm9ub3VzbHkgYW5kIGludm9rZXNcblx0XHQgKiAgdGhlIGNhbGxiYWNrIG9uY2UgdGhlIGF1ZGlvIGJ1ZmZlciBsb2Fkcy4gXG5cdFx0ICogIE5vdGU6IHRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgaWYgYSB1cmxcblx0XHQgKiAgd2FzIHBhc3NlZCBpbiB0byB0aGUgY29uc3RydWN0b3IuIE9ubHkgdXNlIHRoaXNcblx0XHQgKiAgaWYgeW91IHdhbnQgdG8gbWFudWFsbHkgbG9hZCBhIG5ldyB1cmwuIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCBvZiB0aGUgYnVmZmVyIHRvIGxvYWQuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICBGaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICBicm93c2VyLlxuXHRcdCAqICBAcGFyYW0gIHtmdW5jdGlvbj19IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugb25jZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzYW1wbGUgaXMgbG9hZGVkLlxuXHRcdCAqICBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmxvYWQodXJsLCB0aGlzLl9vbmxvYWQuYmluZCh0aGlzLCBjYWxsYmFjaykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEludGVybmFsIGNhbGxiYWNrIHdoZW4gdGhlIGJ1ZmZlciBpcyBsb2FkZWQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5fb25sb2FkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgY2FsbGJhY2sgPSB0aGlzLmRlZmF1bHRBcmcoY2FsbGJhY2ssIFRvbmUubm9PcCk7XG5cdCAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMuYXV0b3N0YXJ0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBsYXkgdGhlIGJ1ZmZlciBhdCB0aGUgZ2l2ZW4gc3RhcnRUaW1lLiBPcHRpb25hbGx5IGFkZCBhbiBvZmZzZXRcblx0XHQgKiAgYW5kL29yIGR1cmF0aW9uIHdoaWNoIHdpbGwgcGxheSB0aGUgYnVmZmVyIGZyb20gYSBwb3NpdGlvblxuXHRcdCAqICB3aXRoaW4gdGhlIGJ1ZmZlciBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLiBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFtzdGFydFRpbWU9bm93XSBXaGVuIHRoZSBwbGF5ZXIgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzYW1wbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHN0YXJ0IGF0LiBcblx0XHQgKiAgQHBhcmFtICB7VGltZT19IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBzYW1wbGUgc2hvdWxkIHBsYXkuIElmIG5vIGR1cmF0aW9uXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGdpdmVuLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGZ1bGwgbGVuZ3RoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgc2FtcGxlIChtaW51cyBhbnkgb2Zmc2V0KVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QbGF5ZXJ9IHRoaXNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqICBAbWV0aG9kIHN0YXJ0XG5cdFx0ICogIEBuYW1lIHN0YXJ0XG5cdFx0ICovXG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgc3RhcnQgbWV0aG9kXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgb2Zmc2V0LCBkdXJhdGlvbikge1xuXHQgICAgICAgIGlmICh0aGlzLl9idWZmZXIubG9hZGVkKSB7XG5cdCAgICAgICAgICAgIC8vaWYgaXQncyBhIGxvb3AgdGhlIGRlZmF1bHQgb2Zmc2V0IGlzIHRoZSBsb29wc3RhcnQgcG9pbnRcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZGVmYXVsdEFyZyhvZmZzZXQsIHRoaXMuX2xvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvL290aGVyd2lzZSB0aGUgZGVmYXVsdCBvZmZzZXQgaXMgMFxuXHQgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1NlY29uZHMob2Zmc2V0KTtcblx0ICAgICAgICAgICAgLy9tYWtlIHN1cmUgaXQgaGFzIGEgcG9zaXRpdmUgZHVyYXRpb25cblx0ICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmRlZmF1bHRBcmcoZHVyYXRpb24sIE1hdGgubWF4KHRoaXMuX2J1ZmZlci5kdXJhdGlvbiAtIG9mZnNldCwgMCkpO1xuXHQgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICAgICAgLy90aGUgdmFsdWVzIGluIHNlY29uZHNcblx0ICAgICAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICAgICAgLy9tYWtlIHRoZSBzb3VyY2Vcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UuYnVmZmVyID0gdGhpcy5fYnVmZmVyLmdldCgpO1xuXHQgICAgICAgICAgICAvL3NldCB0aGUgbG9vcGluZyBwcm9wZXJ0aWVzXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcCA9IHRoaXMuX2xvb3A7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcFN0YXJ0ID0gdGhpcy50b1NlY29uZHModGhpcy5fbG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wRW5kID0gdGhpcy50b1NlY29uZHModGhpcy5fbG9vcEVuZCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvL2lmIGl0J3Mgbm90IGxvb3BpbmcsIHNldCB0aGUgc3RhdGUgY2hhbmdlIGF0IHRoZSBlbmQgb2YgdGhlIHNhbXBsZVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCBzdGFydFRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9hbmQgb3RoZXIgcHJvcGVydGllc1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgICAgIC8vc3RhcnQgaXRcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIC8vbW9kaWZ5IHRoZSBvZmZzZXQgaWYgaXQncyBncmVhdGVyIHRoYW4gdGhlIGxvb3AgdGltZVxuXHQgICAgICAgICAgICAgICAgdmFyIGxvb3BFbmQgPSB0aGlzLl9zb3VyY2UubG9vcEVuZCB8fCB0aGlzLl9idWZmZXIuZHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICB2YXIgbG9vcFN0YXJ0ID0gdGhpcy5fc291cmNlLmxvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIHZhciBsb29wRHVyYXRpb24gPSBsb29wRW5kIC0gbG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA+IGxvb3BFbmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL21vdmUgdGhlIG9mZnNldCBiYWNrXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA+IGxvb3BFbmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IGxvb3BEdXJhdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2Uuc3RhcnQoc3RhcnRUaW1lLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0YXJ0KHN0YXJ0VGltZSwgb2Zmc2V0LCBkdXJhdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignVG9uZS5QbGF5ZXI6IHRyaWVkIHRvIHN0YXJ0IFBsYXllciBiZWZvcmUgdGhlIGJ1ZmZlciB3YXMgbG9hZGVkJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHBsYXliYWNrLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsYXllcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdG9wKHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNlZWsgdG8gYSBzcGVjaWZpYyB0aW1lIGluIHRoZSBwbGF5ZXIncyBidWZmZXIuIElmIHRoZSBcblx0XHQgKiAgc291cmNlIGlzIG5vIGxvbmdlciBwbGF5aW5nIGF0IHRoYXQgdGltZSwgaXQgd2lsbCBzdG9wLlxuXHRcdCAqICBJZiB5b3Ugc2VlayB0byBhIHRpbWUgdGhhdCBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBvZmZzZXQgVGhlIHRpbWUgdG8gc2VlayB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gdGltZSBUaGUgdGltZSBmb3IgdGhlIHNlZWsgZXZlbnQgdG8gb2NjdXIuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUGxheWVyfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc291cmNlLnN0YXJ0KDAuMik7XG5cdFx0ICogc291cmNlLnN0b3AoMC40KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKG9mZnNldCwgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgICAgICAvLyBpZiBpdCdzIGN1cnJlbnRseSBwbGF5aW5nLCBzdG9wIGl0XG5cdCAgICAgICAgICAgIHRoaXMuX3N0b3AodGltZSk7XG5cdCAgICAgICAgICAgIC8vcmVzdGFydCBpdCBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSBsb29wIHN0YXJ0IGFuZCBlbmQuIFdpbGwgb25seSBsb29wIGlmIGxvb3AgaXMgXG5cdFx0ICogIHNldCB0byB0cnVlLiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBsb29wU3RhcnQgVGhlIGxvb3AgZW5kIHRpbWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBsb29wRW5kIFRoZSBsb29wIGVuZCB0aW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsYXllcn0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbG9vcCAwLjEgc2Vjb25kcyBvZiB0aGUgZmlsZS4gXG5cdFx0ICogcGxheWVyLnNldExvb3BQb2ludHMoMC4yLCAwLjMpO1xuXHRcdCAqIHBsYXllci5sb29wID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5zZXRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGxvb3BTdGFydCwgbG9vcEVuZCkge1xuXHQgICAgICAgIHRoaXMubG9vcFN0YXJ0ID0gbG9vcFN0YXJ0O1xuXHQgICAgICAgIHRoaXMubG9vcEVuZCA9IGxvb3BFbmQ7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIHN0YXJ0IGF0IHRoaXMgcG9zaXRpb24uIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wU3RhcnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wU3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gbG9vcFN0YXJ0O1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcFN0YXJ0ID0gdGhpcy50b1NlY29uZHMobG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIGVuZCBhdCB0aGlzIHBvc2l0aW9uLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBsb29wRW5kXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAnbG9vcEVuZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3BFbmQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wRW5kKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BFbmQgPSBsb29wRW5kO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcEVuZCA9IHRoaXMudG9TZWNvbmRzKGxvb3BFbmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYXVkaW8gYnVmZmVyIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RvbmUuQnVmZmVyfVxuXHRcdCAqIEBuYW1lIGJ1ZmZlclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIuc2V0KGJ1ZmZlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBJZiB0aGUgYnVmZmVyIHNob3VsZCBsb29wIG9uY2UgaXQncyBvdmVyLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbG9vcFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ2xvb3AnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGxheWJhY2sgc3BlZWQuIDEgaXMgbm9ybWFsIHNwZWVkLiBUaGlzIGlzIG5vdCBhIHNpZ25hbCBiZWNhdXNlXG5cdFx0ICogU2FmYXJpIGFuZCBpT1MgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgcGxheWJhY2tSYXRlIGFzIGEgc2lnbmFsLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBsYXliYWNrUmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ3BsYXliYWNrUmF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gcmF0ZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHJhdGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkaXJlY3Rpb24gdGhlIGJ1ZmZlciBzaG91bGQgcGxheSBpblxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSByZXZlcnNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAncmV2ZXJzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZXZlcnNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmV2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5yZXZlcnNlID0gcmV2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIERpc3Bvc2UgYW5kIGRpc2Nvbm5lY3QuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUGxheWVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zb3VyY2UgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBsYXllcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFNhbXBsZXIgd3JhcHMgVG9uZS5QbGF5ZXIgaW4gYW4gQW1wbGl0dWRlRW52ZWxvcGUuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB1cmwgdGhlIHVybCBvZiB0aGUgYXVkaW8gZmlsZVxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9uPX0gb25sb2FkIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUgc2FtcGxlIGlzIGxvYWRlZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2FtcGxlciA9IG5ldyBTYW1wbGVyKFwiLi9hdWRpby9jYXNpby9BMS5tcDNcIiwgZnVuY3Rpb24oKXtcblx0XHQgKiBcdC8vcmVwaXRjaCB0aGUgc2FtcGxlIGRvd24gYSBoYWxmIHN0ZXBcblx0XHQgKiBcdHNhbXBsZXIudHJpZ2dlckF0dGFjaygtMSk7XG5cdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU2FtcGxlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5TYW1wbGVyLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2FtcGxlIHBsYXllci5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5QbGF5ZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnBsYXllciA9IG5ldyBUb25lLlBsYXllcihvcHRpb25zLnVybCwgb3B0aW9ucy5vbmxvYWQpO1xuXHQgICAgICAgIHRoaXMucGxheWVyLnJldHJpZ2dlciA9IHRydWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtcGxpdHVkZSBlbnZlbG9wZS4gXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgdGhpcy5wbGF5ZXIuY2hhaW4odGhpcy5lbnZlbG9wZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ3BsYXllcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3A7XG5cdCAgICAgICAgdGhpcy5yZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU2FtcGxlciwgVG9uZS5JbnN0cnVtZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2FtcGxlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ3JldmVyc2UnOiBmYWxzZSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwMSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuMVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgc3RhcnQgb2YgdGhlIHNhbXBsZS4gXG5cdFx0ICogIEBwYXJhbSB7SW50ZXJ2YWx9IFtwaXRjaD0wXSBUaGUgYW1vdW50IHRoZSBzYW1wbGUgc2hvdWxkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSByZXBpdGNoZWQuIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgc2FtcGxlIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gVGhlIHZlbG9jaXR5IG9mIHRoZSBub3RlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNhbXBsZXJ9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzYW1wbGVyLnRyaWdnZXJBdHRhY2soMCwgXCIrMC4xXCIsIDAuNSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAocGl0Y2gsIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHBpdGNoID0gdGhpcy5kZWZhdWx0QXJnKHBpdGNoLCAwKTtcblx0ICAgICAgICB0aGlzLnBsYXllci5wbGF5YmFja1JhdGUgPSB0aGlzLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhwaXRjaCk7XG5cdCAgICAgICAgdGhpcy5wbGF5ZXIuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgc2FtcGxlLiBXaWxsIHN0b3AgdGhlIHNhbXBsZSBvbmNlIHRoZSBcblx0XHQgKiAgZW52ZWxvcGUgaGFzIGZ1bGx5IHJlbGVhc2VkLiBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSBub3RlIHNob3VsZCByZWxlYXNlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNhbXBsZXJ9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzYW1wbGVyLnRyaWdnZXJSZWxlYXNlKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICB0aGlzLnBsYXllci5zdG9wKHRoaXMudG9TZWNvbmRzKHRoaXMuZW52ZWxvcGUucmVsZWFzZSkgKyB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlIGFmdGVyIHRoZSBkdXJhdGlvbi4gXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsfSBpbnRlcnZhbCAgICAgVGhlIGludGVydmFsIGluIGhhbGYtc3RlcHMgdGhhdCB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGUgc2hvdWxkIGJlIHBpdGNoIHNoaWZ0ZWQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBub3RlIHNob3VsZCBiZSBoZWxkIGZvciBiZWZvcmVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmluZyB0aGUgcmVsZWFzZS5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddICBXaGVuIHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gVGhlIHZlbG9jaXR5IHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNhbXBsZXJ9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RyaWdnZXIgdGhlIHVucGl0Y2hlZCBub3RlIGZvciB0aGUgZHVyYXRpb24gb2YgYW4gOHRoIG5vdGVcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZSgwLCBcIjhuXCIpO1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5TYW1wbGVyI1xuXHRcdCAqICBAbmFtZSB0cmlnZ2VyQXR0YWNrUmVsZWFzZVxuXHRcdCAqICBAbWV0aG9kIHRyaWdnZXJBdHRhY2tSZWxlYXNlXG5cdFx0ICovXG5cdCAgICAvKipcblx0XHQgKiBJZiB0aGUgb3V0cHV0IHNhbXBsZSBzaG91bGQgbG9vcCBvciBub3QuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2FtcGxlciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cblx0XHQgKiBAbmFtZSBsb29wXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TYW1wbGVyLnByb3RvdHlwZSwgJ2xvb3AnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYXllci5sb29wO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLnBsYXllci5sb29wID0gbG9vcDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkaXJlY3Rpb24gdGhlIGJ1ZmZlciBzaG91bGQgcGxheSBpblxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNhbXBsZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgcmV2ZXJzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2FtcGxlci5wcm90b3R5cGUsICdyZXZlcnNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5wbGF5ZXIucmV2ZXJzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJldikge1xuXHQgICAgICAgICAgICB0aGlzLnBsYXllci5yZXZlcnNlID0gcmV2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGJ1ZmZlciB0byBwbGF5LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNhbXBsZXIjXG5cdFx0ICogQHR5cGUge1RvbmUuQnVmZmVyfVxuXHRcdCAqIEBuYW1lIGJ1ZmZlclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2FtcGxlci5wcm90b3R5cGUsICdidWZmZXInLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYXllci5idWZmZXI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChidWZmKSB7XG5cdCAgICAgICAgICAgIHRoaXMucGxheWVyLmJ1ZmZlciA9IGJ1ZmY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNhbXBsZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2FtcGxlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdwbGF5ZXInLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5wbGF5ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucGxheWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TYW1wbGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWFwcyBhIE5vcm1hbFJhbmdlIFswLCAxXSB0byBhbiBBdWRpb1JhbmdlIFstMSwgMV0uIFxuXHRcdCAqICAgICAgICAgU2VlIGFsc28gVG9uZS5BdWRpb1RvR2Fpbi4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGcyYSA9IG5ldyBUb25lLkdhaW5Ub0F1ZGlvKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkdhaW5Ub0F1ZGlvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHgpICogMiAtIDE7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HYWluVG9BdWRpbywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HYWluVG9BdWRpb30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluVG9BdWRpby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbm9ybS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR2FpblRvQXVkaW87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBOb3JtYWxpemUgdGFrZXMgYW4gaW5wdXQgbWluIGFuZCBtYXggYW5kIG1hcHMgaXQgbGluZWFybHkgdG8gTm9ybWFsUmFuZ2UgWzAsMV1cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IGlucHV0TWluIHRoZSBtaW4gaW5wdXQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IGlucHV0TWF4IHRoZSBtYXggaW5wdXQgdmFsdWVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbm9ybSA9IG5ldyBUb25lLk5vcm1hbGl6ZSgyLCA0KTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDMpLmNvbm5lY3Qobm9ybSk7XG5cdFx0ICogLy9vdXRwdXQgb2Ygbm9ybSBpcyAwLjUuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob3JtYWxpemUgPSBmdW5jdGlvbiAoaW5wdXRNaW4sIGlucHV0TWF4KSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1pbiBpbnB1dCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2lucHV0TWluID0gdGhpcy5kZWZhdWx0QXJnKGlucHV0TWluLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWF4IGlucHV0IHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5wdXRNYXggPSB0aGlzLmRlZmF1bHRBcmcoaW5wdXRNYXgsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHN1YnRyYWN0IHRoZSBtaW4gZnJvbSB0aGUgaW5wdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BZGR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N1YiA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5BZGQoMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZGl2aWRlIGJ5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGlucHV0IGFuZCBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGl2ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NdWx0aXBseSgxKTtcblx0ICAgICAgICB0aGlzLl9zdWIuY29ubmVjdCh0aGlzLl9kaXYpO1xuXHQgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Ob3JtYWxpemUsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWluaW11bSB2YWx1ZSB0aGUgaW5wdXQgc2lnbmFsIHdpbGwgcmVhY2guXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTm9ybWFsaXplI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRNaW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5faW5wdXRNaW4gPSBtaW47XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgaW5wdXQgc2lnbmFsIHdpbGwgcmVhY2guXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTm9ybWFsaXplI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWF4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRNYXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faW5wdXRNYXggPSBtYXg7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgc2V0IHRoZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9ybWFsaXplLnByb3RvdHlwZS5fc2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc3ViLnZhbHVlID0gLXRoaXMuX2lucHV0TWluO1xuXHQgICAgICAgIHRoaXMuX2Rpdi52YWx1ZSA9IDEgLyAodGhpcy5faW5wdXRNYXggLSB0aGlzLl9pbnB1dE1pbik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vcm1hbGl6ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3N1Yi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3ViID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kaXYuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2RpdiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTm9ybWFsaXplO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgQnVmZmVyU291cmNlTm9kZS5cblx0XHQgKiAgQHBhcmFtICB7QXVkaW9CdWZmZXJ8VG9uZS5CdWZmZXJ9ICBidWZmZXIgICBUaGUgYnVmZmVyIHRvIHBsYXlcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBvbmVuZGVkICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciBpcyBkb25lIHBsYXlpbmcuXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2J1ZmZlcicsXG5cdCAgICAgICAgICAgICdvbmVuZGVkJ1xuXHQgICAgICAgIF0sIFRvbmUuQnVmZmVyU291cmNlLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHRoZSBcblx0XHRcdCAqICBidWZmZXIgc291cmNlIGlzIGRvbmUgcGxheWluZy4gXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub25lbmRlZCA9IG9wdGlvbnMub25lbmRlZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdGltZSB0aGF0IHRoZSBidWZmZXIgd2FzIHN0YXJ0ZWQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IC0xO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0aW1lIHRoYXQgdGhlIGJ1ZmZlciBpcyBzY2hlZHVsZWQgdG8gc3RvcC5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RvcFRpbWUgPSAtMTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZ2FpbiBub2RlIHdoaWNoIGVudmVsb3BlcyB0aGUgQnVmZmVyU291cmNlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2dhaW5Ob2RlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGJ1ZmZlciBzb3VyY2Vcblx0XHRcdCAqICBAdHlwZSAge0F1ZGlvQnVmZmVyU291cmNlTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZS5jb25uZWN0KHRoaXMuX2dhaW5Ob2RlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2tSYXRlIG9mIHRoZSBidWZmZXJcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSBuZXcgVG9uZS5QYXJhbSh0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLCBUb25lLlR5cGUuUG9zaXRpdmUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmYWRlSW4gdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlSW4gPSBvcHRpb25zLmZhZGVJbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZU91dCB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlIHRoYXQgdGhlIGJ1ZmZlciByYW1wcyB0b1xuXHRcdFx0ICogIEB0eXBlIHtHYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9nYWluID0gMTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBvbmVuZGVkIHRpbWVvdXRcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb25lbmRlZFRpbWVvdXQgPSAtMTtcblx0ICAgICAgICAvL3NldCB0aGUgYnVmZmVyIGluaXRpYWxseVxuXHQgICAgICAgIGlmICghdGhpcy5pc1VuZGVmKG9wdGlvbnMuYnVmZmVyKSkge1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG9wdGlvbnMuYnVmZmVyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3A7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5CdWZmZXJTb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlclNvdXJjZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25lbmRlZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnZmFkZUluJzogMCxcblx0ICAgICAgICAnZmFkZU91dCc6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiIG9yIFwic3RvcHBlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydFRpbWUgIT09IC0xICYmIG5vdyA+PSB0aGlzLl9zdGFydFRpbWUgJiYgbm93IDwgdGhpcy5fc3RvcFRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUb25lLlN0YXRlLlN0YXJ0ZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5TdGF0ZS5TdG9wcGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIGJ1ZmZlclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbc3RhcnRUaW1lPW5vd10gV2hlbiB0aGUgcGxheWVyIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW29mZnNldD0wXSBUaGUgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzdGFydCBhdC4gXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSBkdXJhdGlvbiBIb3cgbG9uZyB0aGUgc2FtcGxlIHNob3VsZCBwbGF5LiBJZiBubyBkdXJhdGlvblxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBnaXZlbiwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBmdWxsIGxlbmd0aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHNhbXBsZSAobWludXMgYW55IG9mZnNldClcblx0XHQgKiAgQHBhcmFtICB7R2Fpbn0gIFtnYWluPTFdICBUaGUgZ2FpbiB0byBwbGF5IHRoZSBidWZmZXIgYmFjayBhdC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBmYWRlSW5UaW1lICBUaGUgb3B0aW9uYWwgZmFkZUluIHJhbXAgdGltZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCwgZHVyYXRpb24sIGdhaW4sIGZhZGVJblRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhcnRUaW1lICE9PSAtMSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuQnVmZmVyU291cmNlOiBjYW4gb25seSBiZSBzdGFydGVkIG9uY2UuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIC8vaWYgaXQncyBhIGxvb3AgdGhlIGRlZmF1bHQgb2Zmc2V0IGlzIHRoZSBsb29wc3RhcnQgcG9pbnRcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuXHQgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5kZWZhdWx0QXJnKG9mZnNldCwgdGhpcy5sb29wU3RhcnQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgdGhlIGRlZmF1bHQgb2Zmc2V0IGlzIDBcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZGVmYXVsdEFyZyhvZmZzZXQsIDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9mZnNldCA9IHRoaXMudG9TZWNvbmRzKG9mZnNldCk7XG5cdCAgICAgICAgICAgIC8vdGhlIHZhbHVlcyBpbiBzZWNvbmRzXG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0YXJ0KHRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgICAgIGdhaW4gPSB0aGlzLmRlZmF1bHRBcmcoZ2FpbiwgMSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2dhaW4gPSBnYWluO1xuXHQgICAgICAgICAgICAvL3RoZSBmYWRlSW4gdGltZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmKGZhZGVJblRpbWUpKSB7XG5cdCAgICAgICAgICAgICAgICBmYWRlSW5UaW1lID0gdGhpcy50b1NlY29uZHModGhpcy5mYWRlSW4pO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZmFkZUluVGltZSA9IHRoaXMudG9TZWNvbmRzKGZhZGVJblRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChmYWRlSW5UaW1lID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fZ2FpbiwgdGltZSArIGZhZGVJblRpbWUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShnYWluLCB0aW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lICsgZmFkZUluVGltZTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWYoZHVyYXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZGVmYXVsdEFyZyhkdXJhdGlvbiwgdGhpcy5idWZmZXIuZHVyYXRpb24gLSBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0b3AodGltZSArIGR1cmF0aW9uICsgZmFkZUluVGltZSwgZmFkZUluVGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgdGhlIGJ1ZmZlci4gT3B0aW9uYWxseSBhZGQgYSByYW1wIHRpbWUgdG8gZmFkZSB0aGUgXG5cdFx0ICogIGJ1ZmZlciBvdXQuIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgICAgICBUaGUgdGltZSB0aGUgYnVmZmVyIHNob3VsZCBzdG9wLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIGZhZGVPdXRUaW1lICBIb3cgbG9uZyB0aGUgZ2FpbiBzaG91bGQgZmFkZSBvdXQgZm9yXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlclNvdXJjZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUsIGZhZGVPdXRUaW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAgICAgLy90aGUgZmFkZU91dCB0aW1lXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlzVW5kZWYoZmFkZU91dFRpbWUpKSB7XG5cdCAgICAgICAgICAgICAgICBmYWRlT3V0VGltZSA9IHRoaXMudG9TZWNvbmRzKHRoaXMuZmFkZU91dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmYWRlT3V0VGltZSA9IHRoaXMudG9TZWNvbmRzKGZhZGVPdXRUaW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9zdG9wVGltZSA9IHRpbWUgKyBmYWRlT3V0VGltZTtcblx0ICAgICAgICAgICAgLy9jYW5jZWwgdGhlIGVuZCBjdXJ2ZVxuXHQgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLnNhbXBsZVRpbWUpO1xuXHQgICAgICAgICAgICAvL3NldCBhIG5ldyBvbmVcblx0ICAgICAgICAgICAgaWYgKGZhZGVPdXRUaW1lID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLl9nYWluLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGltZSArIGZhZGVPdXRUaW1lKTtcblx0ICAgICAgICAgICAgICAgIHRpbWUgKz0gZmFkZU91dFRpbWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIGZpeCBmb3Igc2FmYXJpIGJ1ZyBhbmQgb2xkIEZGXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5pc051bWJlcih0aGlzLl9zb3VyY2UucGxheWJhY2tTdGF0ZSkgfHwgdGhpcy5fc291cmNlLnBsYXliYWNrU3RhdGUgPT09IDIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdG9wKHRpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vbmVuZGVkVGltZW91dCk7XG5cdCAgICAgICAgICAgIHRoaXMuX29uZW5kZWRUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9vbmVuZGVkLmJpbmQodGhpcyksICh0aGlzLl9zdG9wVGltZSAtIHRoaXMubm93KCkpICogMTAwMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBjYWxsYmFjayB3aGVuIHRoZSBidWZmZXIgaXMgZW5kZWQuIFxuXHRcdCAqICBJbnZva2VzIGBvbmVuZGVkYCBhbmQgZGlzcG9zZXMgdGhlIG5vZGUuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUuX29uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5vbmVuZGVkKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIGxvb3AgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBzdGFydCBhdCB0aGlzIHBvc2l0aW9uLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXJTb3VyY2UjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgbG9vcFN0YXJ0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmxvb3BTdGFydDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BTdGFydCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcFN0YXJ0ID0gdGhpcy50b1NlY29uZHMobG9vcFN0YXJ0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIGxvb3AgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBlbmQgYXQgdGhpcyBwb3NpdGlvbi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXJTb3VyY2UjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZSwgJ2xvb3BFbmQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UubG9vcEVuZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BFbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3BFbmQgPSB0aGlzLnRvU2Vjb25kcyhsb29wRW5kKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhdWRpbyBidWZmZXIgYmVsb25naW5nIHRvIHRoZSBwbGF5ZXIuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XG5cdFx0ICogQG5hbWUgYnVmZmVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLCAnYnVmZmVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmJ1ZmZlcjtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFRvbmUuQnVmZmVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UuYnVmZmVyID0gYnVmZmVyLmdldCgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogSWYgdGhlIGJ1ZmZlciBzaG91bGQgbG9vcCBvbmNlIGl0J3Mgb3Zlci4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIGxvb3Bcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdsb29wJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmxvb3A7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wID0gbG9vcDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5vbmVuZGVkID0gbnVsbDtcblx0ICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLl9nYWluTm9kZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gLTE7XG5cdCAgICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcblx0ICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25lbmRlZFRpbWVvdXQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJ1ZmZlclNvdXJjZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk11bHRpUGxheWVyIGlzIHdlbGwgc3VpdGVkIGZvciBvbmUtc2hvdHMsIG11bHRpLXNhbXBsZWQgaW5zdHJ1bWVudHNcblx0XHQgKiAgICAgICAgIG9yIGFueSB0aW1lIHlvdSBuZWVkIHRvIHBsYXkgYSBidW5jaCBvZiBhdWRpbyBidWZmZXJzLiBcblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fEFycmF5fFRvbmUuQnVmZmVyc30gIGJ1ZmZlcnMgIFRoZSBidWZmZXJzIHdoaWNoIGFyZSBhdmFpbGFibGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBNdWx0aVBsYXllclxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvZiB0aGUgYnVmZmVycyBhcmUgbG9hZGVkLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbXVsdGlQbGF5ZXIgPSBuZXcgTXVsdGlQbGF5ZXIoe1xuXHRcdCAqIFx0XCJraWNrXCIgOiBcInBhdGgvdG8va2ljay5tcDNcIixcblx0XHQgKiBcdFwic25hcmVcIiA6IFwicGF0aC90by9zbmFyZS5tcDNcIixcblx0XHQgKiB9LCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0bXVsdGlQbGF5ZXIuc3RhcnQoXCJraWNrXCIpO1xuXHRcdCAqIH0pO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY2FuIGFsc28gc3RvcmUgdGhlIHZhbHVlcyBpbiBhbiBhcnJheVxuXHRcdCAqIHZhciBtdWx0aVBsYXllciA9IG5ldyBNdWx0aVBsYXllcihbXCJwYXRoL3RvL2tpY2subXAzXCIsIFwicGF0aC90by9zbmFyZS5tcDNcIl0sIFxuXHRcdCAqIGZ1bmN0aW9uKCl7XG5cdFx0ICogXHQvL2lmIGFuIGFycmF5IGlzIHBhc3NlZCBpbiwgdGhlIHNhbXBsZXMgYXJlIHJlZmVyZW5jZWQgdG8gYnkgaW5kZXhcblx0XHQgKiBcdG11bHRpUGxheWVyLnN0YXJ0KDEpO1xuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybHMnLFxuXHQgICAgICAgICAgICAnb25sb2FkJ1xuXHQgICAgICAgIF0sIFRvbmUuTXVsdGlQbGF5ZXIuZGVmYXVsdHMpO1xuXHQgICAgICAgIGlmIChvcHRpb25zLnVybHMgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcnMpIHtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBBbGwgdGhlIGJ1ZmZlcnMgYmVsb25naW5nIHRvIHRoZSBwbGF5ZXIuXG5cdFx0XHRcdCAqICBAdHlwZSAge1RvbmUuQnVmZmVyc31cblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuYnVmZmVycyA9IG9wdGlvbnMudXJscztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgVG9uZS5CdWZmZXJzKG9wdGlvbnMudXJscywgb3B0aW9ucy5vbmxvYWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudGx5IHBsYXlpbmcgc291cmNlcy5cblx0XHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IHt9O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmYWRlIGluIGVudmVsb3BlIHdoaWNoIGlzIGFwcGxpZWRcblx0XHRcdCAqICB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBCdWZmZXJTb3VyY2Vcblx0XHRcdCAqICBAdHlwZSAge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGVJbiA9IG9wdGlvbnMuZmFkZUluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmYWRlIG91dCBlbnZlbG9wZSB3aGljaCBpcyBhcHBsaWVkXG5cdFx0XHQgKiAgdG8gdGhlIGVuZCBvZiB0aGUgQnVmZmVyU291cmNlXG5cdFx0XHQgKiAgQHR5cGUgIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlT3V0ID0gb3B0aW9ucy5mYWRlT3V0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvdXRwdXQgdm9sdW1lIG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBvdXRwdXQgaW4gZGVjaWJlbHMuXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogc291cmNlLnZvbHVtZS52YWx1ZSA9IC02O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgICAgICAvL21ha2UgdGhlIG91dHB1dCBleHBsaWNpdGx5IHN0ZXJlb1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5vdXRwdXQub3V0cHV0LmNoYW5uZWxDb3VudCA9IDI7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLm91dHB1dC5vdXRwdXQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICAgICAgLy9tdXRlIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk11bHRpUGxheWVyLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdmYWRlSW4nOiAwLFxuXHQgICAgICAgICdmYWRlT3V0JzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE1ha2UgdGhlIHNvdXJjZSBmcm9tIHRoZSBidWZmZXJuYW1lXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBidWZmZXJOYW1lXG5cdFx0ICogQHJldHVybiB7VG9uZS5CdWZmZXJTb3VyY2V9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLl9tYWtlU291cmNlID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUpIHtcblx0ICAgICAgICB2YXIgYnVmZmVyO1xuXHQgICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKGJ1ZmZlck5hbWUpIHx8IHRoaXMuaXNOdW1iZXIoYnVmZmVyTmFtZSkpIHtcblx0ICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWZmZXJzLmdldChidWZmZXJOYW1lKS5nZXQoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlck5hbWUgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcikge1xuXHQgICAgICAgICAgICBidWZmZXIgPSBidWZmZXJOYW1lLmdldCgpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyTmFtZSBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlck5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzb3VyY2UgPSBuZXcgVG9uZS5CdWZmZXJTb3VyY2UoYnVmZmVyKS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZVNvdXJjZXMuaGFzT3duUHJvcGVydHkoYnVmZmVyTmFtZSkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXSA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdLnB1c2goc291cmNlKTtcblx0ICAgICAgICByZXR1cm4gc291cmNlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBhIGJ1ZmZlciBieSBuYW1lLiBUaGUgYHN0YXJ0YCBtZXRob2QgYWxsb3dzIGEgbnVtYmVyIG9mIG9wdGlvbnNcblx0XHQgKiAgdG8gYmUgcGFzc2VkIGluIHN1Y2ggYXMgb2Zmc2V0LCBpbnRlcnZhbCwgYW5kIGdhaW4uIFRoaXMgaXMgZ29vZCBmb3IgbXVsdGktc2FtcGxlZCBcblx0XHQgKiAgaW5zdHJ1bWVudHMgYW5kIHNvdW5kIHNwcml0ZXMgd2hlcmUgc2FtcGxlcyBhcmUgcmVwaXRjaGVkIHBsYXllZCBiYWNrIGF0IGRpZmZlcmVudCB2ZWxvY2l0aWVzLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBidWZmZXJOYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgdG8gc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICAgICAgV2hlbiB0byBzdGFydCB0aGUgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgW29mZnNldD0wXSAgICBUaGUgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlciB0byBwbGF5IGZyb20uXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgZHVyYXRpb24gICBIb3cgbG9uZyB0byBwbGF5IHRoZSBidWZmZXIgZm9yLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbH0gIFtwaXRjaD0wXSAgVGhlIGludGVydmFsIHRvIHJlcGl0Y2ggdGhlIGJ1ZmZlci5cblx0XHQgKiAgQHBhcmFtICB7R2Fpbn0gIFtnYWluPTFdICAgICAgVGhlIGdhaW4gdG8gcGxheSB0aGUgc2FtcGxlIGF0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NdWx0aVBsYXllcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUsIHRpbWUsIG9mZnNldCwgZHVyYXRpb24sIHBpdGNoLCBnYWluKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9tYWtlU291cmNlKGJ1ZmZlck5hbWUpO1xuXHQgICAgICAgIHNvdXJjZS5zdGFydCh0aW1lLCBvZmZzZXQsIGR1cmF0aW9uLCB0aGlzLmRlZmF1bHRBcmcoZ2FpbiwgMSksIHRoaXMuZmFkZUluKTtcblx0ICAgICAgICBpZiAoZHVyYXRpb24pIHtcblx0ICAgICAgICAgICAgc291cmNlLnN0b3AodGltZSArIHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKSwgdGhpcy5mYWRlT3V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGl0Y2ggPSB0aGlzLmRlZmF1bHRBcmcocGl0Y2gsIDApO1xuXHQgICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhwaXRjaCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGEgbG9vcGluZyBidWZmZXIgYnkgbmFtZS4gU2ltaWxhciB0byBgc3RhcnRgLCBidXQgdGhlIGJ1ZmZlclxuXHRcdCAqICBpcyBsb29wZWQgaW5zdGVhZCBvZiBwbGF5ZWQgc3RyYWlnaHQgdGhyb3VnaC4gQ2FuIHN0aWxsIGJlIHN0b3BwZWQgd2l0aCBgc3RvcGAuIFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBidWZmZXJOYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgdG8gc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICAgICAgV2hlbiB0byBzdGFydCB0aGUgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgW29mZnNldD0wXSAgICBUaGUgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlciB0byBwbGF5IGZyb20uXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgbG9vcFN0YXJ0ICAgVGhlIHN0YXJ0IG9mIHRoZSBsb29wLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIGxvb3BFbmRcdFRoZSBlbmQgb2YgdGhlIGxvb3AuXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsfSAgW3BpdGNoPTBdICBUaGUgaW50ZXJ2YWwgdG8gcmVwaXRjaCB0aGUgYnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtHYWlufSAgW2dhaW49MV0gICAgICBUaGUgZ2FpbiB0byBwbGF5IHRoZSBzYW1wbGUgYXQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLk11bHRpUGxheWVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUuc3RhcnRMb29wID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUsIHRpbWUsIG9mZnNldCwgbG9vcFN0YXJ0LCBsb29wRW5kLCBwaXRjaCwgZ2Fpbikge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fbWFrZVNvdXJjZShidWZmZXJOYW1lKTtcblx0ICAgICAgICBzb3VyY2UubG9vcCA9IHRydWU7XG5cdCAgICAgICAgc291cmNlLmxvb3BTdGFydCA9IHRoaXMudG9TZWNvbmRzKHRoaXMuZGVmYXVsdEFyZyhsb29wU3RhcnQsIDApKTtcblx0ICAgICAgICBzb3VyY2UubG9vcEVuZCA9IHRoaXMudG9TZWNvbmRzKHRoaXMuZGVmYXVsdEFyZyhsb29wRW5kLCAwKSk7XG5cdCAgICAgICAgc291cmNlLnN0YXJ0KHRpbWUsIG9mZnNldCwgdW5kZWZpbmVkLCB0aGlzLmRlZmF1bHRBcmcoZ2FpbiwgMSksIHRoaXMuZmFkZUluKTtcblx0ICAgICAgICBwaXRjaCA9IHRoaXMuZGVmYXVsdEFyZyhwaXRjaCwgMCk7XG5cdCAgICAgICAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKHBpdGNoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgZmlyc3QgcGxheWVkIGluc3RhbmNlIG9mIHRoZSBidWZmZXIgbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgYnVmZmVyTmFtZSAgVGhlIGJ1ZmZlciB0byBzdG9wLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgV2hlbiB0byBzdG9wIHRoZSBidWZmZXJcblx0XHQgKiAgQHJldHVybiAge1RvbmUuTXVsdGlQbGF5ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGJ1ZmZlck5hbWUsIHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXSAmJiB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXNbYnVmZmVyTmFtZV0uc2hpZnQoKS5zdG9wKHRpbWUsIHRoaXMuZmFkZU91dCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLk11bHRpUGxheWVyOiBjYW5ub3Qgc3RvcCBhIGJ1ZmZlciB0aGF0IGhhc25cXCd0IGJlZW4gc3RhcnRlZCBvciBpcyBhbHJlYWR5IHN0b3BwZWQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0b3AgYWxsIGN1cnJlbnRseSBwbGF5aW5nIGJ1ZmZlcnMgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgdGltZSAgV2hlbiB0byBzdG9wIHRoZSBidWZmZXJzLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NdWx0aVBsYXllcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlQbGF5ZXIucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBidWZmZXJOYW1lIGluIHRoaXMuX2FjdGl2ZVNvdXJjZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9hY3RpdmVTb3VyY2VzW2J1ZmZlck5hbWVdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZXNbaV0uc3RvcCh0aW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGFub3RoZXIgYnVmZmVyIHRvIHRoZSBhdmFpbGFibGUgYnVmZmVycy5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgdG8gdGhhdCB0aGUgYnVmZmVyIGlzIHJlZmVyZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdG8gaW4gc3RhcnQvc3RvcCBtZXRob2RzLiBcblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd8VG9uZS5CdWZmZXJ9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHRoZSBidWZmZXIuXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgdGhlIGJ1ZmZlciBpcyBsb2FkZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgdXJsLCBjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuYnVmZmVycy5hZGQobmFtZSwgdXJsLCBjYWxsYmFjayk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UuIFwic3RhcnRlZFwiXG5cdFx0ICogIGlmIHRoZXJlIGFyZSBhbnkgYnVmZmVycyBwbGF5aW5nLiBcInN0b3BwZWRcIiBvdGhlcndpc2UuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTXVsdGlQbGF5ZXIjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVNvdXJjZXMubGVuZ3RoID4gMCA/IFRvbmUuU3RhdGUuU3RhcnRlZCA6IFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTXVsdGlQbGF5ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiBzb3VyY2UubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NdWx0aVBsYXllci5wcm90b3R5cGUsICdtdXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lLm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTXVsdGlQbGF5ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBidWZmZXJOYW1lIGluIHRoaXMuX2FjdGl2ZVNvdXJjZXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlc1tidWZmZXJOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmJ1ZmZlcnMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTXVsdGlQbGF5ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqIEBjbGFzcyBUb25lLkdyYWluUGxheWVyIGltcGxlbWVudHMgW2dyYW51bGFyIHN5bnRoZXNpc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JhbnVsYXJfc3ludGhlc2lzKS5cblx0XHQgKiAgICAgICAgR3JhbnVsYXIgU3ludGhlc2lzIGVuYWJsZXMgeW91IHRvIGFkanVzdCBwaXRjaCBhbmQgcGxheWJhY2sgcmF0ZSBpbmRlcGVuZGVudGx5LiBUaGUgZ3JhaW5TaXplIGlzIHRoZSBcblx0XHQgKiAgICAgICAgYW1vdW50IG9mIHRpbWUgZWFjaCBzbWFsbCBjaHVuayBvZiBhdWRpbyBpcyBwbGF5ZWQgZm9yIGFuZCB0aGUgb3ZlcmxhcCBpcyB0aGUgXG5cdFx0ICogICAgICAgIGFtb3VudCBvZiBjcm9zc2ZhZGluZyB0cmFuc2l0aW9uIHRpbWUgYmV0d2VlbiBzdWNjZXNzaXZlIGdyYWlucy5cblx0XHQgKiBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiBAcGFyYW0ge1N0cmluZ3xUb25lLkJ1ZmZlcn0gdXJsXHRUaGUgdXJsIHRvIGxvYWQsIG9yIHRoZSBUb25lLkJ1ZmZlciB0byBwbGF5LlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHRoZSB1cmwgaXMgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5HcmFpblBsYXllci5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYXVkaW8gYnVmZmVyIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5CdWZmZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcihvcHRpb25zLnVybCwgb3B0aW9ucy5vbmxvYWQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFBsYXlzIHRoZSBidWZmZXIgd2l0aCBhIHNtYWxsIGVudmVsb3BlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk11bHRpUGxheWVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5ZXIgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk11bHRpUGxheWVyKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQ3JlYXRlIGEgcmVwZWF0aW5nIHRpY2sgdG8gc2NoZWR1bGVcblx0XHRcdCAqICB0aGUgZ3JhaW5zLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5DbG9ja31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY2xvY2sgPSBuZXcgVG9uZS5DbG9jayh0aGlzLl90aWNrLmJpbmQodGhpcyksIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wRW5kID0gMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2dyYWluU2l6ZSA9IG9wdGlvbnMuZ3JhaW5TaXplO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX292ZXJsYXAgPSBvcHRpb25zLm92ZXJsYXA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWRqdXN0IHRoZSBwaXRjaCBpbmRlcGVuZGVudGx5IG9mIHRoZSBwbGF5YmFja1JhdGUuXG5cdFx0XHQgKiAgQHR5cGUgIHtDZW50c31cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gb3B0aW9ucy5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiB0aW1lIHJhbmRvbWx5IGFkZGVkXG5cdFx0XHQgKiAgb3Igc3VidHJhY3RlZCBmcm9tIHRoZSBncmFpbidzIG9mZnNldFxuXHRcdFx0ICogIEB0eXBlICB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZHJpZnQgPSBvcHRpb25zLmRyaWZ0O1xuXHQgICAgICAgIC8vc2V0dXBcblx0ICAgICAgICB0aGlzLm92ZXJsYXAgPSBvcHRpb25zLm92ZXJsYXA7XG5cdCAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgdGhpcy5ncmFpblNpemUgPSBvcHRpb25zLmdyYWluU2l6ZTtcblx0ICAgICAgICB0aGlzLmxvb3BTdGFydCA9IG9wdGlvbnMubG9vcFN0YXJ0O1xuXHQgICAgICAgIHRoaXMubG9vcEVuZCA9IG9wdGlvbnMubG9vcEVuZDtcblx0ICAgICAgICB0aGlzLnJldmVyc2UgPSBvcHRpb25zLnJldmVyc2U7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HcmFpblBsYXllciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnb3ZlcmxhcCc6IDAuMSxcblx0ICAgICAgICAnZ3JhaW5TaXplJzogMC4yLFxuXHQgICAgICAgICdkcmlmdCc6IDAsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDEsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ2xvb3AnOiBmYWxzZSxcblx0ICAgICAgICAnbG9vcFN0YXJ0JzogMCxcblx0ICAgICAgICAnbG9vcEVuZCc6IDAsXG5cdCAgICAgICAgJ3JldmVyc2UnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBQbGF5IHRoZSBidWZmZXIgYXQgdGhlIGdpdmVuIHN0YXJ0VGltZS4gT3B0aW9uYWxseSBhZGQgYW4gb2Zmc2V0XG5cdFx0ICogIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgdG8gcGxheSBmcm9tLlxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3N0YXJ0VGltZT1ub3ddIFdoZW4gdGhlIHBsYXllciBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNhbXBsZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc3RhcnQgYXQuIFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuR3JhaW5QbGF5ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBzdGFydCBtZXRob2Rcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gb2Zmc2V0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgb2Zmc2V0ID0gdGhpcy5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdCAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1NlY29uZHMob2Zmc2V0KTtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0YXJ0KHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBzdGFydCBtZXRob2Rcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fY2xvY2suc3RvcCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9wbGF5ZXIuc3RvcCh0aGlzLmJ1ZmZlciwgdGltZSk7XG5cdCAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW52b2tlZCBvbiBlYWNoIGNsb2NrIHRpY2suIHNjaGVkdWxlZCBhIG5ld1xuXHRcdCAqICBncmFpbiBhdCB0aGlzIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lIFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xuXHQgICAgICAgIGlmICh0aGlzLmxvb3AgJiYgdGhpcy5fbG9vcEVuZCA+IDApIHtcblx0ICAgICAgICAgICAgYnVmZmVyRHVyYXRpb24gPSB0aGlzLl9sb29wRW5kO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZHJpZnQgPSAoTWF0aC5yYW5kb20oKSAqIDIgLSAxKSAqIHRoaXMuZHJpZnQ7XG5cdCAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCAtIHRoaXMuX292ZXJsYXAgKyBkcmlmdDtcblx0ICAgICAgICB2YXIgZGV0dW5lID0gdGhpcy5kZXR1bmUgLyAxMDA7XG5cdCAgICAgICAgdmFyIG9yaWdpbmFsRmFkZUluID0gdGhpcy5fcGxheWVyLmZhZGVJbjtcblx0ICAgICAgICBpZiAodGhpcy5sb29wICYmIHRoaXMuX29mZnNldCA+IGJ1ZmZlckR1cmF0aW9uKSB7XG5cdCAgICAgICAgICAgIC8vcGxheSB0aGUgZW5kXG5cdCAgICAgICAgICAgIHZhciBlbmRTZWdtZW50RHVyYXRpb24gPSB0aGlzLl9vZmZzZXQgLSBidWZmZXJEdXJhdGlvbjtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWVyLnN0YXJ0KHRoaXMuYnVmZmVyLCB0aW1lLCBvZmZzZXQsIGVuZFNlZ21lbnREdXJhdGlvbiArIHRoaXMuX292ZXJsYXAsIGRldHVuZSk7XG5cdCAgICAgICAgICAgIC8vYW5kIHBsYXkgdGhlIGJlZ2lubmluZyBcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICUgYnVmZmVyRHVyYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICAgICAgdGhpcy5fcGxheWVyLmZhZGVJbiA9IDA7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsYXllci5zdGFydCh0aGlzLmJ1ZmZlciwgdGltZSArIGVuZFNlZ21lbnREdXJhdGlvbiwgdGhpcy5fb2Zmc2V0LCBvZmZzZXQgKyB0aGlzLl9vdmVybGFwLCBkZXR1bmUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fb2Zmc2V0ID4gYnVmZmVyRHVyYXRpb24pIHtcblx0ICAgICAgICAgICAgLy9zZXQgdGhlIHN0YXRlIHRvIHN0b3BwZWQuIFxuXHQgICAgICAgICAgICB0aGlzLnN0b3AodGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllci5mYWRlSW4gPSBNYXRoLm1heCh0aGlzLl9wbGF5ZXIuZmFkZUluICsgb2Zmc2V0LCAwKTtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcGxheWVyLnN0YXJ0KHRoaXMuYnVmZmVyLCB0aW1lLCBvZmZzZXQsIHRoaXMuZ3JhaW5TaXplICsgdGhpcy5fb3ZlcmxhcCwgZGV0dW5lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcGxheWVyLmZhZGVJbiA9IG9yaWdpbmFsRmFkZUluO1xuXHQgICAgICAgIC8vaW5jcmVtZW50IHRoZSBvZmZzZXRcblx0ICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLl9jbG9jay5fbmV4dFRpY2sgLSB0aW1lO1xuXHQgICAgICAgIHRoaXMuX29mZnNldCArPSBkdXJhdGlvbiAqIHRoaXMuX3BsYXliYWNrUmF0ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSnVtcCB0byBhIHNwZWNpZmljIHRpbWUgYW5kIHBsYXkgaXQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICBvZmZzZXQgIFRoZSBvZmZzZXQgdG8ganVtcCB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gdGltZSBXaGVuIHRvIG1ha2UgdGhlIGp1bXAuXG5cdFx0ICogIEByZXR1cm4gIHtbdHlwZV19ICBbZGVzY3JpcHRpb25dXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uIChvZmZzZXQsIHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgIHRoaXMuX3RpY2sodGhpcy50b1NlY29uZHModGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwbGF5YmFjayByYXRlIG9mIHRoZSBzYW1wbGVcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgcGxheWJhY2tSYXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdwbGF5YmFja1JhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IHJhdGU7XG5cdCAgICAgICAgICAgIHRoaXMuZ3JhaW5TaXplID0gdGhpcy5fZ3JhaW5TaXplO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGxvb3Agc3RhcnQgdGltZS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgbG9vcFN0YXJ0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGxvb3AgZW5kIHRpbWUuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ2xvb3BFbmQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wRW5kO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGlyZWN0aW9uIHRoZSBidWZmZXIgc2hvdWxkIHBsYXkgaW5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSByZXZlcnNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdyZXZlcnNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIucmV2ZXJzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJldikge1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlci5yZXZlcnNlID0gcmV2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHNpemUgb2YgZWFjaCBjaHVuayBvZiBhdWRpbyB0aGF0IHRoZSBcblx0XHQgKiBidWZmZXIgaXMgY2hvcHBlZCBpbnRvIGFuZCBwbGF5ZWQgYmFjayBhdC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBncmFpblNpemVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ2dyYWluU2l6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyYWluU2l6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZ3JhaW5TaXplID0gdGhpcy50b1NlY29uZHMoc2l6ZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nsb2NrLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuX3BsYXliYWNrUmF0ZSAvIHRoaXMuX2dyYWluU2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBjcm9zcy1mYWRlIGJldHdlZW4gXG5cdFx0ICogc3VjZXNzaXZlIGdyYWlucy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBvdmVybGFwXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdvdmVybGFwJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxhcDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9vdmVybGFwID0gdGltZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJsYXAgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXIuZmFkZUluID0gMC4wMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllci5mYWRlT3V0ID0gMC4wMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllci5mYWRlSW4gPSB0aW1lO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcGxheWVyLmZhZGVPdXQgPSB0aW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuR3JhaW5QbGF5ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmJ1ZmZlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3BsYXllci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcGxheWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jbG9jay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkdyYWluUGxheWVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuVXNlck1lZGlhIHVzZXMgTWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSB0byBvcGVuIHVwXG5cdFx0ICogICAgICAgICAgYW5kIGV4dGVybmFsIG1pY3JvcGhvbmUgb3IgYXVkaW8gaW5wdXQuIENoZWNrIFxuXHRcdCAqICAgICAgICAgIFtNZWRpYURldmljZXMgQVBJIFN1cHBvcnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhKVxuXHRcdCAqICAgICAgICAgIHRvIHNlZSB3aGljaCBicm93c2VycyBhcmUgc3VwcG9ydGVkLiBBY2Nlc3MgdG8gYW4gZXh0ZXJuYWwgaW5wdXRcblx0XHQgKiAgICAgICAgICBpcyBsaW1pdGVkIHRvIHNlY3VyZSAoSFRUUFMpIGNvbm5lY3Rpb25zLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVscz19IHZvbHVtZSBUaGUgbGV2ZWwgb2YgdGhlIGlucHV0XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9saXN0IHRoZSBpbnB1dHMgYW5kIG9wZW4gdGhlIHRoaXJkIG9uZVxuXHRcdCAqIHZhciBtb3R1ID0gbmV3IFRvbmUuVXNlck1lZGlhKCk7XG5cdFx0ICogXG5cdFx0ICogLy9vcGVuaW5nIHRoZSBpbnB1dCBhc2tzIHRoZSB1c2VyIHRvIGFjdGl2YXRlIHRoZWlyIG1pY1xuXHRcdCAqIG1vdHUub3BlbigpLnRoZW4oZnVuY3Rpb24oKXtcblx0XHQgKiBcdC8vb3BlbmluZyBpcyBhY3RpdmF0ZXMgdGhlIG1pY3JvcGhvbmVcblx0XHQgKiBcdC8vc3RhcnRpbmcgbGV0cyBhdWRpbyB0aHJvdWdoXG5cdFx0ICogXHRtb3R1LnN0YXJ0KDEwKTtcblx0XHQgKiB9KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cywgWyd2b2x1bWUnXSwgVG9uZS5Vc2VyTWVkaWEuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBNZWRpYVN0cmVhbU5vZGUgXG5cdFx0XHQgKiAgQHR5cGUge01lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1lZGlhIHN0cmVhbSBjcmVhdGVkIGJ5IGdldFVzZXJNZWRpYS5cblx0XHRcdCAqICBAdHlwZSB7TG9jYWxNZWRpYVN0cmVhbX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RyZWFtID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3BlbiBkZXZpY2Vcblx0XHRcdCAqICBAdHlwZSAge01lZGlhRGV2aWNlSW5mb31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGV2aWNlID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzLlxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIGlucHV0LnZvbHVtZS52YWx1ZSA9IC02O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgICAgICB0aGlzLm11dGUgPSBvcHRpb25zLm11dGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Vc2VyTWVkaWEpO1xuXHQgICAgLyoqXG5cdFx0ICogdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlVzZXJNZWRpYS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE9wZW4gdGhlIG1lZGlhIHN0cmVhbS4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkIGluLCBpdCBpcyBhc3N1bWVkXG5cdFx0ICogIHRvIGJlIHRoZSBsYWJlbCBvciBpZCBvZiB0aGUgc3RyZWFtLCBpZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sXG5cdFx0ICogIGl0IGlzIHRoZSBpbnB1dCBudW1iZXIgb2YgdGhlIHN0cmVhbS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gW2xhYmVsT3JJZD1cImRlZmF1bHRcIl0gVGhlIGxhYmVsIG9yIGlkIG9mIHRoZSBhdWRpbyBpbnB1dCBtZWRpYSBkZXZpY2UuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2l0aCBubyBhcmd1bWVudCwgdGhlIGRlZmF1bHQgc3RyZWFtIGlzIG9wZW5lZC5cblx0XHQgKiAgQHJldHVybiB7UHJvbWlzZX0gVGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIG9wZW4uXG5cdFx0ICovXG5cdCAgICBUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChsYWJlbE9ySWQpIHtcblx0ICAgICAgICBsYWJlbE9ySWQgPSB0aGlzLmRlZmF1bHRBcmcobGFiZWxPcklkLCAnZGVmYXVsdCcpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uIChkZXZpY2VzKSB7XG5cdCAgICAgICAgICAgIHZhciBkZXZpY2U7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlzTnVtYmVyKGxhYmVsT3JJZCkpIHtcblx0ICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXNbbGFiZWxPcklkXTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXMuZmluZChmdW5jdGlvbiAoZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZS5sYWJlbCA9PT0gbGFiZWxPcklkIHx8IGRldmljZS5kZXZpY2VJZCA9PT0gbGFiZWxPcklkO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWRldmljZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGp1c3QgdGFrZSB0aGUgZmlyc3Qgb25lXG5cdCAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gZGV2aWNlc1swXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL2RpZG4ndCBmaW5kIGEgbWF0Y2hpbmcgZGV2aWNlXG5cdCAgICAgICAgICAgIGlmICghZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuVXNlck1lZGlhOiBubyBtYXRjaGluZyBhdWRpbyBpbnB1dHMuJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZGV2aWNlID0gZGV2aWNlO1xuXHQgICAgICAgICAgICAvL2RvIGdldFVzZXJNZWRpYVxuXHQgICAgICAgICAgICB2YXIgY29uc3RyYWludHMgPSB7XG5cdCAgICAgICAgICAgICAgICBhdWRpbzoge1xuXHQgICAgICAgICAgICAgICAgICAgICdkZXZpY2VJZCc6IGRldmljZS5kZXZpY2VJZCxcblx0ICAgICAgICAgICAgICAgICAgICAnZWNob0NhbmNlbGxhdGlvbic6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICdzYW1wbGVSYXRlJzogdGhpcy5jb250ZXh0LnNhbXBsZVJhdGVcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcblx0ICAgICAgICAgICAgICAgIC8vc3RhcnQgYSBuZXcgc291cmNlIG9ubHkgaWYgdGhlIHByZXZpb3VzIG9uZSBpcyBjbG9zZWRcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RyZWFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vV3JhcCBhIE1lZGlhU3RyZWFtU291cmNlTm9kZSBhcm91bmQgdGhlIGxpdmUgaW5wdXQgc3RyZWFtLlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9Db25uZWN0IHRoZSBNZWRpYVN0cmVhbVNvdXJjZU5vZGUgdG8gYSBnYXRlIGdhaW4gbm9kZVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xvc2UgdGhlIG1lZGlhIHN0cmVhbVxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlVzZXJNZWRpYX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zdHJlYW0pIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0ICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0cmVhbSA9IG51bGw7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBvbGQgbWVkaWEgc3RyZWFtXG5cdCAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9kZXZpY2UgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHRoZSBsaXN0IG9mIGF1ZGlvIGlucHV0IGRldmljZXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIGRldmljZXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBleHRJbnB1dC5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbihkZXZpY2VzKXtcblx0XHQgKiBcdGNvbnNvbGUubG9nKGRldmljZXMpXG5cdFx0ICogfSlcblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZS5lbnVtZXJhdGVEZXZpY2VzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uIChkZXZpY2VzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZXZpY2VzLmZpbHRlcihmdW5jdGlvbiAoZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlLmtpbmQgPT09ICdhdWRpb2lucHV0Jztcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIFwic3RhcnRlZFwiIHdoZW4gdGhlIG1pY3JvcGhvbmUgaXMgb3BlblxuXHRcdCAqICBhbmQgXCJzdG9wcGVkXCIgd2hlbiB0aGUgbWljIGlzIGNsb3NlZC5cblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJlYW0gJiYgdGhpcy5fc3RyZWFtLmFjdGl2ZSA/IFRvbmUuU3RhdGUuU3RhcnRlZCA6IFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0UmV0dXJucyBhbiBpZGVudGlmaWVyIGZvciB0aGUgcmVwcmVzZW50ZWQgZGV2aWNlIHRoYXQgaXMgXG5cdFx0ICogXHRwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zLiBJdCBpcyB1bi1ndWVzc2FibGUgYnkgb3RoZXIgYXBwbGljYXRpb25zIGFuZCBcblx0XHQgKiBcdHVuaXF1ZSB0byB0aGUgb3JpZ2luIG9mIHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uLiBJdCBpcyByZXNldCB3aGVuIHRoZSBcblx0XHQgKiBcdHVzZXIgY2xlYXJzIGNvb2tpZXMgKGZvciBQcml2YXRlIEJyb3dzaW5nLCBhIGRpZmZlcmVudCBpZGVudGlmaWVyIGlzIFxuXHRcdCAqIFx0dXNlZCB0aGF0IGlzIG5vdCBwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zKS4gUmV0dXJucyB1bmRlZmluZWQgd2hlbiB0aGUgXG5cdFx0ICogXHRkZXZpY2UgaXMgbm90IG9wZW4uXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogIEBuYW1lIGRldmljZUlkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnZGV2aWNlSWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kZXZpY2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2UuZGV2aWNlSWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0UmV0dXJucyBhIGdyb3VwIGlkZW50aWZpZXIuIFR3byBkZXZpY2VzIGhhdmUgdGhlIFxuXHRcdCAqIFx0c2FtZSBncm91cCBpZGVudGlmaWVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIHBoeXNpY2FsIGRldmljZS5cblx0XHQgKiBcdFJldHVybnMgdW5kZWZpbmVkIHdoZW4gdGhlIGRldmljZSBpcyBub3Qgb3Blbi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlVzZXJNZWRpYSNcblx0XHQgKiAgQG5hbWUgZ3JvdXBJZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZSwgJ2dyb3VwSWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kZXZpY2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2UuZ3JvdXBJZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRSZXR1cm5zIGEgbGFiZWwgZGVzY3JpYmluZyB0aGlzIGRldmljZSAoZm9yIGV4YW1wbGUgXCJCdWlsdC1pbiBNaWNyb3Bob25lXCIpLiBcblx0XHQgKiBcdFJldHVybnMgdW5kZWZpbmVkIHdoZW4gdGhlIGRldmljZSBpcyBub3Qgb3BlbiBvciBsYWJlbCBpcyBub3QgYXZhaWxhYmxlXG5cdFx0ICogXHRiZWNhdXNlIG9mIHBlcm1pc3Npb25zLlxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBncm91cElkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnbGFiZWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kZXZpY2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2UubGFiZWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIG11dGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vbXV0ZSB0aGUgb3V0cHV0XG5cdFx0ICogdXNlck1lZGlhLm11dGUgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl92b2x1bWUubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogQ2xlYW4gdXAuXG5cdFx0ICogQHJldHVybiB7VG9uZS5Vc2VyTWVkaWF9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNsb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElmIGdldFVzZXJNZWRpYSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG5cdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBzdXBwb3J0ZWRcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYSwgJ3N1cHBvcnRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICFUb25lLnByb3RvdHlwZS5pc1VuZGVmKG5hdmlnYXRvci5tZWRpYURldmljZXMpICYmIFRvbmUucHJvdG90eXBlLmlzRnVuY3Rpb24obmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmUuVXNlck1lZGlhO1xuXHR9KTtcblx0XG5cdHJldHVybiBUb25lO1xufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90b25lL2J1aWxkL1RvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxudmFyIERFRkFVTFRfQkFTRV9OT1RFID0gNDg7XG52YXIgREVGQVVMVF9TT05HX1JBVEUgPSA0NTA7XG5cbnZhciBNT0RFUyA9IHsgcGxheWVyOiAxLCBzb25nOiAyIH07XG5cbnZhciBURU1QT1MgPSB7XG4gIDA6IDIwMCxcbiAgMTogNDAwLFxuICAyOiA4MDBcbn1cblxudmFyIENVUlNPUl9XSURUSCA9IDI2O1xudmFyIENXID0gMTtcbnZhciBDQ1cgPSAtMTtcbnZhciBDVVJTT1JfTEVGVCA9IDA7XG52YXIgQ1VSU09SX1JJR0hUID0gMTtcbnZhciBTVEVQUyA9IDE2O1xudmFyIE5PVEVfRFVSQVRJT04gPSAyMDA7IC8vIDAuMiBzZWNvbmQgZGVsYXkgc2V0IGluIFN1cGVyQ29sbGlkZXJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyIHtcbiAgY29uc3RydWN0b3IoaWQsIG9wdGlvbnMsIG5vdGVzLCBzZW5kTm90ZSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmJhc2VOb3RlID0gb3B0aW9ucy5iYXNlTm90ZSB8fCBERUZBVUxUX0JBU0VfTk9URTtcbiAgICB0aGlzLnNvbmdSYXRlID0gb3B0aW9ucy5zb25nUmF0ZSB8fCBERUZBVUxUX1NPTkdfUkFURTtcbiAgICB0aGlzLnNvbmdUZW1wbyA9IG9wdGlvbnMuc29uZ1RlbXBvIHx8IDE7XG4gICAgdGhpcy5jYW52YXNUb3AgPSBvcHRpb25zLmNhbnZhc1RvcDtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgTU9ERVMuc29uZztcbiAgICB0aGlzLnRpbWVvdXQgPSAwO1xuICAgIC8vIHNvY2tldCBjYWxsYmFja1xuICAgIHRoaXMuc2VuZE5vdGUgPSBzZW5kTm90ZTtcbiAgICAvLyBzb25nIG1vZGVcbiAgICB0aGlzLnNvbmcgPSBvcHRpb25zLnNvbmcgfHwgVEVTVF9TT05HO1xuICAgIHRoaXMuc29uZ0luZGV4ID0gMDtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyIHx8IENXO1xuICAgIC8vIG1vdmVtZW50IGxvZ2ljXG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5tZXRlciA9IG51bGw7XG4gICAgdGhpcy5yb3RhdGlvbkNvdW50ID0gMDtcbiAgICB0aGlzLnRvRmxpcCA9IGZhbHNlO1xuICAgIHRoaXMubGVmdEhhbmQgPSBudWxsO1xuICAgIHRoaXMucmlnaHRIYW5kID0gbnVsbDtcbiAgICB0aGlzLnNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICB0aGlzLmNvbG9yID0gJyM1N0FBODMnIHx8IG9wdGlvbnMuY29sb3I7XG4gICAgdGhpcy5zdGF0ZXMgPSB7XG4gICAgICAxOiB7XG4gICAgICAgIHJvdGF0aW9uOiBDVyxcbiAgICAgICAgb3JpZW50YXRpb246IENVUlNPUl9SSUdIVFxuICAgICAgfSxcbiAgICAgIDI6IHtcbiAgICAgICAgcm90YXRpb246IENDVyxcbiAgICAgICAgb3JpZW50YXRpb246IENVUlNPUl9MRUZUXG4gICAgICB9LFxuICAgICAgMzoge1xuICAgICAgICByb3RhdGlvbjogQ1csXG4gICAgICAgIG9yaWVudGF0aW9uOiBDVVJTT1JfUklHSFRcbiAgICAgIH0sXG4gICAgICA0OiB7XG4gICAgICAgIHJvdGF0aW9uOiBDQ1csXG4gICAgICAgIG9yaWVudGF0aW9uOiBDVVJTT1JfTEVGVFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBwbGF5ZXIgc3BhblxuICAgICQoJy5wbGF5ZXJzJykuYXBwZW5kKFxuICAgICAgJzxkaXYgY2xhc3M9XCJwbGF5ZXJcIiBpZD1cIicgKyB0aGlzLmlkICsgJ1wiPjxzcGFuPjxkaXYgY2xhc3M9XCJjdXJzb3Itd3JhcHBlclwiPjxkaXYgY2xhc3M9XCJjdXJzb3JcIj48L2Rpdj48ZGl2IGNsYXNzPVwiY3Vyc29yLXJpZ2h0XCI+PC9kaXY+PC9kaXY+PC9zcGFuPjwvZGl2PidcbiAgICApO1xuICAgIHRoaXMualF1ZXJ5ID0gJCgnIycgKyB0aGlzLmlkICsgJyBzcGFuJyk7XG4gICAgdGhpcy5jdXJzb3JSaWdodCA9IHRoaXMualF1ZXJ5LmZpbmQoJy5jdXJzb3ItcmlnaHQnKTtcbiAgICB0aGlzLmN1cnNvckxlZnQgPSB0aGlzLmpRdWVyeS5maW5kKCcuY3Vyc29yJyk7XG5cbiAgICB0aGlzLmpRdWVyeS5jc3MoJy13ZWJraXQtdHJhbnNpdGlvbicsICctd2Via2l0LXRyYW5zZm9ybSAnICsgdGhpcy5zb25nUmF0ZSArICdtcyBsaW5lYXInKTtcbiAgICB0aGlzLmpRdWVyeS5jc3MoJ3RyYW5zaXRpb24nLCAndHJhbnNmb3JtICcgKyB0aGlzLnNvbmdSYXRlICsgJ21zIGxpbmVhcicpO1xuICAgIHRoaXMuY3Vyc29yUmlnaHQuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgb3B0aW9ucy5jb2xvci5oZXgpO1xuICAgIHRoaXMuY3Vyc29yTGVmdC5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBvcHRpb25zLmNvbG9yLmhleCk7XG4gIH1cblxuICB0ZW1wbyh0ZW1wb1ZhbHVlKSB7XG4gICAgdGhpcy5zb25nVGVtcG8gPSB0ZW1wb1ZhbHVlO1xuICAgIHRoaXMuc29uZ1JhdGUgPSBURU1QT1NbdGVtcG9WYWx1ZV07XG4gICAgdGhpcy5qUXVlcnkuY3NzKCctd2Via2l0LXRyYW5zaXRpb24nLCAnLXdlYmtpdC10cmFuc2Zvcm0gJyArIHRoaXMuc29uZ1JhdGUgKyAnbXMgbGluZWFyJyk7XG4gICAgdGhpcy5qUXVlcnkuY3NzKCd0cmFuc2l0aW9uJywgJ3RyYW5zZm9ybSAnICsgdGhpcy5zb25nUmF0ZSArICdtcyBsaW5lYXInKTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5wbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXlOZXh0Tm90ZSgpO1xuICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwbGF5TmV4dE5vdGUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50LCBuZXh0LCBuZXh0XzI7XG4gICAgY3VycmVudCA9IHNlbGYuc29uZ1tzZWxmLnNvbmdJbmRleF07XG4gICAgbmV4dCA9IHNlbGYuc29uZ1soc2VsZi5zb25nSW5kZXggKyAxKSAlIHNlbGYuc29uZy5sZW5ndGhdO1xuICAgIG5leHRfMiA9IHNlbGYuc29uZ1soc2VsZi5zb25nSW5kZXggKyAyKSAlIHNlbGYuc29uZy5sZW5ndGhdO1xuXG4gICAgLy8gc2V0cyBsYXN0IG5vdGUgZm9yIHJlZmVyZW5jZSBpZiB0aGVyZSBpcyBhIHN0cmluZyBvZiB0aGUgc2FtZSBub3Rlc1xuICAgIGlmIChjdXJyZW50ICE9PSBuZXh0ICYmIG5leHQgPT09IG5leHRfMikge1xuICAgICAgc2VsZi5sYXN0Tm90ZSA9IGN1cnJlbnQ7XG4gICAgfVxuICAgIC8vIGdldCBhY3R1YWwgbm90ZSBtYXBwaW5nc1xuICAgIHZhciBtaWRpTm90ZSA9IChjdXJyZW50IDwgNyA/IDAgOiAoY3VycmVudCA+IDEzID8gMjQgOiAxMikpICsgc2VsZi5iYXNlTm90ZSArIHNlbGYuc2NhbGVbKGN1cnJlbnQpICUgN107XG5cbiAgICAvLyBpbml0aWFsIHNldHVwXG4gICAgaWYgKCFzZWxmLmxlZnRIYW5kICYmICFzZWxmLnJpZ2h0SGFuZCkge1xuICAgICAgaWYgKGN1cnJlbnQgPD0gbmV4dCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCA+IG5leHQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoc2VsZi5zdGF0ZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IChzZWxmLnRvRmxpcCA/IDIgOiAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlbGYuc3RhdGUgPSAoc2VsZi50b0ZsaXAgPyAxIDogMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWxmLnN0YXRlID0gKHNlbGYudG9GbGlwID8gNCA6IDMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IChzZWxmLnRvRmxpcCA/IDMgOiA0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdpbnZhbGlkIHN0YXRlIHJlYWNoZWQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNlbGYudG9GbGlwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPCBuZXh0ICYmIG5leHQgPCBuZXh0XzIpIHtcbiAgICAgIHNlbGYudG9GbGlwID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPiBuZXh0ICYmIG5leHQgPiBuZXh0XzIpIHtcbiAgICAgIHNlbGYudG9GbGlwID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG5leHQgJiYgbmV4dCAhPT0gbmV4dF8yKSB7XG4gICAgICBpZiAoc2VsZi5sYXN0Tm90ZSkge1xuICAgICAgICBpZiAoc2VsZi5sYXN0Tm90ZSA8IG5leHQgJiYgbmV4dCA8IG5leHRfMikge1xuICAgICAgICAgIHNlbGYudG9GbGlwID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmxhc3ROb3RlID4gbmV4dCAmJiBuZXh0ID4gbmV4dF8yKSB7XG4gICAgICAgICAgc2VsZi50b0ZsaXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBieSBkZWZhdWx0IHdlIG9ubHkgc3RhcnQgQ1dcbiAgICAgICAgLy8gVE9ETzogZml4IHRoaXNcbiAgICAgICAgaWYgKG5leHQgPiBuZXh0XzIpIHtcbiAgICAgICAgICBzZWxmLnRvRmxpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA8IG5leHQpIHtcbiAgICAgIHNlbGYubGVmdEhhbmQgPSBub3Rlc1tjdXJyZW50XTtcbiAgICAgIHNlbGYucmlnaHRIYW5kID0gbm90ZXNbbmV4dF07XG4gICAgfSBlbHNlIGlmIChjdXJyZW50ID4gbmV4dCkge1xuICAgICAgc2VsZi5sZWZ0SGFuZCA9IG5vdGVzW25leHRdO1xuICAgICAgc2VsZi5yaWdodEhhbmQgPSBub3Rlc1tjdXJyZW50XTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG5leHQpIHtcbiAgICAgIHNlbGYucmlnaHRIYW5kID0gbm90ZXNbY3VycmVudF07XG4gICAgICBzZWxmLmxlZnRIYW5kID0gbm90ZXNbY3VycmVudF07XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuc29uZy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBwbGF5IGFuZCBhbmltYXRlIG5vdGVcbiAgICAgIHNlbGYuc2VuZE5vdGUobWlkaU5vdGUpO1xuICAgICAgLy8gYW5pbWF0ZU5vdGUoY3VycmVudCwgMTUwKTtcbiAgICB9XG5cbiAgICAvLyByZW5kZXIgY3Vyc29yXG4gICAgc2VsZi5yZW5kZXIoKTtcblxuICAgIC8vIHJlY3Vyc2l2ZSBjYWxsIGF0IFNPTkdfUkFURVxuICAgIHNlbGYubWV0ZXIgPSBzZXRUaW1lb3V0KHBsYXlOZXh0Tm90ZSwgc2VsZi5zb25nUmF0ZSk7XG4gICAgc2VsZi5zb25nSW5kZXgrKztcbiAgICBpZiAoc2VsZi5zb25nSW5kZXggPT09IHNlbGYuc29uZy5sZW5ndGgpIHNlbGYuc29uZ0luZGV4ID0gMDtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zb25nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gbm8gbm90ZXMgcGxheWVkXG4gICAgICB0aGlzLmN1cnNvclJpZ2h0LmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICB0aGlzLmN1cnNvckxlZnQuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJpZ2h0SGFuZCAmJiAhdGhpcy5sZWZ0SGFuZCkge1xuICAgICAgLy8gZmlyc3QgcGFzcyB0aHJvdWdoXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXJhbXMgPSB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlXTtcbiAgICBpZiAodGhpcy5yaWdodEhhbmQgIT09IHRoaXMubGVmdEhhbmQpIHtcbiAgICAgIHRoaXMucm90YXRpb25Db3VudCArPSBwYXJhbXMucm90YXRpb247XG4gICAgICB0aGlzLmpRdWVyeS5jc3MoJy13ZWJraXQtdHJhbnNmb3JtJywgJ3JvdGF0ZSgnICsgKHRoaXMucm90YXRpb25Db3VudCkgKiAxODAgKyAnZGVnKScpO1xuICAgICAgdGhpcy5qUXVlcnkuY3NzKCd0cmFuc2Zvcm06JywgJ3JvdGF0ZSgnICsgKHRoaXMucm90YXRpb25Db3VudCkgKiAxODAgKyAnZGVnKScpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMub3JpZW50YXRpb24gPT09IENVUlNPUl9MRUZUKSB7XG4gICAgICB0aGlzLmN1cnNvclJpZ2h0LmNzcygnZGlzcGxheScsICdpbml0aWFsJylcbiAgICAgIHRoaXMuY3Vyc29yTGVmdC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3Vyc29yUmlnaHQuY3NzKCdkaXNwbGF5JywgJ25vbmUnKVxuICAgICAgdGhpcy5jdXJzb3JMZWZ0LmNzcygnZGlzcGxheScsICdpbml0aWFsJylcbiAgICB9XG4gICAgdmFyIGRpYW1ldGVyID0gdGhpcy5yaWdodEhhbmQuY2VudGVyIC0gdGhpcy5sZWZ0SGFuZC5jZW50ZXI7XG4gICAgdmFyIHRvcCA9IHRoaXMuY2FudmFzVG9wICsgdGhpcy5sZWZ0SGFuZC53aWR0aCAvIDQgLSBkaWFtZXRlciAvIDI7XG4gICAgdmFyIGxlZnQgPSB0aGlzLmxlZnRIYW5kLmNlbnRlcjtcbiAgICB0aGlzLmpRdWVyeS5jc3MoJ3RvcCcsIHRvcCk7XG4gICAgdGhpcy5qUXVlcnkuY3NzKCdsZWZ0JywgbGVmdCk7XG4gICAgdGhpcy5qUXVlcnkuY3NzKCdoZWlnaHQnLCBkaWFtZXRlcik7XG4gICAgdGhpcy5qUXVlcnkuY3NzKCd3aWR0aCcsIGRpYW1ldGVyKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm1ldGVyKTtcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICAkKCcjJyArIHRoaXMuaWQpLnJlbW92ZSgpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5sYXN0Tm90ZSA9IG51bGw7XG4gICAgdGhpcy5sZWZ0SGFuZCA9IG51bGw7XG4gICAgdGhpcy5yaWdodEhhbmQgPSBudWxsO1xuICAgIHRoaXMuc29uZ0luZGV4ID0gMDtcbiAgICB0aGlzLm1ldGVyID0gbnVsbDtcbiAgICB0aGlzLnRvRmxpcCA9IGZhbHNlO1xuICAgIHRoaXMucm90YXRpb25Db3VudCA9IHRoaXMucm90YXRpb25Db3VudCArICh0aGlzLnJvdGF0aW9uQ291bnQgJSAyID8gMSA6IDApO1xuICB9XG59XG5cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGxheWVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==